/* soapStub.h
   Generated by gSOAP 2.8.92 for ws-inspire-wfs2.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_wfs	"http://www.opengis.net/wfs/2.0"
#define SOAP_NAMESPACE_OF_util	"http://www.opengis.net/wfs-util/2.0"
#define SOAP_NAMESPACE_OF_ows	"http://www.opengis.net/ows/1.1"
#define SOAP_NAMESPACE_OF_idls	"http://inspire.ec.europa.eu/schemas/inspire_dls/1.0"
#define SOAP_NAMESPACE_OF_xlink	"http://www.w3.org/1999/xlink"
#define SOAP_NAMESPACE_OF_fes	"http://www.opengis.net/fes/2.0"
#define SOAP_NAMESPACE_OF_icommon	"http://inspire.ec.europa.eu/schemas/common/1.0"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20892
# error "GSOAP VERSION 20892 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* ws-inspire-wfs2.h:981 */
#ifndef SOAP_TYPE_wfs__ResultTypeType
#define SOAP_TYPE_wfs__ResultTypeType (350)
/* wfs:ResultTypeType */
enum wfs__ResultTypeType {
	wfs__ResultTypeType__results = 0,
	wfs__ResultTypeType__hits = 1
};
#endif

/* ws-inspire-wfs2.h:998 */
#ifndef SOAP_TYPE_wfs__ResolveValueType
#define SOAP_TYPE_wfs__ResolveValueType (352)
/* wfs:ResolveValueType */
enum wfs__ResolveValueType {
	wfs__ResolveValueType__local = 0,
	wfs__ResolveValueType__remote = 1,
	wfs__ResolveValueType__all = 2,
	wfs__ResolveValueType__none = 3
};
#endif

/* ws-inspire-wfs2.h:1017 */
#ifndef SOAP_TYPE_wfs__StarStringType
#define SOAP_TYPE_wfs__StarStringType (354)
/* wfs:StarStringType */
enum wfs__StarStringType {
	wfs__StarStringType___x002a = 0
};
#endif

/* ws-inspire-wfs2.h:1033 */
#ifndef SOAP_TYPE_wfs__AllSomeType
#define SOAP_TYPE_wfs__AllSomeType (356)
/* wfs:AllSomeType */
enum wfs__AllSomeType {
	wfs__AllSomeType__ALL = 0,
	wfs__AllSomeType__SOME = 1
};
#endif

/* ws-inspire-wfs2.h:1050 */
#ifndef SOAP_TYPE_wfs__UpdateActionType
#define SOAP_TYPE_wfs__UpdateActionType (358)
/* wfs:UpdateActionType */
enum wfs__UpdateActionType {
	wfs__UpdateActionType__replace = 0,
	wfs__UpdateActionType__insertBefore = 1,
	wfs__UpdateActionType__insertAfter = 2,
	wfs__UpdateActionType__remove = 3
};
#endif

/* ws-inspire-wfs2.h:1159 */
#ifndef SOAP_TYPE__ows__rangeClosure
#define SOAP_TYPE__ows__rangeClosure (369)
/* ows:rangeClosure */
enum _ows__rangeClosure {
	_ows__rangeClosure__closed = 0,
	_ows__rangeClosure__open = 1,
	_ows__rangeClosure__open_closed = 2,
	_ows__rangeClosure__closed_open = 3
};
#endif

/* ws-inspire-wfs2.h:1202 */
#ifndef SOAP_TYPE_xlink__typeType
#define SOAP_TYPE_xlink__typeType (370)
/* xlink:typeType */
enum xlink__typeType {
	xlink__typeType__simple = 0,
	xlink__typeType__extended = 1,
	xlink__typeType__title = 2,
	xlink__typeType__resource = 3,
	xlink__typeType__locator = 4,
	xlink__typeType__arc = 5
};
#endif

/* ws-inspire-wfs2.h:1273 */
#ifndef SOAP_TYPE_xlink__showType
#define SOAP_TYPE_xlink__showType (380)
/* xlink:showType */
enum xlink__showType {
	xlink__showType__new_ = 0,
	xlink__showType__replace = 1,
	xlink__showType__embed = 2,
	xlink__showType__other = 3,
	xlink__showType__none = 4
};
#endif

/* ws-inspire-wfs2.h:1293 */
#ifndef SOAP_TYPE_xlink__actuateType
#define SOAP_TYPE_xlink__actuateType (382)
/* xlink:actuateType */
enum xlink__actuateType {
	xlink__actuateType__onLoad = 0,
	xlink__actuateType__onRequest = 1,
	xlink__actuateType__other = 2,
	xlink__actuateType__none = 3
};
#endif

/* ws-inspire-wfs2.h:1369 */
#ifndef SOAP_TYPE_fes__VersionActionTokens
#define SOAP_TYPE_fes__VersionActionTokens (392)
/* fes:VersionActionTokens */
enum fes__VersionActionTokens {
	fes__VersionActionTokens__FIRST = 0,
	fes__VersionActionTokens__LAST = 1,
	fes__VersionActionTokens__PREVIOUS = 2,
	fes__VersionActionTokens__NEXT = 3,
	fes__VersionActionTokens__ALL = 4
};
#endif

/* ws-inspire-wfs2.h:1389 */
#ifndef SOAP_TYPE_fes__MatchActionType
#define SOAP_TYPE_fes__MatchActionType (394)
/* fes:MatchActionType */
enum fes__MatchActionType {
	fes__MatchActionType__All = 0,
	fes__MatchActionType__Any = 1,
	fes__MatchActionType__One = 2
};
#endif

/* ws-inspire-wfs2.h:1433 */
#ifndef SOAP_TYPE_fes__SortOrderType
#define SOAP_TYPE_fes__SortOrderType (400)
/* fes:SortOrderType */
enum fes__SortOrderType {
	fes__SortOrderType__DESC = 0,
	fes__SortOrderType__ASC = 1
};
#endif

/* ws-inspire-wfs2.h:1458 */
#ifndef SOAP_TYPE_icommon__topicCategory
#define SOAP_TYPE_icommon__topicCategory (402)
/* icommon:topicCategory */
enum icommon__topicCategory {
	icommon__topicCategory__farming = 0,
	icommon__topicCategory__biota = 1,
	icommon__topicCategory__boundaries = 2,
	icommon__topicCategory__climatologyMeteorologyAtmosphere = 3,
	icommon__topicCategory__economy = 4,
	icommon__topicCategory__elevation = 5,
	icommon__topicCategory__environment = 6,
	icommon__topicCategory__geoscientificInformation = 7,
	icommon__topicCategory__health = 8,
	icommon__topicCategory__imageryBaseMapsEarthCover = 9,
	icommon__topicCategory__intelligenceMilitary = 10,
	icommon__topicCategory__inlandWaters = 11,
	icommon__topicCategory__location = 12,
	icommon__topicCategory__oceans = 13,
	icommon__topicCategory__planningCadastre = 14,
	icommon__topicCategory__society = 15,
	icommon__topicCategory__structure = 16,
	icommon__topicCategory__transportation = 17,
	icommon__topicCategory__utilitiesCommunication = 18
};
#endif

/* ws-inspire-wfs2.h:1509 */
#ifndef SOAP_TYPE_icommon__mediaType
#define SOAP_TYPE_icommon__mediaType (406)
/* icommon:mediaType */
enum icommon__mediaType {
	icommon__mediaType__text_x002fplain = 0,
	icommon__mediaType__text_x002fhtml = 1,
	icommon__mediaType__text_x002fxml = 2,
	icommon__mediaType__application_x002fxml = 3,
	icommon__mediaType__application_x002fjson = 4,
	icommon__mediaType__application_x002fpdf = 5,
	icommon__mediaType__application_x002frdf_x002bxml = 6,
	icommon__mediaType__application_x002fsoap_x002bxml = 7,
	icommon__mediaType__application_x002fvnd_x002eeu_x002eeuropa_x002eec_x002einspire_x002eresource_x002bxml = 8,
	icommon__mediaType__application_x002fvnd_x002egoogle_earth_x002ekml_x002bxml = 9,
	icommon__mediaType__application_x002fvnd_x002egoogle_earth_x002ekml = 10,
	icommon__mediaType__application_x002fvnd_x002egoogle_earth_x002ekmx = 11,
	icommon__mediaType__application_x002fvnd_x002emsword = 12,
	icommon__mediaType__application_x002fvnd_x002ems_excel = 13,
	icommon__mediaType__application_x002fvnd_x002ems_powerpoint = 14,
	icommon__mediaType__application_x002fvnd_x002eoasis_x002eopendocument_x002etext = 15,
	icommon__mediaType__application_x002fvnd_x002eoasis_x002eopendocument_x002espreadsheet = 16,
	icommon__mediaType__application_x002fvnd_x002eoasis_x002eopendocument_x002epresentation = 17,
	icommon__mediaType__application_x002fvnd_x002eoasis_x002eopendocument_x002egraphics = 18,
	icommon__mediaType__application_x002fgml_x002bxml = 19,
	icommon__mediaType__application_x002fvnd_x002eogc_x002ewms_x005fxml = 20,
	icommon__mediaType__application_x002fvnd_x002eogc_x002ecsw_x005fxml = 21,
	icommon__mediaType__application_x002fvnd_x002eogc_x002ecsw_x002ecapabilities_x002eresponse_x005fxml = 22,
	icommon__mediaType__application_x002fvnd_x002eogc_x002ecsw_x002eGetRecordByIdResponse_x005fxml = 23,
	icommon__mediaType__application_x002fvnd_x002eogc_x002ecsw_x002eGetRecordsResponse_x005fxml = 24,
	icommon__mediaType__application_x002fvnd_x002eogc_x002ewfs_x005fxml = 25,
	icommon__mediaType__application_x002fvnd_x002eogc_x002ese_x005fxml = 26,
	icommon__mediaType__application_x002fvnd_x002eiso_x002e19139_x002bxml = 27
};
#endif

/* ws-inspire-wfs2.h:1622 */
#ifndef SOAP_TYPE_icommon__resourceType
#define SOAP_TYPE_icommon__resourceType (412)
/* icommon:resourceType */
enum icommon__resourceType {
	icommon__resourceType__dataset = 0,
	icommon__resourceType__series = 1,
	icommon__resourceType__service = 2
};
#endif

/* ws-inspire-wfs2.h:1640 */
#ifndef SOAP_TYPE_icommon__spatialDataServiceType
#define SOAP_TYPE_icommon__spatialDataServiceType (414)
/* icommon:spatialDataServiceType */
enum icommon__spatialDataServiceType {
	icommon__spatialDataServiceType__discovery = 0,
	icommon__spatialDataServiceType__view = 1,
	icommon__spatialDataServiceType__download = 2,
	icommon__spatialDataServiceType__transformation = 3,
	icommon__spatialDataServiceType__invoke = 4,
	icommon__spatialDataServiceType__other = 5
};
#endif

/* ws-inspire-wfs2.h:1661 */
#ifndef SOAP_TYPE_icommon__degreeOfConformity
#define SOAP_TYPE_icommon__degreeOfConformity (416)
/* icommon:degreeOfConformity */
enum icommon__degreeOfConformity {
	icommon__degreeOfConformity__conformant = 0,
	icommon__degreeOfConformity__notConformant = 1,
	icommon__degreeOfConformity__notEvaluated = 2
};
#endif

/* ws-inspire-wfs2.h:1679 */
#ifndef SOAP_TYPE_icommon__languageISO6392B
#define SOAP_TYPE_icommon__languageISO6392B (418)
/* icommon:languageISO6392B */
enum icommon__languageISO6392B {
	icommon__languageISO6392B__aar = 0,
	icommon__languageISO6392B__abk = 1,
	icommon__languageISO6392B__ace = 2,
	icommon__languageISO6392B__ach = 3,
	icommon__languageISO6392B__ada = 4,
	icommon__languageISO6392B__ady = 5,
	icommon__languageISO6392B__afa = 6,
	icommon__languageISO6392B__afh = 7,
	icommon__languageISO6392B__afr = 8,
	icommon__languageISO6392B__ain = 9,
	icommon__languageISO6392B__aka = 10,
	icommon__languageISO6392B__akk = 11,
	icommon__languageISO6392B__alb = 12,
	icommon__languageISO6392B__ale = 13,
	icommon__languageISO6392B__alg = 14,
	icommon__languageISO6392B__alt = 15,
	icommon__languageISO6392B__amh = 16,
	icommon__languageISO6392B__ang = 17,
	icommon__languageISO6392B__anp = 18,
	icommon__languageISO6392B__apa = 19,
	icommon__languageISO6392B__ara = 20,
	icommon__languageISO6392B__arc = 21,
	icommon__languageISO6392B__arg = 22,
	icommon__languageISO6392B__arm = 23,
	icommon__languageISO6392B__arn = 24,
	icommon__languageISO6392B__arp = 25,
	icommon__languageISO6392B__art = 26,
	icommon__languageISO6392B__arw = 27,
	icommon__languageISO6392B__asm_ = 28,
	icommon__languageISO6392B__ast = 29,
	icommon__languageISO6392B__ath = 30,
	icommon__languageISO6392B__aus = 31,
	icommon__languageISO6392B__ava = 32,
	icommon__languageISO6392B__ave = 33,
	icommon__languageISO6392B__awa = 34,
	icommon__languageISO6392B__aym = 35,
	icommon__languageISO6392B__aze = 36,
	icommon__languageISO6392B__bad = 37,
	icommon__languageISO6392B__bai = 38,
	icommon__languageISO6392B__bak = 39,
	icommon__languageISO6392B__bal = 40,
	icommon__languageISO6392B__bam = 41,
	icommon__languageISO6392B__ban = 42,
	icommon__languageISO6392B__baq = 43,
	icommon__languageISO6392B__bas = 44,
	icommon__languageISO6392B__bat = 45,
	icommon__languageISO6392B__bej = 46,
	icommon__languageISO6392B__bel = 47,
	icommon__languageISO6392B__bem = 48,
	icommon__languageISO6392B__ben = 49,
	icommon__languageISO6392B__ber = 50,
	icommon__languageISO6392B__bho = 51,
	icommon__languageISO6392B__bih = 52,
	icommon__languageISO6392B__bik = 53,
	icommon__languageISO6392B__bin = 54,
	icommon__languageISO6392B__bis = 55,
	icommon__languageISO6392B__bla = 56,
	icommon__languageISO6392B__bnt = 57,
	icommon__languageISO6392B__bos = 58,
	icommon__languageISO6392B__bra = 59,
	icommon__languageISO6392B__bre = 60,
	icommon__languageISO6392B__btk = 61,
	icommon__languageISO6392B__bua = 62,
	icommon__languageISO6392B__bug = 63,
	icommon__languageISO6392B__bul = 64,
	icommon__languageISO6392B__bur = 'A',
	icommon__languageISO6392B__byn = 'B',
	icommon__languageISO6392B__cad = 'C',
	icommon__languageISO6392B__cai = 'D',
	icommon__languageISO6392B__car = 'E',
	icommon__languageISO6392B__cat = 'F',
	icommon__languageISO6392B__cau = 'G',
	icommon__languageISO6392B__ceb = 'H',
	icommon__languageISO6392B__cel = 'I',
	icommon__languageISO6392B__cha = 'J',
	icommon__languageISO6392B__chb = 'K',
	icommon__languageISO6392B__che = 'L',
	icommon__languageISO6392B__chg = 'M',
	icommon__languageISO6392B__chi = 'N',
	icommon__languageISO6392B__chk = 'O',
	icommon__languageISO6392B__chm = 'P',
	icommon__languageISO6392B__chn = 'Q',
	icommon__languageISO6392B__cho = 'R',
	icommon__languageISO6392B__chp = 'S',
	icommon__languageISO6392B__chr = 'T',
	icommon__languageISO6392B__chu = 'U',
	icommon__languageISO6392B__chv = 'V',
	icommon__languageISO6392B__chy = 'W',
	icommon__languageISO6392B__cmc = 'X',
	icommon__languageISO6392B__cop = 'Y',
	icommon__languageISO6392B__cor = 'Z',
	icommon__languageISO6392B__cos = 91,
	icommon__languageISO6392B__cpe = 92,
	icommon__languageISO6392B__cpf = 93,
	icommon__languageISO6392B__cpp = 94,
	icommon__languageISO6392B__cre = 95,
	icommon__languageISO6392B__crh = 96,
	icommon__languageISO6392B__crp = 'a',
	icommon__languageISO6392B__csb = 'b',
	icommon__languageISO6392B__cus = 'c',
	icommon__languageISO6392B__cze = 'd',
	icommon__languageISO6392B__dak = 'e',
	icommon__languageISO6392B__dan = 'f',
	icommon__languageISO6392B__dar = 'g',
	icommon__languageISO6392B__day = 'h',
	icommon__languageISO6392B__del = 'i',
	icommon__languageISO6392B__den = 'j',
	icommon__languageISO6392B__dgr = 'k',
	icommon__languageISO6392B__din = 'l',
	icommon__languageISO6392B__div = 'm',
	icommon__languageISO6392B__doi = 'n',
	icommon__languageISO6392B__dra = 'o',
	icommon__languageISO6392B__dsb = 'p',
	icommon__languageISO6392B__dua = 'q',
	icommon__languageISO6392B__dum = 'r',
	icommon__languageISO6392B__dut = 's',
	icommon__languageISO6392B__dyu = 't',
	icommon__languageISO6392B__dzo = 'u',
	icommon__languageISO6392B__efi = 'v',
	icommon__languageISO6392B__egy = 'w',
	icommon__languageISO6392B__eka = 'x',
	icommon__languageISO6392B__elx = 'y',
	icommon__languageISO6392B__eng = 'z',
	icommon__languageISO6392B__enm = 123,
	icommon__languageISO6392B__epo = 124,
	icommon__languageISO6392B__est = 125,
	icommon__languageISO6392B__ewe = 126,
	icommon__languageISO6392B__ewo = 127,
	icommon__languageISO6392B__fan = 128,
	icommon__languageISO6392B__fao = 129,
	icommon__languageISO6392B__fat = 130,
	icommon__languageISO6392B__fij = 131,
	icommon__languageISO6392B__fil = 132,
	icommon__languageISO6392B__fin = 133,
	icommon__languageISO6392B__fiu = 134,
	icommon__languageISO6392B__fon = 135,
	icommon__languageISO6392B__fre = 136,
	icommon__languageISO6392B__frm = 137,
	icommon__languageISO6392B__fro = 138,
	icommon__languageISO6392B__frr = 139,
	icommon__languageISO6392B__frs = 140,
	icommon__languageISO6392B__fry = 141,
	icommon__languageISO6392B__ful = 142,
	icommon__languageISO6392B__fur = 143,
	icommon__languageISO6392B__gaa = 144,
	icommon__languageISO6392B__gay = 145,
	icommon__languageISO6392B__gba = 146,
	icommon__languageISO6392B__gem = 147,
	icommon__languageISO6392B__geo = 148,
	icommon__languageISO6392B__ger = 149,
	icommon__languageISO6392B__gez = 150,
	icommon__languageISO6392B__gil = 151,
	icommon__languageISO6392B__gla = 152,
	icommon__languageISO6392B__gle = 153,
	icommon__languageISO6392B__glg = 154,
	icommon__languageISO6392B__glv = 155,
	icommon__languageISO6392B__gmh = 156,
	icommon__languageISO6392B__goh = 157,
	icommon__languageISO6392B__gon = 158,
	icommon__languageISO6392B__gor = 159,
	icommon__languageISO6392B__got = 160,
	icommon__languageISO6392B__grb = 161,
	icommon__languageISO6392B__grc = 162,
	icommon__languageISO6392B__gre = 163,
	icommon__languageISO6392B__grn = 164,
	icommon__languageISO6392B__gsw = 165,
	icommon__languageISO6392B__guj = 166,
	icommon__languageISO6392B__gwi = 167,
	icommon__languageISO6392B__hai = 168,
	icommon__languageISO6392B__hat = 169,
	icommon__languageISO6392B__hau = 170,
	icommon__languageISO6392B__haw = 171,
	icommon__languageISO6392B__heb = 172,
	icommon__languageISO6392B__her = 173,
	icommon__languageISO6392B__hil = 174,
	icommon__languageISO6392B__him = 175,
	icommon__languageISO6392B__hin = 176,
	icommon__languageISO6392B__hit = 177,
	icommon__languageISO6392B__hmn = 178,
	icommon__languageISO6392B__hmo = 179,
	icommon__languageISO6392B__hrv = 180,
	icommon__languageISO6392B__hsb = 181,
	icommon__languageISO6392B__hun = 182,
	icommon__languageISO6392B__hup = 183,
	icommon__languageISO6392B__iba = 184,
	icommon__languageISO6392B__ibo = 185,
	icommon__languageISO6392B__ice = 186,
	icommon__languageISO6392B__ido = 187,
	icommon__languageISO6392B__iii = 188,
	icommon__languageISO6392B__ijo = 189,
	icommon__languageISO6392B__iku = 190,
	icommon__languageISO6392B__ile = 191,
	icommon__languageISO6392B__ilo = 192,
	icommon__languageISO6392B__ina = 193,
	icommon__languageISO6392B__inc = 194,
	icommon__languageISO6392B__ind = 195,
	icommon__languageISO6392B__ine = 196,
	icommon__languageISO6392B__inh = 197,
	icommon__languageISO6392B__ipk = 198,
	icommon__languageISO6392B__ira = 199,
	icommon__languageISO6392B__iro = 200,
	icommon__languageISO6392B__ita = 201,
	icommon__languageISO6392B__jav = 202,
	icommon__languageISO6392B__jbo = 203,
	icommon__languageISO6392B__jpn = 204,
	icommon__languageISO6392B__jpr = 205,
	icommon__languageISO6392B__jrb = 206,
	icommon__languageISO6392B__kaa = 207,
	icommon__languageISO6392B__kab = 208,
	icommon__languageISO6392B__kac = 209,
	icommon__languageISO6392B__kal = 210,
	icommon__languageISO6392B__kam = 211,
	icommon__languageISO6392B__kan = 212,
	icommon__languageISO6392B__kar = 213,
	icommon__languageISO6392B__kas = 214,
	icommon__languageISO6392B__kau = 215,
	icommon__languageISO6392B__kaw = 216,
	icommon__languageISO6392B__kaz = 217,
	icommon__languageISO6392B__kbd = 218,
	icommon__languageISO6392B__kha = 219,
	icommon__languageISO6392B__khi = 220,
	icommon__languageISO6392B__khm = 221,
	icommon__languageISO6392B__kho = 222,
	icommon__languageISO6392B__kik = 223,
	icommon__languageISO6392B__kin = 224,
	icommon__languageISO6392B__kir = 225,
	icommon__languageISO6392B__kmb = 226,
	icommon__languageISO6392B__kok = 227,
	icommon__languageISO6392B__kom = 228,
	icommon__languageISO6392B__kon = 229,
	icommon__languageISO6392B__kor = 230,
	icommon__languageISO6392B__kos = 231,
	icommon__languageISO6392B__kpe = 232,
	icommon__languageISO6392B__krc = 233,
	icommon__languageISO6392B__krl = 234,
	icommon__languageISO6392B__kro = 235,
	icommon__languageISO6392B__kru = 236,
	icommon__languageISO6392B__kua = 237,
	icommon__languageISO6392B__kum = 238,
	icommon__languageISO6392B__kur = 239,
	icommon__languageISO6392B__kut = 240,
	icommon__languageISO6392B__lad = 241,
	icommon__languageISO6392B__lah = 242,
	icommon__languageISO6392B__lam = 243,
	icommon__languageISO6392B__lao = 244,
	icommon__languageISO6392B__lat = 245,
	icommon__languageISO6392B__lav = 246,
	icommon__languageISO6392B__lez = 247,
	icommon__languageISO6392B__lim = 248,
	icommon__languageISO6392B__lin = 249,
	icommon__languageISO6392B__lit = 250,
	icommon__languageISO6392B__lol = 251,
	icommon__languageISO6392B__loz = 252,
	icommon__languageISO6392B__ltz = 253,
	icommon__languageISO6392B__lua = 254,
	icommon__languageISO6392B__lub = 255,
	icommon__languageISO6392B__lug = 256,
	icommon__languageISO6392B__lui = 257,
	icommon__languageISO6392B__lun = 258,
	icommon__languageISO6392B__luo = 259,
	icommon__languageISO6392B__lus = 260,
	icommon__languageISO6392B__mac = 261,
	icommon__languageISO6392B__mad = 262,
	icommon__languageISO6392B__mag = 263,
	icommon__languageISO6392B__mah = 264,
	icommon__languageISO6392B__mai = 265,
	icommon__languageISO6392B__mak = 266,
	icommon__languageISO6392B__mal = 267,
	icommon__languageISO6392B__man = 268,
	icommon__languageISO6392B__mao = 269,
	icommon__languageISO6392B__map = 270,
	icommon__languageISO6392B__mar = 271,
	icommon__languageISO6392B__mas = 272,
	icommon__languageISO6392B__may = 273,
	icommon__languageISO6392B__mdf = 274,
	icommon__languageISO6392B__mdr = 275,
	icommon__languageISO6392B__men = 276,
	icommon__languageISO6392B__mga = 277,
	icommon__languageISO6392B__mic = 278,
	icommon__languageISO6392B__min_ = 279,
	icommon__languageISO6392B__mis = 280,
	icommon__languageISO6392B__mkh = 281,
	icommon__languageISO6392B__mlg = 282,
	icommon__languageISO6392B__mlt = 283,
	icommon__languageISO6392B__mnc = 284,
	icommon__languageISO6392B__mni = 285,
	icommon__languageISO6392B__mno = 286,
	icommon__languageISO6392B__moh = 287,
	icommon__languageISO6392B__mon = 288,
	icommon__languageISO6392B__mos = 289,
	icommon__languageISO6392B__mul = 290,
	icommon__languageISO6392B__mun = 291,
	icommon__languageISO6392B__mus = 292,
	icommon__languageISO6392B__mwl = 293,
	icommon__languageISO6392B__mwr = 294,
	icommon__languageISO6392B__myn = 295,
	icommon__languageISO6392B__myv = 296,
	icommon__languageISO6392B__nah = 297,
	icommon__languageISO6392B__nai = 298,
	icommon__languageISO6392B__nap = 299,
	icommon__languageISO6392B__nau = 300,
	icommon__languageISO6392B__nav = 301,
	icommon__languageISO6392B__nbl = 302,
	icommon__languageISO6392B__nde = 303,
	icommon__languageISO6392B__ndo = 304,
	icommon__languageISO6392B__nds = 305,
	icommon__languageISO6392B__nep = 306,
	icommon__languageISO6392B__new_ = 307,
	icommon__languageISO6392B__nia = 308,
	icommon__languageISO6392B__nic = 309,
	icommon__languageISO6392B__niu = 310,
	icommon__languageISO6392B__nno = 311,
	icommon__languageISO6392B__nob = 312,
	icommon__languageISO6392B__nog = 313,
	icommon__languageISO6392B__non = 314,
	icommon__languageISO6392B__nor = 315,
	icommon__languageISO6392B__nqo = 316,
	icommon__languageISO6392B__nso = 317,
	icommon__languageISO6392B__nub = 318,
	icommon__languageISO6392B__nwc = 319,
	icommon__languageISO6392B__nya = 320,
	icommon__languageISO6392B__nym = 321,
	icommon__languageISO6392B__nyn = 322,
	icommon__languageISO6392B__nyo = 323,
	icommon__languageISO6392B__nzi = 324,
	icommon__languageISO6392B__oci = 325,
	icommon__languageISO6392B__oji = 326,
	icommon__languageISO6392B__ori = 327,
	icommon__languageISO6392B__orm = 328,
	icommon__languageISO6392B__osa = 329,
	icommon__languageISO6392B__oss = 330,
	icommon__languageISO6392B__ota = 331,
	icommon__languageISO6392B__oto = 332,
	icommon__languageISO6392B__paa = 333,
	icommon__languageISO6392B__pag = 334,
	icommon__languageISO6392B__pal = 335,
	icommon__languageISO6392B__pam = 336,
	icommon__languageISO6392B__pan = 337,
	icommon__languageISO6392B__pap = 338,
	icommon__languageISO6392B__pau = 339,
	icommon__languageISO6392B__peo = 340,
	icommon__languageISO6392B__per = 341,
	icommon__languageISO6392B__phi = 342,
	icommon__languageISO6392B__phn = 343,
	icommon__languageISO6392B__pli = 344,
	icommon__languageISO6392B__pol = 345,
	icommon__languageISO6392B__pon = 346,
	icommon__languageISO6392B__por = 347,
	icommon__languageISO6392B__pra = 348,
	icommon__languageISO6392B__pro = 349,
	icommon__languageISO6392B__pus = 350,
	icommon__languageISO6392B__qaa_qtz = 351,
	icommon__languageISO6392B__que = 352,
	icommon__languageISO6392B__raj = 353,
	icommon__languageISO6392B__rap = 354,
	icommon__languageISO6392B__rar = 355,
	icommon__languageISO6392B__roa = 356,
	icommon__languageISO6392B__roh = 357,
	icommon__languageISO6392B__rom = 358,
	icommon__languageISO6392B__rum = 359,
	icommon__languageISO6392B__run = 360,
	icommon__languageISO6392B__rup = 361,
	icommon__languageISO6392B__rus = 362,
	icommon__languageISO6392B__sad = 363,
	icommon__languageISO6392B__sag = 364,
	icommon__languageISO6392B__sah = 365,
	icommon__languageISO6392B__sai = 366,
	icommon__languageISO6392B__sal = 367,
	icommon__languageISO6392B__sam = 368,
	icommon__languageISO6392B__san = 369,
	icommon__languageISO6392B__sas = 370,
	icommon__languageISO6392B__sat = 371,
	icommon__languageISO6392B__scn = 372,
	icommon__languageISO6392B__sco = 373,
	icommon__languageISO6392B__sel = 374,
	icommon__languageISO6392B__sem = 375,
	icommon__languageISO6392B__sga = 376,
	icommon__languageISO6392B__sgn = 377,
	icommon__languageISO6392B__shn = 378,
	icommon__languageISO6392B__sid = 379,
	icommon__languageISO6392B__sin = 380,
	icommon__languageISO6392B__sio = 381,
	icommon__languageISO6392B__sit = 382,
	icommon__languageISO6392B__sla = 383,
	icommon__languageISO6392B__slo = 384,
	icommon__languageISO6392B__slv = 385,
	icommon__languageISO6392B__sma = 386,
	icommon__languageISO6392B__sme = 387,
	icommon__languageISO6392B__smi = 388,
	icommon__languageISO6392B__smj = 389,
	icommon__languageISO6392B__smn = 390,
	icommon__languageISO6392B__smo = 391,
	icommon__languageISO6392B__sms = 392,
	icommon__languageISO6392B__sna = 393,
	icommon__languageISO6392B__snd = 394,
	icommon__languageISO6392B__snk = 395,
	icommon__languageISO6392B__sog = 396,
	icommon__languageISO6392B__som = 397,
	icommon__languageISO6392B__son = 398,
	icommon__languageISO6392B__sot = 399,
	icommon__languageISO6392B__spa = 400,
	icommon__languageISO6392B__srd = 401,
	icommon__languageISO6392B__srn = 402,
	icommon__languageISO6392B__srp = 403,
	icommon__languageISO6392B__srr = 404,
	icommon__languageISO6392B__ssa = 405,
	icommon__languageISO6392B__ssw = 406,
	icommon__languageISO6392B__suk = 407,
	icommon__languageISO6392B__sun = 408,
	icommon__languageISO6392B__sus = 409,
	icommon__languageISO6392B__sux = 410,
	icommon__languageISO6392B__swa = 411,
	icommon__languageISO6392B__swe = 412,
	icommon__languageISO6392B__syc = 413,
	icommon__languageISO6392B__syr = 414,
	icommon__languageISO6392B__tah = 415,
	icommon__languageISO6392B__tai = 416,
	icommon__languageISO6392B__tam = 417,
	icommon__languageISO6392B__tat = 418,
	icommon__languageISO6392B__tel = 419,
	icommon__languageISO6392B__tem = 420,
	icommon__languageISO6392B__ter = 421,
	icommon__languageISO6392B__tet = 422,
	icommon__languageISO6392B__tgk = 423,
	icommon__languageISO6392B__tgl = 424,
	icommon__languageISO6392B__tha = 425,
	icommon__languageISO6392B__tib = 426,
	icommon__languageISO6392B__tig = 427,
	icommon__languageISO6392B__tir = 428,
	icommon__languageISO6392B__tiv = 429,
	icommon__languageISO6392B__tkl = 430,
	icommon__languageISO6392B__tlh = 431,
	icommon__languageISO6392B__tli = 432,
	icommon__languageISO6392B__tmh = 433,
	icommon__languageISO6392B__tog = 434,
	icommon__languageISO6392B__ton = 435,
	icommon__languageISO6392B__tpi = 436,
	icommon__languageISO6392B__tsi = 437,
	icommon__languageISO6392B__tsn = 438,
	icommon__languageISO6392B__tso = 439,
	icommon__languageISO6392B__tuk = 440,
	icommon__languageISO6392B__tum = 441,
	icommon__languageISO6392B__tup = 442,
	icommon__languageISO6392B__tur = 443,
	icommon__languageISO6392B__tut = 444,
	icommon__languageISO6392B__tvl = 445,
	icommon__languageISO6392B__twi = 446,
	icommon__languageISO6392B__tyv = 447,
	icommon__languageISO6392B__udm = 448,
	icommon__languageISO6392B__uga = 449,
	icommon__languageISO6392B__uig = 450,
	icommon__languageISO6392B__ukr = 451,
	icommon__languageISO6392B__umb = 452,
	icommon__languageISO6392B__und = 453,
	icommon__languageISO6392B__urd = 454,
	icommon__languageISO6392B__uzb = 455,
	icommon__languageISO6392B__vai = 456,
	icommon__languageISO6392B__ven = 457,
	icommon__languageISO6392B__vie = 458,
	icommon__languageISO6392B__vol = 459,
	icommon__languageISO6392B__vot = 460,
	icommon__languageISO6392B__wak = 461,
	icommon__languageISO6392B__wal = 462,
	icommon__languageISO6392B__war = 463,
	icommon__languageISO6392B__was = 464,
	icommon__languageISO6392B__wel = 465,
	icommon__languageISO6392B__wen = 466,
	icommon__languageISO6392B__wln = 467,
	icommon__languageISO6392B__wol = 468,
	icommon__languageISO6392B__xal = 469,
	icommon__languageISO6392B__xho = 470,
	icommon__languageISO6392B__yao = 471,
	icommon__languageISO6392B__yap = 472,
	icommon__languageISO6392B__yid = 473,
	icommon__languageISO6392B__yor = 474,
	icommon__languageISO6392B__ypk = 475,
	icommon__languageISO6392B__zap = 476,
	icommon__languageISO6392B__zbl = 477,
	icommon__languageISO6392B__zen = 478,
	icommon__languageISO6392B__zha = 479,
	icommon__languageISO6392B__znd = 480,
	icommon__languageISO6392B__zul = 481,
	icommon__languageISO6392B__zun = 482,
	icommon__languageISO6392B__zxx = 483,
	icommon__languageISO6392B__zza = 484
};
#endif

/* ws-inspire-wfs2.h:2191 */
#ifndef SOAP_TYPE_icommon__responsiblePartyRole
#define SOAP_TYPE_icommon__responsiblePartyRole (422)
/* icommon:responsiblePartyRole */
enum icommon__responsiblePartyRole {
	icommon__responsiblePartyRole__resourceProvider = 0,
	icommon__responsiblePartyRole__custodian = 1,
	icommon__responsiblePartyRole__owner = 2,
	icommon__responsiblePartyRole__user = 3,
	icommon__responsiblePartyRole__distributor = 4,
	icommon__responsiblePartyRole__originator = 5,
	icommon__responsiblePartyRole__pointOfContact = 6,
	icommon__responsiblePartyRole__principalInvestigator = 7,
	icommon__responsiblePartyRole__processor = 8,
	icommon__responsiblePartyRole__publisher = 9,
	icommon__responsiblePartyRole__author = 10
};
#endif

/* ws-inspire-wfs2.h:2326 */
#ifndef SOAP_TYPE_icommon__serviceSpatialDataResourceType
#define SOAP_TYPE_icommon__serviceSpatialDataResourceType (426)
/* icommon:serviceSpatialDataResourceType */
enum icommon__serviceSpatialDataResourceType {
	icommon__serviceSpatialDataResourceType__service = 0
};
#endif

/* ws-inspire-wfs2.h:2342 */
#ifndef SOAP_TYPE_icommon__viewSpatialDataServiceType
#define SOAP_TYPE_icommon__viewSpatialDataServiceType (428)
/* icommon:viewSpatialDataServiceType */
enum icommon__viewSpatialDataServiceType {
	icommon__viewSpatialDataServiceType__view = 0
};
#endif

/* ws-inspire-wfs2.h:2358 */
#ifndef SOAP_TYPE_icommon__discoverySpatialDataServiceType
#define SOAP_TYPE_icommon__discoverySpatialDataServiceType (430)
/* icommon:discoverySpatialDataServiceType */
enum icommon__discoverySpatialDataServiceType {
	icommon__discoverySpatialDataServiceType__discovery = 0
};
#endif

/* ws-inspire-wfs2.h:2374 */
#ifndef SOAP_TYPE_icommon__transformationSpatialDataServiceType
#define SOAP_TYPE_icommon__transformationSpatialDataServiceType (432)
/* icommon:transformationSpatialDataServiceType */
enum icommon__transformationSpatialDataServiceType {
	icommon__transformationSpatialDataServiceType__transformation = 0
};
#endif

/* ws-inspire-wfs2.h:2390 */
#ifndef SOAP_TYPE_icommon__invokeSpatialDataServiceType
#define SOAP_TYPE_icommon__invokeSpatialDataServiceType (434)
/* icommon:invokeSpatialDataServiceType */
enum icommon__invokeSpatialDataServiceType {
	icommon__invokeSpatialDataServiceType__invoke = 0
};
#endif

/* ws-inspire-wfs2.h:2406 */
#ifndef SOAP_TYPE_icommon__otherSpatialDataServiceType
#define SOAP_TYPE_icommon__otherSpatialDataServiceType (436)
/* icommon:otherSpatialDataServiceType */
enum icommon__otherSpatialDataServiceType {
	icommon__otherSpatialDataServiceType__other = 0
};
#endif

/* ws-inspire-wfs2.h:2434 */
#ifndef SOAP_TYPE_icommon__euLanguageISO6392B
#define SOAP_TYPE_icommon__euLanguageISO6392B (440)
/* icommon:euLanguageISO6392B */
enum icommon__euLanguageISO6392B {
	icommon__euLanguageISO6392B__bul = 0,
	icommon__euLanguageISO6392B__cze = 1,
	icommon__euLanguageISO6392B__dan = 2,
	icommon__euLanguageISO6392B__dut = 3,
	icommon__euLanguageISO6392B__eng = 4,
	icommon__euLanguageISO6392B__est = 5,
	icommon__euLanguageISO6392B__fin = 6,
	icommon__euLanguageISO6392B__fre = 7,
	icommon__euLanguageISO6392B__ger = 8,
	icommon__euLanguageISO6392B__gre = 9,
	icommon__euLanguageISO6392B__hun = 10,
	icommon__euLanguageISO6392B__gle = 11,
	icommon__euLanguageISO6392B__ita = 12,
	icommon__euLanguageISO6392B__lav = 13,
	icommon__euLanguageISO6392B__lit = 14,
	icommon__euLanguageISO6392B__mlt = 15,
	icommon__euLanguageISO6392B__pol = 16,
	icommon__euLanguageISO6392B__por = 17,
	icommon__euLanguageISO6392B__rum = 18,
	icommon__euLanguageISO6392B__slo = 19,
	icommon__euLanguageISO6392B__slv = 20,
	icommon__euLanguageISO6392B__spa = 21,
	icommon__euLanguageISO6392B__swe = 22
};
#endif

/* ws-inspire-wfs2.h:2472 */
#ifndef SOAP_TYPE_icommon__euLanguageIETF
#define SOAP_TYPE_icommon__euLanguageIETF (442)
/* icommon:euLanguageIETF */
enum icommon__euLanguageIETF {
	icommon__euLanguageIETF__bg = 0,
	icommon__euLanguageIETF__bg_BG = 1,
	icommon__euLanguageIETF__cs = 2,
	icommon__euLanguageIETF__cs_CZ = 3,
	icommon__euLanguageIETF__da = 4,
	icommon__euLanguageIETF__da_DK = 5,
	icommon__euLanguageIETF__nl = 6,
	icommon__euLanguageIETF__nl_NL = 7,
	icommon__euLanguageIETF__en = 8,
	icommon__euLanguageIETF__en_GB = 9,
	icommon__euLanguageIETF__et = 10,
	icommon__euLanguageIETF__et_EE = 11,
	icommon__euLanguageIETF__fi = 12,
	icommon__euLanguageIETF__fi_FI = 13,
	icommon__euLanguageIETF__fr = 14,
	icommon__euLanguageIETF__fr_FR = 15,
	icommon__euLanguageIETF__de = 16,
	icommon__euLanguageIETF__de_DE = 17,
	icommon__euLanguageIETF__de_AT = 18,
	icommon__euLanguageIETF__el = 19,
	icommon__euLanguageIETF__el_GR = 20,
	icommon__euLanguageIETF__hu = 21,
	icommon__euLanguageIETF__hu_HU = 22,
	icommon__euLanguageIETF__ga = 23,
	icommon__euLanguageIETF__ga_IE = 24,
	icommon__euLanguageIETF__it = 25,
	icommon__euLanguageIETF__it_IT = 26,
	icommon__euLanguageIETF__lv = 27,
	icommon__euLanguageIETF__lv_LV = 28,
	icommon__euLanguageIETF__lt = 29,
	icommon__euLanguageIETF__lt_LT = 30,
	icommon__euLanguageIETF__mt = 31,
	icommon__euLanguageIETF__mt_MT = 32,
	icommon__euLanguageIETF__pl = 33,
	icommon__euLanguageIETF__pl_PL = 34,
	icommon__euLanguageIETF__pt = 35,
	icommon__euLanguageIETF__pt_PT = 36,
	icommon__euLanguageIETF__ro = 37,
	icommon__euLanguageIETF__ro_RO = 38,
	icommon__euLanguageIETF__sk = 39,
	icommon__euLanguageIETF__sk_SK = 40,
	icommon__euLanguageIETF__sl = 41,
	icommon__euLanguageIETF__sl_SI = 42,
	icommon__euLanguageIETF__es = 43,
	icommon__euLanguageIETF__es_ES = 44,
	icommon__euLanguageIETF__sv = 45,
	icommon__euLanguageIETF__sv_SE = 46
};
#endif

/* ws-inspire-wfs2.h:9803 */
#ifndef SOAP_TYPE__icommon__classificationOfSpatialDataService_KeywordValue
#define SOAP_TYPE__icommon__classificationOfSpatialDataService_KeywordValue (794)
/* icommon:classificationOfSpatialDataService-KeywordValue */
enum _icommon__classificationOfSpatialDataService_KeywordValue {
	_icommon__classificationOfSpatialDataService_KeywordValue__chainDefinitionService = 0,
	_icommon__classificationOfSpatialDataService_KeywordValue__comEncodingService = 1,
	_icommon__classificationOfSpatialDataService_KeywordValue__comGeographicCompressionService = 2,
	_icommon__classificationOfSpatialDataService_KeywordValue__comGeographicFormatConversionService = 3,
	_icommon__classificationOfSpatialDataService_KeywordValue__comMessagingService = 4,
	_icommon__classificationOfSpatialDataService_KeywordValue__comRemoteFileAndExecutableManagement = 5,
	_icommon__classificationOfSpatialDataService_KeywordValue__comService = 6,
	_icommon__classificationOfSpatialDataService_KeywordValue__comTransferService = 7,
	_icommon__classificationOfSpatialDataService_KeywordValue__humanCatalogueViewer = 8,
	_icommon__classificationOfSpatialDataService_KeywordValue__humanChainDefinitionEditor = 9,
	_icommon__classificationOfSpatialDataService_KeywordValue__humanFeatureGeneralizationEditor = 10,
	_icommon__classificationOfSpatialDataService_KeywordValue__humanGeographicDataStructureViewer = 11,
	_icommon__classificationOfSpatialDataService_KeywordValue__humanGeographicFeatureEditor = 12,
	_icommon__classificationOfSpatialDataService_KeywordValue__humanGeographicSpreadsheetViewer = 13,
	_icommon__classificationOfSpatialDataService_KeywordValue__humanGeographicSymbolEditor = 14,
	_icommon__classificationOfSpatialDataService_KeywordValue__humanGeographicViewer = 15,
	_icommon__classificationOfSpatialDataService_KeywordValue__humanInteractionService = 16,
	_icommon__classificationOfSpatialDataService_KeywordValue__humanServiceEditor = 17,
	_icommon__classificationOfSpatialDataService_KeywordValue__humanWorkflowEnactmentManager = 18,
	_icommon__classificationOfSpatialDataService_KeywordValue__infoCatalogueService = 19,
	_icommon__classificationOfSpatialDataService_KeywordValue__infoCoverageAccessService = 20,
	_icommon__classificationOfSpatialDataService_KeywordValue__infoFeatureAccessService = 21,
	_icommon__classificationOfSpatialDataService_KeywordValue__infoFeatureTypeService = 22,
	_icommon__classificationOfSpatialDataService_KeywordValue__infoGazetteerService = 23,
	_icommon__classificationOfSpatialDataService_KeywordValue__infoManagementService = 24,
	_icommon__classificationOfSpatialDataService_KeywordValue__infoMapAccessService = 25,
	_icommon__classificationOfSpatialDataService_KeywordValue__infoOrderHandlingService = 26,
	_icommon__classificationOfSpatialDataService_KeywordValue__infoProductAccessService = 27,
	_icommon__classificationOfSpatialDataService_KeywordValue__infoRegistryService = 28,
	_icommon__classificationOfSpatialDataService_KeywordValue__infoSensorDescriptionService = 29,
	_icommon__classificationOfSpatialDataService_KeywordValue__infoStandingOrderService = 30,
	_icommon__classificationOfSpatialDataService_KeywordValue__metadataGeographicAnnotationService = 31,
	_icommon__classificationOfSpatialDataService_KeywordValue__metadataProcessingService = 32,
	_icommon__classificationOfSpatialDataService_KeywordValue__metadataStatisticalCalculationService = 33,
	_icommon__classificationOfSpatialDataService_KeywordValue__spatialCoordinateConversionService = 34,
	_icommon__classificationOfSpatialDataService_KeywordValue__spatialCoordinateTransformationService = 35,
	_icommon__classificationOfSpatialDataService_KeywordValue__spatialCoverageVectorConversionService = 36,
	_icommon__classificationOfSpatialDataService_KeywordValue__spatialDimensionMeasurementService = 37,
	_icommon__classificationOfSpatialDataService_KeywordValue__spatialFeatureGeneralizationService = 38,
	_icommon__classificationOfSpatialDataService_KeywordValue__spatialFeatureManipulationService = 39,
	_icommon__classificationOfSpatialDataService_KeywordValue__spatialFeatureMatchingService = 40,
	_icommon__classificationOfSpatialDataService_KeywordValue__spatialImageCoordinateConversionService = 41,
	_icommon__classificationOfSpatialDataService_KeywordValue__spatialImageGeometryModelConversionService = 42,
	_icommon__classificationOfSpatialDataService_KeywordValue__spatialOrthorectificationService = 43,
	_icommon__classificationOfSpatialDataService_KeywordValue__spatialPositioningService = 44,
	_icommon__classificationOfSpatialDataService_KeywordValue__spatialProcessingService = 45,
	_icommon__classificationOfSpatialDataService_KeywordValue__spatialProximityAnalysisService = 46,
	_icommon__classificationOfSpatialDataService_KeywordValue__spatialRectificationService = 47,
	_icommon__classificationOfSpatialDataService_KeywordValue__spatialRouteDeterminationService = 48,
	_icommon__classificationOfSpatialDataService_KeywordValue__spatialSamplingService = 49,
	_icommon__classificationOfSpatialDataService_KeywordValue__spatialSensorGeometryModelAdjustmentService = 50,
	_icommon__classificationOfSpatialDataService_KeywordValue__spatialSubsettingService = 51,
	_icommon__classificationOfSpatialDataService_KeywordValue__spatialTilingChangeService = 52,
	_icommon__classificationOfSpatialDataService_KeywordValue__subscriptionService = 53,
	_icommon__classificationOfSpatialDataService_KeywordValue__taskManagementService = 54,
	_icommon__classificationOfSpatialDataService_KeywordValue__temporalProcessingService = 55,
	_icommon__classificationOfSpatialDataService_KeywordValue__temporalProximityAnalysisService = 56,
	_icommon__classificationOfSpatialDataService_KeywordValue__temporalReferenceSystemTransformationService = 57,
	_icommon__classificationOfSpatialDataService_KeywordValue__temporalSamplingService = 58,
	_icommon__classificationOfSpatialDataService_KeywordValue__temporalSubsettingService = 59,
	_icommon__classificationOfSpatialDataService_KeywordValue__thematicChangeDetectionService = 60,
	_icommon__classificationOfSpatialDataService_KeywordValue__thematicClassificationService = 61,
	_icommon__classificationOfSpatialDataService_KeywordValue__thematicFeatureGeneralizationService = 62,
	_icommon__classificationOfSpatialDataService_KeywordValue__thematicGeocodingService = 63,
	_icommon__classificationOfSpatialDataService_KeywordValue__thematicGeographicInformationExtractionService = 64,
	_icommon__classificationOfSpatialDataService_KeywordValue__thematicGeoparsingService = 'A',
	_icommon__classificationOfSpatialDataService_KeywordValue__thematicGoparameterCalculationService = 'B',
	_icommon__classificationOfSpatialDataService_KeywordValue__thematicImageManipulationService = 'C',
	_icommon__classificationOfSpatialDataService_KeywordValue__thematicImageProcessingService = 'D',
	_icommon__classificationOfSpatialDataService_KeywordValue__thematicImageSynthesisService = 'E',
	_icommon__classificationOfSpatialDataService_KeywordValue__thematicImageUnderstandingService = 'F',
	_icommon__classificationOfSpatialDataService_KeywordValue__thematicMultibandImageManipulationService = 'G',
	_icommon__classificationOfSpatialDataService_KeywordValue__thematicObjectDetectionService = 'H',
	_icommon__classificationOfSpatialDataService_KeywordValue__thematicProcessingService = 'I',
	_icommon__classificationOfSpatialDataService_KeywordValue__thematicReducedResolutionGenerationService = 'J',
	_icommon__classificationOfSpatialDataService_KeywordValue__thematicSpatialCountingService = 'K',
	_icommon__classificationOfSpatialDataService_KeywordValue__thematicSubsettingService = 'L',
	_icommon__classificationOfSpatialDataService_KeywordValue__workflowEnactmentService = 'M'
};
#endif

/* ws-inspire-wfs2.h:9994 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fbul_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fbul_URL (796)
/* icommon:resLocInspireInteroperabilityRegulation_bul-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fbul_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005fbul_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aBG_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:9999 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fbul_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fbul_MediaType (797)
/* icommon:resLocInspireInteroperabilityRegulation_bul-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fbul_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005fbul_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10023 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fcze_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fcze_URL (798)
/* icommon:resLocInspireInteroperabilityRegulation_cze-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fcze_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005fcze_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aCS_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10028 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fcze_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fcze_MediaType (799)
/* icommon:resLocInspireInteroperabilityRegulation_cze-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fcze_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005fcze_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10052 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fdan_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fdan_URL (800)
/* icommon:resLocInspireInteroperabilityRegulation_dan-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fdan_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005fdan_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aDA_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10057 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fdan_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fdan_MediaType (801)
/* icommon:resLocInspireInteroperabilityRegulation_dan-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fdan_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005fdan_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10081 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fdut_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fdut_URL (802)
/* icommon:resLocInspireInteroperabilityRegulation_dut-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fdut_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005fdut_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aNL_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10086 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fdut_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fdut_MediaType (803)
/* icommon:resLocInspireInteroperabilityRegulation_dut-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fdut_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005fdut_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10110 */
#ifndef SOAP_TYPE__icommon__resLocGEMETInspireThemes_x005feng_URL
#define SOAP_TYPE__icommon__resLocGEMETInspireThemes_x005feng_URL (804)
/* icommon:resLocGEMETInspireThemes_eng-URL */
enum _icommon__resLocGEMETInspireThemes_x005feng_URL {
	_icommon__resLocGEMETInspireThemes_x005feng_URL__http_x003a_x002f_x002fwww_x002eeionet_x002eeuropa_x002eeu_x002fgemet_x002finspire_x005fthemes_x003flangcode_x003den = 0
};
#endif

/* ws-inspire-wfs2.h:10115 */
#ifndef SOAP_TYPE__icommon__resLocGEMETInspireThemes_x005feng_MediaType
#define SOAP_TYPE__icommon__resLocGEMETInspireThemes_x005feng_MediaType (805)
/* icommon:resLocGEMETInspireThemes_eng-MediaType */
enum _icommon__resLocGEMETInspireThemes_x005feng_MediaType {
	_icommon__resLocGEMETInspireThemes_x005feng_MediaType__text_x002fhtml = 0
};
#endif

/* ws-inspire-wfs2.h:10139 */
#ifndef SOAP_TYPE__icommon__citationGEMETInspireThemes_x005feng_Title
#define SOAP_TYPE__icommon__citationGEMETInspireThemes_x005feng_Title (806)
/* icommon:citationGEMETInspireThemes_eng-Title */
enum _icommon__citationGEMETInspireThemes_x005feng_Title {
	_icommon__citationGEMETInspireThemes_x005feng_Title__GEMET_x0020__x0020INSPIRE_x0020themes = 0
};
#endif

/* ws-inspire-wfs2.h:10148 */
#ifndef SOAP_TYPE__icommon__citationGEMETInspireThemes_x005feng_DateOfPublication
#define SOAP_TYPE__icommon__citationGEMETInspireThemes_x005feng_DateOfPublication (808)
/* icommon:citationGEMETInspireThemes_eng-DateOfPublication */
enum _icommon__citationGEMETInspireThemes_x005feng_DateOfPublication {
	_icommon__citationGEMETInspireThemes_x005feng_DateOfPublication__2008_06_01 = 0
};
#endif

/* ws-inspire-wfs2.h:10179 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005feng_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005feng_URL (811)
/* icommon:resLocInspireInteroperabilityRegulation_eng-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005feng_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005feng_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aEN_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10184 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005feng_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005feng_MediaType (812)
/* icommon:resLocInspireInteroperabilityRegulation_eng-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005feng_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005feng_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10208 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fest_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fest_URL (813)
/* icommon:resLocInspireInteroperabilityRegulation_est-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fest_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005fest_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aET_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10213 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fest_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fest_MediaType (814)
/* icommon:resLocInspireInteroperabilityRegulation_est-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fest_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005fest_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10237 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005ffin_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005ffin_URL (815)
/* icommon:resLocInspireInteroperabilityRegulation_fin-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005ffin_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005ffin_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aFI_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10242 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005ffin_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005ffin_MediaType (816)
/* icommon:resLocInspireInteroperabilityRegulation_fin-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005ffin_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005ffin_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10266 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005ffre_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005ffre_URL (817)
/* icommon:resLocInspireInteroperabilityRegulation_fre-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005ffre_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005ffre_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aFR_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10271 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005ffre_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005ffre_MediaType (818)
/* icommon:resLocInspireInteroperabilityRegulation_fre-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005ffre_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005ffre_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10295 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fger_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fger_URL (819)
/* icommon:resLocInspireInteroperabilityRegulation_ger-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fger_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005fger_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aDE_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10300 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fger_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fger_MediaType (820)
/* icommon:resLocInspireInteroperabilityRegulation_ger-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fger_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005fger_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10324 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fgle_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fgle_URL (821)
/* icommon:resLocInspireInteroperabilityRegulation_gle-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fgle_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005fgle_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aEN_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10329 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fgle_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fgle_MediaType (822)
/* icommon:resLocInspireInteroperabilityRegulation_gle-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fgle_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005fgle_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10353 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fgre_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fgre_URL (823)
/* icommon:resLocInspireInteroperabilityRegulation_gre-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fgre_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005fgre_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aEL_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10358 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fgre_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fgre_MediaType (824)
/* icommon:resLocInspireInteroperabilityRegulation_gre-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fgre_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005fgre_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10382 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fhun_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fhun_URL (825)
/* icommon:resLocInspireInteroperabilityRegulation_hun-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fhun_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005fhun_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aHU_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10387 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fhun_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fhun_MediaType (826)
/* icommon:resLocInspireInteroperabilityRegulation_hun-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fhun_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005fhun_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10411 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fita_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fita_URL (827)
/* icommon:resLocInspireInteroperabilityRegulation_ita-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fita_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005fita_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aIT_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10416 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fita_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fita_MediaType (828)
/* icommon:resLocInspireInteroperabilityRegulation_ita-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fita_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005fita_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10440 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005flav_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005flav_URL (829)
/* icommon:resLocInspireInteroperabilityRegulation_lav-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005flav_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005flav_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aLV_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10445 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005flav_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005flav_MediaType (830)
/* icommon:resLocInspireInteroperabilityRegulation_lav-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005flav_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005flav_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10469 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005flit_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005flit_URL (831)
/* icommon:resLocInspireInteroperabilityRegulation_lit-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005flit_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005flit_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aLT_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10474 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005flit_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005flit_MediaType (832)
/* icommon:resLocInspireInteroperabilityRegulation_lit-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005flit_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005flit_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10498 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fmlt_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fmlt_URL (833)
/* icommon:resLocInspireInteroperabilityRegulation_mlt-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fmlt_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005fmlt_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aMT_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10503 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fmlt_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fmlt_MediaType (834)
/* icommon:resLocInspireInteroperabilityRegulation_mlt-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fmlt_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005fmlt_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10527 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fpol_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fpol_URL (835)
/* icommon:resLocInspireInteroperabilityRegulation_pol-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fpol_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005fpol_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aPL_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10532 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fpol_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fpol_MediaType (836)
/* icommon:resLocInspireInteroperabilityRegulation_pol-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fpol_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005fpol_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10556 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fpor_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fpor_URL (837)
/* icommon:resLocInspireInteroperabilityRegulation_por-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fpor_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005fpor_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aPT_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10561 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fpor_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fpor_MediaType (838)
/* icommon:resLocInspireInteroperabilityRegulation_por-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fpor_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005fpor_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10585 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005frum_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005frum_URL (839)
/* icommon:resLocInspireInteroperabilityRegulation_rum-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005frum_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005frum_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aRO_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10590 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005frum_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005frum_MediaType (840)
/* icommon:resLocInspireInteroperabilityRegulation_rum-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005frum_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005frum_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10614 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fslo_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fslo_URL (841)
/* icommon:resLocInspireInteroperabilityRegulation_slo-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fslo_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005fslo_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aSK_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10619 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fslo_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fslo_MediaType (842)
/* icommon:resLocInspireInteroperabilityRegulation_slo-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fslo_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005fslo_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10643 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fslv_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fslv_URL (843)
/* icommon:resLocInspireInteroperabilityRegulation_slv-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fslv_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005fslv_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aSL_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10648 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fslv_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fslv_MediaType (844)
/* icommon:resLocInspireInteroperabilityRegulation_slv-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fslv_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005fslv_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10672 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fspa_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fspa_URL (845)
/* icommon:resLocInspireInteroperabilityRegulation_spa-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fspa_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005fspa_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aEN_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10677 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fspa_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fspa_MediaType (846)
/* icommon:resLocInspireInteroperabilityRegulation_spa-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fspa_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005fspa_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:10701 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fswe_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fswe_URL (847)
/* icommon:resLocInspireInteroperabilityRegulation_swe-URL */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fswe_URL {
	_icommon__resLocInspireInteroperabilityRegulation_x005fswe_URL__http_x003a_x002f_x002feur_lex_x002eeuropa_x002eeu_x002fLexUriServ_x002fLexUriServ_x002edo_x003furi_x003dOJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aSV_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:10706 */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fswe_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fswe_MediaType (848)
/* icommon:resLocInspireInteroperabilityRegulation_swe-MediaType */
enum _icommon__resLocInspireInteroperabilityRegulation_x005fswe_MediaType {
	_icommon__resLocInspireInteroperabilityRegulation_x005fswe_MediaType__application_x002fpdf = 0
};
#endif

/* ws-inspire-wfs2.h:11229 */
#ifndef SOAP_TYPE__icommon__dataset_ResourceType
#define SOAP_TYPE__icommon__dataset_ResourceType (864)
/* icommon:dataset-ResourceType */
enum _icommon__dataset_ResourceType {
	_icommon__dataset_ResourceType__dataset = 0
};
#endif

/* ws-inspire-wfs2.h:11312 */
#ifndef SOAP_TYPE__icommon__series_ResourceType
#define SOAP_TYPE__icommon__series_ResourceType (867)
/* icommon:series-ResourceType */
enum _icommon__series_ResourceType {
	_icommon__series_ResourceType__series = 0
};
#endif

/* ws-inspire-wfs2.h:11483 */
#ifndef SOAP_TYPE__icommon__originatingControlledVocabularyGemetInspireThemes_Title
#define SOAP_TYPE__icommon__originatingControlledVocabularyGemetInspireThemes_Title (868)
/* icommon:originatingControlledVocabularyGemetInspireThemes-Title */
enum _icommon__originatingControlledVocabularyGemetInspireThemes_Title {
	_icommon__originatingControlledVocabularyGemetInspireThemes_Title__GEMET_x0020__x0020INSPIRE_x0020themes = 0
};
#endif

/* ws-inspire-wfs2.h:11492 */
#ifndef SOAP_TYPE__icommon__originatingControlledVocabularyGemetInspireThemes_DateOfPublication
#define SOAP_TYPE__icommon__originatingControlledVocabularyGemetInspireThemes_DateOfPublication (870)
/* icommon:originatingControlledVocabularyGemetInspireThemes-DateOfPublication */
enum _icommon__originatingControlledVocabularyGemetInspireThemes_DateOfPublication {
	_icommon__originatingControlledVocabularyGemetInspireThemes_DateOfPublication__2008_06_01 = 0
};
#endif

/* ws-inspire-wfs2.h:11520 */
#ifndef SOAP_TYPE__icommon__originatingControlledVocabularyMD_Title
#define SOAP_TYPE__icommon__originatingControlledVocabularyMD_Title (872)
/* icommon:originatingControlledVocabularyMD-Title */
enum _icommon__originatingControlledVocabularyMD_Title {
	_icommon__originatingControlledVocabularyMD_Title__GEMET_x0020__x0020INSPIRE_x0020themes = 0
};
#endif

/* ws-inspire-wfs2.h:11529 */
#ifndef SOAP_TYPE__icommon__originatingControlledVocabularyMD_DateOfPublication
#define SOAP_TYPE__icommon__originatingControlledVocabularyMD_DateOfPublication (874)
/* icommon:originatingControlledVocabularyMD-DateOfPublication */
enum _icommon__originatingControlledVocabularyMD_DateOfPublication {
	_icommon__originatingControlledVocabularyMD_DateOfPublication__2008_06_01 = 0
};
#endif

/* ws-inspire-wfs2.h:11559 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fbul_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fbul_KeywordValue (876)
/* icommon:inspireTheme_bul-KeywordValue */
enum _icommon__inspireTheme_x005fbul_KeywordValue {
	_icommon__inspireTheme_x005fbul_KeywordValue___x0410_x0434_x043c_x0438_x043d_x0438_x0441_x0442_x0440_x0430_x0442_x0438_x0432_x043d_x0438_x0020_x0435_x0434_x0438_x043d_x0438_x0446_x0438 = 0,
	_icommon__inspireTheme_x005fbul_KeywordValue___x0410_x0434_x0440_x0435_x0441_x0438 = 1,
	_icommon__inspireTheme_x005fbul_KeywordValue___x0410_x0442_x043c_x043e_x0441_x0444_x0435_x0440_x043d_x0438_x0020_x0443_x0441_x043b_x043e_x0432_x0438_x044f = 2,
	_icommon__inspireTheme_x005fbul_KeywordValue___x0411_x0438_x043e_x0433_x0435_x043e_x0433_x0440_x0430_x0444_x0441_x043a_x0438_x0020_x0440_x0435_x0433_x0438_x043e_x043d_x0438 = 3,
	_icommon__inspireTheme_x005fbul_KeywordValue___x0413_x0435_x043e_x0433_x0440_x0430_x0444_x0441_x043a_x0438_x0020_x043a_x043e_x043e_x0440_x0434_x0438_x043d_x0430_x0442_x043d_x0438_x0020_x0441_x0438_x0441_x0442_x0435_x043c_x0438 = 4,
	_icommon__inspireTheme_x005fbul_KeywordValue___x0413_x0435_x043e_x0433_x0440_x0430_x0444_x0441_x043a_x0438_x0020_x043d_x0430_x0438_x043c_x0435_x043d_x043e_x0432_x0430_x043d_x0438_x044f = 5,
	_icommon__inspireTheme_x005fbul_KeywordValue___x0413_x0435_x043e_x043b_x043e_x0433_x0438_x044f = 6,
	_icommon__inspireTheme_x005fbul_KeywordValue___x0415_x043d_x0435_x0440_x0433_x0438_x0439_x043d_x0438_x0020_x0438_x0437_x0442_x043e_x0447_x043d_x0438_x0446_x0438 = 7,
	_icommon__inspireTheme_x005fbul_KeywordValue___x0417_x0430_x0449_x0438_x0442_x0435_x043d_x0438_x0020_x043e_x0431_x0435_x043a_x0442_x0438 = 8,
	_icommon__inspireTheme_x005fbul_KeywordValue___x0417_x0434_x0440_x0430_x0432_x0435_x0020_x0438_x0020_x0431_x0435_x0437_x043e_x043f_x0430_x0441_x043d_x043e_x0441_x0442_x0020_x043d_x0430_x0020_x0447_x043e_x0432_x0435_x043a_x0430 = 9,
	_icommon__inspireTheme_x005fbul_KeywordValue___x0417_x0435_x043c_x043d_x0430_x0020_x043f_x043e_x043a_x0440_x0438_x0432_x043a_x0430 = 10,
	_icommon__inspireTheme_x005fbul_KeywordValue___x041a_x0430_x0434_x0430_x0441_x0442_x0440_x0430_x043b_x043d_x0438_x0020_x043f_x0430_x0440_x0446_x0435_x043b_x0438 = 11,
	_icommon__inspireTheme_x005fbul_KeywordValue___x041a_x043e_x043c_x0443_x043d_x0430_x043b_x043d_x043e__x0431_x0438_x0442_x043e_x0432_x0438_x0020_x0438_x0020_x043e_x0431_x0449_x0435_x0441_x0442_x0432_x0435_x043d_x0438_x0020_x0443_x0441_x043b_x0443_x0433_x0438 = 12,
	_icommon__inspireTheme_x005fbul_KeywordValue___x041a_x043e_x043e_x0440_x0434_x0438_x043d_x0430_x0442_x043d_x0438_x0020_x0441_x043f_x0440_x0430_x0432_x043e_x0447_x043d_x0438_x0020_x0441_x0438_x0441_x0442_x0435_x043c_x0438 = 13,
	_icommon__inspireTheme_x005fbul_KeywordValue___x041c_x0435_x0441_x0442_x043e_x043e_x0431_x0438_x0442_x0430_x043d_x0438_x044f_x0020_x0438_x0020_x0431_x0438_x043e_x0442_x043e_x043f_x0438 = 14,
	_icommon__inspireTheme_x005fbul_KeywordValue___x041c_x0435_x0442_x0435_x043e_x0440_x043e_x043b_x043e_x0433_x0438_x0447_x043d_x0438_x0020_x0433_x0435_x043e_x0433_x0440_x0430_x0444_x0441_x043a_x0438_x0020_x0445_x0430_x0440_x0430_x043a_x0442_x0435_x0440_x0438_x0441_x0442_x0438_x043a_x0438 = 15,
	_icommon__inspireTheme_x005fbul_KeywordValue___x041c_x0438_x043d_x0435_x0440_x0430_x043b_x043d_x0438_x0020_x0440_x0435_x0441_x0443_x0440_x0441_x0438 = 16,
	_icommon__inspireTheme_x005fbul_KeywordValue___x041c_x043e_x0440_x0441_x043a_x0438_x0020_x0440_x0435_x0433_x0438_x043e_x043d_x0438 = 17,
	_icommon__inspireTheme_x005fbul_KeywordValue___x041e_x043a_x0435_x0430_x043d_x043e_x0433_x0440_x0430_x0444_x0441_x043a_x0438_x0020_x0433_x0435_x043e_x0433_x0440_x0430_x0444_x0441_x043a_x0438_x0020_x0445_x0430_x0440_x0430_x043a_x0442_x0435_x0440_x0438_x0441_x0442_x0438_x043a_x0438 = 18,
	_icommon__inspireTheme_x005fbul_KeywordValue___x041e_x0440_x0442_x043e_x0438_x0437_x043e_x0431_x0440_x0430_x0436_x0435_x043d_x0438_x0435 = 19,
	_icommon__inspireTheme_x005fbul_KeywordValue___x041f_x043e_x043b_x0437_x0432_x0430_x043d_x0435_x0020_x043d_x0430_x0020_x0437_x0435_x043c_x044f_x0442_x0430 = 20,
	_icommon__inspireTheme_x005fbul_KeywordValue___x041f_x043e_x0447_x0432_x0430 = 21,
	_icommon__inspireTheme_x005fbul_KeywordValue___x041f_x0440_x0438_x0440_x043e_x0434_x043d_x0438_x0020_x0440_x0438_x0441_x043a_x043e_x0432_x0438_x0020_x0437_x043e_x043d_x0438 = 22,
	_icommon__inspireTheme_x005fbul_KeywordValue___x041f_x0440_x043e_x0438_x0437_x0432_x043e_x0434_x0441_x0442_x0432_x0435_x043d_x0438_x0020_x0438_x0020_x043f_x0440_x043e_x043c_x0438_x0448_x043b_x0435_x043d_x0438_x0020_x0441_x044a_x043e_x0440_x044a_x0436_x0435_x043d_x0438_x044f = 23,
	_icommon__inspireTheme_x005fbul_KeywordValue___x0420_x0430_x0437_x043f_x0440_x0435_x0434_x0435_x043b_x0435_x043d_x0438_x0435_x0020_x043d_x0430_x0020_x0432_x0438_x0434_x043e_x0432_x0435_x0442_x0435 = 24,
	_icommon__inspireTheme_x005fbul_KeywordValue___x0420_x0430_x0437_x043f_x0440_x0435_x0434_x0435_x043b_x0435_x043d_x0438_x0435_x0020_x043d_x0430_x0020_x043d_x0430_x0441_x0435_x043b_x0435_x043d_x0438_x0435_x0442_x043e_x0020_x2014_x0020_x0434_x0435_x043c_x043e_x0433_x0440_x0430_x0444_x0438_x044f = 25,
	_icommon__inspireTheme_x005fbul_KeywordValue___x0420_x0435_x043b_x0435_x0444 = 26,
	_icommon__inspireTheme_x005fbul_KeywordValue___x0421_x0433_x0440_x0430_x0434_x0438 = 27,
	_icommon__inspireTheme_x005fbul_KeywordValue___x0421_x0435_x043b_x0441_x043a_x043e_x0441_x0442_x043e_x043f_x0430_x043d_x0441_x043a_x0438_x0020_x0438_x0020_x0432_x043e_x0434_x043d_x043e_x0441_x0442_x043e_x043f_x0430_x043d_x0441_x043a_x0438_x0020_x0441_x044a_x043e_x0440_x044a_x0436_x0435_x043d_x0438_x044f = 28,
	_icommon__inspireTheme_x005fbul_KeywordValue___x0421_x0442_x0430_x0442_x0438_x0441_x0442_x0438_x0447_x0435_x0441_x043a_x0438_x0020_x0435_x0434_x0438_x043d_x0438_x0446_x0438 = 29,
	_icommon__inspireTheme_x005fbul_KeywordValue___x0421_x044a_x043e_x0440_x044a_x0436_x0435_x043d_x0438_x044f_x0020_x0437_x0430_x0020_x0443_x043f_x0440_x0430_x0432_x043b_x0435_x043d_x0438_x0435_x0020_x043d_x0430_x0020_x043e_x043a_x043e_x043b_x043d_x0430_x0442_x0430_x0020_x0441_x0440_x0435_x0434_x0430 = 30,
	_icommon__inspireTheme_x005fbul_KeywordValue___x0422_x0440_x0430_x043d_x0441_x043f_x043e_x0440_x0442_x043d_x0438_x0020_x043c_x0440_x0435_x0436_x0438 = 31,
	_icommon__inspireTheme_x005fbul_KeywordValue___x0423_x043f_x0440_x0430_x0432_x043b_x0435_x043d_x0438_x0435_x0020_x043d_x0430_x0020_x0442_x0435_x0440_x0438_x0442_x043e_x0440_x0438_x044f_x0442_x0430_x002f_x043e_x0433_x0440_x0430_x043d_x0438_x0447_x0435_x043d_x0438_x002f_x0440_x0435_x0433_x0443_x043b_x0438_x0440_x0430_x043d_x0438_x0020_x0437_x043e_x043d_x0438_x0020_x0438_x0020_x043e_x0442_x0447_x0435_x0442_x043d_x0438_x0020_x0435_x0434_x0438_x043d_x0438_x0446_x0438 = 32,
	_icommon__inspireTheme_x005fbul_KeywordValue___x0425_x0438_x0434_x0440_x043e_x0433_x0440_x0430_x0444_x0438_x044f = 33
};
#endif

/* ws-inspire-wfs2.h:11618 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fbul_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fbul_Title (877)
/* icommon:citationInspireInteroperabilityRegulation_bul-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005fbul_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005fbul_Title___x0420_x0415_x0413_x041b_x0410_x041c_x0415_x041d_x0422_x0020_x0028_x0415_x0421_x0029_x0020_x2116_x00201089_x002f2010_x0020_x041d_x0410_x0020_x041a_x041e_x041c_x0418_x0421_x0418_x042f_x0422_x0410_x0020_x043e_x0442_x002023_x0020_x043d_x043e_x0435_x043c_x0432_x0440_x0438_x00202010_x0020_x0433_x043e_x0434_x0438_x043d_x0430_x0020_x0437_x0430_x0020_x043f_x0440_x0438_x043b_x0430_x0433_x0430_x043d_x0435_x0020_x043d_x0430_x0020_x0414_x0438_x0440_x0435_x043a_x0442_x0438_x0432_x0430_x00202007_x002f2_x002f_x0415_x041e_x0020_x043d_x0430_x0020_x0415_x0432_x0440_x043e_x043f_x0435_x0439_x0441_x043a_x0438_x044f_x0020_x043f_x0430_x0440_x043b_x0430_x043c_x0435_x043d_x0442_x0020_x0438_x0020_x043d_x0430_x0020_x0421_x044a_x0432_x0435_x0442_x0430_x0020_x043f_x043e_x0020_x043e_x0442_x043d_x043e_x0448_x0435_x043d_x0438_x0435_x0020_x043d_x0430_x0020_x043e_x043f_x0435_x0440_x0430_x0442_x0438_x0432_x043d_x0430_x0442_x0430_x0020_x0441_x044a_x0432_x043c_x0435_x0441_x0442_x0438_x043c_x043e_x0441_x0442_x0020_x043d_x0430_x0020_x043c_x0430_x0441_x0438_x0432_x0438_x0020_x043e_x0442_x0020_x043f_x0440_x043e_x0441_x0442_x0440_x0430_x043d_x0441_x0442_x0432_x0435_x043d_x0438_x0020_x0434_x0430_x043d_x043d_x0438_x0020_x0438_x0020_x0443_x0441_x043b_x0443_x0433_x0438_x0020_x0437_x0430_x0020_x043f_x0440_x043e_x0441_x0442_x0440_x0430_x043d_x0441_x0442_x0432_x0435_x043d_x0438_x0020_x0434_x0430_x043d_x043d_x0438 = 0
};
#endif

/* ws-inspire-wfs2.h:11627 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fbul_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fbul_DateOfPublication (879)
/* icommon:citationInspireInteroperabilityRegulation_bul-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005fbul_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005fbul_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:11634 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fbul_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fbul_URI (881)
/* icommon:citationInspireInteroperabilityRegulation_bul-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005fbul_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005fbul_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aBG_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:11664 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fcze_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fcze_KeywordValue (883)
/* icommon:inspireTheme_cze-KeywordValue */
enum _icommon__inspireTheme_x005fcze_KeywordValue {
	_icommon__inspireTheme_x005fcze_KeywordValue__Adresy = 0,
	_icommon__inspireTheme_x005fcze_KeywordValue__Bioregiony = 1,
	_icommon__inspireTheme_x005fcze_KeywordValue__Budovy = 2,
	_icommon__inspireTheme_x005fcze_KeywordValue__Chr_x00e1n_x011bn_x00e1_x0020_x00fazem_x00ed = 3,
	_icommon__inspireTheme_x005fcze_KeywordValue__Dopravn_x00ed_x0020s_x00edt_x011b = 4,
	_icommon__inspireTheme_x005fcze_KeywordValue__Energetick_x00e9_x0020zdroje = 5,
	_icommon__inspireTheme_x005fcze_KeywordValue__Geologie = 6,
	_icommon__inspireTheme_x005fcze_KeywordValue__Katastr_x00e1ln_x00ed_x0020parcely = 7,
	_icommon__inspireTheme_x005fcze_KeywordValue__Krajinn_x00fd_x0020pokryv = 8,
	_icommon__inspireTheme_x005fcze_KeywordValue__Lidsk_x00e9_x0020zdrav_x00ed_x0020a_x0020bezpe_x010dnost = 9,
	_icommon__inspireTheme_x005fcze_KeywordValue__Mo_x0159sk_x00e9_x0020oblasti = 10,
	_icommon__inspireTheme_x005fcze_KeywordValue__Nadmo_x0159sk_x00e1_x0020v_x00fd_x0161ka = 11,
	_icommon__inspireTheme_x005fcze_KeywordValue__Nerostn_x00e9_x0020suroviny = 12,
	_icommon__inspireTheme_x005fcze_KeywordValue__Oblasti_x0020ohro_x017een_x00e9_x0020p_x0159_x00edrodn_x00edmi_x0020riziky = 13,
	_icommon__inspireTheme_x005fcze_KeywordValue__Ortofotosn_x00edmky = 14,
	_icommon__inspireTheme_x005fcze_KeywordValue__P_x016fda = 15,
	_icommon__inspireTheme_x005fcze_KeywordValue__Rozlo_x017een_x00ed_x0020druh_x016f = 16,
	_icommon__inspireTheme_x005fcze_KeywordValue__Rozlo_x017een_x00ed_x0020obyvatelstva_x0020_x2013_x0020demografie = 17,
	_icommon__inspireTheme_x005fcze_KeywordValue__Sou_x0159adnicov_x00e9_x0020referen_x010dn_x00ed_x0020syst_x00e9my = 18,
	_icommon__inspireTheme_x005fcze_KeywordValue__Spr_x00e1vn_x00ed_x0020jednotky = 19,
	_icommon__inspireTheme_x005fcze_KeywordValue__Spr_x00e1vn_x00ed_x0020oblasti_x002fchr_x00e1n_x011bn_x00e1_x0020p_x00e1sma_x002fregulovan_x00e1_x0020_x00fazem_x00ed_x0020a_x0020jednotky_x0020pod_x00e1vaj_x00edc_x00ed_x0020hl_x00e1_x0161en_x00ed = 20,
	_icommon__inspireTheme_x005fcze_KeywordValue__Stanovi_x0161t_x011b_x0020a_x0020biotopy = 21,
	_icommon__inspireTheme_x005fcze_KeywordValue__Statistick_x00e9_x0020jednotky = 22,
	_icommon__inspireTheme_x005fcze_KeywordValue__Stav_x0020ovzdu_x0161_x00ed = 23,
	_icommon__inspireTheme_x005fcze_KeywordValue__Ve_x0159ejn_x00e9_x0020slu_x017eby_x0020a_x0020slu_x017eby_x0020ve_x0159ejn_x00e9_x0020spr_x00e1vy = 24,
	_icommon__inspireTheme_x005fcze_KeywordValue__Vodopis = 25,
	_icommon__inspireTheme_x005fcze_KeywordValue__V_x00fdrobn_x00ed_x0020a_x0020pr_x016fmyslov_x00e1_x0020za_x0159_x00edzen_x00ed = 26,
	_icommon__inspireTheme_x005fcze_KeywordValue__Vyu_x017eit_x00ed_x0020_x00fazem_x00ed = 27,
	_icommon__inspireTheme_x005fcze_KeywordValue__Za_x0159_x00edzen_x00ed_x0020pro_x0020sledov_x00e1n_x00ed_x0020_x017eivotn_x00edho_x0020prost_x0159ed_x00ed = 28,
	_icommon__inspireTheme_x005fcze_KeywordValue__Zem_x011bd_x011blsk_x00e1_x0020a_x0020akvakulturn_x00ed_x0020za_x0159_x00edzen_x00ed = 29,
	_icommon__inspireTheme_x005fcze_KeywordValue__Zem_x011bpisn_x00e9_x0020meteorologick_x00e9_x0020prvky = 30,
	_icommon__inspireTheme_x005fcze_KeywordValue__Zem_x011bpisn_x00e9_x0020n_x00e1zvy = 31,
	_icommon__inspireTheme_x005fcze_KeywordValue__Zem_x011bpisn_x00e9_x0020oce_x00e1nografick_x00e9_x0020prvky = 32,
	_icommon__inspireTheme_x005fcze_KeywordValue__Zem_x011bpisn_x00e9_x0020soustavy_x0020sou_x0159adnicov_x00fdch_x0020s_x00edt_x00ed = 33
};
#endif

/* ws-inspire-wfs2.h:11723 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fcze_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fcze_Title (884)
/* icommon:citationInspireInteroperabilityRegulation_cze-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005fcze_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005fcze_Title__NA_x0158_x00cdZEN_x00cd_x0020KOMISE_x0020_x0028EU_x0029_x0020_x010d_x002e_x00201089_x002f2010_x0020ze_x0020dne_x002023_x002e_x0020listopadu_x00202010_x002c_x0020kter_x00fdm_x0020se_x0020prov_x00e1d_x00ed_x0020sm_x011brnice_x0020Evropsk_x00e9ho_x0020parlamentu_x0020a_x0020Rady_x00202007_x002f2_x002fES_x002c_x0020pokud_x0020jde_x0020o_x0020interoperabilitu_x0020sad_x0020prostorov_x00fdch_x0020dat_x0020a_x0020slu_x017eeb_x0020prostorov_x00fdch_x0020dat = 0
};
#endif

/* ws-inspire-wfs2.h:11732 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fcze_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fcze_DateOfPublication (886)
/* icommon:citationInspireInteroperabilityRegulation_cze-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005fcze_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005fcze_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:11739 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fcze_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fcze_URI (888)
/* icommon:citationInspireInteroperabilityRegulation_cze-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005fcze_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005fcze_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aCS_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:11769 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fdan_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fdan_KeywordValue (890)
/* icommon:inspireTheme_dan-KeywordValue */
enum _icommon__inspireTheme_x005fdan_KeywordValue {
	_icommon__inspireTheme_x005fdan_KeywordValue__Administrative_x0020enheder = 0,
	_icommon__inspireTheme_x005fdan_KeywordValue__Adresser = 1,
	_icommon__inspireTheme_x005fdan_KeywordValue__Arealanvendelse = 2,
	_icommon__inspireTheme_x005fdan_KeywordValue__Areald_x00e6kke = 3,
	_icommon__inspireTheme_x005fdan_KeywordValue__Artsfordeling = 4,
	_icommon__inspireTheme_x005fdan_KeywordValue__Atmosf_x00e6riske_x0020forhold = 5,
	_icommon__inspireTheme_x005fdan_KeywordValue__Befolkningsfordeling_x0020_x2014_x0020demografi = 6,
	_icommon__inspireTheme_x005fdan_KeywordValue__Beskyttede_x0020lokaliteter = 7,
	_icommon__inspireTheme_x005fdan_KeywordValue__Biogeografiske_x0020regioner = 8,
	_icommon__inspireTheme_x005fdan_KeywordValue__Bygninger = 9,
	_icommon__inspireTheme_x005fdan_KeywordValue__Energiressourcer = 10,
	_icommon__inspireTheme_x005fdan_KeywordValue__Forvaltede_x0020og_x0020regulerede_x0020omr_x00e5der_x0020samt_x0020omr_x00e5der_x0020med_x0020brugsbegr_x00e6nsning_x0020og_x0020indberetningsenheder = 11,
	_icommon__inspireTheme_x005fdan_KeywordValue__Geografiske_x0020kvadratnetsystemer = 12,
	_icommon__inspireTheme_x005fdan_KeywordValue__Geologi = 13,
	_icommon__inspireTheme_x005fdan_KeywordValue__Havomr_x00e5der = 14,
	_icommon__inspireTheme_x005fdan_KeywordValue__H_x00f8jde = 15,
	_icommon__inspireTheme_x005fdan_KeywordValue__Hydrograf = 16,
	_icommon__inspireTheme_x005fdan_KeywordValue__Jord = 17,
	_icommon__inspireTheme_x005fdan_KeywordValue__Koordinatsystemer = 18,
	_icommon__inspireTheme_x005fdan_KeywordValue__Landbrugs__x0020og_x0020akvakulturanl_x00e6g = 19,
	_icommon__inspireTheme_x005fdan_KeywordValue__Levesteder_x0020og_x0020biotoper = 20,
	_icommon__inspireTheme_x005fdan_KeywordValue__Matrikul_x00e6re_x0020parceller = 21,
	_icommon__inspireTheme_x005fdan_KeywordValue__Meteorologisk_geografiske_x0020forhold = 22,
	_icommon__inspireTheme_x005fdan_KeywordValue__Milj_x00f8overv_x00e5gningsfaciliteter = 23,
	_icommon__inspireTheme_x005fdan_KeywordValue__Mineralressourcer = 24,
	_icommon__inspireTheme_x005fdan_KeywordValue__Oceanografiske_x002fgeografiske_x0020forhold = 25,
	_icommon__inspireTheme_x005fdan_KeywordValue__Offentlig_x0020forsyningsvirksomhed_x0020og_x0020offentlige_x0020tjenesteydelser = 26,
	_icommon__inspireTheme_x005fdan_KeywordValue__Omr_x00e5der_x0020med_x0020naturlige_x0020risici = 27,
	_icommon__inspireTheme_x005fdan_KeywordValue__Ortofoto = 28,
	_icommon__inspireTheme_x005fdan_KeywordValue__Produktions__x0020og_x0020industrifaciliteter = 29,
	_icommon__inspireTheme_x005fdan_KeywordValue__Sikkerhed = 30,
	_icommon__inspireTheme_x005fdan_KeywordValue__Statistiske_x0020enheder = 31,
	_icommon__inspireTheme_x005fdan_KeywordValue__Stednavne = 32,
	_icommon__inspireTheme_x005fdan_KeywordValue__Transportnet = 33
};
#endif

/* ws-inspire-wfs2.h:11828 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdan_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdan_Title (891)
/* icommon:citationInspireInteroperabilityRegulation_dan-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005fdan_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005fdan_Title__KOMMISSIONENS_x0020FORORDNING_x0020_x0028EU_x0029_x0020Nr_x002e_x00201089_x002f2010_x0020af_x002023_x002e_x0020november_x00202010_x0020om_x0020gennemf_x00f8relse_x0020af_x0020Europa_Parlamentets_x0020og_x0020R_x00e5dets_x0020direktiv_x00202007_x002f2_x002fEF_x0020for_x0020s_x00e5_x0020vidt_x0020ang_x00e5r_x0020interoperabilitet_x0020for_x0020geodatas_x00e6t_x0020og_x0020_tjenester = 0
};
#endif

/* ws-inspire-wfs2.h:11837 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdan_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdan_DateOfPublication (893)
/* icommon:citationInspireInteroperabilityRegulation_dan-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005fdan_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005fdan_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:11844 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdan_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdan_URI (895)
/* icommon:citationInspireInteroperabilityRegulation_dan-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005fdan_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005fdan_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aDA_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:11874 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fdut_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fdut_KeywordValue (897)
/* icommon:inspireTheme_dut-KeywordValue */
enum _icommon__inspireTheme_x005fdut_KeywordValue {
	_icommon__inspireTheme_x005fdut_KeywordValue__Administratieve_x0020eenheden = 0,
	_icommon__inspireTheme_x005fdut_KeywordValue__Adressen = 1,
	_icommon__inspireTheme_x005fdut_KeywordValue__Atmosferische_x0020omstandigheden = 2,
	_icommon__inspireTheme_x005fdut_KeywordValue__Beschermde_x0020gebieden = 3,
	_icommon__inspireTheme_x005fdut_KeywordValue__Biogeografische_x0020gebieden = 4,
	_icommon__inspireTheme_x005fdut_KeywordValue__Bodem = 5,
	_icommon__inspireTheme_x005fdut_KeywordValue__Bodemgebruik = 6,
	_icommon__inspireTheme_x005fdut_KeywordValue__Energiebronnen = 7,
	_icommon__inspireTheme_x005fdut_KeywordValue__Faciliteiten_x0020voor_x0020landbouw_x0020en_x0020aquacultuur = 8,
	_icommon__inspireTheme_x005fdut_KeywordValue__Faciliteiten_x0020voor_x0020productie_x0020en_x0020industrie = 9,
	_icommon__inspireTheme_x005fdut_KeywordValue__Gebieden_x0020met_x0020natuurrisico_x0027es = 10,
	_icommon__inspireTheme_x005fdut_KeywordValue__Gebiedsbeheer_x002c_x0020gebieden_x0020waar_x0020beperkingen_x0020gelden_x002c_x0020gereguleerde_x0020gebieden_x0020en_x0020rapportage_eenheden = 11,
	_icommon__inspireTheme_x005fdut_KeywordValue__Gebouwen = 12,
	_icommon__inspireTheme_x005fdut_KeywordValue__Geografisch_x0020rastersysteem = 13,
	_icommon__inspireTheme_x005fdut_KeywordValue__Geografische_x0020namen = 14,
	_icommon__inspireTheme_x005fdut_KeywordValue__Geologie = 15,
	_icommon__inspireTheme_x005fdut_KeywordValue__Habitats_x0020en_x0020biotopen = 16,
	_icommon__inspireTheme_x005fdut_KeywordValue__Hoogte = 17,
	_icommon__inspireTheme_x005fdut_KeywordValue__Hydrografie = 18,
	_icommon__inspireTheme_x005fdut_KeywordValue__Kadastrale_x0020percelen = 19,
	_icommon__inspireTheme_x005fdut_KeywordValue__Landgebruik = 20,
	_icommon__inspireTheme_x005fdut_KeywordValue__Menselijke_x0020gezondheid_x0020en_x0020veiligheid = 21,
	_icommon__inspireTheme_x005fdut_KeywordValue__Meteorologische_x0020geografische_x0020kenmerken = 22,
	_icommon__inspireTheme_x005fdut_KeywordValue__Milieubewakingsvoorzieningen = 23,
	_icommon__inspireTheme_x005fdut_KeywordValue__Minerale_x0020bronnen = 24,
	_icommon__inspireTheme_x005fdut_KeywordValue__Nutsdiensten_x0020en_x0020overheidsdiensten = 25,
	_icommon__inspireTheme_x005fdut_KeywordValue__Oceanografische_x0020geografische_x0020kenmerken = 26,
	_icommon__inspireTheme_x005fdut_KeywordValue__Orthobeeldvorming = 27,
	_icommon__inspireTheme_x005fdut_KeywordValue__Spreiding_x0020van_x0020de_x0020bevolking_x0020_x2014_x0020demografie = 28,
	_icommon__inspireTheme_x005fdut_KeywordValue__Spreiding_x0020van_x0020soorten = 29,
	_icommon__inspireTheme_x005fdut_KeywordValue__Statistische_x0020eenheden = 30,
	_icommon__inspireTheme_x005fdut_KeywordValue__Systemen_x0020voor_x0020verwijzing_x0020door_x0020middel_x0020van_x0020co_x00f6rdinaten = 31,
	_icommon__inspireTheme_x005fdut_KeywordValue__Vervoersnetwerken = 32,
	_icommon__inspireTheme_x005fdut_KeywordValue__Zeegebieden = 33
};
#endif

/* ws-inspire-wfs2.h:11933 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdut_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdut_Title (898)
/* icommon:citationInspireInteroperabilityRegulation_dut-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005fdut_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005fdut_Title__VERORDENING_x0020_x0028EU_x0029_x0020Nr_x002e_x00201089_x002f2010_x0020VAN_x0020DE_x0020COMMISSIE_x0020van_x002023_x0020november_x00202010_x0020ter_x0020uitvoering_x0020van_x0020Richtlijn_x00202007_x002f2_x002fEG_x0020van_x0020het_x0020Europees_x0020Parlement_x0020en_x0020de_x0020Raad_x0020betreffende_x0020de_x0020interoperabiliteit_x0020van_x0020verzamelingen_x0020ruimtelijke_x0020gegevens_x0020en_x0020van_x0020diensten_x0020met_x0020betrekking_x0020tot_x0020ruimtelijke_x0020gegevens = 0
};
#endif

/* ws-inspire-wfs2.h:11942 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdut_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdut_DateOfPublication (900)
/* icommon:citationInspireInteroperabilityRegulation_dut-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005fdut_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005fdut_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:11949 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdut_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdut_URI (902)
/* icommon:citationInspireInteroperabilityRegulation_dut-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005fdut_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005fdut_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aNL_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:11979 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005feng_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005feng_KeywordValue (904)
/* icommon:inspireTheme_eng-KeywordValue */
enum _icommon__inspireTheme_x005feng_KeywordValue {
	_icommon__inspireTheme_x005feng_KeywordValue__Addresses = 0,
	_icommon__inspireTheme_x005feng_KeywordValue__Administrative_x0020units = 1,
	_icommon__inspireTheme_x005feng_KeywordValue__Agricultural_x0020and_x0020aquaculture_x0020facilities = 2,
	_icommon__inspireTheme_x005feng_KeywordValue__Area_x0020management_x002frestriction_x002fregulation_x0020zones_x0020and_x0020reporting_x0020units = 3,
	_icommon__inspireTheme_x005feng_KeywordValue__Atmospheric_x0020conditions = 4,
	_icommon__inspireTheme_x005feng_KeywordValue__Bio_geographical_x0020regions = 5,
	_icommon__inspireTheme_x005feng_KeywordValue__Buildings = 6,
	_icommon__inspireTheme_x005feng_KeywordValue__Cadastral_x0020parcels = 7,
	_icommon__inspireTheme_x005feng_KeywordValue__Coordinate_x0020reference_x0020systems = 8,
	_icommon__inspireTheme_x005feng_KeywordValue__Elevation = 9,
	_icommon__inspireTheme_x005feng_KeywordValue__Energy_x0020resources = 10,
	_icommon__inspireTheme_x005feng_KeywordValue__Environmental_x0020monitoring_x0020facilities = 11,
	_icommon__inspireTheme_x005feng_KeywordValue__Geographical_x0020grid_x0020systems = 12,
	_icommon__inspireTheme_x005feng_KeywordValue__Geographical_x0020names = 13,
	_icommon__inspireTheme_x005feng_KeywordValue__Geology = 14,
	_icommon__inspireTheme_x005feng_KeywordValue__Habitats_x0020and_x0020biotopes = 15,
	_icommon__inspireTheme_x005feng_KeywordValue__Human_x0020health_x0020and_x0020safety = 16,
	_icommon__inspireTheme_x005feng_KeywordValue__Hydrography = 17,
	_icommon__inspireTheme_x005feng_KeywordValue__Land_x0020cover = 18,
	_icommon__inspireTheme_x005feng_KeywordValue__Land_x0020use = 19,
	_icommon__inspireTheme_x005feng_KeywordValue__Meteorological_x0020geographical_x0020features = 20,
	_icommon__inspireTheme_x005feng_KeywordValue__Mineral_x0020resources = 21,
	_icommon__inspireTheme_x005feng_KeywordValue__Natural_x0020risk_x0020zones = 22,
	_icommon__inspireTheme_x005feng_KeywordValue__Oceanographic_x0020geographical_x0020features = 23,
	_icommon__inspireTheme_x005feng_KeywordValue__Orthoimagery = 24,
	_icommon__inspireTheme_x005feng_KeywordValue__Population_x0020distribution_x0020_x2014_x0020demography = 25,
	_icommon__inspireTheme_x005feng_KeywordValue__Production_x0020and_x0020industrial_x0020facilities = 26,
	_icommon__inspireTheme_x005feng_KeywordValue__Protected_x0020sites = 27,
	_icommon__inspireTheme_x005feng_KeywordValue__Sea_x0020regions = 28,
	_icommon__inspireTheme_x005feng_KeywordValue__Soil = 29,
	_icommon__inspireTheme_x005feng_KeywordValue__Species_x0020distribution = 30,
	_icommon__inspireTheme_x005feng_KeywordValue__Statistical_x0020units = 31,
	_icommon__inspireTheme_x005feng_KeywordValue__Transport_x0020networks = 32,
	_icommon__inspireTheme_x005feng_KeywordValue__Utility_x0020and_x0020governmental_x0020services = 33
};
#endif

/* ws-inspire-wfs2.h:12038 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005feng_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005feng_Title (905)
/* icommon:citationInspireInteroperabilityRegulation_eng-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005feng_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005feng_Title__COMMISSION_x0020REGULATION_x0020_x0028EU_x0029_x0020No_x00201089_x002f2010_x0020of_x002023_x0020November_x00202010_x0020implementing_x0020Directive_x00202007_x002f2_x002fEC_x0020of_x0020the_x0020European_x0020Parliament_x0020and_x0020of_x0020the_x0020Council_x0020as_x0020regards_x0020interoperability_x0020of_x0020spatial_x0020data_x0020sets_x0020and_x0020services = 0
};
#endif

/* ws-inspire-wfs2.h:12047 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005feng_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005feng_DateOfPublication (907)
/* icommon:citationInspireInteroperabilityRegulation_eng-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005feng_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005feng_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:12054 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005feng_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005feng_URI (909)
/* icommon:citationInspireInteroperabilityRegulation_eng-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005feng_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005feng_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aEN_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:12084 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fest_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fest_KeywordValue (911)
/* icommon:inspireTheme_est-KeywordValue */
enum _icommon__inspireTheme_x005fest_KeywordValue {
	_icommon__inspireTheme_x005fest_KeywordValue__Aadressid = 0,
	_icommon__inspireTheme_x005fest_KeywordValue__Atmosf_x00e4_x00e4ritingimused = 1,
	_icommon__inspireTheme_x005fest_KeywordValue__Bio_geograafilised_x0020piirkonnad = 2,
	_icommon__inspireTheme_x005fest_KeywordValue__Ehitised = 3,
	_icommon__inspireTheme_x005fest_KeywordValue__Elanikkonna_x0020jaotumine_x0020_x2013_x0020demograafia = 4,
	_icommon__inspireTheme_x005fest_KeywordValue__Elupaigad_x0020ja_x0020biotoobid = 5,
	_icommon__inspireTheme_x005fest_KeywordValue__Energiaressursid = 6,
	_icommon__inspireTheme_x005fest_KeywordValue__Geograafilised_x0020nimed = 7,
	_icommon__inspireTheme_x005fest_KeywordValue__Geograafilised_x0020ruutv_x00f5rgud = 8,
	_icommon__inspireTheme_x005fest_KeywordValue__Geoloogia = 9,
	_icommon__inspireTheme_x005fest_KeywordValue__Haldus_x00fcksused = 10,
	_icommon__inspireTheme_x005fest_KeywordValue__H_x00fcdrograafia = 11,
	_icommon__inspireTheme_x005fest_KeywordValue__Inimeste_x0020tervis_x0020ja_x0020ohutus = 12,
	_icommon__inspireTheme_x005fest_KeywordValue__Kaitsealused_x0020kohad = 13,
	_icommon__inspireTheme_x005fest_KeywordValue__Katastri_x00fcksused = 14,
	_icommon__inspireTheme_x005fest_KeywordValue__Keskkonnaseirerajatised = 15,
	_icommon__inspireTheme_x005fest_KeywordValue__Kommunaal__x0020ja_x0020riiklikud_x0020teenused = 16,
	_icommon__inspireTheme_x005fest_KeywordValue__Koordinaats_x00fcsteemid = 17,
	_icommon__inspireTheme_x005fest_KeywordValue__K_x00f5rgused = 18,
	_icommon__inspireTheme_x005fest_KeywordValue__Liikide_x0020jaotumine = 19,
	_icommon__inspireTheme_x005fest_KeywordValue__Looduslikud_x0020ohutsoonid = 20,
	_icommon__inspireTheme_x005fest_KeywordValue__Maakasutus = 21,
	_icommon__inspireTheme_x005fest_KeywordValue__Maakate = 22,
	_icommon__inspireTheme_x005fest_KeywordValue__Maavarad = 23,
	_icommon__inspireTheme_x005fest_KeywordValue__Merepiirkonnad = 24,
	_icommon__inspireTheme_x005fest_KeywordValue__Meteoroloogilis_geograafilised_x0020tunnusjooned = 25,
	_icommon__inspireTheme_x005fest_KeywordValue__Okeanograafilis_geograafilised_x0020tunnusjooned = 26,
	_icommon__inspireTheme_x005fest_KeywordValue__Ortokujutised = 27,
	_icommon__inspireTheme_x005fest_KeywordValue__Pinnas = 28,
	_icommon__inspireTheme_x005fest_KeywordValue__P_x00f5llumajandus__x0020ja_x0020vesiviljelusrajatised = 29,
	_icommon__inspireTheme_x005fest_KeywordValue__Statistilised_x0020_x00fcksused = 30,
	_icommon__inspireTheme_x005fest_KeywordValue__Tootmis__x0020ja_x0020t_x00f6_x00f6stusrajatised = 31,
	_icommon__inspireTheme_x005fest_KeywordValue__Transpordiv_x00f5rgud = 32,
	_icommon__inspireTheme_x005fest_KeywordValue___x00dcldplaneering_x002fpiirangu__x002freguleeritud_x0020tsoonid_x0020ja_x0020aruandlus_x00fcksused = 33
};
#endif

/* ws-inspire-wfs2.h:12143 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fest_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fest_Title (912)
/* icommon:citationInspireInteroperabilityRegulation_est-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005fest_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005fest_Title__KOMISJONI_x0020M_x00c4_x00c4RUS_x0020_x0028EL_x0029_x0020nr_x00201089_x002f2010_x002c_x002023_x002e_x0020november_x00202010_x002c_x0020millega_x0020rakendatakse_x0020Euroopa_x0020Parlamendi_x0020ja_x0020n_x00f5ukogu_x0020direktiivi_x00202007_x002f2_x002fE_x00dc_x0020seoses_x0020ruumiandmekogumite_x0020ja_x0020_teenuste_x0020ristkasutatavusega = 0
};
#endif

/* ws-inspire-wfs2.h:12152 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fest_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fest_DateOfPublication (914)
/* icommon:citationInspireInteroperabilityRegulation_est-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005fest_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005fest_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:12159 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fest_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fest_URI (916)
/* icommon:citationInspireInteroperabilityRegulation_est-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005fest_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005fest_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aET_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:12189 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005ffin_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005ffin_KeywordValue (918)
/* icommon:inspireTheme_fin-KeywordValue */
enum _icommon__inspireTheme_x005ffin_KeywordValue {
	_icommon__inspireTheme_x005ffin_KeywordValue__Aluesuunnittelun_x002c_x0020rajoitusten_x0020ja_x0020s_x00e4_x00e4ntelyn_x0020piiriin_x0020kuuluvat_x0020alueet_x0020ja_x0020raportointiyksik_x00f6t = 0,
	_icommon__inspireTheme_x005ffin_KeywordValue__Biomaantieteelliset_x0020alueet = 1,
	_icommon__inspireTheme_x005ffin_KeywordValue__Elinymp_x00e4rist_x00f6t_x0020ja_x0020biotoopit = 2,
	_icommon__inspireTheme_x005ffin_KeywordValue__Energiavarat = 3,
	_icommon__inspireTheme_x005ffin_KeywordValue__Geologia = 4,
	_icommon__inspireTheme_x005ffin_KeywordValue__Hallinnolliset_x0020yksik_x00f6t = 5,
	_icommon__inspireTheme_x005ffin_KeywordValue__Hydrografia = 6,
	_icommon__inspireTheme_x005ffin_KeywordValue__Ilmakeh_x00e4n_x0020tila = 7,
	_icommon__inspireTheme_x005ffin_KeywordValue__Ilmaston_x0020maantieteelliset_x0020ominaispiirteet = 8,
	_icommon__inspireTheme_x005ffin_KeywordValue__Kiinteist_x00f6t = 9,
	_icommon__inspireTheme_x005ffin_KeywordValue__Koordinaattij_x00e4rjestelm_x00e4t = 10,
	_icommon__inspireTheme_x005ffin_KeywordValue__Korkeus = 11,
	_icommon__inspireTheme_x005ffin_KeywordValue__Lajien_x0020levinneisyys = 12,
	_icommon__inspireTheme_x005ffin_KeywordValue__Liikenneverkot = 13,
	_icommon__inspireTheme_x005ffin_KeywordValue__Luonnonriskialueet = 14,
	_icommon__inspireTheme_x005ffin_KeywordValue__Maank_x00e4ytt_x00f6 = 15,
	_icommon__inspireTheme_x005ffin_KeywordValue__Maanpeite = 16,
	_icommon__inspireTheme_x005ffin_KeywordValue__Maaper_x00e4 = 17,
	_icommon__inspireTheme_x005ffin_KeywordValue__Maatalous__x0020ja_x0020vesiviljelylaitokset = 18,
	_icommon__inspireTheme_x005ffin_KeywordValue__Merentutkimuksen_x0020maantieteelliset_x0020ominaispiirteet = 19,
	_icommon__inspireTheme_x005ffin_KeywordValue__Merialueet = 20,
	_icommon__inspireTheme_x005ffin_KeywordValue__Mineraalivarat = 21,
	_icommon__inspireTheme_x005ffin_KeywordValue__Ortoilmakuvat = 22,
	_icommon__inspireTheme_x005ffin_KeywordValue__Osoitteet = 23,
	_icommon__inspireTheme_x005ffin_KeywordValue__Paikannimet = 24,
	_icommon__inspireTheme_x005ffin_KeywordValue__Paikannusruudustot = 25,
	_icommon__inspireTheme_x005ffin_KeywordValue__Rakennukset = 26,
	_icommon__inspireTheme_x005ffin_KeywordValue__Suojellut_x0020alueet = 27,
	_icommon__inspireTheme_x005ffin_KeywordValue__Tilastoyksik_x00f6t = 28,
	_icommon__inspireTheme_x005ffin_KeywordValue__Tuotanto__x0020ja_x0020teollisuuslaitokset = 29,
	_icommon__inspireTheme_x005ffin_KeywordValue__V_x00e4est_x00f6jakauma_x0020_x2013_x0020demografia = 30,
	_icommon__inspireTheme_x005ffin_KeywordValue__V_x00e4est_x00f6n_x0020terveys_x0020ja_x0020turvallisuus = 31,
	_icommon__inspireTheme_x005ffin_KeywordValue__Yleishy_x00f6dylliset_x0020ja_x0020muut_x0020julkiset_x0020palvelut = 32,
	_icommon__inspireTheme_x005ffin_KeywordValue__Ymp_x00e4rist_x00f6n_x0020tilan_x0020seurantalaitteet = 33
};
#endif

/* ws-inspire-wfs2.h:12248 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffin_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffin_Title (919)
/* icommon:citationInspireInteroperabilityRegulation_fin-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005ffin_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005ffin_Title__KOMISSION_x0020ASETUS_x0020_x0028EU_x0029_x0020N_x003ao_x00201089_x002f2010_x002c_x0020annettu_x002023_x0020p_x00e4iv_x00e4n_x00e4_x0020marraskuuta_x00202010_x002c_x0020Euroopan_x0020parlamentin_x0020ja_x0020neuvoston_x0020direktiivin_x00202007_x002f2_x002fEY_x0020t_x00e4yt_x00e4nt_x00f6_x00f6npanosta_x0020paikkatietoaineistojen_x0020ja_x0020_palvelujen_x0020yhteentoimivuuden_x0020osalta = 0
};
#endif

/* ws-inspire-wfs2.h:12257 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffin_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffin_DateOfPublication (921)
/* icommon:citationInspireInteroperabilityRegulation_fin-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005ffin_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005ffin_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:12264 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffin_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffin_URI (923)
/* icommon:citationInspireInteroperabilityRegulation_fin-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005ffin_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005ffin_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aFI_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:12294 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005ffre_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005ffre_KeywordValue (925)
/* icommon:inspireTheme_fre-KeywordValue */
enum _icommon__inspireTheme_x005ffre_KeywordValue {
	_icommon__inspireTheme_x005ffre_KeywordValue__Adresses = 0,
	_icommon__inspireTheme_x005ffre_KeywordValue__Altitude = 1,
	_icommon__inspireTheme_x005ffre_KeywordValue__B_x00e2timents = 2,
	_icommon__inspireTheme_x005ffre_KeywordValue__Caract_x00e9ristiques_x0020g_x00e9ographiques_x0020m_x00e9t_x00e9orologiques = 3,
	_icommon__inspireTheme_x005ffre_KeywordValue__Caract_x00e9ristiques_x0020g_x00e9ographiques_x0020oc_x00e9anographiques = 4,
	_icommon__inspireTheme_x005ffre_KeywordValue__Conditions_x0020atmosph_x00e9riques = 5,
	_icommon__inspireTheme_x005ffre_KeywordValue__D_x00e9nominations_x0020g_x00e9ographiques = 6,
	_icommon__inspireTheme_x005ffre_KeywordValue__G_x00e9ologie = 7,
	_icommon__inspireTheme_x005ffre_KeywordValue__Habitats_x0020et_x0020biotopes = 8,
	_icommon__inspireTheme_x005ffre_KeywordValue__Hydrographie = 9,
	_icommon__inspireTheme_x005ffre_KeywordValue__Installations_x0020agricoles_x0020et_x0020aquacoles = 10,
	_icommon__inspireTheme_x005ffre_KeywordValue__Installations_x0020de_x0020suivi_x0020environnemental = 11,
	_icommon__inspireTheme_x005ffre_KeywordValue__Lieux_x0020de_x0020production_x0020et_x0020sites_x0020industriels = 12,
	_icommon__inspireTheme_x005ffre_KeywordValue__Occupation_x0020des_x0020terres = 13,
	_icommon__inspireTheme_x005ffre_KeywordValue__Ortho_imagerie = 14,
	_icommon__inspireTheme_x005ffre_KeywordValue__Parcelles_x0020cadastrales = 15,
	_icommon__inspireTheme_x005ffre_KeywordValue__R_x00e9f_x00e9rentiels_x0020de_x0020coordonn_x00e9es = 16,
	_icommon__inspireTheme_x005ffre_KeywordValue__R_x00e9gions_x0020biog_x00e9ographiques = 17,
	_icommon__inspireTheme_x005ffre_KeywordValue__R_x00e9gions_x0020maritimes = 18,
	_icommon__inspireTheme_x005ffre_KeywordValue__R_x00e9partition_x0020de_x0020la_x0020population_x0020_x2014_x0020d_x00e9mographie = 19,
	_icommon__inspireTheme_x005ffre_KeywordValue__R_x00e9partition_x0020des_x0020esp_x00e8ces = 20,
	_icommon__inspireTheme_x005ffre_KeywordValue__R_x00e9seaux_x0020de_x0020transport = 21,
	_icommon__inspireTheme_x005ffre_KeywordValue__Ressources_x0020min_x00e9rales = 22,
	_icommon__inspireTheme_x005ffre_KeywordValue__Sant_x00e9_x0020et_x0020s_x00e9curit_x00e9_x0020des_x0020personnes = 23,
	_icommon__inspireTheme_x005ffre_KeywordValue__Services_x0020d_x0027utilit_x00e9_x0020publique_x0020et_x0020services_x0020publics = 24,
	_icommon__inspireTheme_x005ffre_KeywordValue__Sites_x0020prot_x00e9g_x00e9s = 25,
	_icommon__inspireTheme_x005ffre_KeywordValue__Sols = 26,
	_icommon__inspireTheme_x005ffre_KeywordValue__Sources_x0020d_x0027_x00e9nergie = 27,
	_icommon__inspireTheme_x005ffre_KeywordValue__Syst_x00e8mes_x0020de_x0020maillage_x0020g_x00e9ographique = 28,
	_icommon__inspireTheme_x005ffre_KeywordValue__Unit_x00e9s_x0020administratives = 29,
	_icommon__inspireTheme_x005ffre_KeywordValue__Unit_x00e9s_x0020statistiques = 30,
	_icommon__inspireTheme_x005ffre_KeywordValue__Usage_x0020des_x0020sols = 31,
	_icommon__inspireTheme_x005ffre_KeywordValue__Zones_x0020_x00e0_x0020risque_x0020naturel = 32,
	_icommon__inspireTheme_x005ffre_KeywordValue__Zones_x0020de_x0020gestion_x002c_x0020de_x0020restriction_x0020ou_x0020de_x0020r_x00e9glementation_x0020et_x0020unit_x00e9s_x0020de_x0020d_x00e9claration = 33
};
#endif

/* ws-inspire-wfs2.h:12353 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffre_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffre_Title (926)
/* icommon:citationInspireInteroperabilityRegulation_fre-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005ffre_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005ffre_Title__R_x00c8GLEMENT_x0020_x0028UE_x0029_x0020N_x0020o_x00201089_x002f2010_x0020DE_x0020LA_x0020COMMISSION_x0020du_x002023_x0020novembre_x00202010_x0020portant_x0020modalit_x00e9s_x0020d_x0027application_x0020de_x0020la_x0020directive_x00202007_x002f2_x002fCE_x0020du_x0020Parlement_x0020europ_x00e9en_x0020et_x0020du_x0020Conseil_x0020en_x0020ce_x0020qui_x0020concerne_x0020l_x0027interop_x00e9rabilit_x00e9_x0020des_x0020s_x00e9ries_x0020et_x0020des_x0020services_x0020de_x0020donn_x00e9es_x0020g_x00e9ographiques = 0
};
#endif

/* ws-inspire-wfs2.h:12362 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffre_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffre_DateOfPublication (928)
/* icommon:citationInspireInteroperabilityRegulation_fre-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005ffre_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005ffre_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:12369 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffre_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffre_URI (930)
/* icommon:citationInspireInteroperabilityRegulation_fre-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005ffre_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005ffre_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aFR_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:12399 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fger_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fger_KeywordValue (932)
/* icommon:inspireTheme_ger-KeywordValue */
enum _icommon__inspireTheme_x005fger_KeywordValue {
	_icommon__inspireTheme_x005fger_KeywordValue__Adressen = 0,
	_icommon__inspireTheme_x005fger_KeywordValue__Atmosph_x00e4rische_x0020Bedingungen = 1,
	_icommon__inspireTheme_x005fger_KeywordValue__Bewirtschaftungsgebiete_x002fSchutzgebiete_x002fgeregelte_x0020Gebiete_x0020und_x0020Berichterstattungseinheiten = 2,
	_icommon__inspireTheme_x005fger_KeywordValue__Biogeografische_x0020Regionen = 3,
	_icommon__inspireTheme_x005fger_KeywordValue__Boden = 4,
	_icommon__inspireTheme_x005fger_KeywordValue__Bodenbedeckung = 5,
	_icommon__inspireTheme_x005fger_KeywordValue__Bodennutzung = 6,
	_icommon__inspireTheme_x005fger_KeywordValue__Energiequellen = 7,
	_icommon__inspireTheme_x005fger_KeywordValue__Flurst_x00fccke_x002fGrundst_x00fccke_x0020_x0028Katasterparzellen_x0029 = 8,
	_icommon__inspireTheme_x005fger_KeywordValue__Geb_x00e4ude = 9,
	_icommon__inspireTheme_x005fger_KeywordValue__Gebiete_x0020mit_x0020naturbedingten_x0020Risiken = 10,
	_icommon__inspireTheme_x005fger_KeywordValue__Geografische_x0020Bezeichnungen = 11,
	_icommon__inspireTheme_x005fger_KeywordValue__Geografische_x0020Gittersysteme = 12,
	_icommon__inspireTheme_x005fger_KeywordValue__Geologie = 13,
	_icommon__inspireTheme_x005fger_KeywordValue__Gesundheit_x0020und_x0020Sicherheit = 14,
	_icommon__inspireTheme_x005fger_KeywordValue__Gew_x00e4ssernetz = 15,
	_icommon__inspireTheme_x005fger_KeywordValue__H_x00f6he = 16,
	_icommon__inspireTheme_x005fger_KeywordValue__Koordinatenreferenzsysteme = 17,
	_icommon__inspireTheme_x005fger_KeywordValue__Landwirtschaftliche_x0020Anlagen_x0020und_x0020Aquakulturanlagen = 18,
	_icommon__inspireTheme_x005fger_KeywordValue__Lebensr_x00e4ume_x0020und_x0020Biotope = 19,
	_icommon__inspireTheme_x005fger_KeywordValue__Meeresregionen = 20,
	_icommon__inspireTheme_x005fger_KeywordValue__Meteorologisch_geografische_x0020Kennwerte = 21,
	_icommon__inspireTheme_x005fger_KeywordValue__Mineralische_x0020Bodensch_x00e4tze = 22,
	_icommon__inspireTheme_x005fger_KeywordValue__Orthofotografie = 23,
	_icommon__inspireTheme_x005fger_KeywordValue__Ozeanografisch_geografische_x0020Kennwerte = 24,
	_icommon__inspireTheme_x005fger_KeywordValue__Produktions__x0020und_x0020Industrieanlagen = 25,
	_icommon__inspireTheme_x005fger_KeywordValue__Schutzgebiete = 26,
	_icommon__inspireTheme_x005fger_KeywordValue__Statistische_x0020Einheiten = 27,
	_icommon__inspireTheme_x005fger_KeywordValue__Umwelt_x00fcberwachung = 28,
	_icommon__inspireTheme_x005fger_KeywordValue__Verkehrsnetze = 29,
	_icommon__inspireTheme_x005fger_KeywordValue__Versorgungswirtschaft_x0020und_x0020staatliche_x0020Dienste = 30,
	_icommon__inspireTheme_x005fger_KeywordValue__Verteilung_x0020der_x0020Arten = 31,
	_icommon__inspireTheme_x005fger_KeywordValue__Verteilung_x0020der_x0020Bev_x00f6lkerung_x0020_x2014_x0020Demografie = 32,
	_icommon__inspireTheme_x005fger_KeywordValue__Verwaltungseinheiten = 33
};
#endif

/* ws-inspire-wfs2.h:12458 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fger_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fger_Title (933)
/* icommon:citationInspireInteroperabilityRegulation_ger-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005fger_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005fger_Title__VERORDNUNG_x0020_x0028EG_x0029_x0020Nr_x002e_x00201089_x002f2010_x0020DER_x0020KOMMISSION_x0020vom_x002023_x002e_x0020November_x00202010_x0020zur_x0020Durchf_x00fchrung_x0020der_x0020Richtlinie_x00202007_x002f2_x002fEG_x0020des_x0020Europ_x00e4ischen_x0020Parlaments_x0020und_x0020des_x0020Rates_x0020hinsichtlich_x0020der_x0020Interoperabilit_x00e4t_x0020von_x0020Geodatens_x00e4tzen_x0020und_x0020_diensten = 0
};
#endif

/* ws-inspire-wfs2.h:12467 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fger_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fger_DateOfPublication (935)
/* icommon:citationInspireInteroperabilityRegulation_ger-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005fger_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005fger_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:12474 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fger_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fger_URI (937)
/* icommon:citationInspireInteroperabilityRegulation_ger-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005fger_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005fger_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aDE_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:12504 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fgle_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fgle_KeywordValue (939)
/* icommon:inspireTheme_gle-KeywordValue */
enum _icommon__inspireTheme_x005fgle_KeywordValue {
	_icommon__inspireTheme_x005fgle_KeywordValue__Addresses = 0,
	_icommon__inspireTheme_x005fgle_KeywordValue__Administrative_x0020units = 1,
	_icommon__inspireTheme_x005fgle_KeywordValue__Agricultural_x0020and_x0020aquaculture_x0020facilities = 2,
	_icommon__inspireTheme_x005fgle_KeywordValue__Area_x0020management_x002frestriction_x002fregulation_x0020zones_x0020and_x0020reporting_x0020units = 3,
	_icommon__inspireTheme_x005fgle_KeywordValue__Atmospheric_x0020conditions = 4,
	_icommon__inspireTheme_x005fgle_KeywordValue__Bio_geographical_x0020regions = 5,
	_icommon__inspireTheme_x005fgle_KeywordValue__Buildings = 6,
	_icommon__inspireTheme_x005fgle_KeywordValue__Cadastral_x0020parcels = 7,
	_icommon__inspireTheme_x005fgle_KeywordValue__Coordinate_x0020reference_x0020systems = 8,
	_icommon__inspireTheme_x005fgle_KeywordValue__Elevation = 9,
	_icommon__inspireTheme_x005fgle_KeywordValue__Energy_x0020resources = 10,
	_icommon__inspireTheme_x005fgle_KeywordValue__Environmental_x0020monitoring_x0020facilities = 11,
	_icommon__inspireTheme_x005fgle_KeywordValue__Geographical_x0020grid_x0020systems = 12,
	_icommon__inspireTheme_x005fgle_KeywordValue__Geographical_x0020names = 13,
	_icommon__inspireTheme_x005fgle_KeywordValue__Geology = 14,
	_icommon__inspireTheme_x005fgle_KeywordValue__Habitats_x0020and_x0020biotopes = 15,
	_icommon__inspireTheme_x005fgle_KeywordValue__Human_x0020health_x0020and_x0020safety = 16,
	_icommon__inspireTheme_x005fgle_KeywordValue__Hydrography = 17,
	_icommon__inspireTheme_x005fgle_KeywordValue__Land_x0020cover = 18,
	_icommon__inspireTheme_x005fgle_KeywordValue__Land_x0020use = 19,
	_icommon__inspireTheme_x005fgle_KeywordValue__Meteorological_x0020geographical_x0020features = 20,
	_icommon__inspireTheme_x005fgle_KeywordValue__Mineral_x0020resources = 21,
	_icommon__inspireTheme_x005fgle_KeywordValue__Natural_x0020risk_x0020zones = 22,
	_icommon__inspireTheme_x005fgle_KeywordValue__Oceanographic_x0020geographical_x0020features = 23,
	_icommon__inspireTheme_x005fgle_KeywordValue__Orthoimagery = 24,
	_icommon__inspireTheme_x005fgle_KeywordValue__Population_x0020distribution_x0020_x2014_x0020demography = 25,
	_icommon__inspireTheme_x005fgle_KeywordValue__Production_x0020and_x0020industrial_x0020facilities = 26,
	_icommon__inspireTheme_x005fgle_KeywordValue__Protected_x0020sites = 27,
	_icommon__inspireTheme_x005fgle_KeywordValue__Sea_x0020regions = 28,
	_icommon__inspireTheme_x005fgle_KeywordValue__Soil = 29,
	_icommon__inspireTheme_x005fgle_KeywordValue__Species_x0020distribution = 30,
	_icommon__inspireTheme_x005fgle_KeywordValue__Statistical_x0020units = 31,
	_icommon__inspireTheme_x005fgle_KeywordValue__Transport_x0020networks = 32,
	_icommon__inspireTheme_x005fgle_KeywordValue__Utility_x0020and_x0020governmental_x0020services = 33
};
#endif

/* ws-inspire-wfs2.h:12563 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgle_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgle_Title (940)
/* icommon:citationInspireInteroperabilityRegulation_gle-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005fgle_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005fgle_Title__COMMISSION_x0020REGULATION_x0020_x0028EU_x0029_x0020No_x00201089_x002f2010_x0020of_x002023_x0020November_x00202010_x0020implementing_x0020Directive_x00202007_x002f2_x002fEC_x0020of_x0020the_x0020European_x0020Parliament_x0020and_x0020of_x0020the_x0020Council_x0020as_x0020regards_x0020interoperability_x0020of_x0020spatial_x0020data_x0020sets_x0020and_x0020services = 0
};
#endif

/* ws-inspire-wfs2.h:12572 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgle_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgle_DateOfPublication (942)
/* icommon:citationInspireInteroperabilityRegulation_gle-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005fgle_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005fgle_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:12579 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgle_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgle_URI (944)
/* icommon:citationInspireInteroperabilityRegulation_gle-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005fgle_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005fgle_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aEN_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:12609 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fgre_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fgre_KeywordValue (946)
/* icommon:inspireTheme_gre-KeywordValue */
enum _icommon__inspireTheme_x005fgre_KeywordValue {
	_icommon__inspireTheme_x005fgre_KeywordValue___x0391_x03bd_x03b8_x03c1_x03ce_x03c0_x03b9_x03bd_x03b7_x0020_x03c5_x03b3_x03b5_x03af_x03b1_x0020_x03ba_x03b1_x03b9_x0020_x03b1_x03c3_x03c6_x03ac_x03bb_x03b5_x03b9_x03b1 = 0,
	_icommon__inspireTheme_x005fgre_KeywordValue___x0391_x03c4_x03bc_x03bf_x03c3_x03c6_x03b1_x03b9_x03c1_x03b9_x03ba_x03ad_x03c2_x0020_x03c3_x03c5_x03bd_x03b8_x03ae_x03ba_x03b5_x03c2 = 1,
	_icommon__inspireTheme_x005fgre_KeywordValue___x0392_x03b9_x03bf_x03b3_x03b5_x03c9_x03b3_x03c1_x03b1_x03c6_x03b9_x03ba_x03ad_x03c2_x0020_x03c0_x03b5_x03c1_x03b9_x03bf_x03c7_x03ad_x03c2 = 2,
	_icommon__inspireTheme_x005fgre_KeywordValue___x0393_x03b5_x03c9_x03bb_x03bf_x03b3_x03af_x03b1 = 3,
	_icommon__inspireTheme_x005fgre_KeywordValue___x0393_x03b5_x03c9_x03c1_x03b3_x03b9_x03ba_x03ad_x03c2_x0020_x03b5_x03b3_x03ba_x03b1_x03c4_x03b1_x03c3_x03c4_x03ac_x03c3_x03b5_x03b9_x03c2_x0020_x03ba_x03b1_x03b9_x0020_x03b5_x03b3_x03ba_x03b1_x03c4_x03b1_x03c3_x03c4_x03ac_x03c3_x03b5_x03b9_x03c2_x0020_x03c5_x03b4_x03b1_x03c4_x03bf_x03ba_x03b1_x03bb_x03bb_x03b9_x03ad_x03c1_x03b3_x03b5_x03b9_x03b1_x03c2 = 4,
	_icommon__inspireTheme_x005fgre_KeywordValue___x0393_x03b5_x03c9_x03c4_x03b5_x03bc_x03ac_x03c7_x03b9_x03b1_x0020_x03ba_x03c4_x03b7_x03bc_x03b1_x03c4_x03bf_x03bb_x03bf_x03b3_x03af_x03bf_x03c5 = 5,
	_icommon__inspireTheme_x005fgre_KeywordValue___x0394_x03b9_x03b5_x03c5_x03b8_x03cd_x03bd_x03c3_x03b5_x03b9_x03c2 = 6,
	_icommon__inspireTheme_x005fgre_KeywordValue___x0394_x03af_x03ba_x03c4_x03c5_x03b1_x0020_x03bc_x03b5_x03c4_x03b1_x03c6_x03bf_x03c1_x03ce_x03bd = 7,
	_icommon__inspireTheme_x005fgre_KeywordValue___x0394_x03b9_x03bf_x03b9_x03ba_x03b7_x03c4_x03b9_x03ba_x03ad_x03c2_x0020_x03b5_x03bd_x03cc_x03c4_x03b7_x03c4_x03b5_x03c2 = 8,
	_icommon__inspireTheme_x005fgre_KeywordValue___x0395_x03b3_x03ba_x03b1_x03c4_x03b1_x03c3_x03c4_x03ac_x03c3_x03b5_x03b9_x03c2_x0020_x03c0_x03b1_x03c1_x03b1_x03b3_x03c9_x03b3_x03ae_x03c2_x0020_x03ba_x03b1_x03b9_x0020_x03b2_x03b9_x03bf_x03bc_x03b7_x03c7_x03b1_x03bd_x03b9_x03ba_x03ad_x03c2_x0020_x03b5_x03b3_x03ba_x03b1_x03c4_x03b1_x03c3_x03c4_x03ac_x03c3_x03b5_x03b9_x03c2 = 9,
	_icommon__inspireTheme_x005fgre_KeywordValue___x0395_x03b3_x03ba_x03b1_x03c4_x03b1_x03c3_x03c4_x03ac_x03c3_x03b5_x03b9_x03c2_x0020_x03c0_x03b1_x03c1_x03b1_x03ba_x03bf_x03bb_x03bf_x03cd_x03b8_x03b7_x03c3_x03b7_x03c2_x0020_x03c4_x03bf_x03c5_x0020_x03c0_x03b5_x03c1_x03b9_x03b2_x03ac_x03bb_x03bb_x03bf_x03bd_x03c4_x03bf_x03c2 = 10,
	_icommon__inspireTheme_x005fgre_KeywordValue___x0388_x03b4_x03b1_x03c6_x03bf_x03c2 = 11,
	_icommon__inspireTheme_x005fgre_KeywordValue___x0395_x03bd_x03b4_x03b9_x03b1_x03b9_x03c4_x03ae_x03bc_x03b1_x03c4_x03b1_x0020_x03ba_x03b1_x03b9_x0020_x03b2_x03b9_x03cc_x03c4_x03bf_x03c0_x03bf_x03b9 = 12,
	_icommon__inspireTheme_x005fgre_KeywordValue___x0395_x03bd_x03b5_x03c1_x03b3_x03b5_x03b9_x03b1_x03ba_x03bf_x03af_x0020_x03c0_x03cc_x03c1_x03bf_x03b9 = 13,
	_icommon__inspireTheme_x005fgre_KeywordValue___x0395_x03c0_x03b9_x03c7_x03b5_x03b9_x03c1_x03ae_x03c3_x03b5_x03b9_x03c2_x0020_x03ba_x03bf_x03b9_x03bd_x03ae_x03c2_x0020_x03c9_x03c6_x03b5_x03bb_x03b5_x03af_x03b1_x03c2_x0020_x03ba_x03b1_x03b9_x0020_x03ba_x03c1_x03b1_x03c4_x03b9_x03ba_x03ad_x03c2_x0020_x03c5_x03c0_x03b7_x03c1_x03b5_x03c3_x03af_x03b5_x03c2 = 14,
	_icommon__inspireTheme_x005fgre_KeywordValue___x0396_x03ce_x03bd_x03b5_x03c2_x0020_x03b4_x03b9_x03b1_x03c7_x03b5_x03af_x03c1_x03b9_x03c3_x03b7_x03c2_x002f_x03c0_x03b5_x03c1_x03b9_x03bf_x03c1_x03b9_x03c3_x03bc_x03bf_x03cd_x002f_x03c1_x03cd_x03b8_x03bc_x03b9_x03c3_x03b7_x03c2_x0020_x03b5_x03ba_x03c4_x03ac_x03c3_x03b5_x03c9_x03bd_x0020_x03ba_x03b1_x03b9_x0020_x03bc_x03bf_x03bd_x03ac_x03b4_x03b5_x03c2_x0020_x03b1_x03bd_x03b1_x03c6_x03bf_x03c1_x03ac_x03c2 = 15,
	_icommon__inspireTheme_x005fgre_KeywordValue___x0396_x03ce_x03bd_x03b5_x03c2_x0020_x03c6_x03c5_x03c3_x03b9_x03ba_x03ce_x03bd_x0020_x03ba_x03b9_x03bd_x03b4_x03cd_x03bd_x03c9_x03bd = 16,
	_icommon__inspireTheme_x005fgre_KeywordValue___x0398_x03b1_x03bb_x03ac_x03c3_x03c3_x03b9_x03b5_x03c2_x0020_x03c0_x03b5_x03c1_x03b9_x03bf_x03c7_x03ad_x03c2 = 17,
	_icommon__inspireTheme_x005fgre_KeywordValue___x039a_x03ac_x03bb_x03c5_x03c8_x03b7_x0020_x03b3_x03b7_x03c2 = 18,
	_icommon__inspireTheme_x005fgre_KeywordValue___x039a_x03b1_x03c4_x03b1_x03bd_x03bf_x03bc_x03ae_x0020_x03b5_x03b9_x03b4_x03ce_x03bd = 19,
	_icommon__inspireTheme_x005fgre_KeywordValue___x039a_x03b1_x03c4_x03b1_x03bd_x03bf_x03bc_x03ae_x0020_x03c0_x03bb_x03b7_x03b8_x03c5_x03c3_x03bc_x03bf_x03cd_x0020_x2014_x0020_x03b4_x03b7_x03bc_x03bf_x03b3_x03c1_x03b1_x03c6_x03af_x03b1 = 20,
	_icommon__inspireTheme_x005fgre_KeywordValue___x039a_x03c4_x03af_x03c1_x03b9_x03b1 = 21,
	_icommon__inspireTheme_x005fgre_KeywordValue___x039c_x03b5_x03c4_x03b5_x03c9_x03c1_x03bf_x03bb_x03bf_x03b3_x03b9_x03ba_x03ac_x0020_x03b3_x03b5_x03c9_x03b3_x03c1_x03b1_x03c6_x03b9_x03ba_x03ac_x0020_x03c7_x03b1_x03c1_x03b1_x03ba_x03c4_x03b7_x03c1_x03b9_x03c3_x03c4_x03b9_x03ba_x03ac = 22,
	_icommon__inspireTheme_x005fgre_KeywordValue___x039f_x03c1_x03b8_x03bf_x03c6_x03c9_x03c4_x03bf_x03b3_x03c1_x03b1_x03c6_x03af_x03b1 = 23,
	_icommon__inspireTheme_x005fgre_KeywordValue___x039f_x03c1_x03c5_x03ba_x03c4_x03bf_x03af_x0020_x03c0_x03cc_x03c1_x03bf_x03b9 = 24,
	_icommon__inspireTheme_x005fgre_KeywordValue___x03a0_x03c1_x03bf_x03c3_x03c4_x03b1_x03c4_x03b5_x03c5_x03cc_x03bc_x03b5_x03bd_x03b5_x03c2_x0020_x03c4_x03bf_x03c0_x03bf_x03b8_x03b5_x03c3_x03af_x03b5_x03c2 = 25,
	_icommon__inspireTheme_x005fgre_KeywordValue___x03a3_x03c4_x03b1_x03c4_x03b9_x03c3_x03c4_x03b9_x03ba_x03ad_x03c2_x0020_x03bc_x03bf_x03bd_x03ac_x03b4_x03b5_x03c2 = 26,
	_icommon__inspireTheme_x005fgre_KeywordValue___x03a3_x03c5_x03c3_x03c4_x03ae_x03bc_x03b1_x03c4_x03b1_x0020_x03b3_x03b5_x03c9_x03b3_x03c1_x03b1_x03c6_x03b9_x03ba_x03bf_x03cd_x0020_x03ba_x03b1_x03bd_x03bd_x03ac_x03b2_x03bf_x03c5 = 27,
	_icommon__inspireTheme_x005fgre_KeywordValue___x03a3_x03c5_x03c3_x03c4_x03ae_x03bc_x03b1_x03c4_x03b1_x0020_x03c3_x03c5_x03bd_x03c4_x03b5_x03c4_x03b1_x03b3_x03bc_x03ad_x03bd_x03c9_x03bd = 28,
	_icommon__inspireTheme_x005fgre_KeywordValue___x03a4_x03bf_x03c0_x03c9_x03bd_x03cd_x03bc_x03b9_x03b1 = 29,
	_icommon__inspireTheme_x005fgre_KeywordValue___x03a5_x03b4_x03c1_x03bf_x03b3_x03c1_x03b1_x03c6_x03af_x03b1 = 30,
	_icommon__inspireTheme_x005fgre_KeywordValue___x03a5_x03c8_x03bf_x03bc_x03b5_x03c4_x03c1_x03af_x03b1 = 31,
	_icommon__inspireTheme_x005fgre_KeywordValue___x03a7_x03c1_x03ae_x03c3_x03b5_x03b9_x03c2_x0020_x03b3_x03b7_x03c2 = 32,
	_icommon__inspireTheme_x005fgre_KeywordValue___x03a9_x03ba_x03b5_x03b1_x03bd_x03bf_x03b3_x03c1_x03b1_x03c6_x03b9_x03ba_x03ac_x0020_x03b3_x03b5_x03c9_x03b3_x03c1_x03b1_x03c6_x03b9_x03ba_x03ac_x0020_x03c7_x03b1_x03c1_x03b1_x03ba_x03c4_x03b7_x03c1_x03b9_x03c3_x03c4_x03b9_x03ba_x03ac = 33
};
#endif

/* ws-inspire-wfs2.h:12668 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgre_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgre_Title (947)
/* icommon:citationInspireInteroperabilityRegulation_gre-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005fgre_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005fgre_Title___x039a_x0391_x039d_x039f_x039d_x0399_x03a3_x039c_x039f_x03a3_x0020_x0028_x0395_x0395_x0029_x0020_x03b1_x03c1_x03b9_x03b8_x002e_x00201089_x002f2010_x0020_x03a4_x0397_x03a3_x0020_x0395_x03a0_x0399_x03a4_x03a1_x039f_x03a0_x0397_x03a3_x0020_x03c4_x03b7_x03c2_x002023_x03b7_x03c2_x0020_x039d_x03bf_x03b5_x03bc_x03b2_x03c1_x03af_x03bf_x03c5_x00202010_x0020_x03c3_x03c7_x03b5_x03c4_x03b9_x03ba_x03ac_x0020_x03bc_x03b5_x0020_x03c4_x03b7_x03bd_x0020_x03b5_x03c6_x03b1_x03c1_x03bc_x03bf_x03b3_x03ae_x0020_x03c4_x03b7_x03c2_x0020_x03bf_x03b4_x03b7_x03b3_x03af_x03b1_x03c2_x00202007_x002f2_x002f_x0395_x039a_x0020_x03c4_x03bf_x03c5_x0020_x0395_x03c5_x03c1_x03c9_x03c0_x03b1_x03ca_x03ba_x03bf_x03cd_x0020_x039a_x03bf_x03b9_x03bd_x03bf_x03b2_x03bf_x03c5_x03bb_x03af_x03bf_x03c5_x0020_x03ba_x03b1_x03b9_x0020_x03c4_x03bf_x03c5_x0020_x03a3_x03c5_x03bc_x03b2_x03bf_x03c5_x03bb_x03af_x03bf_x03c5_x0020_x03cc_x03c3_x03bf_x03bd_x0020_x03b1_x03c6_x03bf_x03c1_x03ac_x0020_x03c4_x03b7_x0020_x03b4_x03b9_x03b1_x03bb_x03b5_x03b9_x03c4_x03bf_x03c5_x03c1_x03b3_x03b9_x03ba_x03cc_x03c4_x03b7_x03c4_x03b1_x0020_x03c4_x03c9_x03bd_x0020_x03c3_x03c5_x03bd_x03cc_x03bb_x03c9_x03bd_x0020_x03ba_x03b1_x03b9_x0020_x03c4_x03c9_x03bd_x0020_x03c5_x03c0_x03b7_x03c1_x03b5_x03c3_x03b9_x03ce_x03bd_x0020_x03c7_x03c9_x03c1_x03b9_x03ba_x03ce_x03bd_x0020_x03b4_x03b5_x03b4_x03bf_x03bc_x03ad_x03bd_x03c9_x03bd = 0
};
#endif

/* ws-inspire-wfs2.h:12677 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgre_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgre_DateOfPublication (949)
/* icommon:citationInspireInteroperabilityRegulation_gre-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005fgre_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005fgre_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:12684 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgre_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgre_URI (951)
/* icommon:citationInspireInteroperabilityRegulation_gre-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005fgre_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005fgre_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aEL_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:12714 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fhun_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fhun_KeywordValue (953)
/* icommon:inspireTheme_hun-KeywordValue */
enum _icommon__inspireTheme_x005fhun_KeywordValue {
	_icommon__inspireTheme_x005fhun_KeywordValue__A_x0020fajok_x0020megoszl_x00e1sa = 0,
	_icommon__inspireTheme_x005fhun_KeywordValue__A_x0020felsz_x00edn_x0020bor_x00edt_x00e1sa = 1,
	_icommon__inspireTheme_x005fhun_KeywordValue__A_x0020n_x00e9pess_x00e9g_x0020eloszl_x00e1sa_x0020_x2013_x0020demogr_x00e1fia = 2,
	_icommon__inspireTheme_x005fhun_KeywordValue___x00c1sv_x00e1nyi_x0020nyersanyagok = 3,
	_icommon__inspireTheme_x005fhun_KeywordValue__Biogeogr_x00e1fiai_x0020r_x00e9gi_x00f3k = 4,
	_icommon__inspireTheme_x005fhun_KeywordValue__C_x00edmek = 5,
	_icommon__inspireTheme_x005fhun_KeywordValue__Domborzat = 6,
	_icommon__inspireTheme_x005fhun_KeywordValue___x00c9l_x0151helyek_x0020_x00e9s_x0020biot_x00f3pok = 7,
	_icommon__inspireTheme_x005fhun_KeywordValue__Emberi_x0020eg_x00e9szs_x00e9g_x0020_x00e9s_x0020biztons_x00e1g = 8,
	_icommon__inspireTheme_x005fhun_KeywordValue__Energiaforr_x00e1sok = 9,
	_icommon__inspireTheme_x005fhun_KeywordValue___x00c9p_x00fcletek = 10,
	_icommon__inspireTheme_x005fhun_KeywordValue__F_x00f6ldhaszn_x00e1lat = 11,
	_icommon__inspireTheme_x005fhun_KeywordValue__F_x00f6ldrajzi_x0020nevek = 12,
	_icommon__inspireTheme_x005fhun_KeywordValue__F_x00f6ldrajzi_x0020r_x00e1csrendszerek = 13,
	_icommon__inspireTheme_x005fhun_KeywordValue__F_x00f6ldtan = 14,
	_icommon__inspireTheme_x005fhun_KeywordValue__Kataszteri_x0020parcell_x00e1k = 15,
	_icommon__inspireTheme_x005fhun_KeywordValue__Koordin_x00e1tarendszerek = 16,
	_icommon__inspireTheme_x005fhun_KeywordValue__K_x00f6rnyezetv_x00e9delmi_x0020monitoringl_x00e9tes_x00edtm_x00e9nyek = 17,
	_icommon__inspireTheme_x005fhun_KeywordValue__K_x00f6zigazgat_x00e1si_x0020egys_x00e9gek = 18,
	_icommon__inspireTheme_x005fhun_KeywordValue__K_x00f6zleked_x00e9si_x0020h_x00e1l_x00f3zatok = 19,
	_icommon__inspireTheme_x005fhun_KeywordValue__K_x00f6z_x00fczemi_x0020_x00e9s_x0020k_x00f6zszolg_x00e1ltat_x00e1sok = 20,
	_icommon__inspireTheme_x005fhun_KeywordValue__L_x00e9gk_x00f6ri_x0020viszonyok = 21,
	_icommon__inspireTheme_x005fhun_KeywordValue__Meteorol_x00f3giai_x0020f_x00f6ldrajzi_x0020jellemz_x0151k = 22,
	_icommon__inspireTheme_x005fhun_KeywordValue__Mez_x0151gazdas_x00e1gi_x0020_x00e9s_x0020akvakult_x00fara__x00e1gazati_x0020l_x00e9tes_x00edtm_x00e9nyek = 23,
	_icommon__inspireTheme_x005fhun_KeywordValue__Oceanogr_x00e1fiai_x0020f_x00f6ldrajzi_x0020jellemz_x0151k = 24,
	_icommon__inspireTheme_x005fhun_KeywordValue__Ortofot_x00f3k = 25,
	_icommon__inspireTheme_x005fhun_KeywordValue__Statisztikai_x0020egys_x00e9gek = 26,
	_icommon__inspireTheme_x005fhun_KeywordValue__Talaj = 27,
	_icommon__inspireTheme_x005fhun_KeywordValue__Tengeri_x0020r_x00e9gi_x00f3k = 28,
	_icommon__inspireTheme_x005fhun_KeywordValue__Termel_x0151_x0020_x00e9s_x0020ipari_x0020l_x00e9tes_x00edtm_x00e9nyek = 29,
	_icommon__inspireTheme_x005fhun_KeywordValue__Term_x00e9szeti_x0020kock_x00e1zati_x0020z_x00f3n_x00e1k = 30,
	_icommon__inspireTheme_x005fhun_KeywordValue__Ter_x00fcletgazd_x00e1lkod_x00e1si_x002f_korl_x00e1toz_x00e1si_x002f_szab_x00e1lyoz_x00e1si_x0020_x00f6vezetek_x0020_x00e9s_x0020adatszolg_x00e1ltat_x00f3_x0020egys_x00e9gek = 31,
	_icommon__inspireTheme_x005fhun_KeywordValue__V_x00e9dett_x0020helyek = 32,
	_icommon__inspireTheme_x005fhun_KeywordValue__V_x00edzrajz = 33
};
#endif

/* ws-inspire-wfs2.h:12773 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fhun_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fhun_Title (954)
/* icommon:citationInspireInteroperabilityRegulation_hun-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005fhun_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005fhun_Title__A_x0020BIZOTTS_x00c1G_x00201089_x002f2010_x002fEU_x0020RENDELETE_x0020_x00282010_x002e_x0020november_x002023_x002e_x0029_x0020a_x00202007_x002f2_x002fEK_x0020eur_x00f3pai_x0020parlamenti_x0020_x00e9s_x0020tan_x00e1csi_x0020ir_x00e1nyelv_x0020t_x00e9radatk_x00e9szletek_x0020_x00e9s_x0020_szolg_x00e1ltat_x00e1sok_x0020interoperabilit_x00e1s_x00e1ra_x0020vonatkoz_x00f3_x0020rendelkez_x00e9seinek_x0020v_x00e9grehajt_x00e1s_x00e1r_x00f3l = 0
};
#endif

/* ws-inspire-wfs2.h:12782 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fhun_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fhun_DateOfPublication (956)
/* icommon:citationInspireInteroperabilityRegulation_hun-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005fhun_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005fhun_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:12789 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fhun_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fhun_URI (958)
/* icommon:citationInspireInteroperabilityRegulation_hun-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005fhun_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005fhun_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aHU_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:12819 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fita_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fita_KeywordValue (960)
/* icommon:inspireTheme_ita-KeywordValue */
enum _icommon__inspireTheme_x005fita_KeywordValue {
	_icommon__inspireTheme_x005fita_KeywordValue__Condizioni_x0020atmosferiche = 0,
	_icommon__inspireTheme_x005fita_KeywordValue__Copertura_x0020del_x0020suolo = 1,
	_icommon__inspireTheme_x005fita_KeywordValue__Distribuzione_x0020della_x0020popolazione_x0020_x2014_x0020demografia = 2,
	_icommon__inspireTheme_x005fita_KeywordValue__Distribuzione_x0020delle_x0020specie = 3,
	_icommon__inspireTheme_x005fita_KeywordValue__Edifici = 4,
	_icommon__inspireTheme_x005fita_KeywordValue__Elementi_x0020geografici_x0020meteorologici = 5,
	_icommon__inspireTheme_x005fita_KeywordValue__Elementi_x0020geografici_x0020oceanografici = 6,
	_icommon__inspireTheme_x005fita_KeywordValue__Elevazione = 7,
	_icommon__inspireTheme_x005fita_KeywordValue__Geologia = 8,
	_icommon__inspireTheme_x005fita_KeywordValue__Habitat_x0020e_x0020biotopi = 9,
	_icommon__inspireTheme_x005fita_KeywordValue__Idrografia = 10,
	_icommon__inspireTheme_x005fita_KeywordValue__Impianti_x0020agricoli_x0020e_x0020di_x0020acquacoltura = 11,
	_icommon__inspireTheme_x005fita_KeywordValue__Impianti_x0020di_x0020monitoraggio_x0020ambientale = 12,
	_icommon__inspireTheme_x005fita_KeywordValue__Indirizzi = 13,
	_icommon__inspireTheme_x005fita_KeywordValue__Nomi_x0020geografici = 14,
	_icommon__inspireTheme_x005fita_KeywordValue__Orto_x0020immagini = 15,
	_icommon__inspireTheme_x005fita_KeywordValue__Parcelle_x0020catastali = 16,
	_icommon__inspireTheme_x005fita_KeywordValue__Produzione_x0020e_x0020impianti_x0020industriali = 17,
	_icommon__inspireTheme_x005fita_KeywordValue__Regioni_x0020biogeografiche = 18,
	_icommon__inspireTheme_x005fita_KeywordValue__Regioni_x0020marine = 19,
	_icommon__inspireTheme_x005fita_KeywordValue__Reti_x0020di_x0020trasporto = 20,
	_icommon__inspireTheme_x005fita_KeywordValue__Risorse_x0020energetiche = 21,
	_icommon__inspireTheme_x005fita_KeywordValue__Risorse_x0020minerarie = 22,
	_icommon__inspireTheme_x005fita_KeywordValue__Salute_x0020umana_x0020e_x0020sicurezza = 23,
	_icommon__inspireTheme_x005fita_KeywordValue__Servizi_x0020di_x0020pubblica_x0020utilit_x00e0_x0020e_x0020servizi_x0020amministrativi = 24,
	_icommon__inspireTheme_x005fita_KeywordValue__Sistemi_x0020di_x0020coordinate = 25,
	_icommon__inspireTheme_x005fita_KeywordValue__Sistemi_x0020di_x0020griglie_x0020geografiche = 26,
	_icommon__inspireTheme_x005fita_KeywordValue__Siti_x0020protetti = 27,
	_icommon__inspireTheme_x005fita_KeywordValue__Suolo = 28,
	_icommon__inspireTheme_x005fita_KeywordValue__Unit_x00e0_x0020amministrative = 29,
	_icommon__inspireTheme_x005fita_KeywordValue__Unit_x00e0_x0020statistiche = 30,
	_icommon__inspireTheme_x005fita_KeywordValue__Utilizzo_x0020del_x0020territorio = 31,
	_icommon__inspireTheme_x005fita_KeywordValue__Zone_x0020a_x0020rischio_x0020naturale = 32,
	_icommon__inspireTheme_x005fita_KeywordValue__Zone_x0020sottoposte_x0020a_x0020gestione_x002flimitazioni_x002fregolamentazione_x0020e_x0020unit_x00e0_x0020con_x0020obbligo_x0020di_x0020comunicare_x0020dati = 33
};
#endif

/* ws-inspire-wfs2.h:12878 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fita_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fita_Title (961)
/* icommon:citationInspireInteroperabilityRegulation_ita-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005fita_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005fita_Title__REGOLAMENTO_x0020_x0028UE_x0029_x0020N_x002e_x00201089_x002f2010_x0020DELLA_x0020COMMISSIONE_x0020del_x002023_x0020novembre_x00202010_x0020recante_x0020attuazione_x0020della_x0020direttiva_x00202007_x002f2_x002fCE_x0020del_x0020Parlamento_x0020europeo_x0020e_x0020del_x0020Consiglio_x0020per_x0020quanto_x0020riguarda_x0020l_x0027interoperabilit_x00e0_x0020dei_x0020set_x0020di_x0020dati_x0020territoriali_x0020e_x0020dei_x0020servizi_x0020di_x0020dati_x0020territoriali = 0
};
#endif

/* ws-inspire-wfs2.h:12887 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fita_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fita_DateOfPublication (963)
/* icommon:citationInspireInteroperabilityRegulation_ita-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005fita_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005fita_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:12894 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fita_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fita_URI (965)
/* icommon:citationInspireInteroperabilityRegulation_ita-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005fita_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005fita_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aIT_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:12924 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005flav_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005flav_KeywordValue (967)
/* icommon:inspireTheme_lav-KeywordValue */
enum _icommon__inspireTheme_x005flav_KeywordValue {
	_icommon__inspireTheme_x005flav_KeywordValue__Administrat_x012bvas_x0020vien_x012bbas = 0,
	_icommon__inspireTheme_x005flav_KeywordValue__Adreses = 1,
	_icommon__inspireTheme_x005flav_KeywordValue__Aizsarg_x0101jamas_x0020teritorijas = 2,
	_icommon__inspireTheme_x005flav_KeywordValue__Apgabala_x0020p_x0101rvald_x012bbas_x002fierobe_x017eojumu_x002freglament_x0113tas_x0020zonas_x0020un_x0020zi_x0146o_x0161anas_x0020vien_x012bbas = 3,
	_icommon__inspireTheme_x005flav_KeywordValue__Atmosf_x0113ras_x0020apst_x0101k_x013ci = 4,
	_icommon__inspireTheme_x005flav_KeywordValue__Augsne = 5,
	_icommon__inspireTheme_x005flav_KeywordValue__Augstums = 6,
	_icommon__inspireTheme_x005flav_KeywordValue__Bio_x0123eogr_x0101fiskie_x0020re_x0123ioni = 7,
	_icommon__inspireTheme_x005flav_KeywordValue__Cilv_x0113ku_x0020vesel_x012bba_x0020un_x0020dro_x0161_x012bba = 8,
	_icommon__inspireTheme_x005flav_KeywordValue__Dabas_x0020apdraud_x0113juma_x0020zonas = 9,
	_icommon__inspireTheme_x005flav_KeywordValue__Der_x012bgo_x0020izrakte_x0146u_x0020resursi = 10,
	_icommon__inspireTheme_x005flav_KeywordValue__Dz_x012bvotnes_x0020un_x0020biotopi = 11,
	_icommon__inspireTheme_x005flav_KeywordValue___x0112kas = 12,
	_icommon__inspireTheme_x005flav_KeywordValue__Ener_x0123ijas_x0020resursi = 13,
	_icommon__inspireTheme_x005flav_KeywordValue___x0122eogr_x0101fisko_x0020koordin_x0101tu_x0020t_x012bklu_x0020sist_x0113mas = 14,
	_icommon__inspireTheme_x005flav_KeywordValue___x0122eolo_x0123ija = 15,
	_icommon__inspireTheme_x005flav_KeywordValue__Hidrogr_x0101fija = 16,
	_icommon__inspireTheme_x005flav_KeywordValue__Iedz_x012bvot_x0101ju_x0020sadal_x012bjums_x0020_x2013_x0020demogr_x0101fija = 17,
	_icommon__inspireTheme_x005flav_KeywordValue__J_x016bru_x0020re_x0123ioni = 18,
	_icommon__inspireTheme_x005flav_KeywordValue__Kadastr_x0101li_x0020zemes_x0020gabali = 19,
	_icommon__inspireTheme_x005flav_KeywordValue__Komun_x0101lie_x0020un_x0020valsts_x0020dienesti = 20,
	_icommon__inspireTheme_x005flav_KeywordValue__Koordin_x0101tu_x0020atskaites_x0020sist_x0113mas = 21,
	_icommon__inspireTheme_x005flav_KeywordValue__Lauksaimniec_x012bbas_x0020un_x0020akvakult_x016bras_x0020iek_x0101rtas = 22,
	_icommon__inspireTheme_x005flav_KeywordValue__Meteorolo_x0123iski_x0020_x0123eogr_x0101fiskie_x0020raksturlielumi = 23,
	_icommon__inspireTheme_x005flav_KeywordValue__Okeanogr_x0101fiski_x0020_x0123eogr_x0101fiskie_x0020raksturlielumi = 24,
	_icommon__inspireTheme_x005flav_KeywordValue__Ortofotogr_x0101fija = 25,
	_icommon__inspireTheme_x005flav_KeywordValue__Ra_x017eo_x0161anas_x0020un_x0020r_x016bpniec_x012bbas_x0020iek_x0101rtas = 26,
	_icommon__inspireTheme_x005flav_KeywordValue__Statistikas_x0020vien_x012bbas = 27,
	_icommon__inspireTheme_x005flav_KeywordValue__Sugu_x0020izplat_x012bba = 28,
	_icommon__inspireTheme_x005flav_KeywordValue__Topon_x012bmi = 29,
	_icommon__inspireTheme_x005flav_KeywordValue__Transporta_x0020t_x012bkli = 30,
	_icommon__inspireTheme_x005flav_KeywordValue__Vides_x0020monitoringa_x0020iek_x0101rtas = 31,
	_icommon__inspireTheme_x005flav_KeywordValue__Zemes_x0020izmanto_x0161ana = 32,
	_icommon__inspireTheme_x005flav_KeywordValue__Zemes_x0020virsma = 33
};
#endif

/* ws-inspire-wfs2.h:12983 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flav_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flav_Title (968)
/* icommon:citationInspireInteroperabilityRegulation_lav-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005flav_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005flav_Title__KOMISIJAS_x0020REGULA_x0020_x0028ES_x0029_x0020Nr_x002e_x00201089_x002f2010_x0020_x00282010_x002e_x0020gada_x002023_x002e_x0020novembris_x0029_x002c_x0020ar_x0020kuru_x0020_x012bsteno_x0020Eiropas_x0020Parlamenta_x0020un_x0020Padomes_x0020Direkt_x012bvu_x00202007_x002f2_x002fEK_x0020attiec_x012bb_x0101_x0020uz_x0020telpisko_x0020datu_x0020kopu_x0020un_x0020telpisko_x0020datu_x0020pakalpojumu_x0020savstarp_x0113jo_x0020izmantojam_x012bbu = 0
};
#endif

/* ws-inspire-wfs2.h:12992 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flav_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flav_DateOfPublication (970)
/* icommon:citationInspireInteroperabilityRegulation_lav-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005flav_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005flav_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:12999 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flav_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flav_URI (972)
/* icommon:citationInspireInteroperabilityRegulation_lav-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005flav_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005flav_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aLV_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:13029 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005flit_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005flit_KeywordValue (974)
/* icommon:inspireTheme_lit-KeywordValue */
enum _icommon__inspireTheme_x005flit_KeywordValue {
	_icommon__inspireTheme_x005flit_KeywordValue__Administraciniai_x0020vienetai = 0,
	_icommon__inspireTheme_x005flit_KeywordValue__Adresai = 1,
	_icommon__inspireTheme_x005flit_KeywordValue__Aplinkos_x0020steb_x0117senos_x0020priemon_x0117s = 2,
	_icommon__inspireTheme_x005flit_KeywordValue__Atmosferos_x0020s_x0105lygos = 3,
	_icommon__inspireTheme_x005flit_KeywordValue__Auk_x0161tis = 4,
	_icommon__inspireTheme_x005flit_KeywordValue__Biogeografiniai_x0020regionai = 5,
	_icommon__inspireTheme_x005flit_KeywordValue__Buvein_x0117s_x0020ir_x0020biotopai = 6,
	_icommon__inspireTheme_x005flit_KeywordValue__Dirvo_x017eemis = 7,
	_icommon__inspireTheme_x005flit_KeywordValue__Energijos_x0020i_x0161tekliai = 8,
	_icommon__inspireTheme_x005flit_KeywordValue__Gamtini_x0173_x0020pavoj_x0173_x0020zonos = 9,
	_icommon__inspireTheme_x005flit_KeywordValue__Gamybos_x0020ir_x0020pramon_x0117s_x0020_x012frenginiai = 10,
	_icommon__inspireTheme_x005flit_KeywordValue__Geografiniai_x0020pavadinimai = 11,
	_icommon__inspireTheme_x005flit_KeywordValue__Geografinio_x0020tinklelio_x0020sistemos = 12,
	_icommon__inspireTheme_x005flit_KeywordValue__Geologija = 13,
	_icommon__inspireTheme_x005flit_KeywordValue__Gyventoj_x0173_x0020pasiskirstymas_x0020_x2013_x0020demografija = 14,
	_icommon__inspireTheme_x005flit_KeywordValue__Hidrografija = 15,
	_icommon__inspireTheme_x005flit_KeywordValue__J_x016br_x0173_x0020regionai = 16,
	_icommon__inspireTheme_x005flit_KeywordValue__Kadastro_x0020sklypai = 17,
	_icommon__inspireTheme_x005flit_KeywordValue__Komunalin_x0117s_x0020_x012fmon_x0117s_x0020ir_x0020valstyb_x0117s_x0020tarnybos = 18,
	_icommon__inspireTheme_x005flit_KeywordValue__Koordina_x010di_x0173_x0020atskaitos_x0020sistemos = 19,
	_icommon__inspireTheme_x005flit_KeywordValue__Meteorologin_x0117s_x0020geografin_x0117s_x0020s_x0105lygos = 20,
	_icommon__inspireTheme_x005flit_KeywordValue__Naudingosios_x0020i_x0161kasenos = 21,
	_icommon__inspireTheme_x005flit_KeywordValue__Okeanografin_x0117s_x0020geografin_x0117s_x0020s_x0105lygos = 22,
	_icommon__inspireTheme_x005flit_KeywordValue__Ortofotografinis_x0020vaizdavimas = 23,
	_icommon__inspireTheme_x005flit_KeywordValue__Pastatai = 24,
	_icommon__inspireTheme_x005flit_KeywordValue__R_x016b_x0161i_x0173_x0020pasiskirstymas = 25,
	_icommon__inspireTheme_x005flit_KeywordValue__Saugomos_x0020teritorijos = 26,
	_icommon__inspireTheme_x005flit_KeywordValue__Statistiniai_x0020vienetai = 27,
	_icommon__inspireTheme_x005flit_KeywordValue__Transporto_x0020tinklai = 28,
	_icommon__inspireTheme_x005flit_KeywordValue__Tvarkomos_x0020teritorijos_x002c_x0020ribojamos_x0020ir_x0020reglamentuojamos_x0020zonos_x0020bei_x0020vienetai_x002c_x0020u_x017e_x0020kuriuos_x0020atsiskaitoma = 29,
	_icommon__inspireTheme_x005flit_KeywordValue___x017dem_x0117s_x0020danga = 30,
	_icommon__inspireTheme_x005flit_KeywordValue___x017dem_x0117s_x0020naudojimas = 31,
	_icommon__inspireTheme_x005flit_KeywordValue___x017dem_x0117s_x0020_x016bkio_x0020ir_x0020akvakult_x016bros_x0020infrastrukt_x016bra = 32,
	_icommon__inspireTheme_x005flit_KeywordValue___x017dmoni_x0173_x0020sveikata_x0020ir_x0020sauga = 33
};
#endif

/* ws-inspire-wfs2.h:13088 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flit_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flit_Title (975)
/* icommon:citationInspireInteroperabilityRegulation_lit-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005flit_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005flit_Title__KOMISIJOS_x0020REGLAMENTAS_x0020_x0028ES_x0029_x0020Nr_x002e_x00201089_x002f2010_x00202010_x0020m_x002e_x0020lapkri_x010dio_x002023_x0020d_x002e_x0020kuriuo_x0020_x012fgyvendinamos_x0020Europos_x0020Parlamento_x0020ir_x0020Tarybos_x0020direktyvos_x00202007_x002f2_x002fEB_x0020nuostatos_x0020d_x0117l_x0020erdvini_x0173_x0020duomen_x0173_x0020rinkini_x0173_x0020ir_x0020paslaug_x0173_x0020s_x0105veikumo = 0
};
#endif

/* ws-inspire-wfs2.h:13097 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flit_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flit_DateOfPublication (977)
/* icommon:citationInspireInteroperabilityRegulation_lit-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005flit_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005flit_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:13104 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flit_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flit_URI (979)
/* icommon:citationInspireInteroperabilityRegulation_lit-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005flit_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005flit_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aLT_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:13134 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fmlt_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fmlt_KeywordValue (981)
/* icommon:inspireTheme_mlt-KeywordValue */
enum _icommon__inspireTheme_x005fmlt_KeywordValue {
	_icommon__inspireTheme_x005fmlt_KeywordValue__Addresses = 0,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Administrative_x0020units = 1,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Agricultural_x0020and_x0020aquaculture_x0020facilities = 2,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Area_x0020management_x002frestriction_x002fregulation_x0020zones_x0020and_x0020reporting_x0020units = 3,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Atmospheric_x0020conditions = 4,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Bio_geographical_x0020regions = 5,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Buildings = 6,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Cadastral_x0020parcels = 7,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Coordinate_x0020reference_x0020systems = 8,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Elevation = 9,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Energy_x0020resources = 10,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Environmental_x0020monitoring_x0020facilities = 11,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Geographical_x0020grid_x0020systems = 12,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Geographical_x0020names = 13,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Geology = 14,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Habitats_x0020and_x0020biotopes = 15,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Human_x0020health_x0020and_x0020safety = 16,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Hydrography = 17,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Land_x0020cover = 18,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Land_x0020use = 19,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Meteorological_x0020geographical_x0020features = 20,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Mineral_x0020resources = 21,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Natural_x0020risk_x0020zones = 22,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Oceanographic_x0020geographical_x0020features = 23,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Orthoimagery = 24,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Population_x0020distribution_x0020_x2014_x0020demography = 25,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Production_x0020and_x0020industrial_x0020facilities = 26,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Protected_x0020sites = 27,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Sea_x0020regions = 28,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Soil = 29,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Species_x0020distribution = 30,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Statistical_x0020units = 31,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Transport_x0020networks = 32,
	_icommon__inspireTheme_x005fmlt_KeywordValue__Utility_x0020and_x0020governmental_x0020services = 33
};
#endif

/* ws-inspire-wfs2.h:13193 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fmlt_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fmlt_Title (982)
/* icommon:citationInspireInteroperabilityRegulation_mlt-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005fmlt_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005fmlt_Title__REGOLAMENT_x0020TAL_KUMMISSJONI_x0020_x0028UE_x0029_x0020Nru_x00201089_x002f2010_x0020tat_23_x0020ta_x0027_x0020Novembru_x00202010_x0020li_x0020jimplimenta_x0020d_Direttiva_x00202007_x002f2_x002fKE_x0020tal_Parlament_x0020Ewropew_x0020u_x0020tal_Kunsill_x0020fir_rigward_x0020tal__x0020interoperabbilt_x00e0_x0020tas_settijiet_x0020ta_x2019_x0020dejta_x0020u_x0020servizzi_x0020_x0121eografi_x010bi = 0
};
#endif

/* ws-inspire-wfs2.h:13202 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fmlt_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fmlt_DateOfPublication (984)
/* icommon:citationInspireInteroperabilityRegulation_mlt-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005fmlt_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005fmlt_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:13209 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fmlt_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fmlt_URI (986)
/* icommon:citationInspireInteroperabilityRegulation_mlt-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005fmlt_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005fmlt_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aMT_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:13239 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fpol_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fpol_KeywordValue (988)
/* icommon:inspireTheme_pol-KeywordValue */
enum _icommon__inspireTheme_x005fpol_KeywordValue {
	_icommon__inspireTheme_x005fpol_KeywordValue__Adresy = 0,
	_icommon__inspireTheme_x005fpol_KeywordValue__Budynki = 1,
	_icommon__inspireTheme_x005fpol_KeywordValue__Dzia_x0142ki_x0020katastralne = 2,
	_icommon__inspireTheme_x005fpol_KeywordValue__Geologia = 3,
	_icommon__inspireTheme_x005fpol_KeywordValue__Gleba = 4,
	_icommon__inspireTheme_x005fpol_KeywordValue__Gospodarowanie_x0020obszarem_x002fstrefy_x0020ograniczone_x002fregulacyjne_x0020oraz_x0020jednostki_x0020sprawozdawcze = 5,
	_icommon__inspireTheme_x005fpol_KeywordValue__Hydrografia = 6,
	_icommon__inspireTheme_x005fpol_KeywordValue__Jednostki_x0020administracyjne = 7,
	_icommon__inspireTheme_x005fpol_KeywordValue__Jednostki_x0020statystyczne = 8,
	_icommon__inspireTheme_x005fpol_KeywordValue__Nazwy_x0020geograficzne = 9,
	_icommon__inspireTheme_x005fpol_KeywordValue__Obiekty_x0020produkcyjne_x0020i_x0020przemys_x0142owe = 10,
	_icommon__inspireTheme_x005fpol_KeywordValue__Obiekty_x0020rolnicze_x0020oraz_x0020akwakultury = 11,
	_icommon__inspireTheme_x005fpol_KeywordValue__Obszary_x0020chronione = 12,
	_icommon__inspireTheme_x005fpol_KeywordValue__Regiony_x0020biogeograficzne = 13,
	_icommon__inspireTheme_x005fpol_KeywordValue__Regiony_x0020morskie = 14,
	_icommon__inspireTheme_x005fpol_KeywordValue__Rozmieszczenie_x0020gatunk_x00f3w = 15,
	_icommon__inspireTheme_x005fpol_KeywordValue__Rozmieszczenie_x0020ludno_x015bci_x0020_x2013_x0020demografia = 16,
	_icommon__inspireTheme_x005fpol_KeywordValue__Sieci_x0020transportowe = 17,
	_icommon__inspireTheme_x005fpol_KeywordValue__Siedliska_x0020i_x0020obszary_x0020przyrodniczo_x0020jednorodne = 18,
	_icommon__inspireTheme_x005fpol_KeywordValue__Sporz_x0105dzanie_x0020ortoobraz_x00f3w = 19,
	_icommon__inspireTheme_x005fpol_KeywordValue__Strefy_x0020zagro_x017cenia_x0020naturalnego = 20,
	_icommon__inspireTheme_x005fpol_KeywordValue__Systemy_x0020odniesienia_x0020za_x0020pomoc_x0105_x0020wsp_x00f3_x0142rz_x0119dnych = 21,
	_icommon__inspireTheme_x005fpol_KeywordValue__Systemy_x0020siatek_x0020geograficznych = 22,
	_icommon__inspireTheme_x005fpol_KeywordValue__Ukszta_x0142towanie_x0020terenu = 23,
	_icommon__inspireTheme_x005fpol_KeywordValue__Urz_x0105dzenia_x0020do_x0020monitorowania_x0020_x015brodowiska = 24,
	_icommon__inspireTheme_x005fpol_KeywordValue__Us_x0142ugi_x0020u_x017cyteczno_x015bci_x0020publicznej_x0020i_x0020s_x0142u_x017cby_x0020pa_x0144stwowe = 25,
	_icommon__inspireTheme_x005fpol_KeywordValue__U_x017cytkowanie_x0020terenu = 26,
	_icommon__inspireTheme_x005fpol_KeywordValue__Warunki_x0020atmosferyczne = 27,
	_icommon__inspireTheme_x005fpol_KeywordValue__Warunki_x0020meteorologiczno_geograficzne = 28,
	_icommon__inspireTheme_x005fpol_KeywordValue__Warunki_x0020oceanograficzno_geograficzne = 29,
	_icommon__inspireTheme_x005fpol_KeywordValue__Zagospodarowanie_x0020przestrzenne = 30,
	_icommon__inspireTheme_x005fpol_KeywordValue__Zasoby_x0020energetyczne = 31,
	_icommon__inspireTheme_x005fpol_KeywordValue__Zasoby_x0020mineralne = 32,
	_icommon__inspireTheme_x005fpol_KeywordValue__Zdrowie_x0020i_x0020bezpiecze_x0144stwo_x0020ludzi = 33
};
#endif

/* ws-inspire-wfs2.h:13298 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpol_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpol_Title (989)
/* icommon:citationInspireInteroperabilityRegulation_pol-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005fpol_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005fpol_Title__ROZPORZ_x0104DZENIE_x0020KOMISJI_x0020_x0028UE_x0029_x0020NR_x00201089_x002f2010_x0020z_x0020dnia_x002023_x0020listopada_x00202010_x0020r_x002e_x0020w_x0020sprawie_x0020wykonania_x0020dyrektywy_x00202007_x002f2_x002fWE_x0020Parlamentu_x0020Europejskiego_x0020i_x0020Rady_x0020w_x0020zakresie_x0020interoperacyjno_x015bci_x0020zbior_x00f3w_x0020i_x0020us_x0142ug_x0020danych_x0020przestrzennych = 0
};
#endif

/* ws-inspire-wfs2.h:13307 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpol_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpol_DateOfPublication (991)
/* icommon:citationInspireInteroperabilityRegulation_pol-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005fpol_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005fpol_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:13314 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpol_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpol_URI (993)
/* icommon:citationInspireInteroperabilityRegulation_pol-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005fpol_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005fpol_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aPL_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:13344 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fpor_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fpor_KeywordValue (995)
/* icommon:inspireTheme_por-KeywordValue */
enum _icommon__inspireTheme_x005fpor_KeywordValue {
	_icommon__inspireTheme_x005fpor_KeywordValue__Altitude = 0,
	_icommon__inspireTheme_x005fpor_KeywordValue__Caracter_x00edsticas_x0020geometeorol_x00f3gicas = 1,
	_icommon__inspireTheme_x005fpor_KeywordValue__Caracter_x00edsticas_x0020oceanogr_x00e1ficas = 2,
	_icommon__inspireTheme_x005fpor_KeywordValue__Condi_x00e7_x00f5es_x0020atmosf_x00e9ricas = 3,
	_icommon__inspireTheme_x005fpor_KeywordValue__Distribui_x00e7_x00e3o_x0020da_x0020popula_x00e7_x00e3o_x0020_x2014_x0020demografia = 4,
	_icommon__inspireTheme_x005fpor_KeywordValue__Distribui_x00e7_x00e3o_x0020das_x0020esp_x00e9cies = 5,
	_icommon__inspireTheme_x005fpor_KeywordValue__Edif_x00edcios = 6,
	_icommon__inspireTheme_x005fpor_KeywordValue__Endere_x00e7os = 7,
	_icommon__inspireTheme_x005fpor_KeywordValue__Geologia = 8,
	_icommon__inspireTheme_x005fpor_KeywordValue__Habitats_x0020e_x0020bi_x00f3topos = 9,
	_icommon__inspireTheme_x005fpor_KeywordValue__Hidrografia = 10,
	_icommon__inspireTheme_x005fpor_KeywordValue__Instala_x00e7_x00f5es_x0020agr_x00edcolas_x0020e_x0020aqu_x00edcolas = 11,
	_icommon__inspireTheme_x005fpor_KeywordValue__Instala_x00e7_x00f5es_x0020de_x0020monitoriza_x00e7_x00e3o_x0020do_x0020ambiente = 12,
	_icommon__inspireTheme_x005fpor_KeywordValue__Instala_x00e7_x00f5es_x0020industriais_x0020e_x0020de_x0020produ_x00e7_x00e3o = 13,
	_icommon__inspireTheme_x005fpor_KeywordValue__Ocupa_x00e7_x00e3o_x0020do_x0020solo = 14,
	_icommon__inspireTheme_x005fpor_KeywordValue__Ortoimagens = 15,
	_icommon__inspireTheme_x005fpor_KeywordValue__Parcelas_x0020cadastrais = 16,
	_icommon__inspireTheme_x005fpor_KeywordValue__Recursos_x0020energ_x00e9ticos = 17,
	_icommon__inspireTheme_x005fpor_KeywordValue__Recursos_x0020minerais = 18,
	_icommon__inspireTheme_x005fpor_KeywordValue__Redes_x0020de_x0020transporte = 19,
	_icommon__inspireTheme_x005fpor_KeywordValue__Regi_x00f5es_x0020biogeogr_x00e1ficas = 20,
	_icommon__inspireTheme_x005fpor_KeywordValue__Regi_x00f5es_x0020marinhas = 21,
	_icommon__inspireTheme_x005fpor_KeywordValue__Sa_x00fade_x0020humana_x0020e_x0020seguran_x00e7a = 22,
	_icommon__inspireTheme_x005fpor_KeywordValue__Servi_x00e7os_x0020de_x0020utilidade_x0020p_x00fablica_x0020e_x0020do_x0020Estado = 23,
	_icommon__inspireTheme_x005fpor_KeywordValue__Sistemas_x0020de_x0020quadr_x00edculas_x0020geogr_x00e1ficas = 24,
	_icommon__inspireTheme_x005fpor_KeywordValue__Sistemas_x0020de_x0020referencia = 25,
	_icommon__inspireTheme_x005fpor_KeywordValue__S_x00edtios_x0020protegidos = 26,
	_icommon__inspireTheme_x005fpor_KeywordValue__Solo = 27,
	_icommon__inspireTheme_x005fpor_KeywordValue__Topon_x00edmia = 28,
	_icommon__inspireTheme_x005fpor_KeywordValue__Unidades_x0020administrativas = 29,
	_icommon__inspireTheme_x005fpor_KeywordValue__Unidades_x0020estat_x00edsticas = 30,
	_icommon__inspireTheme_x005fpor_KeywordValue__Uso_x0020do_x0020solo = 31,
	_icommon__inspireTheme_x005fpor_KeywordValue__Zonas_x0020de_x0020gest_x00e3o_x002frestri_x00e7_x00e3o_x002fregulamenta_x00e7_x00e3o_x0020e_x0020unidades_x0020de_x0020refer_x00eancia = 32,
	_icommon__inspireTheme_x005fpor_KeywordValue__Zonas_x0020de_x0020risco_x0020natural = 33
};
#endif

/* ws-inspire-wfs2.h:13403 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpor_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpor_Title (996)
/* icommon:citationInspireInteroperabilityRegulation_por-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005fpor_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005fpor_Title__REGULAMENTO_x0020_x0028UE_x0029_x0020N_x002e_x0020o_x00201089_x002f2010_x0020DA_x0020COMISS_x00c3O_x0020de_x002023_x0020de_x0020Novembro_x0020de_x00202010_x0020que_x0020estabelece_x0020as_x0020disposi_x00e7_x00f5es_x0020de_x0020execu_x00e7_x00e3o_x0020da_x0020Directiva_x00202007_x002f2_x002fCE_x0020do_x0020Parlamento_x0020Europeu_x0020e_x0020do_x0020Conselho_x0020relativamente_x0020_x00e0_x0020interoperabilidade_x0020dos_x0020conjuntos_x0020e_x0020servi_x00e7os_x0020de_x0020dados_x0020geogr_x00e1ficos = 0
};
#endif

/* ws-inspire-wfs2.h:13412 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpor_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpor_DateOfPublication (998)
/* icommon:citationInspireInteroperabilityRegulation_por-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005fpor_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005fpor_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:13419 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpor_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpor_URI (1000)
/* icommon:citationInspireInteroperabilityRegulation_por-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005fpor_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005fpor_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aPT_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:13449 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005frum_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005frum_KeywordValue (1002)
/* icommon:inspireTheme_rum-KeywordValue */
enum _icommon__inspireTheme_x005frum_KeywordValue {
	_icommon__inspireTheme_x005frum_KeywordValue__Acoperire_x0020terestr_x0103 = 0,
	_icommon__inspireTheme_x005frum_KeywordValue__Adrese = 1,
	_icommon__inspireTheme_x005frum_KeywordValue__Caracteristici_x0020geografice_x0020meteorologice = 2,
	_icommon__inspireTheme_x005frum_KeywordValue__Caracteristici_x0020geografice_x0020oceanografice = 3,
	_icommon__inspireTheme_x005frum_KeywordValue__Cl_x0103diri = 4,
	_icommon__inspireTheme_x005frum_KeywordValue__Condi_x0163ii_x0020atmosferice = 5,
	_icommon__inspireTheme_x005frum_KeywordValue__Denumiri_x0020geografice = 6,
	_icommon__inspireTheme_x005frum_KeywordValue__Eleva_x0163ie = 7,
	_icommon__inspireTheme_x005frum_KeywordValue__Geologie = 8,
	_icommon__inspireTheme_x005frum_KeywordValue__Habitate_x0020_x015fi_x0020biotopuri = 9,
	_icommon__inspireTheme_x005frum_KeywordValue__Hidrografie = 10,
	_icommon__inspireTheme_x005frum_KeywordValue__Instala_x0163ii_x0020agricole_x0020_x015fi_x0020pentru_x0020acvacultur_x0103 = 11,
	_icommon__inspireTheme_x005frum_KeywordValue__Instala_x0163ii_x0020de_x0020produc_x0163ie_x0020_x015fi_x0020industriale = 12,
	_icommon__inspireTheme_x005frum_KeywordValue__Instala_x0163ii_x0020de_x0020supraveghere_x0020a_x0020mediului = 13,
	_icommon__inspireTheme_x005frum_KeywordValue__Ortoimagini = 14,
	_icommon__inspireTheme_x005frum_KeywordValue__Parcele_x0020cadastrale = 15,
	_icommon__inspireTheme_x005frum_KeywordValue__Regiuni_x0020biogeografice = 16,
	_icommon__inspireTheme_x005frum_KeywordValue__Regiuni_x0020maritime = 17,
	_icommon__inspireTheme_x005frum_KeywordValue__Repartizarea_x0020popula_x0163iei_x0020_x2013_x0020demografie = 18,
	_icommon__inspireTheme_x005frum_KeywordValue__Repartizarea_x0020speciilor = 19,
	_icommon__inspireTheme_x005frum_KeywordValue__Resurse_x0020energetice = 20,
	_icommon__inspireTheme_x005frum_KeywordValue__Resurse_x0020minerale = 21,
	_icommon__inspireTheme_x005frum_KeywordValue__Re_x0163ele_x0020de_x0020transport = 22,
	_icommon__inspireTheme_x005frum_KeywordValue__S_x0103n_x0103tate_x0020_x015fi_x0020siguran_x0163_x0103_x0020uman_x0103 = 23,
	_icommon__inspireTheme_x005frum_KeywordValue__Servicii_x0020de_x0020utilitate_x0020public_x0103_x0020_x015fi_x0020servicii_x0020publice = 24,
	_icommon__inspireTheme_x005frum_KeywordValue__Sisteme_x0020de_x0020caroiaj_x0020geografic = 25,
	_icommon__inspireTheme_x005frum_KeywordValue__Sisteme_x0020de_x0020coordonate_x0020de_x0020referin_x0163_x0103 = 26,
	_icommon__inspireTheme_x005frum_KeywordValue__Soluri = 27,
	_icommon__inspireTheme_x005frum_KeywordValue__Unit_x0103_x0163i_x0020administrative = 28,
	_icommon__inspireTheme_x005frum_KeywordValue__Unit_x0103_x0163i_x0020statistice = 29,
	_icommon__inspireTheme_x005frum_KeywordValue__Utilizarea_x0020terenului = 30,
	_icommon__inspireTheme_x005frum_KeywordValue__Zone_x0020de_x0020administrare_x002frestric_x0163ie_x002freglementare_x0020_x015fi_x0020unit_x0103_x0163i_x0020de_x0020raportare = 31,
	_icommon__inspireTheme_x005frum_KeywordValue__Zone_x0020de_x0020risc_x0020natural = 32,
	_icommon__inspireTheme_x005frum_KeywordValue__Zone_x0020protejate = 33
};
#endif

/* ws-inspire-wfs2.h:13508 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005frum_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005frum_Title (1003)
/* icommon:citationInspireInteroperabilityRegulation_rum-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005frum_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005frum_Title__REGULAMENTUL_x0020_x0028UE_x0029_x0020NR_x002e_x00201089_x002f2010_x0020AL_x0020COMISIEI_x0020din_x002023_x0020noiembrie_x00202010_x0020de_x0020punere_x0020_x00een_x0020aplicare_x0020a_x0020Directivei_x00202007_x002f2_x002fCE_x0020a_x0020Parlamentului_x0020European_x0020_x015fi_x0020a_x0020Consiliului_x0020_x00een_x0020ceea_x0020ce_x0020prive_x015fte_x0020interoperabilitatea_x0020seturilor_x0020_x015fi_x0020serviciilor_x0020de_x0020date_x0020spa_x0163iale = 0
};
#endif

/* ws-inspire-wfs2.h:13517 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005frum_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005frum_DateOfPublication (1005)
/* icommon:citationInspireInteroperabilityRegulation_rum-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005frum_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005frum_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:13524 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005frum_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005frum_URI (1007)
/* icommon:citationInspireInteroperabilityRegulation_rum-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005frum_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005frum_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aRO_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:13554 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fslo_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fslo_KeywordValue (1009)
/* icommon:inspireTheme_slo-KeywordValue */
enum _icommon__inspireTheme_x005fslo_KeywordValue {
	_icommon__inspireTheme_x005fslo_KeywordValue__Adresy = 0,
	_icommon__inspireTheme_x005fslo_KeywordValue__Atmosf_x00e9rick_x00e9_x0020podmienky = 1,
	_icommon__inspireTheme_x005fslo_KeywordValue__Biogeografick_x00e9_x0020regi_x00f3ny = 2,
	_icommon__inspireTheme_x005fslo_KeywordValue__Chr_x00e1nen_x00e9_x0020_x00fazemia = 3,
	_icommon__inspireTheme_x005fslo_KeywordValue__Dopravn_x00e9_x0020siete = 4,
	_icommon__inspireTheme_x005fslo_KeywordValue__Geografick_x00e9_x0020syst_x00e9my_x0020siet_x00ed = 5,
	_icommon__inspireTheme_x005fslo_KeywordValue__Geol_x00f3gia = 6,
	_icommon__inspireTheme_x005fslo_KeywordValue__Habitaty_x0020a_x0020biotopy = 7,
	_icommon__inspireTheme_x005fslo_KeywordValue__Hydrografia = 8,
	_icommon__inspireTheme_x005fslo_KeywordValue__Katastr_x00e1lne_x0020parcely = 9,
	_icommon__inspireTheme_x005fslo_KeywordValue__Krajinn_x00e1_x0020pokr_x00fdvka_x0020_x0028land_x0020cover_x0029 = 10,
	_icommon__inspireTheme_x005fslo_KeywordValue___x013dudsk_x00e9_x0020zdravie_x0020a_x0020bezpe_x010dnos_x0165 = 11,
	_icommon__inspireTheme_x005fslo_KeywordValue__Meteorologick_x00e9_x0020geografick_x00e9_x0020prvky = 12,
	_icommon__inspireTheme_x005fslo_KeywordValue__Morsk_x00e9_x0020regi_x00f3ny = 13,
	_icommon__inspireTheme_x005fslo_KeywordValue__Oce_x00e1nografick_x00e9_x0020geografick_x00e9_x0020prvky = 14,
	_icommon__inspireTheme_x005fslo_KeywordValue__Ortometria = 15,
	_icommon__inspireTheme_x005fslo_KeywordValue__P_x00f4da = 16,
	_icommon__inspireTheme_x005fslo_KeywordValue__Po_x013enohospod_x00e1rske_x0020zariadenia_x0020a_x0020zariadenia_x0020akvakult_x00fary = 17,
	_icommon__inspireTheme_x005fslo_KeywordValue__Rozmiestnenie_x0020obyvate_x013estva_x0020_x2013_x0020demografia = 18,
	_icommon__inspireTheme_x005fslo_KeywordValue__Spr_x00e1vne_x0020jednotky = 19,
	_icommon__inspireTheme_x005fslo_KeywordValue__Spravovan_x00e9_x002fobmedzen_x00e9_x002fregulovan_x00e9_x0020z_x00f3ny_x0020a_x0020jednotky_x0020pod_x00e1vaj_x00face_x0020spr_x00e1vy = 20,
	_icommon__inspireTheme_x005fslo_KeywordValue___x0160tatistick_x00e9_x0020jednotky = 21,
	_icommon__inspireTheme_x005fslo_KeywordValue__Stavby = 22,
	_icommon__inspireTheme_x005fslo_KeywordValue__S_x00faradnicov_x00e9_x0020referen_x010dn_x00e9_x0020syst_x00e9my = 23,
	_icommon__inspireTheme_x005fslo_KeywordValue__Verejn_x00e9_x0020a_x0020_x0161t_x00e1tne_x0020slu_x017eby = 24,
	_icommon__inspireTheme_x005fslo_KeywordValue__V_x00fdrobn_x00e9_x0020a_x0020priemyseln_x00e9_x0020zariadenia = 25,
	_icommon__inspireTheme_x005fslo_KeywordValue__V_x00fd_x0161ka = 26,
	_icommon__inspireTheme_x005fslo_KeywordValue__V_x00fdskyt_x0020druhov = 27,
	_icommon__inspireTheme_x005fslo_KeywordValue__Vyu_x017eitie_x0020_x00fazemia = 28,
	_icommon__inspireTheme_x005fslo_KeywordValue__Zariadenia_x0020na_x0020monitorovanie_x0020_x017eivotn_x00e9ho_x0020prostredia = 29,
	_icommon__inspireTheme_x005fslo_KeywordValue__Zdroje_x0020energie = 30,
	_icommon__inspireTheme_x005fslo_KeywordValue__Zdroje_x0020nerastn_x00fdch_x0020surov_x00edn = 31,
	_icommon__inspireTheme_x005fslo_KeywordValue__Zemepisn_x00e9_x0020n_x00e1zvy = 32,
	_icommon__inspireTheme_x005fslo_KeywordValue__Z_x00f3ny_x0020pr_x00edrodn_x00e9ho_x0020rizika = 33
};
#endif

/* ws-inspire-wfs2.h:13613 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslo_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslo_Title (1010)
/* icommon:citationInspireInteroperabilityRegulation_slo-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005fslo_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005fslo_Title__NARIADENIE_x0020KOMISIE_x0020_x0028E_x00da_x0029_x0020_x010d_x002e_x00201089_x002f2010_x0020z_x002023_x002e_x0020novembra_x00202010_x002c_x0020ktor_x00fdm_x0020sa_x0020vykon_x00e1va_x0020smernica_x0020Eur_x00f3pskeho_x0020parlamentu_x0020a_x0020Rady_x00202007_x002f2_x002fES_x002c_x0020pokia_x013e_x0020ide_x0020o_x0020interoperabilitu_x0020s_x00faborov_x0020a_x0020slu_x017eieb_x0020priestorov_x00fdch_x0020_x00fadajov = 0
};
#endif

/* ws-inspire-wfs2.h:13622 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslo_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslo_DateOfPublication (1012)
/* icommon:citationInspireInteroperabilityRegulation_slo-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005fslo_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005fslo_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:13629 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslo_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslo_URI (1014)
/* icommon:citationInspireInteroperabilityRegulation_slo-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005fslo_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005fslo_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aSK_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:13659 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fslv_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fslv_KeywordValue (1016)
/* icommon:inspireTheme_slv-KeywordValue */
enum _icommon__inspireTheme_x005fslv_KeywordValue {
	_icommon__inspireTheme_x005fslv_KeywordValue__Biogeografske_x0020regije = 0,
	_icommon__inspireTheme_x005fslv_KeywordValue__Digitalni_x0020model_x0020vi_x0161in = 1,
	_icommon__inspireTheme_x005fslv_KeywordValue__Energetski_x0020viri = 2,
	_icommon__inspireTheme_x005fslv_KeywordValue__Geografska_x0020koordinatna_x0020mre_x017ea = 3,
	_icommon__inspireTheme_x005fslv_KeywordValue__Geologija = 4,
	_icommon__inspireTheme_x005fslv_KeywordValue__Habitati_x0020in_x0020biotopi = 5,
	_icommon__inspireTheme_x005fslv_KeywordValue__Hidrografija = 6,
	_icommon__inspireTheme_x005fslv_KeywordValue__Katastrske_x0020parcele = 7,
	_icommon__inspireTheme_x005fslv_KeywordValue__Komunalne_x0020in_x0020javne_x0020storitve = 8,
	_icommon__inspireTheme_x005fslv_KeywordValue__Meteorolo_x0161ke_x0020zna_x010dilnosti = 9,
	_icommon__inspireTheme_x005fslv_KeywordValue__Mineralni_x0020viri = 10,
	_icommon__inspireTheme_x005fslv_KeywordValue__Morske_x0020regije = 11,
	_icommon__inspireTheme_x005fslv_KeywordValue__Namenska_x0020raba_x0020tal = 12,
	_icommon__inspireTheme_x005fslv_KeywordValue__Naprave_x0020in_x0020objekti_x0020za_x0020monitoring_x0020okolja = 13,
	_icommon__inspireTheme_x005fslv_KeywordValue__Naslovi = 14,
	_icommon__inspireTheme_x005fslv_KeywordValue__Objekti_x0020in_x0020naprave_x0020za_x0020kmetijstvo_x0020in_x0020ribogojstvo = 15,
	_icommon__inspireTheme_x005fslv_KeywordValue__Obmo_x010dja_x0020nevarnosti_x0020naravnih_x0020nesre_x010d = 16,
	_icommon__inspireTheme_x005fslv_KeywordValue__Obmo_x010dja_x0020upravljanja_x002fzaprta_x0020obmo_x010dja_x002fregulirana_x0020obmo_x010dja_x0020in_x0020poro_x010devalske_x0020enote = 17,
	_icommon__inspireTheme_x005fslv_KeywordValue__Oceanogeografske_x0020zna_x010dilnosti = 18,
	_icommon__inspireTheme_x005fslv_KeywordValue__Ortofoto = 19,
	_icommon__inspireTheme_x005fslv_KeywordValue__Ozra_x010dje = 20,
	_icommon__inspireTheme_x005fslv_KeywordValue__Pokrovnost_x0020tal = 21,
	_icommon__inspireTheme_x005fslv_KeywordValue__Porazdelitev_x0020prebivalstva_x0020_x2013_x0020demografski_x0020podatki = 22,
	_icommon__inspireTheme_x005fslv_KeywordValue__Porazdelitev_x0020vrst = 23,
	_icommon__inspireTheme_x005fslv_KeywordValue__Proizvodni_x0020in_x0020industrijski_x0020objekti_x0020in_x0020naprave = 24,
	_icommon__inspireTheme_x005fslv_KeywordValue__Prometna_x0020omre_x017eja = 25,
	_icommon__inspireTheme_x005fslv_KeywordValue__Referen_x010dni_x0020koordinatni_x0020sistemi = 26,
	_icommon__inspireTheme_x005fslv_KeywordValue__Statisti_x010dni_x0020okoli_x0161i = 27,
	_icommon__inspireTheme_x005fslv_KeywordValue__Stavbe = 28,
	_icommon__inspireTheme_x005fslv_KeywordValue__Tla = 29,
	_icommon__inspireTheme_x005fslv_KeywordValue__Upravne_x0020enote = 30,
	_icommon__inspireTheme_x005fslv_KeywordValue__Zavarovana_x0020obmo_x010dja = 31,
	_icommon__inspireTheme_x005fslv_KeywordValue__Zdravje_x0020in_x0020varnost_x0020prebivalstva = 32,
	_icommon__inspireTheme_x005fslv_KeywordValue__Zemljepisna_x0020imena = 33
};
#endif

/* ws-inspire-wfs2.h:13718 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslv_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslv_Title (1017)
/* icommon:citationInspireInteroperabilityRegulation_slv-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005fslv_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005fslv_Title__UREDBA_x0020KOMISIJE_x0020_x0028EU_x0029_x0020_x0161t_x002e_x00201089_x002f2010_x0020z_x0020dne_x002023_x002e_x0020novembra_x00202010_x0020o_x0020izvajanju_x0020Direktive_x00202007_x002f2_x002fES_x0020Evropskega_x0020parlamenta_x0020in_x0020Sveta_x0020glede_x0020medopravilnosti_x0020zbirk_x0020prostorskih_x0020podatkov_x0020in_x0020storitev_x0020v_x0020zvezi_x0020s_x0020prostorskimi_x0020podatki = 0
};
#endif

/* ws-inspire-wfs2.h:13727 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslv_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslv_DateOfPublication (1019)
/* icommon:citationInspireInteroperabilityRegulation_slv-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005fslv_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005fslv_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:13734 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslv_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslv_URI (1021)
/* icommon:citationInspireInteroperabilityRegulation_slv-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005fslv_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005fslv_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aSL_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:13764 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fspa_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fspa_KeywordValue (1023)
/* icommon:inspireTheme_spa-KeywordValue */
enum _icommon__inspireTheme_x005fspa_KeywordValue {
	_icommon__inspireTheme_x005fspa_KeywordValue__Aspectos_x0020geogr_x00e1ficos_x0020de_x0020car_x00e1cter_x0020meteorol_x00f3gico = 0,
	_icommon__inspireTheme_x005fspa_KeywordValue__Condiciones_x0020atmosf_x00e9ricas = 1,
	_icommon__inspireTheme_x005fspa_KeywordValue__Cubierta_x0020terrestre = 2,
	_icommon__inspireTheme_x005fspa_KeywordValue__Direcciones = 3,
	_icommon__inspireTheme_x005fspa_KeywordValue__Distribuci_x00f3n_x0020de_x0020la_x0020poblaci_x00f3n_x0020_x2014_x0020demograf_x00eda = 4,
	_icommon__inspireTheme_x005fspa_KeywordValue__Distribuci_x00f3n_x0020de_x0020las_x0020especies = 5,
	_icommon__inspireTheme_x005fspa_KeywordValue__Edificios = 6,
	_icommon__inspireTheme_x005fspa_KeywordValue__Elevaciones = 7,
	_icommon__inspireTheme_x005fspa_KeywordValue__Geolog_x00eda = 8,
	_icommon__inspireTheme_x005fspa_KeywordValue__H_x00e1bitats_x0020y_x0020biotopos = 9,
	_icommon__inspireTheme_x005fspa_KeywordValue__Hidrograf_x00eda = 10,
	_icommon__inspireTheme_x005fspa_KeywordValue__Instalaciones_x0020agr_x00edcolas_x0020y_x0020de_x0020acuicultura = 11,
	_icommon__inspireTheme_x005fspa_KeywordValue__Instalaciones_x0020de_x0020observaci_x00f3n_x0020del_x0020medio_x0020ambiente = 12,
	_icommon__inspireTheme_x005fspa_KeywordValue__Instalaciones_x0020de_x0020producci_x00f3n_x0020e_x0020industriales = 13,
	_icommon__inspireTheme_x005fspa_KeywordValue__Lugares_x0020protegidos = 14,
	_icommon__inspireTheme_x005fspa_KeywordValue__Nombres_x0020geogr_x00e1ficos = 15,
	_icommon__inspireTheme_x005fspa_KeywordValue__Ortoim_x00e1genes = 16,
	_icommon__inspireTheme_x005fspa_KeywordValue__Parcelas_x0020catastrales = 17,
	_icommon__inspireTheme_x005fspa_KeywordValue__Rasgos_x0020geogr_x00e1ficos_x0020oceanogr_x00e1ficos = 18,
	_icommon__inspireTheme_x005fspa_KeywordValue__Recursos_x0020energ_x00e9ticos = 19,
	_icommon__inspireTheme_x005fspa_KeywordValue__Recursos_x0020minerales = 20,
	_icommon__inspireTheme_x005fspa_KeywordValue__Redes_x0020de_x0020transporte = 21,
	_icommon__inspireTheme_x005fspa_KeywordValue__Regiones_x0020biogeogr_x00e1ficas = 22,
	_icommon__inspireTheme_x005fspa_KeywordValue__Regiones_x0020marinas = 23,
	_icommon__inspireTheme_x005fspa_KeywordValue__Salud_x0020y_x0020seguridad_x0020humanas = 24,
	_icommon__inspireTheme_x005fspa_KeywordValue__Servicios_x0020de_x0020utilidad_x0020p_x00fablica_x0020y_x0020estatales = 25,
	_icommon__inspireTheme_x005fspa_KeywordValue__Sistema_x0020de_x0020cuadr_x00edculas_x0020geogr_x00e1ficas = 26,
	_icommon__inspireTheme_x005fspa_KeywordValue__Sistemas_x0020de_x0020coordenadas_x0020de_x0020referencia = 27,
	_icommon__inspireTheme_x005fspa_KeywordValue__Suelo = 28,
	_icommon__inspireTheme_x005fspa_KeywordValue__Unidades_x0020administrativas = 29,
	_icommon__inspireTheme_x005fspa_KeywordValue__Unidades_x0020estad_x00edsticas = 30,
	_icommon__inspireTheme_x005fspa_KeywordValue__Uso_x0020del_x0020suelo = 31,
	_icommon__inspireTheme_x005fspa_KeywordValue__Zonas_x0020de_x0020riesgos_x0020naturales = 32,
	_icommon__inspireTheme_x005fspa_KeywordValue__Zonas_x0020sujetas_x0020a_x0020ordenaci_x00f3n_x002c_x0020a_x0020restricciones_x0020o_x0020reglamentaciones_x0020y_x0020unidades_x0020de_x0020notificaci_x00f3n = 33
};
#endif

/* ws-inspire-wfs2.h:13823 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fspa_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fspa_Title (1024)
/* icommon:citationInspireInteroperabilityRegulation_spa-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005fspa_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005fspa_Title__REGLAMENTO_x0020_x0028UE_x0029_x0020N_x0020o_x00201089_x002f2010_x0020DE_x0020LA_x0020COMISI_x00d3N_x0020de_x002023_x0020de_x0020noviembre_x0020de_x00202010_x0020por_x0020el_x0020que_x0020se_x0020aplica_x0020la_x0020Directiva_x00202007_x002f2_x002fCE_x0020del_x0020Parlamento_x0020Europeo_x0020y_x0020del_x0020Consejo_x0020en_x0020lo_x0020que_x0020se_x0020refiere_x0020a_x0020la_x0020interoperabilidad_x0020de_x0020los_x0020conjuntos_x0020y_x0020los_x0020servicios_x0020de_x0020datos_x0020espaciales = 0
};
#endif

/* ws-inspire-wfs2.h:13832 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fspa_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fspa_DateOfPublication (1026)
/* icommon:citationInspireInteroperabilityRegulation_spa-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005fspa_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005fspa_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:13839 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fspa_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fspa_URI (1028)
/* icommon:citationInspireInteroperabilityRegulation_spa-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005fspa_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005fspa_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aES_x003aPDF = 0
};
#endif

/* ws-inspire-wfs2.h:13869 */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fswe_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fswe_KeywordValue (1030)
/* icommon:inspireTheme_swe-KeywordValue */
enum _icommon__inspireTheme_x005fswe_KeywordValue {
	_icommon__inspireTheme_x005fswe_KeywordValue__Administrativa_x0020enheter = 0,
	_icommon__inspireTheme_x005fswe_KeywordValue__Adresser = 1,
	_icommon__inspireTheme_x005fswe_KeywordValue__Allm_x00e4nnyttiga_x0020och_x0020offentliga_x0020tj_x00e4nster = 2,
	_icommon__inspireTheme_x005fswe_KeywordValue__Anl_x00e4ggningar_x0020f_x00f6r_x0020milj_x00f6_x00f6vervakning = 3,
	_icommon__inspireTheme_x005fswe_KeywordValue__Arters_x0020utbredning = 4,
	_icommon__inspireTheme_x005fswe_KeywordValue__Atmosf_x00e4riska_x0020f_x00f6rh_x00e5llanden = 5,
	_icommon__inspireTheme_x005fswe_KeywordValue__Befolkningsf_x00f6rdelning_x0020_x2013_x0020demografi = 6,
	_icommon__inspireTheme_x005fswe_KeywordValue__Biogeografiska_x0020regioner = 7,
	_icommon__inspireTheme_x005fswe_KeywordValue__Byggnader = 8,
	_icommon__inspireTheme_x005fswe_KeywordValue__Energiresurser = 9,
	_icommon__inspireTheme_x005fswe_KeywordValue__Fastighetsomr_x00e5den = 10,
	_icommon__inspireTheme_x005fswe_KeywordValue__Geografiska_x0020meteorologiska_x0020f_x00f6rh_x00e5llanden = 11,
	_icommon__inspireTheme_x005fswe_KeywordValue__Geografiska_x0020namn = 12,
	_icommon__inspireTheme_x005fswe_KeywordValue__Geografiska_x0020oceanografiska_x0020f_x00f6rh_x00e5llanden = 13,
	_icommon__inspireTheme_x005fswe_KeywordValue__Geografiska_x0020rutn_x00e4tssystem = 14,
	_icommon__inspireTheme_x005fswe_KeywordValue__Geologi = 15,
	_icommon__inspireTheme_x005fswe_KeywordValue__Havsomr_x00e5den = 16,
	_icommon__inspireTheme_x005fswe_KeywordValue__Hydrografi = 17,
	_icommon__inspireTheme_x005fswe_KeywordValue__H_x00f6jd = 18,
	_icommon__inspireTheme_x005fswe_KeywordValue__Jordbruks__x0020och_x0020vattenbruksanl_x00e4ggningar = 19,
	_icommon__inspireTheme_x005fswe_KeywordValue__Landt_x00e4cke = 20,
	_icommon__inspireTheme_x005fswe_KeywordValue__Mark = 21,
	_icommon__inspireTheme_x005fswe_KeywordValue__Markanv_x00e4ndning = 22,
	_icommon__inspireTheme_x005fswe_KeywordValue__Mineralfyndigheter = 23,
	_icommon__inspireTheme_x005fswe_KeywordValue__M_x00e4nniskors_x0020h_x00e4lsa_x0020och_x0020s_x00e4kerhet = 24,
	_icommon__inspireTheme_x005fswe_KeywordValue__Naturliga_x0020riskomr_x00e5den = 25,
	_icommon__inspireTheme_x005fswe_KeywordValue__Naturtyper_x0020och_x0020biotoper = 26,
	_icommon__inspireTheme_x005fswe_KeywordValue__Omr_x00e5den_x0020med_x0020s_x00e4rskild_x0020f_x00f6rvaltning_x002fbegr_x00e4nsningar_x002freglering_x0020samt_x0020enheter_x0020f_x00f6r_x0020rapportering = 27,
	_icommon__inspireTheme_x005fswe_KeywordValue__Ortofoto = 28,
	_icommon__inspireTheme_x005fswe_KeywordValue__Produktions__x0020och_x0020industrianl_x00e4ggningar = 29,
	_icommon__inspireTheme_x005fswe_KeywordValue__Referenskoordinatsystem = 30,
	_icommon__inspireTheme_x005fswe_KeywordValue__Skyddade_x0020omr_x00e5den = 31,
	_icommon__inspireTheme_x005fswe_KeywordValue__Statistiska_x0020enheter = 32,
	_icommon__inspireTheme_x005fswe_KeywordValue__Transportn_x00e4t = 33
};
#endif

/* ws-inspire-wfs2.h:13928 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fswe_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fswe_Title (1031)
/* icommon:citationInspireInteroperabilityRegulation_swe-Title */
enum _icommon__citationInspireInteroperabilityRegulation_x005fswe_Title {
	_icommon__citationInspireInteroperabilityRegulation_x005fswe_Title__KOMMISSIONENS_x0020F_x00d6RORDNING_x0020_x0028EU_x0029_x0020nr_x00201089_x002f2010_x0020av_x0020den_x002023_x0020november_x00202010_x0020om_x0020genomf_x00f6rande_x0020av_x0020Europaparlamentets_x0020och_x0020r_x00e5dets_x0020direktiv_x00202007_x002f2_x002fEG_x0020vad_x0020g_x00e4ller_x0020interoperabilitet_x0020f_x00f6r_x0020rumsliga_x0020datam_x00e4ngder_x0020och_x0020datatj_x00e4nster = 0
};
#endif

/* ws-inspire-wfs2.h:13937 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fswe_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fswe_DateOfPublication (1033)
/* icommon:citationInspireInteroperabilityRegulation_swe-DateOfPublication */
enum _icommon__citationInspireInteroperabilityRegulation_x005fswe_DateOfPublication {
	_icommon__citationInspireInteroperabilityRegulation_x005fswe_DateOfPublication__2010_12_08 = 0
};
#endif

/* ws-inspire-wfs2.h:13944 */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fswe_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fswe_URI (1035)
/* icommon:citationInspireInteroperabilityRegulation_swe-URI */
enum _icommon__citationInspireInteroperabilityRegulation_x005fswe_URI {
	_icommon__citationInspireInteroperabilityRegulation_x005fswe_URI__OJ_x003aL_x003a2010_x003a323_x003a0011_x003a0102_x003aSV_x003aPDF = 0
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xsd__anyType;	/* xsd.h:57 */
class xsd__base64Binary;	/* xsd.h:64 */
class xsd__hexBinary;	/* xsd.h:71 */
class wfs__VersionStringType__;	/* ws-inspire-wfs2.h:972 */
class wfs__ResultTypeType_;	/* ws-inspire-wfs2.h:989 */
class wfs__ResolveValueType_;	/* ws-inspire-wfs2.h:1008 */
class wfs__StarStringType_;	/* ws-inspire-wfs2.h:1024 */
class wfs__AllSomeType_;	/* ws-inspire-wfs2.h:1041 */
class wfs__UpdateActionType_;	/* ws-inspire-wfs2.h:1060 */
class ows__MimeType__;	/* ws-inspire-wfs2.h:1093 */
class ows__VersionType__;	/* ws-inspire-wfs2.h:1110 */
class ows__ServiceType__;	/* ws-inspire-wfs2.h:1130 */
class ows__UpdateSequenceType__;	/* ws-inspire-wfs2.h:1146 */
class xlink__typeType_;	/* ws-inspire-wfs2.h:1214 */
class xlink__hrefType__;	/* ws-inspire-wfs2.h:1226 */
class xlink__roleType__;	/* ws-inspire-wfs2.h:1239 */
class xlink__arcroleType__;	/* ws-inspire-wfs2.h:1252 */
class xlink__titleAttrType__;	/* ws-inspire-wfs2.h:1264 */
class xlink__showType_;	/* ws-inspire-wfs2.h:1284 */
class xlink__actuateType_;	/* ws-inspire-wfs2.h:1303 */
class xlink__labelType__;	/* ws-inspire-wfs2.h:1315 */
class xlink__fromType__;	/* ws-inspire-wfs2.h:1327 */
class xlink__toType__;	/* ws-inspire-wfs2.h:1339 */
class fes__SchemaElement__;	/* ws-inspire-wfs2.h:1360 */
class fes__VersionActionTokens_;	/* ws-inspire-wfs2.h:1380 */
class fes__MatchActionType_;	/* ws-inspire-wfs2.h:1398 */
class fes__UomSymbol__;	/* ws-inspire-wfs2.h:1411 */
class fes__UomURI__;	/* ws-inspire-wfs2.h:1424 */
class fes__SortOrderType_;	/* ws-inspire-wfs2.h:1441 */
class icommon__topicCategory_;	/* ws-inspire-wfs2.h:1483 */
class icommon__notEmptyString__;	/* ws-inspire-wfs2.h:1496 */
class icommon__mediaType_;	/* ws-inspire-wfs2.h:1583 */
class icommon__emailType__;	/* ws-inspire-wfs2.h:1596 */
class icommon__iso8601Date__;	/* ws-inspire-wfs2.h:1613 */
class icommon__resourceType_;	/* ws-inspire-wfs2.h:1631 */
class icommon__spatialDataServiceType_;	/* ws-inspire-wfs2.h:1652 */
class icommon__degreeOfConformity_;	/* ws-inspire-wfs2.h:1670 */
class icommon__languageISO6392B_;	/* ws-inspire-wfs2.h:2170 */
class icommon__languageIETF__;	/* ws-inspire-wfs2.h:2182 */
class icommon__responsiblePartyRole_;	/* ws-inspire-wfs2.h:2252 */
class icommon__geoBoxDigits__;	/* ws-inspire-wfs2.h:2269 */
class icommon__serviceSpatialDataResourceType_;	/* ws-inspire-wfs2.h:2333 */
class icommon__viewSpatialDataServiceType_;	/* ws-inspire-wfs2.h:2349 */
class icommon__discoverySpatialDataServiceType_;	/* ws-inspire-wfs2.h:2365 */
class icommon__transformationSpatialDataServiceType_;	/* ws-inspire-wfs2.h:2381 */
class icommon__invokeSpatialDataServiceType_;	/* ws-inspire-wfs2.h:2397 */
class icommon__otherSpatialDataServiceType_;	/* ws-inspire-wfs2.h:2413 */
class icommon__keywordValue__;	/* ws-inspire-wfs2.h:2425 */
class icommon__euLanguageISO6392B_;	/* ws-inspire-wfs2.h:2463 */
class icommon__euLanguageIETF_;	/* ws-inspire-wfs2.h:2525 */
class wfs__BaseRequestType;	/* ws-inspire-wfs2.h:285 */
struct __wfs__QueryPropertyType_sequence;	/* ws-inspire-wfs2.h:2588 */
class wfs__QueryPropertyType;	/* ws-inspire-wfs2.h:287 */
struct __wfs__StoredQueryPropertyType_sequence;	/* ws-inspire-wfs2.h:2612 */
class wfs__StoredQueryPropertyType;	/* ws-inspire-wfs2.h:291 */
class wfs__ParameterType;	/* ws-inspire-wfs2.h:295 */
class wfs__FeatureTypeListType;	/* ws-inspire-wfs2.h:301 */
class _wfs__FeatureTypeType_NoCRS;	/* ws-inspire-wfs2.h:2711 */
class wfs__FeatureTypeType;	/* ws-inspire-wfs2.h:303 */
struct __wfs__OutputFormatListType_sequence;	/* ws-inspire-wfs2.h:2743 */
class wfs__OutputFormatListType;	/* ws-inspire-wfs2.h:305 */
class wfs__MetadataURLType;	/* ws-inspire-wfs2.h:307 */
class wfs__ExtendedDescriptionType;	/* ws-inspire-wfs2.h:309 */
class wfs__ElementType;	/* ws-inspire-wfs2.h:311 */
struct __wfs__ValueListType_sequence;	/* ws-inspire-wfs2.h:2847 */
class wfs__ValueListType;	/* ws-inspire-wfs2.h:313 */
class wfs__ValueCollectionType;	/* ws-inspire-wfs2.h:319 */
union _wfs__union_MemberPropertyType;	/* ws-inspire-wfs2.h:2908 */
class wfs__MemberPropertyType;	/* ws-inspire-wfs2.h:321 */
class wfs__TupleType;	/* ws-inspire-wfs2.h:323 */
class wfs__SimpleFeatureCollectionType;	/* ws-inspire-wfs2.h:331 */
class wfs__EnvelopePropertyType;	/* ws-inspire-wfs2.h:333 */
class wfs__ListStoredQueriesResponseType;	/* ws-inspire-wfs2.h:337 */
class wfs__StoredQueryListItemType;	/* ws-inspire-wfs2.h:339 */
class wfs__DescribeStoredQueriesResponseType;	/* ws-inspire-wfs2.h:343 */
class wfs__StoredQueryDescriptionType;	/* ws-inspire-wfs2.h:345 */
class wfs__ParameterExpressionType;	/* ws-inspire-wfs2.h:349 */
union _wfs__union_QueryExpressionTextType;	/* ws-inspire-wfs2.h:3155 */
class wfs__QueryExpressionTextType;	/* ws-inspire-wfs2.h:351 */
class wfs__ExecutionStatusType;	/* ws-inspire-wfs2.h:353 */
class wfs__LockFeatureResponseType;	/* ws-inspire-wfs2.h:359 */
struct __wfs__FeaturesLockedType_sequence;	/* ws-inspire-wfs2.h:3253 */
class wfs__FeaturesLockedType;	/* ws-inspire-wfs2.h:361 */
struct __wfs__FeaturesNotLockedType_sequence;	/* ws-inspire-wfs2.h:3278 */
class wfs__FeaturesNotLockedType;	/* ws-inspire-wfs2.h:363 */
class wfs__AbstractTransactionActionType;	/* ws-inspire-wfs2.h:367 */
class _wfs__PropertyType_ValueReference;	/* ws-inspire-wfs2.h:3337 */
class wfs__PropertyType;	/* ws-inspire-wfs2.h:373 */
class wfs__TransactionResponseType;	/* ws-inspire-wfs2.h:381 */
class wfs__TransactionSummaryType;	/* ws-inspire-wfs2.h:383 */
class wfs__ActionResultsType;	/* ws-inspire-wfs2.h:385 */
struct __wfs__CreatedOrModifiedFeatureType_sequence;	/* ws-inspire-wfs2.h:3437 */
class wfs__CreatedOrModifiedFeatureType;	/* ws-inspire-wfs2.h:387 */
class wfs__EmptyType;	/* ws-inspire-wfs2.h:389 */
union _wfs__union_additionalValues;	/* ws-inspire-wfs2.h:3483 */
class _wfs__additionalValues;	/* ws-inspire-wfs2.h:395 */
class _wfs__truncatedResponse;	/* ws-inspire-wfs2.h:397 */
union _wfs__union_additionalObjects;	/* ws-inspire-wfs2.h:3545 */
class _wfs__additionalObjects;	/* ws-inspire-wfs2.h:401 */
class util__DescribeFeatureTypeResponseType;	/* ws-inspire-wfs2.h:405 */
class ows__ExceptionType;	/* ws-inspire-wfs2.h:407 */
class ows__GetResourceByIdType;	/* ws-inspire-wfs2.h:409 */
class ows__DescriptionType;	/* ws-inspire-wfs2.h:411 */
union _ows__union_MetadataType;	/* ws-inspire-wfs2.h:3746 */
class ows__MetadataType;	/* ws-inspire-wfs2.h:417 */
class ows__BoundingBoxType;	/* ws-inspire-wfs2.h:419 */
class ows__KeywordsType;	/* ws-inspire-wfs2.h:425 */
class ows__ResponsiblePartyType;	/* ws-inspire-wfs2.h:429 */
class ows__ResponsiblePartySubsetType;	/* ws-inspire-wfs2.h:431 */
class ows__ContactType;	/* ws-inspire-wfs2.h:433 */
class ows__OnlineResourceType;	/* ws-inspire-wfs2.h:435 */
class ows__TelephoneType;	/* ws-inspire-wfs2.h:437 */
class ows__AddressType;	/* ws-inspire-wfs2.h:439 */
class ows__CapabilitiesBaseType;	/* ws-inspire-wfs2.h:441 */
class ows__GetCapabilitiesType;	/* ws-inspire-wfs2.h:443 */
class ows__AcceptVersionsType;	/* ws-inspire-wfs2.h:445 */
class ows__SectionsType;	/* ws-inspire-wfs2.h:447 */
class ows__AcceptFormatsType;	/* ws-inspire-wfs2.h:449 */
union _ows__union_UnNamedDomainType;	/* ws-inspire-wfs2.h:4344 */
union _ows__union_UnNamedDomainType_;	/* ws-inspire-wfs2.h:4410 */
class ows__UnNamedDomainType;	/* ws-inspire-wfs2.h:455 */
class ows__RangeType;	/* ws-inspire-wfs2.h:459 */
class ows__ContentsBaseType;	/* ws-inspire-wfs2.h:463 */
class ows__AbstractReferenceBaseType;	/* ws-inspire-wfs2.h:469 */
class _ows__ExceptionReport;	/* ws-inspire-wfs2.h:477 */
class _ows__ServiceProvider;	/* ws-inspire-wfs2.h:484 */
class _ows__OperationsMetadata;	/* ws-inspire-wfs2.h:486 */
class _ows__Operation;	/* ws-inspire-wfs2.h:488 */
union _ows__union_DCP;	/* ws-inspire-wfs2.h:4818 */
class _ows__DCP;	/* ws-inspire-wfs2.h:490 */
union _ows__union_HTTP;	/* ws-inspire-wfs2.h:4858 */
class __ows__union_HTTP;	/* ws-inspire-wfs2.h:4853 */
class _ows__HTTP;	/* ws-inspire-wfs2.h:492 */
class _ows__AnyValue;	/* ws-inspire-wfs2.h:494 */
class _ows__NoValues;	/* ws-inspire-wfs2.h:496 */
union _ows__union_AllowedValues;	/* ws-inspire-wfs2.h:4953 */
class __ows__union_AllowedValues;	/* ws-inspire-wfs2.h:4948 */
class _ows__AllowedValues;	/* ws-inspire-wfs2.h:500 */
class xlink__simple;	/* ws-inspire-wfs2.h:504 */
union _xlink__union_extended;	/* ws-inspire-wfs2.h:5064 */
class __xlink__union_extended;	/* ws-inspire-wfs2.h:5060 */
class xlink__extended;	/* ws-inspire-wfs2.h:506 */
class xlink__titleEltType;	/* ws-inspire-wfs2.h:508 */
class xlink__resourceType;	/* ws-inspire-wfs2.h:510 */
union _xlink__union_locatorType;	/* ws-inspire-wfs2.h:5206 */
class __xlink__union_locatorType;	/* ws-inspire-wfs2.h:5201 */
class xlink__locatorType;	/* ws-inspire-wfs2.h:512 */
union _xlink__union_arcType;	/* ws-inspire-wfs2.h:5255 */
class __xlink__union_arcType;	/* ws-inspire-wfs2.h:5250 */
class xlink__arcType;	/* ws-inspire-wfs2.h:514 */
class fes__AbstractQueryExpressionType;	/* ws-inspire-wfs2.h:516 */
class fes__AbstractProjectionClauseType;	/* ws-inspire-wfs2.h:520 */
class fes__AbstractSelectionClauseType;	/* ws-inspire-wfs2.h:522 */
class fes__AbstractSortingClauseType;	/* ws-inspire-wfs2.h:524 */
class fes__ComparisonOpsType;	/* ws-inspire-wfs2.h:528 */
class fes__SpatialOpsType;	/* ws-inspire-wfs2.h:530 */
class fes__TemporalOpsType;	/* ws-inspire-wfs2.h:532 */
class fes__LogicOpsType;	/* ws-inspire-wfs2.h:534 */
class fes__ExtensionOpsType;	/* ws-inspire-wfs2.h:536 */
class fes__AbstractIdType;	/* ws-inspire-wfs2.h:538 */
union _fes__union_LowerBoundaryType;	/* ws-inspire-wfs2.h:5510 */
class fes__LowerBoundaryType;	/* ws-inspire-wfs2.h:552 */
union _fes__union_UpperBoundaryType;	/* ws-inspire-wfs2.h:5546 */
class fes__UpperBoundaryType;	/* ws-inspire-wfs2.h:554 */
union _fes__union_FunctionType;	/* ws-inspire-wfs2.h:5581 */
class __fes__union_FunctionType;	/* ws-inspire-wfs2.h:5576 */
class fes__FunctionType;	/* ws-inspire-wfs2.h:570 */
class fes__LiteralType;	/* ws-inspire-wfs2.h:572 */
class fes__ConformanceType;	/* ws-inspire-wfs2.h:574 */
class fes__Id_x005fCapabilitiesType;	/* ws-inspire-wfs2.h:576 */
class fes__ResourceIdentifierType;	/* ws-inspire-wfs2.h:578 */
class fes__Scalar_x005fCapabilitiesType;	/* ws-inspire-wfs2.h:580 */
struct __fes__ComparisonOperatorsType_sequence;	/* ws-inspire-wfs2.h:5724 */
class fes__ComparisonOperatorsType;	/* ws-inspire-wfs2.h:582 */
class fes__ComparisonOperatorType;	/* ws-inspire-wfs2.h:584 */
class fes__AvailableFunctionsType;	/* ws-inspire-wfs2.h:586 */
class fes__AvailableFunctionType;	/* ws-inspire-wfs2.h:588 */
class fes__ArgumentsType;	/* ws-inspire-wfs2.h:590 */
class fes__ArgumentType;	/* ws-inspire-wfs2.h:592 */
class fes__Spatial_x005fCapabilitiesType;	/* ws-inspire-wfs2.h:594 */
class _fes__GeometryOperandsType_GeometryOperand;	/* ws-inspire-wfs2.h:5885 */
class fes__GeometryOperandsType;	/* ws-inspire-wfs2.h:596 */
class fes__SpatialOperatorsType;	/* ws-inspire-wfs2.h:598 */
class fes__SpatialOperatorType;	/* ws-inspire-wfs2.h:600 */
class fes__Temporal_x005fCapabilitiesType;	/* ws-inspire-wfs2.h:602 */
class _fes__TemporalOperandsType_TemporalOperand;	/* ws-inspire-wfs2.h:5981 */
class fes__TemporalOperandsType;	/* ws-inspire-wfs2.h:604 */
class fes__TemporalOperatorsType;	/* ws-inspire-wfs2.h:606 */
class fes__TemporalOperatorType;	/* ws-inspire-wfs2.h:608 */
class fes__Extended_x005fCapabilitiesType;	/* ws-inspire-wfs2.h:610 */
class fes__AdditionalOperatorsType;	/* ws-inspire-wfs2.h:612 */
class fes__ExtensionOperatorType;	/* ws-inspire-wfs2.h:614 */
class fes__SortByType;	/* ws-inspire-wfs2.h:616 */
class fes__SortPropertyType;	/* ws-inspire-wfs2.h:618 */
class _fes__Filter_x005fCapabilities;	/* ws-inspire-wfs2.h:620 */
class _fes__LogicalOperators;	/* ws-inspire-wfs2.h:622 */
class icommon__resource;	/* ws-inspire-wfs2.h:624 */
class icommon__metadataPointOfContact;	/* ws-inspire-wfs2.h:636 */
class _icommon__responsibleOrganisation_ResponsibleParty;	/* ws-inspire-wfs2.h:6302 */
class icommon__responsibleOrganisation;	/* ws-inspire-wfs2.h:638 */
union _icommon__union_citation;	/* ws-inspire-wfs2.h:6338 */
class icommon__citation;	/* ws-inspire-wfs2.h:640 */
class icommon__conformity;	/* ws-inspire-wfs2.h:644 */
class icommon__temporalReference;	/* ws-inspire-wfs2.h:652 */
union _icommon__union_temporalExtent;	/* ws-inspire-wfs2.h:6431 */
class __icommon__union_temporalExtent;	/* ws-inspire-wfs2.h:6426 */
class icommon__temporalExtent;	/* ws-inspire-wfs2.h:654 */
class icommon__keyword;	/* ws-inspire-wfs2.h:656 */
class icommon__resourceLocatorType;	/* ws-inspire-wfs2.h:660 */
class icommon__languageElement;	/* ws-inspire-wfs2.h:662 */
class icommon__geographicBoundingBox;	/* ws-inspire-wfs2.h:668 */
class icommon__spatialResolution;	/* ws-inspire-wfs2.h:670 */
class icommon__uniqueResourceIdentifier;	/* ws-inspire-wfs2.h:672 */
class icommon__ExtendedCapabilitiesType;	/* ws-inspire-wfs2.h:676 */
class icommon__supportedLanguagesType;	/* ws-inspire-wfs2.h:678 */
class _icommon__layers_Layer_CoordinateReferenceSystems_CRS;	/* ws-inspire-wfs2.h:6824 */
class _icommon__layers_Layer_CoordinateReferenceSystems;	/* ws-inspire-wfs2.h:6809 */
class _icommon__layers_Layer_Styles_Style_StyleAbstract;	/* ws-inspire-wfs2.h:6873 */
class _icommon__layers_Layer_Styles_Style_StyleFormat;	/* ws-inspire-wfs2.h:6887 */
class _icommon__layers_Layer_Styles_Style_StyleURL;	/* ws-inspire-wfs2.h:6901 */
class _icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendFormat;	/* ws-inspire-wfs2.h:6941 */
class _icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendURL;	/* ws-inspire-wfs2.h:6959 */
class _icommon__layers_Layer_Styles_Style_LegendList_Legend;	/* ws-inspire-wfs2.h:6928 */
class _icommon__layers_Layer_Styles_Style_LegendList;	/* ws-inspire-wfs2.h:6915 */
class _icommon__layers_Layer_Styles_Style;	/* ws-inspire-wfs2.h:6856 */
class _icommon__layers_Layer_Styles;	/* ws-inspire-wfs2.h:6843 */
class _icommon__layers_Layer;	/* ws-inspire-wfs2.h:6772 */
class icommon__layers;	/* ws-inspire-wfs2.h:684 */
class _icommon__IntervalOfDates;	/* ws-inspire-wfs2.h:848 */
class wfs__StoredQueryType;	/* ws-inspire-wfs2.h:293 */
class wfs__GetCapabilitiesType;	/* ws-inspire-wfs2.h:297 */
class _wfs__WFS_x005fCapabilitiesType_WSDL;	/* ws-inspire-wfs2.h:7123 */
class wfs__WFS_x005fCapabilitiesType;	/* ws-inspire-wfs2.h:299 */
class wfs__DescribeFeatureTypeType;	/* ws-inspire-wfs2.h:315 */
union _wfs__union_GetPropertyValueType;	/* ws-inspire-wfs2.h:7190 */
class wfs__GetPropertyValueType;	/* ws-inspire-wfs2.h:317 */
union _wfs__union_GetFeatureType;	/* ws-inspire-wfs2.h:7253 */
class __wfs__union_GetFeatureType;	/* ws-inspire-wfs2.h:7248 */
class wfs__GetFeatureType;	/* ws-inspire-wfs2.h:325 */
class wfs__FeatureCollectionType;	/* ws-inspire-wfs2.h:329 */
class wfs__ListStoredQueriesType;	/* ws-inspire-wfs2.h:335 */
class wfs__DescribeStoredQueriesType;	/* ws-inspire-wfs2.h:341 */
class wfs__CreateStoredQueryType;	/* ws-inspire-wfs2.h:347 */
class wfs__CreateStoredQueryResponseType;	/* ws-inspire-wfs2.h:355 */
union _wfs__union_LockFeatureType;	/* ws-inspire-wfs2.h:7454 */
class __wfs__union_LockFeatureType;	/* ws-inspire-wfs2.h:7449 */
class wfs__LockFeatureType;	/* ws-inspire-wfs2.h:357 */
union _wfs__union_TransactionType;	/* ws-inspire-wfs2.h:7503 */
struct __wfs__TransactionType_sequence;	/* ws-inspire-wfs2.h:7496 */
class wfs__TransactionType;	/* ws-inspire-wfs2.h:365 */
class wfs__InsertType;	/* ws-inspire-wfs2.h:369 */
class wfs__UpdateType;	/* ws-inspire-wfs2.h:371 */
class wfs__ReplaceType;	/* ws-inspire-wfs2.h:375 */
class wfs__DeleteType;	/* ws-inspire-wfs2.h:377 */
class wfs__NativeType;	/* ws-inspire-wfs2.h:379 */
class _wfs__Title;	/* ws-inspire-wfs2.h:391 */
class _wfs__Abstract;	/* ws-inspire-wfs2.h:393 */
class _wfs__PropertyName;	/* ws-inspire-wfs2.h:399 */
class _wfs__DropStoredQuery;	/* ws-inspire-wfs2.h:403 */
class ows__BasicIdentificationType;	/* ws-inspire-wfs2.h:413 */
class ows__WGS84BoundingBoxType;	/* ws-inspire-wfs2.h:421 */
class ows__LanguageStringType;	/* ws-inspire-wfs2.h:423 */
class ows__CodeType;	/* ws-inspire-wfs2.h:427 */
class ows__RequestMethodType;	/* ws-inspire-wfs2.h:451 */
class ows__DomainType;	/* ws-inspire-wfs2.h:453 */
class ows__ValueType;	/* ws-inspire-wfs2.h:457 */
class ows__DomainMetadataType;	/* ws-inspire-wfs2.h:461 */
union _ows__union_DatasetDescriptionSummaryBaseType;	/* ws-inspire-wfs2.h:8261 */
class __ows__union_DatasetDescriptionSummaryBaseType;	/* ws-inspire-wfs2.h:8256 */
class ows__DatasetDescriptionSummaryBaseType;	/* ws-inspire-wfs2.h:465 */
class ows__ReferenceType;	/* ws-inspire-wfs2.h:471 */
class _ows__ServiceIdentification;	/* ws-inspire-wfs2.h:482 */
class _ows__ValuesReference;	/* ws-inspire-wfs2.h:498 */
class idls__ExtendedCapabilitiesType;	/* ws-inspire-wfs2.h:502 */
union _fes__union_AbstractAdhocQueryExpressionType;	/* ws-inspire-wfs2.h:8594 */
class __fes__union_AbstractAdhocQueryExpressionType;	/* ws-inspire-wfs2.h:8589 */
union _fes__union_AbstractAdhocQueryExpressionType_;	/* ws-inspire-wfs2.h:8608 */
union _fes__union_AbstractAdhocQueryExpressionType__;	/* ws-inspire-wfs2.h:8619 */
class fes__AbstractAdhocQueryExpressionType;	/* ws-inspire-wfs2.h:518 */
union _fes__union_FilterType______;	/* ws-inspire-wfs2.h:8763 */
class __fes__union_FilterType______;	/* ws-inspire-wfs2.h:8758 */
struct ___fes__union_FilterType______;	/* ws-inspire-wfs2.h:8756 */
union _fes__union_FilterType;	/* ws-inspire-wfs2.h:8651 */
class fes__FilterType;	/* ws-inspire-wfs2.h:526 */
class fes__ResourceIdType;	/* ws-inspire-wfs2.h:540 */
union _fes__union_BinaryComparisonOpType;	/* ws-inspire-wfs2.h:8830 */
class __fes__union_BinaryComparisonOpType;	/* ws-inspire-wfs2.h:8825 */
class fes__BinaryComparisonOpType;	/* ws-inspire-wfs2.h:542 */
union _fes__union_PropertyIsLikeType;	/* ws-inspire-wfs2.h:8872 */
class __fes__union_PropertyIsLikeType;	/* ws-inspire-wfs2.h:8867 */
class fes__PropertyIsLikeType;	/* ws-inspire-wfs2.h:544 */
union _fes__union_PropertyIsNullType;	/* ws-inspire-wfs2.h:8915 */
class fes__PropertyIsNullType;	/* ws-inspire-wfs2.h:546 */
union _fes__union_PropertyIsNilType;	/* ws-inspire-wfs2.h:8949 */
class fes__PropertyIsNilType;	/* ws-inspire-wfs2.h:548 */
union _fes__union_PropertyIsBetweenType;	/* ws-inspire-wfs2.h:8985 */
class fes__PropertyIsBetweenType;	/* ws-inspire-wfs2.h:550 */
union _fes__union_BinarySpatialOpType;	/* ws-inspire-wfs2.h:9024 */
class __fes__union_BinarySpatialOpType;	/* ws-inspire-wfs2.h:9019 */
class fes__BinarySpatialOpType;	/* ws-inspire-wfs2.h:556 */
union _fes__union_BinaryTemporalOpType;	/* ws-inspire-wfs2.h:9071 */
class __fes__union_BinaryTemporalOpType;	/* ws-inspire-wfs2.h:9066 */
class fes__BinaryTemporalOpType;	/* ws-inspire-wfs2.h:558 */
union _fes__union_BBOXType;	/* ws-inspire-wfs2.h:9118 */
class __fes__union_BBOXType;	/* ws-inspire-wfs2.h:9113 */
class fes__BBOXType;	/* ws-inspire-wfs2.h:560 */
union _fes__union_DistanceBufferType;	/* ws-inspire-wfs2.h:9164 */
class __fes__union_DistanceBufferType;	/* ws-inspire-wfs2.h:9160 */
class fes__DistanceBufferType;	/* ws-inspire-wfs2.h:562 */
union _fes__union_BinaryLogicOpType_______;	/* ws-inspire-wfs2.h:9327 */
class __fes__union_BinaryLogicOpType_______;	/* ws-inspire-wfs2.h:9322 */
struct ___fes__union_BinaryLogicOpType_______;	/* ws-inspire-wfs2.h:9320 */
union _fes__union_BinaryLogicOpType_;	/* ws-inspire-wfs2.h:9215 */
class __fes__union_BinaryLogicOpType;	/* ws-inspire-wfs2.h:9209 */
class fes__BinaryLogicOpType;	/* ws-inspire-wfs2.h:564 */
union _fes__union_UnaryLogicOpType_______;	/* ws-inspire-wfs2.h:9476 */
class __fes__union_UnaryLogicOpType_______;	/* ws-inspire-wfs2.h:9471 */
struct ___fes__union_UnaryLogicOpType_______;	/* ws-inspire-wfs2.h:9469 */
union _fes__union_UnaryLogicOpType_;	/* ws-inspire-wfs2.h:9364 */
class fes__UnaryLogicOpType;	/* ws-inspire-wfs2.h:566 */
class fes__MeasureType;	/* ws-inspire-wfs2.h:568 */
class icommon__data;	/* ws-inspire-wfs2.h:626 */
class icommon__service_x005fext;	/* ws-inspire-wfs2.h:632 */
union _icommon__union_citationConformity;	/* ws-inspire-wfs2.h:9707 */
class icommon__citationConformity;	/* ws-inspire-wfs2.h:642 */
union _icommon__union_originatingControlledVocabulary;	/* ws-inspire-wfs2.h:9756 */
class icommon__originatingControlledVocabulary;	/* ws-inspire-wfs2.h:646 */
class icommon__classificationOfSpatialDataService;	/* ws-inspire-wfs2.h:658 */
class icommon__languageElementISO6392B;	/* ws-inspire-wfs2.h:664 */
class icommon__languageElementIETF;	/* ws-inspire-wfs2.h:666 */
class icommon__inspireTheme;	/* ws-inspire-wfs2.h:674 */
class icommon__resLocInspireInteroperabilityRegulation_x005fbul;	/* ws-inspire-wfs2.h:708 */
class icommon__resLocInspireInteroperabilityRegulation_x005fcze;	/* ws-inspire-wfs2.h:714 */
class icommon__resLocInspireInteroperabilityRegulation_x005fdan;	/* ws-inspire-wfs2.h:720 */
class icommon__resLocInspireInteroperabilityRegulation_x005fdut;	/* ws-inspire-wfs2.h:726 */
class icommon__resLocGEMETInspireThemes_x005feng;	/* ws-inspire-wfs2.h:732 */
union _icommon__union_citationGEMETInspireThemes_x005feng;	/* ws-inspire-wfs2.h:10146 */
class icommon__citationGEMETInspireThemes_x005feng;	/* ws-inspire-wfs2.h:734 */
class icommon__resLocInspireInteroperabilityRegulation_x005feng;	/* ws-inspire-wfs2.h:736 */
class icommon__resLocInspireInteroperabilityRegulation_x005fest;	/* ws-inspire-wfs2.h:742 */
class icommon__resLocInspireInteroperabilityRegulation_x005ffin;	/* ws-inspire-wfs2.h:748 */
class icommon__resLocInspireInteroperabilityRegulation_x005ffre;	/* ws-inspire-wfs2.h:754 */
class icommon__resLocInspireInteroperabilityRegulation_x005fger;	/* ws-inspire-wfs2.h:760 */
class icommon__resLocInspireInteroperabilityRegulation_x005fgle;	/* ws-inspire-wfs2.h:766 */
class icommon__resLocInspireInteroperabilityRegulation_x005fgre;	/* ws-inspire-wfs2.h:772 */
class icommon__resLocInspireInteroperabilityRegulation_x005fhun;	/* ws-inspire-wfs2.h:778 */
class icommon__resLocInspireInteroperabilityRegulation_x005fita;	/* ws-inspire-wfs2.h:784 */
class icommon__resLocInspireInteroperabilityRegulation_x005flav;	/* ws-inspire-wfs2.h:790 */
class icommon__resLocInspireInteroperabilityRegulation_x005flit;	/* ws-inspire-wfs2.h:796 */
class icommon__resLocInspireInteroperabilityRegulation_x005fmlt;	/* ws-inspire-wfs2.h:802 */
class icommon__resLocInspireInteroperabilityRegulation_x005fpol;	/* ws-inspire-wfs2.h:808 */
class icommon__resLocInspireInteroperabilityRegulation_x005fpor;	/* ws-inspire-wfs2.h:814 */
class icommon__resLocInspireInteroperabilityRegulation_x005frum;	/* ws-inspire-wfs2.h:820 */
class icommon__resLocInspireInteroperabilityRegulation_x005fslo;	/* ws-inspire-wfs2.h:826 */
class icommon__resLocInspireInteroperabilityRegulation_x005fslv;	/* ws-inspire-wfs2.h:832 */
class icommon__resLocInspireInteroperabilityRegulation_x005fspa;	/* ws-inspire-wfs2.h:840 */
class icommon__resLocInspireInteroperabilityRegulation_x005fswe;	/* ws-inspire-wfs2.h:844 */
class wfs__QueryType;	/* ws-inspire-wfs2.h:289 */
class wfs__GetFeatureWithLockType;	/* ws-inspire-wfs2.h:327 */
union _ows__union_IdentificationType;	/* ws-inspire-wfs2.h:10915 */
class __ows__union_IdentificationType;	/* ws-inspire-wfs2.h:10910 */
union _ows__union_IdentificationType_;	/* ws-inspire-wfs2.h:10949 */
class __ows__union_IdentificationType_;	/* ws-inspire-wfs2.h:10944 */
class ows__IdentificationType;	/* ws-inspire-wfs2.h:415 */
union _ows__union_ServiceReferenceType;	/* ws-inspire-wfs2.h:11060 */
class ows__ServiceReferenceType;	/* ws-inspire-wfs2.h:467 */
union _ows__union_ReferenceGroupType;	/* ws-inspire-wfs2.h:11139 */
class __ows__union_ReferenceGroupType;	/* ws-inspire-wfs2.h:11134 */
class ows__ReferenceGroupType;	/* ws-inspire-wfs2.h:473 */
class ows__ManifestType;	/* ws-inspire-wfs2.h:475 */
class icommon__dataset;	/* ws-inspire-wfs2.h:628 */
class icommon__series;	/* ws-inspire-wfs2.h:630 */
class icommon__service;	/* ws-inspire-wfs2.h:634 */
union _icommon__union_originatingControlledVocabularyGemetInspireThemes;	/* ws-inspire-wfs2.h:11490 */
class icommon__originatingControlledVocabularyGemetInspireThemes;	/* ws-inspire-wfs2.h:648 */
union _icommon__union_originatingControlledVocabularyMD;	/* ws-inspire-wfs2.h:11527 */
class icommon__originatingControlledVocabularyMD;	/* ws-inspire-wfs2.h:650 */
class icommon__inspireTheme_x005fbul;	/* ws-inspire-wfs2.h:706 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fbul;	/* ws-inspire-wfs2.h:11625 */
class icommon__citationInspireInteroperabilityRegulation_x005fbul;	/* ws-inspire-wfs2.h:710 */
class icommon__inspireTheme_x005fcze;	/* ws-inspire-wfs2.h:712 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fcze;	/* ws-inspire-wfs2.h:11730 */
class icommon__citationInspireInteroperabilityRegulation_x005fcze;	/* ws-inspire-wfs2.h:716 */
class icommon__inspireTheme_x005fdan;	/* ws-inspire-wfs2.h:718 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fdan;	/* ws-inspire-wfs2.h:11835 */
class icommon__citationInspireInteroperabilityRegulation_x005fdan;	/* ws-inspire-wfs2.h:722 */
class icommon__inspireTheme_x005fdut;	/* ws-inspire-wfs2.h:724 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fdut;	/* ws-inspire-wfs2.h:11940 */
class icommon__citationInspireInteroperabilityRegulation_x005fdut;	/* ws-inspire-wfs2.h:728 */
class icommon__inspireTheme_x005feng;	/* ws-inspire-wfs2.h:730 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005feng;	/* ws-inspire-wfs2.h:12045 */
class icommon__citationInspireInteroperabilityRegulation_x005feng;	/* ws-inspire-wfs2.h:738 */
class icommon__inspireTheme_x005fest;	/* ws-inspire-wfs2.h:740 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fest;	/* ws-inspire-wfs2.h:12150 */
class icommon__citationInspireInteroperabilityRegulation_x005fest;	/* ws-inspire-wfs2.h:744 */
class icommon__inspireTheme_x005ffin;	/* ws-inspire-wfs2.h:746 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005ffin;	/* ws-inspire-wfs2.h:12255 */
class icommon__citationInspireInteroperabilityRegulation_x005ffin;	/* ws-inspire-wfs2.h:750 */
class icommon__inspireTheme_x005ffre;	/* ws-inspire-wfs2.h:752 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005ffre;	/* ws-inspire-wfs2.h:12360 */
class icommon__citationInspireInteroperabilityRegulation_x005ffre;	/* ws-inspire-wfs2.h:756 */
class icommon__inspireTheme_x005fger;	/* ws-inspire-wfs2.h:758 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fger;	/* ws-inspire-wfs2.h:12465 */
class icommon__citationInspireInteroperabilityRegulation_x005fger;	/* ws-inspire-wfs2.h:762 */
class icommon__inspireTheme_x005fgle;	/* ws-inspire-wfs2.h:764 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fgle;	/* ws-inspire-wfs2.h:12570 */
class icommon__citationInspireInteroperabilityRegulation_x005fgle;	/* ws-inspire-wfs2.h:768 */
class icommon__inspireTheme_x005fgre;	/* ws-inspire-wfs2.h:770 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fgre;	/* ws-inspire-wfs2.h:12675 */
class icommon__citationInspireInteroperabilityRegulation_x005fgre;	/* ws-inspire-wfs2.h:774 */
class icommon__inspireTheme_x005fhun;	/* ws-inspire-wfs2.h:776 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fhun;	/* ws-inspire-wfs2.h:12780 */
class icommon__citationInspireInteroperabilityRegulation_x005fhun;	/* ws-inspire-wfs2.h:780 */
class icommon__inspireTheme_x005fita;	/* ws-inspire-wfs2.h:782 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fita;	/* ws-inspire-wfs2.h:12885 */
class icommon__citationInspireInteroperabilityRegulation_x005fita;	/* ws-inspire-wfs2.h:786 */
class icommon__inspireTheme_x005flav;	/* ws-inspire-wfs2.h:788 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005flav;	/* ws-inspire-wfs2.h:12990 */
class icommon__citationInspireInteroperabilityRegulation_x005flav;	/* ws-inspire-wfs2.h:792 */
class icommon__inspireTheme_x005flit;	/* ws-inspire-wfs2.h:794 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005flit;	/* ws-inspire-wfs2.h:13095 */
class icommon__citationInspireInteroperabilityRegulation_x005flit;	/* ws-inspire-wfs2.h:798 */
class icommon__inspireTheme_x005fmlt;	/* ws-inspire-wfs2.h:800 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fmlt;	/* ws-inspire-wfs2.h:13200 */
class icommon__citationInspireInteroperabilityRegulation_x005fmlt;	/* ws-inspire-wfs2.h:804 */
class icommon__inspireTheme_x005fpol;	/* ws-inspire-wfs2.h:806 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fpol;	/* ws-inspire-wfs2.h:13305 */
class icommon__citationInspireInteroperabilityRegulation_x005fpol;	/* ws-inspire-wfs2.h:810 */
class icommon__inspireTheme_x005fpor;	/* ws-inspire-wfs2.h:812 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fpor;	/* ws-inspire-wfs2.h:13410 */
class icommon__citationInspireInteroperabilityRegulation_x005fpor;	/* ws-inspire-wfs2.h:816 */
class icommon__inspireTheme_x005frum;	/* ws-inspire-wfs2.h:818 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005frum;	/* ws-inspire-wfs2.h:13515 */
class icommon__citationInspireInteroperabilityRegulation_x005frum;	/* ws-inspire-wfs2.h:822 */
class icommon__inspireTheme_x005fslo;	/* ws-inspire-wfs2.h:824 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fslo;	/* ws-inspire-wfs2.h:13620 */
class icommon__citationInspireInteroperabilityRegulation_x005fslo;	/* ws-inspire-wfs2.h:828 */
class icommon__inspireTheme_x005fslv;	/* ws-inspire-wfs2.h:830 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fslv;	/* ws-inspire-wfs2.h:13725 */
class icommon__citationInspireInteroperabilityRegulation_x005fslv;	/* ws-inspire-wfs2.h:834 */
class icommon__inspireTheme_x005fspa;	/* ws-inspire-wfs2.h:836 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fspa;	/* ws-inspire-wfs2.h:13830 */
class icommon__citationInspireInteroperabilityRegulation_x005fspa;	/* ws-inspire-wfs2.h:838 */
class icommon__inspireTheme_x005fswe;	/* ws-inspire-wfs2.h:842 */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fswe;	/* ws-inspire-wfs2.h:13935 */
class icommon__citationInspireInteroperabilityRegulation_x005fswe;	/* ws-inspire-wfs2.h:846 */
class icommon__discoveryService_x005fext;	/* ws-inspire-wfs2.h:680 */
class icommon__viewService_x005fext;	/* ws-inspire-wfs2.h:686 */
class icommon__downloadService_x005fext;	/* ws-inspire-wfs2.h:690 */
class icommon__transformationService_x005fext;	/* ws-inspire-wfs2.h:694 */
class icommon__invokeService_x005fext;	/* ws-inspire-wfs2.h:698 */
class icommon__otherService_x005fext;	/* ws-inspire-wfs2.h:702 */
class icommon__discoveryService;	/* ws-inspire-wfs2.h:682 */
class icommon__viewService;	/* ws-inspire-wfs2.h:688 */
class icommon__downloadService;	/* ws-inspire-wfs2.h:692 */
class icommon__transformationService;	/* ws-inspire-wfs2.h:696 */
class icommon__invokeService;	/* ws-inspire-wfs2.h:700 */
class icommon__otherService;	/* ws-inspire-wfs2.h:704 */
struct __f2i_plu__wfs_x002ecreateStoredQueryResponse;	/* ws-inspire-wfs2.h:15436 */
struct __f2i_plu__wfs_x002ecreateStoredQuery;	/* ws-inspire-wfs2.h:15436 */
struct __f2i_plu__wfs_x002edescribeFeatureType;	/* ws-inspire-wfs2.h:15503 */
struct __f2i_plu__wfs_x002egetFeature;	/* ws-inspire-wfs2.h:15570 */
struct __f2i_plu__wfs_x002edescribeStoredQueries;	/* ws-inspire-wfs2.h:15637 */
struct __f2i_plu__wfs_x002elistStoredQueries;	/* ws-inspire-wfs2.h:15704 */
struct __f2i_plu__wfs_x002edropStoredQueryResponse;	/* ws-inspire-wfs2.h:15771 */
struct __f2i_plu__wfs_x002edropStoredQuery;	/* ws-inspire-wfs2.h:15771 */
struct __f2i_plu__wfs_x002egetCapabilities;	/* ws-inspire-wfs2.h:15838 */
struct __f2i_plu__wfs_x002egetFeatureWithLock;	/* ws-inspire-wfs2.h:15905 */
struct __f2i_plu__wfs_x002egetPropertyValue;	/* ws-inspire-wfs2.h:15972 */
struct __f2i_plu__wfs_x002elockFeature;	/* ws-inspire-wfs2.h:16039 */
struct __f2i_plu__wfs_x002etransaction;	/* ws-inspire-wfs2.h:16106 */

/* xsd.h:57 */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (10)
/* Type xsd__anyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:anyType': */
class SOAP_CMAC xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:anyType' wrapped by this struct
        char *__item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyType
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__anyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyType, default initialized and not managed by a soap context
        virtual xsd__anyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__anyType); }
      public:
        /// Constructor with default initializations
        xsd__anyType() : __item(), soap() { }
        virtual ~xsd__anyType() { }
        /// Friend allocator used by soap_new_xsd__anyType(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xsd.h:64 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (13)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XML schema type 'xsd:string'
        char *id;
        /// Optional element 'type' of XML schema type 'xsd:string'
        char *type;
        /// Optional element 'options' of XML schema type 'xsd:string'
        char *options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary); }
      public:
        /// Constructor with default initializations
        xsd__base64Binary() : __ptr(), __size(), id(), type(), options(), soap() { }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xsd.h:71 */
#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (17)
/* hexBinary XML schema type: */
class SOAP_CMAC xsd__hexBinary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__hexBinary
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__hexBinary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__hexBinary, default initialized and not managed by a soap context
        virtual xsd__hexBinary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__hexBinary); }
      public:
        /// Constructor with default initializations
        xsd__hexBinary() : __ptr(), __size(), soap() { }
        virtual ~xsd__hexBinary() { }
        /// Friend allocator used by soap_new_xsd__hexBinary(struct soap*, int)
        friend SOAP_FMAC1 xsd__hexBinary * SOAP_FMAC2 soap_instantiate_xsd__hexBinary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:972 */
#ifndef SOAP_TYPE_wfs__VersionStringType__
#define SOAP_TYPE_wfs__VersionStringType__ (349)
/* Type wfs__VersionStringType__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'wfs:VersionStringType': */
class SOAP_CMAC wfs__VersionStringType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'wfs:VersionStringType' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_wfs__VersionStringType__
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__VersionStringType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__VersionStringType__, default initialized and not managed by a soap context
        virtual wfs__VersionStringType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__VersionStringType__); }
      public:
        /// Constructor with default initializations
        wfs__VersionStringType__() : __item() { }
        virtual ~wfs__VersionStringType__() { }
        /// Friend allocator used by soap_new_wfs__VersionStringType__(struct soap*, int)
        friend SOAP_FMAC1 wfs__VersionStringType__ * SOAP_FMAC2 soap_instantiate_wfs__VersionStringType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:989 */
#ifndef SOAP_TYPE_wfs__ResultTypeType_
#define SOAP_TYPE_wfs__ResultTypeType_ (351)
/* Type wfs__ResultTypeType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'wfs:ResultTypeType': */
class SOAP_CMAC wfs__ResultTypeType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'wfs:ResultTypeType' wrapped by this struct
        enum wfs__ResultTypeType __item;
      public:
        /// Return unique type id SOAP_TYPE_wfs__ResultTypeType_
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__ResultTypeType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__ResultTypeType_, default initialized and not managed by a soap context
        virtual wfs__ResultTypeType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__ResultTypeType_); }
      public:
        /// Constructor with default initializations
        wfs__ResultTypeType_() : __item() { }
        virtual ~wfs__ResultTypeType_() { }
        /// Friend allocator used by soap_new_wfs__ResultTypeType_(struct soap*, int)
        friend SOAP_FMAC1 wfs__ResultTypeType_ * SOAP_FMAC2 soap_instantiate_wfs__ResultTypeType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1008 */
#ifndef SOAP_TYPE_wfs__ResolveValueType_
#define SOAP_TYPE_wfs__ResolveValueType_ (353)
/* Type wfs__ResolveValueType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'wfs:ResolveValueType': */
class SOAP_CMAC wfs__ResolveValueType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'wfs:ResolveValueType' wrapped by this struct
        enum wfs__ResolveValueType __item;
      public:
        /// Return unique type id SOAP_TYPE_wfs__ResolveValueType_
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__ResolveValueType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__ResolveValueType_, default initialized and not managed by a soap context
        virtual wfs__ResolveValueType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__ResolveValueType_); }
      public:
        /// Constructor with default initializations
        wfs__ResolveValueType_() : __item() { }
        virtual ~wfs__ResolveValueType_() { }
        /// Friend allocator used by soap_new_wfs__ResolveValueType_(struct soap*, int)
        friend SOAP_FMAC1 wfs__ResolveValueType_ * SOAP_FMAC2 soap_instantiate_wfs__ResolveValueType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1024 */
#ifndef SOAP_TYPE_wfs__StarStringType_
#define SOAP_TYPE_wfs__StarStringType_ (355)
/* Type wfs__StarStringType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'wfs:StarStringType': */
class SOAP_CMAC wfs__StarStringType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'wfs:StarStringType' wrapped by this struct
        enum wfs__StarStringType __item;
      public:
        /// Return unique type id SOAP_TYPE_wfs__StarStringType_
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__StarStringType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__StarStringType_, default initialized and not managed by a soap context
        virtual wfs__StarStringType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__StarStringType_); }
      public:
        /// Constructor with default initializations
        wfs__StarStringType_() : __item() { }
        virtual ~wfs__StarStringType_() { }
        /// Friend allocator used by soap_new_wfs__StarStringType_(struct soap*, int)
        friend SOAP_FMAC1 wfs__StarStringType_ * SOAP_FMAC2 soap_instantiate_wfs__StarStringType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1041 */
#ifndef SOAP_TYPE_wfs__AllSomeType_
#define SOAP_TYPE_wfs__AllSomeType_ (357)
/* Type wfs__AllSomeType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'wfs:AllSomeType': */
class SOAP_CMAC wfs__AllSomeType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'wfs:AllSomeType' wrapped by this struct
        enum wfs__AllSomeType __item;
      public:
        /// Return unique type id SOAP_TYPE_wfs__AllSomeType_
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__AllSomeType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__AllSomeType_, default initialized and not managed by a soap context
        virtual wfs__AllSomeType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__AllSomeType_); }
      public:
        /// Constructor with default initializations
        wfs__AllSomeType_() : __item() { }
        virtual ~wfs__AllSomeType_() { }
        /// Friend allocator used by soap_new_wfs__AllSomeType_(struct soap*, int)
        friend SOAP_FMAC1 wfs__AllSomeType_ * SOAP_FMAC2 soap_instantiate_wfs__AllSomeType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1060 */
#ifndef SOAP_TYPE_wfs__UpdateActionType_
#define SOAP_TYPE_wfs__UpdateActionType_ (359)
/* Type wfs__UpdateActionType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'wfs:UpdateActionType': */
class SOAP_CMAC wfs__UpdateActionType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'wfs:UpdateActionType' wrapped by this struct
        enum wfs__UpdateActionType __item;
      public:
        /// Return unique type id SOAP_TYPE_wfs__UpdateActionType_
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__UpdateActionType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__UpdateActionType_, default initialized and not managed by a soap context
        virtual wfs__UpdateActionType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__UpdateActionType_); }
      public:
        /// Constructor with default initializations
        wfs__UpdateActionType_() : __item() { }
        virtual ~wfs__UpdateActionType_() { }
        /// Friend allocator used by soap_new_wfs__UpdateActionType_(struct soap*, int)
        friend SOAP_FMAC1 wfs__UpdateActionType_ * SOAP_FMAC2 soap_instantiate_wfs__UpdateActionType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1093 */
#ifndef SOAP_TYPE_ows__MimeType__
#define SOAP_TYPE_ows__MimeType__ (361)
/* Type ows__MimeType__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'ows:MimeType': */
class SOAP_CMAC ows__MimeType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'ows:MimeType' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_ows__MimeType__
        virtual long soap_type(void) const { return SOAP_TYPE_ows__MimeType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__MimeType__, default initialized and not managed by a soap context
        virtual ows__MimeType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__MimeType__); }
      public:
        /// Constructor with default initializations
        ows__MimeType__() : __item() { }
        virtual ~ows__MimeType__() { }
        /// Friend allocator used by soap_new_ows__MimeType__(struct soap*, int)
        friend SOAP_FMAC1 ows__MimeType__ * SOAP_FMAC2 soap_instantiate_ows__MimeType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1110 */
#ifndef SOAP_TYPE_ows__VersionType__
#define SOAP_TYPE_ows__VersionType__ (363)
/* Type ows__VersionType__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'ows:VersionType': */
class SOAP_CMAC ows__VersionType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'ows:VersionType' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_ows__VersionType__
        virtual long soap_type(void) const { return SOAP_TYPE_ows__VersionType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__VersionType__, default initialized and not managed by a soap context
        virtual ows__VersionType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__VersionType__); }
      public:
        /// Constructor with default initializations
        ows__VersionType__() : __item() { }
        virtual ~ows__VersionType__() { }
        /// Friend allocator used by soap_new_ows__VersionType__(struct soap*, int)
        friend SOAP_FMAC1 ows__VersionType__ * SOAP_FMAC2 soap_instantiate_ows__VersionType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1130 */
#ifndef SOAP_TYPE_ows__ServiceType__
#define SOAP_TYPE_ows__ServiceType__ (366)
/* Type ows__ServiceType__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'ows:ServiceType': */
class SOAP_CMAC ows__ServiceType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'ows:ServiceType' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_ows__ServiceType__
        virtual long soap_type(void) const { return SOAP_TYPE_ows__ServiceType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__ServiceType__, default initialized and not managed by a soap context
        virtual ows__ServiceType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__ServiceType__); }
      public:
        /// Constructor with default initializations
        ows__ServiceType__() : __item() { }
        virtual ~ows__ServiceType__() { }
        /// Friend allocator used by soap_new_ows__ServiceType__(struct soap*, int)
        friend SOAP_FMAC1 ows__ServiceType__ * SOAP_FMAC2 soap_instantiate_ows__ServiceType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1146 */
#ifndef SOAP_TYPE_ows__UpdateSequenceType__
#define SOAP_TYPE_ows__UpdateSequenceType__ (368)
/* Type ows__UpdateSequenceType__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'ows:UpdateSequenceType': */
class SOAP_CMAC ows__UpdateSequenceType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'ows:UpdateSequenceType' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_ows__UpdateSequenceType__
        virtual long soap_type(void) const { return SOAP_TYPE_ows__UpdateSequenceType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__UpdateSequenceType__, default initialized and not managed by a soap context
        virtual ows__UpdateSequenceType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__UpdateSequenceType__); }
      public:
        /// Constructor with default initializations
        ows__UpdateSequenceType__() : __item() { }
        virtual ~ows__UpdateSequenceType__() { }
        /// Friend allocator used by soap_new_ows__UpdateSequenceType__(struct soap*, int)
        friend SOAP_FMAC1 ows__UpdateSequenceType__ * SOAP_FMAC2 soap_instantiate_ows__UpdateSequenceType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1214 */
#ifndef SOAP_TYPE_xlink__typeType_
#define SOAP_TYPE_xlink__typeType_ (371)
/* Type xlink__typeType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xlink:typeType': */
class SOAP_CMAC xlink__typeType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xlink:typeType' wrapped by this struct
        enum xlink__typeType __item;
      public:
        /// Return unique type id SOAP_TYPE_xlink__typeType_
        virtual long soap_type(void) const { return SOAP_TYPE_xlink__typeType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__typeType_, default initialized and not managed by a soap context
        virtual xlink__typeType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__typeType_); }
      public:
        /// Constructor with default initializations
        xlink__typeType_() : __item() { }
        virtual ~xlink__typeType_() { }
        /// Friend allocator used by soap_new_xlink__typeType_(struct soap*, int)
        friend SOAP_FMAC1 xlink__typeType_ * SOAP_FMAC2 soap_instantiate_xlink__typeType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1226 */
#ifndef SOAP_TYPE_xlink__hrefType__
#define SOAP_TYPE_xlink__hrefType__ (373)
/* Type xlink__hrefType__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xlink:hrefType': */
class SOAP_CMAC xlink__hrefType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xlink:hrefType' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xlink__hrefType__
        virtual long soap_type(void) const { return SOAP_TYPE_xlink__hrefType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__hrefType__, default initialized and not managed by a soap context
        virtual xlink__hrefType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__hrefType__); }
      public:
        /// Constructor with default initializations
        xlink__hrefType__() : __item() { }
        virtual ~xlink__hrefType__() { }
        /// Friend allocator used by soap_new_xlink__hrefType__(struct soap*, int)
        friend SOAP_FMAC1 xlink__hrefType__ * SOAP_FMAC2 soap_instantiate_xlink__hrefType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1239 */
#ifndef SOAP_TYPE_xlink__roleType__
#define SOAP_TYPE_xlink__roleType__ (375)
/* Type xlink__roleType__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xlink:roleType': */
class SOAP_CMAC xlink__roleType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xlink:roleType' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xlink__roleType__
        virtual long soap_type(void) const { return SOAP_TYPE_xlink__roleType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__roleType__, default initialized and not managed by a soap context
        virtual xlink__roleType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__roleType__); }
      public:
        /// Constructor with default initializations
        xlink__roleType__() : __item() { }
        virtual ~xlink__roleType__() { }
        /// Friend allocator used by soap_new_xlink__roleType__(struct soap*, int)
        friend SOAP_FMAC1 xlink__roleType__ * SOAP_FMAC2 soap_instantiate_xlink__roleType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1252 */
#ifndef SOAP_TYPE_xlink__arcroleType__
#define SOAP_TYPE_xlink__arcroleType__ (377)
/* Type xlink__arcroleType__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xlink:arcroleType': */
class SOAP_CMAC xlink__arcroleType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xlink:arcroleType' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xlink__arcroleType__
        virtual long soap_type(void) const { return SOAP_TYPE_xlink__arcroleType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__arcroleType__, default initialized and not managed by a soap context
        virtual xlink__arcroleType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__arcroleType__); }
      public:
        /// Constructor with default initializations
        xlink__arcroleType__() : __item() { }
        virtual ~xlink__arcroleType__() { }
        /// Friend allocator used by soap_new_xlink__arcroleType__(struct soap*, int)
        friend SOAP_FMAC1 xlink__arcroleType__ * SOAP_FMAC2 soap_instantiate_xlink__arcroleType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1264 */
#ifndef SOAP_TYPE_xlink__titleAttrType__
#define SOAP_TYPE_xlink__titleAttrType__ (379)
/* Type xlink__titleAttrType__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xlink:titleAttrType': */
class SOAP_CMAC xlink__titleAttrType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xlink:titleAttrType' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xlink__titleAttrType__
        virtual long soap_type(void) const { return SOAP_TYPE_xlink__titleAttrType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__titleAttrType__, default initialized and not managed by a soap context
        virtual xlink__titleAttrType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__titleAttrType__); }
      public:
        /// Constructor with default initializations
        xlink__titleAttrType__() : __item() { }
        virtual ~xlink__titleAttrType__() { }
        /// Friend allocator used by soap_new_xlink__titleAttrType__(struct soap*, int)
        friend SOAP_FMAC1 xlink__titleAttrType__ * SOAP_FMAC2 soap_instantiate_xlink__titleAttrType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1284 */
#ifndef SOAP_TYPE_xlink__showType_
#define SOAP_TYPE_xlink__showType_ (381)
/* Type xlink__showType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xlink:showType': */
class SOAP_CMAC xlink__showType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xlink:showType' wrapped by this struct
        enum xlink__showType __item;
      public:
        /// Return unique type id SOAP_TYPE_xlink__showType_
        virtual long soap_type(void) const { return SOAP_TYPE_xlink__showType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__showType_, default initialized and not managed by a soap context
        virtual xlink__showType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__showType_); }
      public:
        /// Constructor with default initializations
        xlink__showType_() : __item() { }
        virtual ~xlink__showType_() { }
        /// Friend allocator used by soap_new_xlink__showType_(struct soap*, int)
        friend SOAP_FMAC1 xlink__showType_ * SOAP_FMAC2 soap_instantiate_xlink__showType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1303 */
#ifndef SOAP_TYPE_xlink__actuateType_
#define SOAP_TYPE_xlink__actuateType_ (383)
/* Type xlink__actuateType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xlink:actuateType': */
class SOAP_CMAC xlink__actuateType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xlink:actuateType' wrapped by this struct
        enum xlink__actuateType __item;
      public:
        /// Return unique type id SOAP_TYPE_xlink__actuateType_
        virtual long soap_type(void) const { return SOAP_TYPE_xlink__actuateType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__actuateType_, default initialized and not managed by a soap context
        virtual xlink__actuateType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__actuateType_); }
      public:
        /// Constructor with default initializations
        xlink__actuateType_() : __item() { }
        virtual ~xlink__actuateType_() { }
        /// Friend allocator used by soap_new_xlink__actuateType_(struct soap*, int)
        friend SOAP_FMAC1 xlink__actuateType_ * SOAP_FMAC2 soap_instantiate_xlink__actuateType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1315 */
#ifndef SOAP_TYPE_xlink__labelType__
#define SOAP_TYPE_xlink__labelType__ (385)
/* Type xlink__labelType__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xlink:labelType': */
class SOAP_CMAC xlink__labelType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xlink:labelType' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xlink__labelType__
        virtual long soap_type(void) const { return SOAP_TYPE_xlink__labelType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__labelType__, default initialized and not managed by a soap context
        virtual xlink__labelType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__labelType__); }
      public:
        /// Constructor with default initializations
        xlink__labelType__() : __item() { }
        virtual ~xlink__labelType__() { }
        /// Friend allocator used by soap_new_xlink__labelType__(struct soap*, int)
        friend SOAP_FMAC1 xlink__labelType__ * SOAP_FMAC2 soap_instantiate_xlink__labelType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1327 */
#ifndef SOAP_TYPE_xlink__fromType__
#define SOAP_TYPE_xlink__fromType__ (387)
/* Type xlink__fromType__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xlink:fromType': */
class SOAP_CMAC xlink__fromType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xlink:fromType' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xlink__fromType__
        virtual long soap_type(void) const { return SOAP_TYPE_xlink__fromType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__fromType__, default initialized and not managed by a soap context
        virtual xlink__fromType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__fromType__); }
      public:
        /// Constructor with default initializations
        xlink__fromType__() : __item() { }
        virtual ~xlink__fromType__() { }
        /// Friend allocator used by soap_new_xlink__fromType__(struct soap*, int)
        friend SOAP_FMAC1 xlink__fromType__ * SOAP_FMAC2 soap_instantiate_xlink__fromType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1339 */
#ifndef SOAP_TYPE_xlink__toType__
#define SOAP_TYPE_xlink__toType__ (389)
/* Type xlink__toType__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xlink:toType': */
class SOAP_CMAC xlink__toType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xlink:toType' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xlink__toType__
        virtual long soap_type(void) const { return SOAP_TYPE_xlink__toType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__toType__, default initialized and not managed by a soap context
        virtual xlink__toType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__toType__); }
      public:
        /// Constructor with default initializations
        xlink__toType__() : __item() { }
        virtual ~xlink__toType__() { }
        /// Friend allocator used by soap_new_xlink__toType__(struct soap*, int)
        friend SOAP_FMAC1 xlink__toType__ * SOAP_FMAC2 soap_instantiate_xlink__toType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1360 */
#ifndef SOAP_TYPE_fes__SchemaElement__
#define SOAP_TYPE_fes__SchemaElement__ (391)
/* Type fes__SchemaElement__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'fes:SchemaElement': */
class SOAP_CMAC fes__SchemaElement__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'fes:SchemaElement' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_fes__SchemaElement__
        virtual long soap_type(void) const { return SOAP_TYPE_fes__SchemaElement__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__SchemaElement__, default initialized and not managed by a soap context
        virtual fes__SchemaElement__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__SchemaElement__); }
      public:
        /// Constructor with default initializations
        fes__SchemaElement__() : __item() { }
        virtual ~fes__SchemaElement__() { }
        /// Friend allocator used by soap_new_fes__SchemaElement__(struct soap*, int)
        friend SOAP_FMAC1 fes__SchemaElement__ * SOAP_FMAC2 soap_instantiate_fes__SchemaElement__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1380 */
#ifndef SOAP_TYPE_fes__VersionActionTokens_
#define SOAP_TYPE_fes__VersionActionTokens_ (393)
/* Type fes__VersionActionTokens_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'fes:VersionActionTokens': */
class SOAP_CMAC fes__VersionActionTokens_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'fes:VersionActionTokens' wrapped by this struct
        enum fes__VersionActionTokens __item;
      public:
        /// Return unique type id SOAP_TYPE_fes__VersionActionTokens_
        virtual long soap_type(void) const { return SOAP_TYPE_fes__VersionActionTokens_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__VersionActionTokens_, default initialized and not managed by a soap context
        virtual fes__VersionActionTokens_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__VersionActionTokens_); }
      public:
        /// Constructor with default initializations
        fes__VersionActionTokens_() : __item() { }
        virtual ~fes__VersionActionTokens_() { }
        /// Friend allocator used by soap_new_fes__VersionActionTokens_(struct soap*, int)
        friend SOAP_FMAC1 fes__VersionActionTokens_ * SOAP_FMAC2 soap_instantiate_fes__VersionActionTokens_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1398 */
#ifndef SOAP_TYPE_fes__MatchActionType_
#define SOAP_TYPE_fes__MatchActionType_ (395)
/* Type fes__MatchActionType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'fes:MatchActionType': */
class SOAP_CMAC fes__MatchActionType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'fes:MatchActionType' wrapped by this struct
        enum fes__MatchActionType __item;
      public:
        /// Return unique type id SOAP_TYPE_fes__MatchActionType_
        virtual long soap_type(void) const { return SOAP_TYPE_fes__MatchActionType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__MatchActionType_, default initialized and not managed by a soap context
        virtual fes__MatchActionType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__MatchActionType_); }
      public:
        /// Constructor with default initializations
        fes__MatchActionType_() : __item() { }
        virtual ~fes__MatchActionType_() { }
        /// Friend allocator used by soap_new_fes__MatchActionType_(struct soap*, int)
        friend SOAP_FMAC1 fes__MatchActionType_ * SOAP_FMAC2 soap_instantiate_fes__MatchActionType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1411 */
#ifndef SOAP_TYPE_fes__UomSymbol__
#define SOAP_TYPE_fes__UomSymbol__ (397)
/* Type fes__UomSymbol__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'fes:UomSymbol': */
class SOAP_CMAC fes__UomSymbol__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'fes:UomSymbol' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_fes__UomSymbol__
        virtual long soap_type(void) const { return SOAP_TYPE_fes__UomSymbol__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__UomSymbol__, default initialized and not managed by a soap context
        virtual fes__UomSymbol__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__UomSymbol__); }
      public:
        /// Constructor with default initializations
        fes__UomSymbol__() : __item() { }
        virtual ~fes__UomSymbol__() { }
        /// Friend allocator used by soap_new_fes__UomSymbol__(struct soap*, int)
        friend SOAP_FMAC1 fes__UomSymbol__ * SOAP_FMAC2 soap_instantiate_fes__UomSymbol__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1424 */
#ifndef SOAP_TYPE_fes__UomURI__
#define SOAP_TYPE_fes__UomURI__ (399)
/* Type fes__UomURI__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'fes:UomURI': */
class SOAP_CMAC fes__UomURI__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'fes:UomURI' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_fes__UomURI__
        virtual long soap_type(void) const { return SOAP_TYPE_fes__UomURI__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__UomURI__, default initialized and not managed by a soap context
        virtual fes__UomURI__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__UomURI__); }
      public:
        /// Constructor with default initializations
        fes__UomURI__() : __item() { }
        virtual ~fes__UomURI__() { }
        /// Friend allocator used by soap_new_fes__UomURI__(struct soap*, int)
        friend SOAP_FMAC1 fes__UomURI__ * SOAP_FMAC2 soap_instantiate_fes__UomURI__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1441 */
#ifndef SOAP_TYPE_fes__SortOrderType_
#define SOAP_TYPE_fes__SortOrderType_ (401)
/* Type fes__SortOrderType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'fes:SortOrderType': */
class SOAP_CMAC fes__SortOrderType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'fes:SortOrderType' wrapped by this struct
        enum fes__SortOrderType __item;
      public:
        /// Return unique type id SOAP_TYPE_fes__SortOrderType_
        virtual long soap_type(void) const { return SOAP_TYPE_fes__SortOrderType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__SortOrderType_, default initialized and not managed by a soap context
        virtual fes__SortOrderType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__SortOrderType_); }
      public:
        /// Constructor with default initializations
        fes__SortOrderType_() : __item() { }
        virtual ~fes__SortOrderType_() { }
        /// Friend allocator used by soap_new_fes__SortOrderType_(struct soap*, int)
        friend SOAP_FMAC1 fes__SortOrderType_ * SOAP_FMAC2 soap_instantiate_fes__SortOrderType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1483 */
#ifndef SOAP_TYPE_icommon__topicCategory_
#define SOAP_TYPE_icommon__topicCategory_ (403)
/* Type icommon__topicCategory_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'icommon:topicCategory': */
class SOAP_CMAC icommon__topicCategory_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'icommon:topicCategory' wrapped by this struct
        enum icommon__topicCategory __item;
      public:
        /// Return unique type id SOAP_TYPE_icommon__topicCategory_
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__topicCategory_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__topicCategory_, default initialized and not managed by a soap context
        virtual icommon__topicCategory_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__topicCategory_); }
      public:
        /// Constructor with default initializations
        icommon__topicCategory_() : __item() { }
        virtual ~icommon__topicCategory_() { }
        /// Friend allocator used by soap_new_icommon__topicCategory_(struct soap*, int)
        friend SOAP_FMAC1 icommon__topicCategory_ * SOAP_FMAC2 soap_instantiate_icommon__topicCategory_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1496 */
#ifndef SOAP_TYPE_icommon__notEmptyString__
#define SOAP_TYPE_icommon__notEmptyString__ (405)
/* Type icommon__notEmptyString__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'icommon:notEmptyString': */
class SOAP_CMAC icommon__notEmptyString__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'icommon:notEmptyString' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_icommon__notEmptyString__
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__notEmptyString__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__notEmptyString__, default initialized and not managed by a soap context
        virtual icommon__notEmptyString__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__notEmptyString__); }
      public:
        /// Constructor with default initializations
        icommon__notEmptyString__() : __item() { }
        virtual ~icommon__notEmptyString__() { }
        /// Friend allocator used by soap_new_icommon__notEmptyString__(struct soap*, int)
        friend SOAP_FMAC1 icommon__notEmptyString__ * SOAP_FMAC2 soap_instantiate_icommon__notEmptyString__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1583 */
#ifndef SOAP_TYPE_icommon__mediaType_
#define SOAP_TYPE_icommon__mediaType_ (407)
/* Type icommon__mediaType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'icommon:mediaType': */
class SOAP_CMAC icommon__mediaType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'icommon:mediaType' wrapped by this struct
        enum icommon__mediaType __item;
      public:
        /// Return unique type id SOAP_TYPE_icommon__mediaType_
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__mediaType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__mediaType_, default initialized and not managed by a soap context
        virtual icommon__mediaType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__mediaType_); }
      public:
        /// Constructor with default initializations
        icommon__mediaType_() : __item() { }
        virtual ~icommon__mediaType_() { }
        /// Friend allocator used by soap_new_icommon__mediaType_(struct soap*, int)
        friend SOAP_FMAC1 icommon__mediaType_ * SOAP_FMAC2 soap_instantiate_icommon__mediaType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1596 */
#ifndef SOAP_TYPE_icommon__emailType__
#define SOAP_TYPE_icommon__emailType__ (409)
/* Type icommon__emailType__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'icommon:emailType': */
class SOAP_CMAC icommon__emailType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'icommon:emailType' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_icommon__emailType__
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__emailType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__emailType__, default initialized and not managed by a soap context
        virtual icommon__emailType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__emailType__); }
      public:
        /// Constructor with default initializations
        icommon__emailType__() : __item() { }
        virtual ~icommon__emailType__() { }
        /// Friend allocator used by soap_new_icommon__emailType__(struct soap*, int)
        friend SOAP_FMAC1 icommon__emailType__ * SOAP_FMAC2 soap_instantiate_icommon__emailType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1613 */
#ifndef SOAP_TYPE_icommon__iso8601Date__
#define SOAP_TYPE_icommon__iso8601Date__ (411)
/* Type icommon__iso8601Date__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'icommon:iso8601Date': */
class SOAP_CMAC icommon__iso8601Date__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'icommon:iso8601Date' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_icommon__iso8601Date__
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__iso8601Date__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__iso8601Date__, default initialized and not managed by a soap context
        virtual icommon__iso8601Date__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__iso8601Date__); }
      public:
        /// Constructor with default initializations
        icommon__iso8601Date__() : __item() { }
        virtual ~icommon__iso8601Date__() { }
        /// Friend allocator used by soap_new_icommon__iso8601Date__(struct soap*, int)
        friend SOAP_FMAC1 icommon__iso8601Date__ * SOAP_FMAC2 soap_instantiate_icommon__iso8601Date__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1631 */
#ifndef SOAP_TYPE_icommon__resourceType_
#define SOAP_TYPE_icommon__resourceType_ (413)
/* Type icommon__resourceType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'icommon:resourceType': */
class SOAP_CMAC icommon__resourceType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'icommon:resourceType' wrapped by this struct
        enum icommon__resourceType __item;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resourceType_
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resourceType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resourceType_, default initialized and not managed by a soap context
        virtual icommon__resourceType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resourceType_); }
      public:
        /// Constructor with default initializations
        icommon__resourceType_() : __item() { }
        virtual ~icommon__resourceType_() { }
        /// Friend allocator used by soap_new_icommon__resourceType_(struct soap*, int)
        friend SOAP_FMAC1 icommon__resourceType_ * SOAP_FMAC2 soap_instantiate_icommon__resourceType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1652 */
#ifndef SOAP_TYPE_icommon__spatialDataServiceType_
#define SOAP_TYPE_icommon__spatialDataServiceType_ (415)
/* Type icommon__spatialDataServiceType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'icommon:spatialDataServiceType': */
class SOAP_CMAC icommon__spatialDataServiceType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'icommon:spatialDataServiceType' wrapped by this struct
        enum icommon__spatialDataServiceType __item;
      public:
        /// Return unique type id SOAP_TYPE_icommon__spatialDataServiceType_
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__spatialDataServiceType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__spatialDataServiceType_, default initialized and not managed by a soap context
        virtual icommon__spatialDataServiceType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__spatialDataServiceType_); }
      public:
        /// Constructor with default initializations
        icommon__spatialDataServiceType_() : __item() { }
        virtual ~icommon__spatialDataServiceType_() { }
        /// Friend allocator used by soap_new_icommon__spatialDataServiceType_(struct soap*, int)
        friend SOAP_FMAC1 icommon__spatialDataServiceType_ * SOAP_FMAC2 soap_instantiate_icommon__spatialDataServiceType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:1670 */
#ifndef SOAP_TYPE_icommon__degreeOfConformity_
#define SOAP_TYPE_icommon__degreeOfConformity_ (417)
/* Type icommon__degreeOfConformity_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'icommon:degreeOfConformity': */
class SOAP_CMAC icommon__degreeOfConformity_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'icommon:degreeOfConformity' wrapped by this struct
        enum icommon__degreeOfConformity __item;
      public:
        /// Return unique type id SOAP_TYPE_icommon__degreeOfConformity_
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__degreeOfConformity_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__degreeOfConformity_, default initialized and not managed by a soap context
        virtual icommon__degreeOfConformity_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__degreeOfConformity_); }
      public:
        /// Constructor with default initializations
        icommon__degreeOfConformity_() : __item() { }
        virtual ~icommon__degreeOfConformity_() { }
        /// Friend allocator used by soap_new_icommon__degreeOfConformity_(struct soap*, int)
        friend SOAP_FMAC1 icommon__degreeOfConformity_ * SOAP_FMAC2 soap_instantiate_icommon__degreeOfConformity_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:2170 */
#ifndef SOAP_TYPE_icommon__languageISO6392B_
#define SOAP_TYPE_icommon__languageISO6392B_ (419)
/* Type icommon__languageISO6392B_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'icommon:languageISO6392B': */
class SOAP_CMAC icommon__languageISO6392B_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'icommon:languageISO6392B' wrapped by this struct
        enum icommon__languageISO6392B __item;
      public:
        /// Return unique type id SOAP_TYPE_icommon__languageISO6392B_
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__languageISO6392B_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__languageISO6392B_, default initialized and not managed by a soap context
        virtual icommon__languageISO6392B_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__languageISO6392B_); }
      public:
        /// Constructor with default initializations
        icommon__languageISO6392B_() : __item() { }
        virtual ~icommon__languageISO6392B_() { }
        /// Friend allocator used by soap_new_icommon__languageISO6392B_(struct soap*, int)
        friend SOAP_FMAC1 icommon__languageISO6392B_ * SOAP_FMAC2 soap_instantiate_icommon__languageISO6392B_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:2182 */
#ifndef SOAP_TYPE_icommon__languageIETF__
#define SOAP_TYPE_icommon__languageIETF__ (421)
/* Type icommon__languageIETF__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'icommon:languageIETF': */
class SOAP_CMAC icommon__languageIETF__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'icommon:languageIETF' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_icommon__languageIETF__
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__languageIETF__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__languageIETF__, default initialized and not managed by a soap context
        virtual icommon__languageIETF__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__languageIETF__); }
      public:
        /// Constructor with default initializations
        icommon__languageIETF__() : __item() { }
        virtual ~icommon__languageIETF__() { }
        /// Friend allocator used by soap_new_icommon__languageIETF__(struct soap*, int)
        friend SOAP_FMAC1 icommon__languageIETF__ * SOAP_FMAC2 soap_instantiate_icommon__languageIETF__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:2252 */
#ifndef SOAP_TYPE_icommon__responsiblePartyRole_
#define SOAP_TYPE_icommon__responsiblePartyRole_ (423)
/* Type icommon__responsiblePartyRole_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'icommon:responsiblePartyRole': */
class SOAP_CMAC icommon__responsiblePartyRole_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'icommon:responsiblePartyRole' wrapped by this struct
        enum icommon__responsiblePartyRole __item;
      public:
        /// Return unique type id SOAP_TYPE_icommon__responsiblePartyRole_
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__responsiblePartyRole_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__responsiblePartyRole_, default initialized and not managed by a soap context
        virtual icommon__responsiblePartyRole_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__responsiblePartyRole_); }
      public:
        /// Constructor with default initializations
        icommon__responsiblePartyRole_() : __item() { }
        virtual ~icommon__responsiblePartyRole_() { }
        /// Friend allocator used by soap_new_icommon__responsiblePartyRole_(struct soap*, int)
        friend SOAP_FMAC1 icommon__responsiblePartyRole_ * SOAP_FMAC2 soap_instantiate_icommon__responsiblePartyRole_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:2269 */
#ifndef SOAP_TYPE_icommon__geoBoxDigits__
#define SOAP_TYPE_icommon__geoBoxDigits__ (425)
/* Type icommon__geoBoxDigits__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'icommon:geoBoxDigits': */
class SOAP_CMAC icommon__geoBoxDigits__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'icommon:geoBoxDigits' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_icommon__geoBoxDigits__
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__geoBoxDigits__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__geoBoxDigits__, default initialized and not managed by a soap context
        virtual icommon__geoBoxDigits__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__geoBoxDigits__); }
      public:
        /// Constructor with default initializations
        icommon__geoBoxDigits__() : __item() { }
        virtual ~icommon__geoBoxDigits__() { }
        /// Friend allocator used by soap_new_icommon__geoBoxDigits__(struct soap*, int)
        friend SOAP_FMAC1 icommon__geoBoxDigits__ * SOAP_FMAC2 soap_instantiate_icommon__geoBoxDigits__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:2333 */
#ifndef SOAP_TYPE_icommon__serviceSpatialDataResourceType_
#define SOAP_TYPE_icommon__serviceSpatialDataResourceType_ (427)
/* Type icommon__serviceSpatialDataResourceType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'icommon:serviceSpatialDataResourceType': */
class SOAP_CMAC icommon__serviceSpatialDataResourceType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'icommon:serviceSpatialDataResourceType' wrapped by this struct
        enum icommon__serviceSpatialDataResourceType __item;
      public:
        /// Return unique type id SOAP_TYPE_icommon__serviceSpatialDataResourceType_
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__serviceSpatialDataResourceType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__serviceSpatialDataResourceType_, default initialized and not managed by a soap context
        virtual icommon__serviceSpatialDataResourceType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__serviceSpatialDataResourceType_); }
      public:
        /// Constructor with default initializations
        icommon__serviceSpatialDataResourceType_() : __item() { }
        virtual ~icommon__serviceSpatialDataResourceType_() { }
        /// Friend allocator used by soap_new_icommon__serviceSpatialDataResourceType_(struct soap*, int)
        friend SOAP_FMAC1 icommon__serviceSpatialDataResourceType_ * SOAP_FMAC2 soap_instantiate_icommon__serviceSpatialDataResourceType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:2349 */
#ifndef SOAP_TYPE_icommon__viewSpatialDataServiceType_
#define SOAP_TYPE_icommon__viewSpatialDataServiceType_ (429)
/* Type icommon__viewSpatialDataServiceType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'icommon:viewSpatialDataServiceType': */
class SOAP_CMAC icommon__viewSpatialDataServiceType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'icommon:viewSpatialDataServiceType' wrapped by this struct
        enum icommon__viewSpatialDataServiceType __item;
      public:
        /// Return unique type id SOAP_TYPE_icommon__viewSpatialDataServiceType_
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__viewSpatialDataServiceType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__viewSpatialDataServiceType_, default initialized and not managed by a soap context
        virtual icommon__viewSpatialDataServiceType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__viewSpatialDataServiceType_); }
      public:
        /// Constructor with default initializations
        icommon__viewSpatialDataServiceType_() : __item() { }
        virtual ~icommon__viewSpatialDataServiceType_() { }
        /// Friend allocator used by soap_new_icommon__viewSpatialDataServiceType_(struct soap*, int)
        friend SOAP_FMAC1 icommon__viewSpatialDataServiceType_ * SOAP_FMAC2 soap_instantiate_icommon__viewSpatialDataServiceType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:2365 */
#ifndef SOAP_TYPE_icommon__discoverySpatialDataServiceType_
#define SOAP_TYPE_icommon__discoverySpatialDataServiceType_ (431)
/* Type icommon__discoverySpatialDataServiceType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'icommon:discoverySpatialDataServiceType': */
class SOAP_CMAC icommon__discoverySpatialDataServiceType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'icommon:discoverySpatialDataServiceType' wrapped by this struct
        enum icommon__discoverySpatialDataServiceType __item;
      public:
        /// Return unique type id SOAP_TYPE_icommon__discoverySpatialDataServiceType_
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__discoverySpatialDataServiceType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__discoverySpatialDataServiceType_, default initialized and not managed by a soap context
        virtual icommon__discoverySpatialDataServiceType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__discoverySpatialDataServiceType_); }
      public:
        /// Constructor with default initializations
        icommon__discoverySpatialDataServiceType_() : __item() { }
        virtual ~icommon__discoverySpatialDataServiceType_() { }
        /// Friend allocator used by soap_new_icommon__discoverySpatialDataServiceType_(struct soap*, int)
        friend SOAP_FMAC1 icommon__discoverySpatialDataServiceType_ * SOAP_FMAC2 soap_instantiate_icommon__discoverySpatialDataServiceType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:2381 */
#ifndef SOAP_TYPE_icommon__transformationSpatialDataServiceType_
#define SOAP_TYPE_icommon__transformationSpatialDataServiceType_ (433)
/* Type icommon__transformationSpatialDataServiceType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'icommon:transformationSpatialDataServiceType': */
class SOAP_CMAC icommon__transformationSpatialDataServiceType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'icommon:transformationSpatialDataServiceType' wrapped by this struct
        enum icommon__transformationSpatialDataServiceType __item;
      public:
        /// Return unique type id SOAP_TYPE_icommon__transformationSpatialDataServiceType_
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__transformationSpatialDataServiceType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__transformationSpatialDataServiceType_, default initialized and not managed by a soap context
        virtual icommon__transformationSpatialDataServiceType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__transformationSpatialDataServiceType_); }
      public:
        /// Constructor with default initializations
        icommon__transformationSpatialDataServiceType_() : __item() { }
        virtual ~icommon__transformationSpatialDataServiceType_() { }
        /// Friend allocator used by soap_new_icommon__transformationSpatialDataServiceType_(struct soap*, int)
        friend SOAP_FMAC1 icommon__transformationSpatialDataServiceType_ * SOAP_FMAC2 soap_instantiate_icommon__transformationSpatialDataServiceType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:2397 */
#ifndef SOAP_TYPE_icommon__invokeSpatialDataServiceType_
#define SOAP_TYPE_icommon__invokeSpatialDataServiceType_ (435)
/* Type icommon__invokeSpatialDataServiceType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'icommon:invokeSpatialDataServiceType': */
class SOAP_CMAC icommon__invokeSpatialDataServiceType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'icommon:invokeSpatialDataServiceType' wrapped by this struct
        enum icommon__invokeSpatialDataServiceType __item;
      public:
        /// Return unique type id SOAP_TYPE_icommon__invokeSpatialDataServiceType_
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__invokeSpatialDataServiceType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__invokeSpatialDataServiceType_, default initialized and not managed by a soap context
        virtual icommon__invokeSpatialDataServiceType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__invokeSpatialDataServiceType_); }
      public:
        /// Constructor with default initializations
        icommon__invokeSpatialDataServiceType_() : __item() { }
        virtual ~icommon__invokeSpatialDataServiceType_() { }
        /// Friend allocator used by soap_new_icommon__invokeSpatialDataServiceType_(struct soap*, int)
        friend SOAP_FMAC1 icommon__invokeSpatialDataServiceType_ * SOAP_FMAC2 soap_instantiate_icommon__invokeSpatialDataServiceType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:2413 */
#ifndef SOAP_TYPE_icommon__otherSpatialDataServiceType_
#define SOAP_TYPE_icommon__otherSpatialDataServiceType_ (437)
/* Type icommon__otherSpatialDataServiceType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'icommon:otherSpatialDataServiceType': */
class SOAP_CMAC icommon__otherSpatialDataServiceType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'icommon:otherSpatialDataServiceType' wrapped by this struct
        enum icommon__otherSpatialDataServiceType __item;
      public:
        /// Return unique type id SOAP_TYPE_icommon__otherSpatialDataServiceType_
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__otherSpatialDataServiceType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__otherSpatialDataServiceType_, default initialized and not managed by a soap context
        virtual icommon__otherSpatialDataServiceType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__otherSpatialDataServiceType_); }
      public:
        /// Constructor with default initializations
        icommon__otherSpatialDataServiceType_() : __item() { }
        virtual ~icommon__otherSpatialDataServiceType_() { }
        /// Friend allocator used by soap_new_icommon__otherSpatialDataServiceType_(struct soap*, int)
        friend SOAP_FMAC1 icommon__otherSpatialDataServiceType_ * SOAP_FMAC2 soap_instantiate_icommon__otherSpatialDataServiceType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:2425 */
#ifndef SOAP_TYPE_icommon__keywordValue__
#define SOAP_TYPE_icommon__keywordValue__ (439)
/* Type icommon__keywordValue__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'icommon:keywordValue': */
class SOAP_CMAC icommon__keywordValue__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'icommon:keywordValue' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_icommon__keywordValue__
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__keywordValue__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__keywordValue__, default initialized and not managed by a soap context
        virtual icommon__keywordValue__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__keywordValue__); }
      public:
        /// Constructor with default initializations
        icommon__keywordValue__() : __item() { }
        virtual ~icommon__keywordValue__() { }
        /// Friend allocator used by soap_new_icommon__keywordValue__(struct soap*, int)
        friend SOAP_FMAC1 icommon__keywordValue__ * SOAP_FMAC2 soap_instantiate_icommon__keywordValue__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:2463 */
#ifndef SOAP_TYPE_icommon__euLanguageISO6392B_
#define SOAP_TYPE_icommon__euLanguageISO6392B_ (441)
/* Type icommon__euLanguageISO6392B_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'icommon:euLanguageISO6392B': */
class SOAP_CMAC icommon__euLanguageISO6392B_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'icommon:euLanguageISO6392B' wrapped by this struct
        enum icommon__euLanguageISO6392B __item;
      public:
        /// Return unique type id SOAP_TYPE_icommon__euLanguageISO6392B_
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__euLanguageISO6392B_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__euLanguageISO6392B_, default initialized and not managed by a soap context
        virtual icommon__euLanguageISO6392B_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__euLanguageISO6392B_); }
      public:
        /// Constructor with default initializations
        icommon__euLanguageISO6392B_() : __item() { }
        virtual ~icommon__euLanguageISO6392B_() { }
        /// Friend allocator used by soap_new_icommon__euLanguageISO6392B_(struct soap*, int)
        friend SOAP_FMAC1 icommon__euLanguageISO6392B_ * SOAP_FMAC2 soap_instantiate_icommon__euLanguageISO6392B_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:2525 */
#ifndef SOAP_TYPE_icommon__euLanguageIETF_
#define SOAP_TYPE_icommon__euLanguageIETF_ (443)
/* Type icommon__euLanguageIETF_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'icommon:euLanguageIETF': */
class SOAP_CMAC icommon__euLanguageIETF_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'icommon:euLanguageIETF' wrapped by this struct
        enum icommon__euLanguageIETF __item;
      public:
        /// Return unique type id SOAP_TYPE_icommon__euLanguageIETF_
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__euLanguageIETF_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__euLanguageIETF_, default initialized and not managed by a soap context
        virtual icommon__euLanguageIETF_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__euLanguageIETF_); }
      public:
        /// Constructor with default initializations
        icommon__euLanguageIETF_() : __item() { }
        virtual ~icommon__euLanguageIETF_() { }
        /// Friend allocator used by soap_new_icommon__euLanguageIETF_(struct soap*, int)
        friend SOAP_FMAC1 icommon__euLanguageIETF_ * SOAP_FMAC2 soap_instantiate_icommon__euLanguageIETF_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:285 */
#ifndef SOAP_TYPE_wfs__BaseRequestType
#define SOAP_TYPE_wfs__BaseRequestType (52)
/* Type wfs__BaseRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'wfs:BaseRequestType': */
class SOAP_CMAC wfs__BaseRequestType : public xsd__anyType {
      public:
        /// Required attribute 'service' of XML schema type 'xsd:string'
        std::string service;	///< initialized with fixed value = "WFS"
        /// Required attribute 'version' of XML schema type 'wfs:VersionStringType'
        std::string version;
        /// Optional attribute 'handle' of XML schema type 'xsd:string'
        std::string *handle;
      public:
        /// Return unique type id SOAP_TYPE_wfs__BaseRequestType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__BaseRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__BaseRequestType, default initialized and not managed by a soap context
        virtual wfs__BaseRequestType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__BaseRequestType); }
      public:
        /// Constructor with default initializations
        wfs__BaseRequestType() : service("WFS"), version(), handle() { }
        virtual ~wfs__BaseRequestType() { }
        /// Friend allocator used by soap_new_wfs__BaseRequestType(struct soap*, int)
        friend SOAP_FMAC1 wfs__BaseRequestType * SOAP_FMAC2 soap_instantiate_wfs__BaseRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:2588 */
#ifndef SOAP_TYPE___wfs__QueryPropertyType_sequence
#define SOAP_TYPE___wfs__QueryPropertyType_sequence (445)
/* Wrapper: */
struct SOAP_CMAC __wfs__QueryPropertyType_sequence {
      public:
        /** Required element 'wfs:Query' of XML schema type 'wfs:QueryType' */
        wfs__QueryType *Query;
      public:
        /** Return unique type id SOAP_TYPE___wfs__QueryPropertyType_sequence */
        long soap_type() const { return SOAP_TYPE___wfs__QueryPropertyType_sequence; }
        /** Constructor with member initializations */
        __wfs__QueryPropertyType_sequence() : Query() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wfs__QueryPropertyType_sequence * SOAP_FMAC2 soap_instantiate___wfs__QueryPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:287 */
#ifndef SOAP_TYPE_wfs__QueryPropertyType
#define SOAP_TYPE_wfs__QueryPropertyType (53)
/* Type wfs__QueryPropertyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:QueryPropertyType': */
class SOAP_CMAC wfs__QueryPropertyType : public xsd__anyType {
      public:
        struct __wfs__QueryPropertyType_sequence *__QueryPropertyType_sequence;
      public:
        /// Return unique type id SOAP_TYPE_wfs__QueryPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__QueryPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__QueryPropertyType, default initialized and not managed by a soap context
        virtual wfs__QueryPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__QueryPropertyType); }
      public:
        /// Constructor with default initializations
        wfs__QueryPropertyType() : __QueryPropertyType_sequence() { }
        virtual ~wfs__QueryPropertyType() { }
        /// Friend allocator used by soap_new_wfs__QueryPropertyType(struct soap*, int)
        friend SOAP_FMAC1 wfs__QueryPropertyType * SOAP_FMAC2 soap_instantiate_wfs__QueryPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:2612 */
#ifndef SOAP_TYPE___wfs__StoredQueryPropertyType_sequence
#define SOAP_TYPE___wfs__StoredQueryPropertyType_sequence (448)
/* Wrapper: */
struct SOAP_CMAC __wfs__StoredQueryPropertyType_sequence {
      public:
        /** Required element 'wfs:StoredQuery' of XML schema type 'wfs:StoredQueryType' */
        wfs__StoredQueryType *StoredQuery;
      public:
        /** Return unique type id SOAP_TYPE___wfs__StoredQueryPropertyType_sequence */
        long soap_type() const { return SOAP_TYPE___wfs__StoredQueryPropertyType_sequence; }
        /** Constructor with member initializations */
        __wfs__StoredQueryPropertyType_sequence() : StoredQuery() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wfs__StoredQueryPropertyType_sequence * SOAP_FMAC2 soap_instantiate___wfs__StoredQueryPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:291 */
#ifndef SOAP_TYPE_wfs__StoredQueryPropertyType
#define SOAP_TYPE_wfs__StoredQueryPropertyType (55)
/* Type wfs__StoredQueryPropertyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:StoredQueryPropertyType': */
class SOAP_CMAC wfs__StoredQueryPropertyType : public xsd__anyType {
      public:
        struct __wfs__StoredQueryPropertyType_sequence *__StoredQueryPropertyType_sequence;
      public:
        /// Return unique type id SOAP_TYPE_wfs__StoredQueryPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__StoredQueryPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__StoredQueryPropertyType, default initialized and not managed by a soap context
        virtual wfs__StoredQueryPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__StoredQueryPropertyType); }
      public:
        /// Constructor with default initializations
        wfs__StoredQueryPropertyType() : __StoredQueryPropertyType_sequence() { }
        virtual ~wfs__StoredQueryPropertyType() { }
        /// Friend allocator used by soap_new_wfs__StoredQueryPropertyType(struct soap*, int)
        friend SOAP_FMAC1 wfs__StoredQueryPropertyType * SOAP_FMAC2 soap_instantiate_wfs__StoredQueryPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:295 */
#ifndef SOAP_TYPE_wfs__ParameterType
#define SOAP_TYPE_wfs__ParameterType (57)
/* Type wfs__ParameterType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:ParameterType': */
class SOAP_CMAC wfs__ParameterType : public xsd__anyType {
      public:
        char *__any;
        /// Required attribute 'name' of XML schema type 'xsd:string'
        std::string name;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_wfs__ParameterType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__ParameterType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__ParameterType, default initialized and not managed by a soap context
        virtual wfs__ParameterType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__ParameterType); }
      public:
        /// Constructor with default initializations
        wfs__ParameterType() : __any(), name(), __mixed() { }
        virtual ~wfs__ParameterType() { }
        /// Friend allocator used by soap_new_wfs__ParameterType(struct soap*, int)
        friend SOAP_FMAC1 wfs__ParameterType * SOAP_FMAC2 soap_instantiate_wfs__ParameterType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:301 */
#ifndef SOAP_TYPE_wfs__FeatureTypeListType
#define SOAP_TYPE_wfs__FeatureTypeListType (60)
/* Type wfs__FeatureTypeListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:FeatureTypeListType': */
class SOAP_CMAC wfs__FeatureTypeListType : public xsd__anyType {
      public:
        /// Required element 'wfs:FeatureType' of XML schema type 'wfs:FeatureTypeType'
        std::vector<wfs__FeatureTypeType *> FeatureType;
      public:
        /// Return unique type id SOAP_TYPE_wfs__FeatureTypeListType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__FeatureTypeListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__FeatureTypeListType, default initialized and not managed by a soap context
        virtual wfs__FeatureTypeListType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__FeatureTypeListType); }
      public:
        /// Constructor with default initializations
        wfs__FeatureTypeListType() : FeatureType() { }
        virtual ~wfs__FeatureTypeListType() { }
        /// Friend allocator used by soap_new_wfs__FeatureTypeListType(struct soap*, int)
        friend SOAP_FMAC1 wfs__FeatureTypeListType * SOAP_FMAC2 soap_instantiate_wfs__FeatureTypeListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:2711 */
#ifndef SOAP_TYPE__wfs__FeatureTypeType_NoCRS
#define SOAP_TYPE__wfs__FeatureTypeType_NoCRS (461)
/* complex XML schema type 'wfs:FeatureTypeType-NoCRS': */
class SOAP_CMAC _wfs__FeatureTypeType_NoCRS {
      public:
        /// Return unique type id SOAP_TYPE__wfs__FeatureTypeType_NoCRS
        virtual long soap_type(void) const { return SOAP_TYPE__wfs__FeatureTypeType_NoCRS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wfs__FeatureTypeType_NoCRS, default initialized and not managed by a soap context
        virtual _wfs__FeatureTypeType_NoCRS *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wfs__FeatureTypeType_NoCRS); }
      public:
        /// Constructor with default initializations
        _wfs__FeatureTypeType_NoCRS() { }
        virtual ~_wfs__FeatureTypeType_NoCRS() { }
        /// Friend allocator used by soap_new__wfs__FeatureTypeType_NoCRS(struct soap*, int)
        friend SOAP_FMAC1 _wfs__FeatureTypeType_NoCRS * SOAP_FMAC2 soap_instantiate__wfs__FeatureTypeType_NoCRS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:303 */
#ifndef SOAP_TYPE_wfs__FeatureTypeType
#define SOAP_TYPE_wfs__FeatureTypeType (61)
/* Type wfs__FeatureTypeType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:FeatureTypeType': */
class SOAP_CMAC wfs__FeatureTypeType : public xsd__anyType {
      public:
        /// Required element 'wfs:Name' of XML schema type 'xsd:QName'
        char *Name;
        /// Optional element 'wfs:Title' of XML schema type 'wfs:Title'
        std::vector<_wfs__Title *> Title;
        /// Optional element 'wfs:Abstract' of XML schema type 'wfs:Abstract'
        std::vector<_wfs__Abstract *> Abstract;
        /// Optional element 'ows:Keywords' of XML schema type 'ows:KeywordsType'
        std::vector<ows__KeywordsType *> ows__Keywords;
        /// Optional element 'wfs:DefaultCRS' of XML schema type 'xsd:anyURI'
        char **DefaultCRS;
        /// Optional element 'wfs:OtherCRS' of XML schema type 'xsd:anyURI'
        std::vector<char *> OtherCRS;
        /// Optional element 'wfs:NoCRS' of XML schema type 'wfs:FeatureTypeType-NoCRS'
        _wfs__FeatureTypeType_NoCRS *NoCRS;
        /// Optional element 'wfs:OutputFormats' of XML schema type 'wfs:OutputFormatListType'
        wfs__OutputFormatListType *OutputFormats;
        /// Optional element 'ows:WGS84BoundingBox' of XML schema type 'ows:WGS84BoundingBoxType'
        std::vector<ows__WGS84BoundingBoxType *> ows__WGS84BoundingBox;
        /// Optional element 'wfs:MetadataURL' of XML schema type 'wfs:MetadataURLType'
        std::vector<wfs__MetadataURLType *> MetadataURL;
        /// Optional element 'wfs:ExtendedDescription' of XML schema type 'wfs:ExtendedDescriptionType'
        wfs__ExtendedDescriptionType *ExtendedDescription;
      public:
        /// Return unique type id SOAP_TYPE_wfs__FeatureTypeType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__FeatureTypeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__FeatureTypeType, default initialized and not managed by a soap context
        virtual wfs__FeatureTypeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__FeatureTypeType); }
      public:
        /// Constructor with default initializations
        wfs__FeatureTypeType() : Name(), Title(), Abstract(), ows__Keywords(), DefaultCRS(), OtherCRS(), NoCRS(), OutputFormats(), ows__WGS84BoundingBox(), MetadataURL(), ExtendedDescription() { }
        virtual ~wfs__FeatureTypeType() { }
        /// Friend allocator used by soap_new_wfs__FeatureTypeType(struct soap*, int)
        friend SOAP_FMAC1 wfs__FeatureTypeType * SOAP_FMAC2 soap_instantiate_wfs__FeatureTypeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:2743 */
#ifndef SOAP_TYPE___wfs__OutputFormatListType_sequence
#define SOAP_TYPE___wfs__OutputFormatListType_sequence (469)
/* Wrapper: */
struct SOAP_CMAC __wfs__OutputFormatListType_sequence {
      public:
        /** Required element 'wfs:Format' of XML schema type 'xsd:string' */
        std::string Format;
      public:
        /** Return unique type id SOAP_TYPE___wfs__OutputFormatListType_sequence */
        long soap_type() const { return SOAP_TYPE___wfs__OutputFormatListType_sequence; }
        /** Constructor with member initializations */
        __wfs__OutputFormatListType_sequence() : Format() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wfs__OutputFormatListType_sequence * SOAP_FMAC2 soap_instantiate___wfs__OutputFormatListType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:305 */
#ifndef SOAP_TYPE_wfs__OutputFormatListType
#define SOAP_TYPE_wfs__OutputFormatListType (62)
/* Type wfs__OutputFormatListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:OutputFormatListType': */
class SOAP_CMAC wfs__OutputFormatListType : public xsd__anyType {
      public:
        std::vector<struct __wfs__OutputFormatListType_sequence> __OutputFormatListType_sequence;
      public:
        /// Return unique type id SOAP_TYPE_wfs__OutputFormatListType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__OutputFormatListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__OutputFormatListType, default initialized and not managed by a soap context
        virtual wfs__OutputFormatListType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__OutputFormatListType); }
      public:
        /// Constructor with default initializations
        wfs__OutputFormatListType() : __OutputFormatListType_sequence() { }
        virtual ~wfs__OutputFormatListType() { }
        /// Friend allocator used by soap_new_wfs__OutputFormatListType(struct soap*, int)
        friend SOAP_FMAC1 wfs__OutputFormatListType * SOAP_FMAC2 soap_instantiate_wfs__OutputFormatListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:307 */
#ifndef SOAP_TYPE_wfs__MetadataURLType
#define SOAP_TYPE_wfs__MetadataURLType (63)
/* Type wfs__MetadataURLType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'wfs:MetadataURLType': */
class SOAP_CMAC wfs__MetadataURLType : public xsd__anyType {
      public:
        /// Optional attribute 'about' of XML schema type 'xsd:anyURI'
        char **about;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType xlink__type;	///< initialized with fixed value = (enum xlink__typeType)0
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_wfs__MetadataURLType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__MetadataURLType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__MetadataURLType, default initialized and not managed by a soap context
        virtual wfs__MetadataURLType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__MetadataURLType); }
      public:
        /// Constructor with default initializations
        wfs__MetadataURLType() : about(), xlink__type((enum xlink__typeType)0), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~wfs__MetadataURLType() { }
        /// Friend allocator used by soap_new_wfs__MetadataURLType(struct soap*, int)
        friend SOAP_FMAC1 wfs__MetadataURLType * SOAP_FMAC2 soap_instantiate_wfs__MetadataURLType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:309 */
#ifndef SOAP_TYPE_wfs__ExtendedDescriptionType
#define SOAP_TYPE_wfs__ExtendedDescriptionType (64)
/* Type wfs__ExtendedDescriptionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:ExtendedDescriptionType': */
class SOAP_CMAC wfs__ExtendedDescriptionType : public xsd__anyType {
      public:
        /// Required element 'wfs:Element' of XML schema type 'wfs:ElementType'
        std::vector<wfs__ElementType *> Element;
      public:
        /// Return unique type id SOAP_TYPE_wfs__ExtendedDescriptionType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__ExtendedDescriptionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__ExtendedDescriptionType, default initialized and not managed by a soap context
        virtual wfs__ExtendedDescriptionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__ExtendedDescriptionType); }
      public:
        /// Constructor with default initializations
        wfs__ExtendedDescriptionType() : Element() { }
        virtual ~wfs__ExtendedDescriptionType() { }
        /// Friend allocator used by soap_new_wfs__ExtendedDescriptionType(struct soap*, int)
        friend SOAP_FMAC1 wfs__ExtendedDescriptionType * SOAP_FMAC2 soap_instantiate_wfs__ExtendedDescriptionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:311 */
#ifndef SOAP_TYPE_wfs__ElementType
#define SOAP_TYPE_wfs__ElementType (65)
/* Type wfs__ElementType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:ElementType': */
class SOAP_CMAC wfs__ElementType : public xsd__anyType {
      public:
        /// Required element 'ows:Metadata' of XML schema type 'ows:MetadataType'
        ows__MetadataType *ows__Metadata;
        /// Required element 'wfs:ValueList' of XML schema type 'wfs:ValueListType'
        wfs__ValueListType *ValueList;
        /// Required attribute 'name' of XML schema type 'xsd:string'
        std::string name;
        /// Required attribute 'type' of XML schema type 'xsd:QName'
        char *type;
      public:
        /// Return unique type id SOAP_TYPE_wfs__ElementType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__ElementType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__ElementType, default initialized and not managed by a soap context
        virtual wfs__ElementType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__ElementType); }
      public:
        /// Constructor with default initializations
        wfs__ElementType() : ows__Metadata(), ValueList(), name(), type() { }
        virtual ~wfs__ElementType() { }
        /// Friend allocator used by soap_new_wfs__ElementType(struct soap*, int)
        friend SOAP_FMAC1 wfs__ElementType * SOAP_FMAC2 soap_instantiate_wfs__ElementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:2847 */
#ifndef SOAP_TYPE___wfs__ValueListType_sequence
#define SOAP_TYPE___wfs__ValueListType_sequence (481)
/* Wrapper: */
struct SOAP_CMAC __wfs__ValueListType_sequence {
      public:
        /** Required element 'wfs:Value' of XML schema type 'xsd:anyType' */
        xsd__anyType *Value;
      public:
        /** Return unique type id SOAP_TYPE___wfs__ValueListType_sequence */
        long soap_type() const { return SOAP_TYPE___wfs__ValueListType_sequence; }
        /** Constructor with member initializations */
        __wfs__ValueListType_sequence() : Value() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wfs__ValueListType_sequence * SOAP_FMAC2 soap_instantiate___wfs__ValueListType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:313 */
#ifndef SOAP_TYPE_wfs__ValueListType
#define SOAP_TYPE_wfs__ValueListType (66)
/* Type wfs__ValueListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:ValueListType': */
class SOAP_CMAC wfs__ValueListType : public xsd__anyType {
      public:
        std::vector<struct __wfs__ValueListType_sequence> __ValueListType_sequence;
      public:
        /// Return unique type id SOAP_TYPE_wfs__ValueListType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__ValueListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__ValueListType, default initialized and not managed by a soap context
        virtual wfs__ValueListType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__ValueListType); }
      public:
        /// Constructor with default initializations
        wfs__ValueListType() : __ValueListType_sequence() { }
        virtual ~wfs__ValueListType() { }
        /// Friend allocator used by soap_new_wfs__ValueListType(struct soap*, int)
        friend SOAP_FMAC1 wfs__ValueListType * SOAP_FMAC2 soap_instantiate_wfs__ValueListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:319 */
#ifndef SOAP_TYPE_wfs__ValueCollectionType
#define SOAP_TYPE_wfs__ValueCollectionType (69)
/* Type wfs__ValueCollectionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:ValueCollectionType': */
class SOAP_CMAC wfs__ValueCollectionType : public xsd__anyType {
      public:
        /// Optional element 'wfs:member' of XML schema type 'wfs:MemberPropertyType'
        std::vector<wfs__MemberPropertyType *> member;
        /// Optional element 'wfs:additionalValues' of XML schema type 'wfs:additionalValues'
        _wfs__additionalValues *additionalValues;
        /// Optional element 'wfs:truncatedResponse' of XML schema type 'wfs:truncatedResponse'
        _wfs__truncatedResponse *truncatedResponse;
        /// Required attribute 'timeStamp' of XML schema type 'xsd:dateTime'
        time_t timeStamp;
        /// Required attribute 'numberMatched' of XML schema type 'wfs:nonNegativeIntegerOrUnknown'
        std::string numberMatched;
        /// Required attribute 'numberReturned' of XML schema type 'xsd:nonNegativeInteger'
        ULONG64 numberReturned;
        /// Optional attribute 'next' of XML schema type 'xsd:anyURI'
        char **next;
        /// Optional attribute 'previous' of XML schema type 'xsd:anyURI'
        char **previous;
      public:
        /// Return unique type id SOAP_TYPE_wfs__ValueCollectionType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__ValueCollectionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__ValueCollectionType, default initialized and not managed by a soap context
        virtual wfs__ValueCollectionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__ValueCollectionType); }
      public:
        /// Constructor with default initializations
        wfs__ValueCollectionType() : member(), additionalValues(), truncatedResponse(), timeStamp(), numberMatched(), numberReturned(), next(), previous() { }
        virtual ~wfs__ValueCollectionType() { }
        /// Friend allocator used by soap_new_wfs__ValueCollectionType(struct soap*, int)
        friend SOAP_FMAC1 wfs__ValueCollectionType * SOAP_FMAC2 soap_instantiate_wfs__ValueCollectionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:2908 */
#ifndef SOAP_TYPE__wfs__union_MemberPropertyType
#define SOAP_TYPE__wfs__union_MemberPropertyType (489)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _wfs__union_MemberPropertyType
{
        #define SOAP_UNION__wfs__union_MemberPropertyType___any	(1)	/**< union variant selector value for member __any */
        char *__any;
        #define SOAP_UNION__wfs__union_MemberPropertyType_Tuple	(2)	/**< union variant selector value for member Tuple */
        wfs__TupleType *Tuple;
        #define SOAP_UNION__wfs__union_MemberPropertyType_SimpleFeatureCollection	(3)	/**< union variant selector value for member SimpleFeatureCollection */
        wfs__SimpleFeatureCollectionType *SimpleFeatureCollection;
        #define SOAP_UNION__wfs__union_MemberPropertyType_FeatureCollection	(4)	/**< union variant selector value for member FeatureCollection */
        wfs__FeatureCollectionType *FeatureCollection;
};
#endif

/* ws-inspire-wfs2.h:321 */
#ifndef SOAP_TYPE_wfs__MemberPropertyType
#define SOAP_TYPE_wfs__MemberPropertyType (70)
/* Type wfs__MemberPropertyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:MemberPropertyType': */
class SOAP_CMAC wfs__MemberPropertyType : public xsd__anyType {
      public:
        /// Union with union _wfs__union_MemberPropertyType variant selector __union_MemberPropertyType set to one of: SOAP_UNION__wfs__union_MemberPropertyType___any SOAP_UNION__wfs__union_MemberPropertyType_Tuple SOAP_UNION__wfs__union_MemberPropertyType_SimpleFeatureCollection SOAP_UNION__wfs__union_MemberPropertyType_FeatureCollection
        int __union_MemberPropertyType;
        union _wfs__union_MemberPropertyType union_MemberPropertyType;
        /// Optional attribute 'state' of XML schema type 'wfs:StateValueType'
        std::string *state;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType xlink__type;	///< initialized with fixed value = (enum xlink__typeType)0
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_wfs__MemberPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__MemberPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__MemberPropertyType, default initialized and not managed by a soap context
        virtual wfs__MemberPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__MemberPropertyType); }
      public:
        /// Constructor with default initializations
        wfs__MemberPropertyType() : __union_MemberPropertyType(), state(), xlink__type((enum xlink__typeType)0), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), __mixed() { }
        virtual ~wfs__MemberPropertyType() { }
        /// Friend allocator used by soap_new_wfs__MemberPropertyType(struct soap*, int)
        friend SOAP_FMAC1 wfs__MemberPropertyType * SOAP_FMAC2 soap_instantiate_wfs__MemberPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:323 */
#ifndef SOAP_TYPE_wfs__TupleType
#define SOAP_TYPE_wfs__TupleType (71)
/* Type wfs__TupleType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:TupleType': */
class SOAP_CMAC wfs__TupleType : public xsd__anyType {
      public:
        /// Required element 'wfs:member' of XML schema type 'wfs:MemberPropertyType'
        std::vector<wfs__MemberPropertyType *> member;
      public:
        /// Return unique type id SOAP_TYPE_wfs__TupleType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__TupleType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__TupleType, default initialized and not managed by a soap context
        virtual wfs__TupleType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__TupleType); }
      public:
        /// Constructor with default initializations
        wfs__TupleType() : member() { }
        virtual ~wfs__TupleType() { }
        /// Friend allocator used by soap_new_wfs__TupleType(struct soap*, int)
        friend SOAP_FMAC1 wfs__TupleType * SOAP_FMAC2 soap_instantiate_wfs__TupleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:331 */
#ifndef SOAP_TYPE_wfs__SimpleFeatureCollectionType
#define SOAP_TYPE_wfs__SimpleFeatureCollectionType (75)
/* Type wfs__SimpleFeatureCollectionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:SimpleFeatureCollectionType': */
class SOAP_CMAC wfs__SimpleFeatureCollectionType : public xsd__anyType {
      public:
        /// Optional element 'wfs:boundedBy' of XML schema type 'wfs:EnvelopePropertyType'
        wfs__EnvelopePropertyType *boundedBy;
        /// Optional element 'wfs:member' of XML schema type 'wfs:MemberPropertyType'
        std::vector<wfs__MemberPropertyType *> member;
      public:
        /// Return unique type id SOAP_TYPE_wfs__SimpleFeatureCollectionType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__SimpleFeatureCollectionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__SimpleFeatureCollectionType, default initialized and not managed by a soap context
        virtual wfs__SimpleFeatureCollectionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__SimpleFeatureCollectionType); }
      public:
        /// Constructor with default initializations
        wfs__SimpleFeatureCollectionType() : boundedBy(), member() { }
        virtual ~wfs__SimpleFeatureCollectionType() { }
        /// Friend allocator used by soap_new_wfs__SimpleFeatureCollectionType(struct soap*, int)
        friend SOAP_FMAC1 wfs__SimpleFeatureCollectionType * SOAP_FMAC2 soap_instantiate_wfs__SimpleFeatureCollectionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:333 */
#ifndef SOAP_TYPE_wfs__EnvelopePropertyType
#define SOAP_TYPE_wfs__EnvelopePropertyType (76)
/* Type wfs__EnvelopePropertyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:EnvelopePropertyType': */
class SOAP_CMAC wfs__EnvelopePropertyType : public xsd__anyType {
      public:
        char *__any;
      public:
        /// Return unique type id SOAP_TYPE_wfs__EnvelopePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__EnvelopePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__EnvelopePropertyType, default initialized and not managed by a soap context
        virtual wfs__EnvelopePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__EnvelopePropertyType); }
      public:
        /// Constructor with default initializations
        wfs__EnvelopePropertyType() : __any() { }
        virtual ~wfs__EnvelopePropertyType() { }
        /// Friend allocator used by soap_new_wfs__EnvelopePropertyType(struct soap*, int)
        friend SOAP_FMAC1 wfs__EnvelopePropertyType * SOAP_FMAC2 soap_instantiate_wfs__EnvelopePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:337 */
#ifndef SOAP_TYPE_wfs__ListStoredQueriesResponseType
#define SOAP_TYPE_wfs__ListStoredQueriesResponseType (78)
/* Type wfs__ListStoredQueriesResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:ListStoredQueriesResponseType': */
class SOAP_CMAC wfs__ListStoredQueriesResponseType : public xsd__anyType {
      public:
        /// Optional element 'wfs:StoredQuery' of XML schema type 'wfs:StoredQueryListItemType'
        std::vector<wfs__StoredQueryListItemType *> StoredQuery;
      public:
        /// Return unique type id SOAP_TYPE_wfs__ListStoredQueriesResponseType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__ListStoredQueriesResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__ListStoredQueriesResponseType, default initialized and not managed by a soap context
        virtual wfs__ListStoredQueriesResponseType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__ListStoredQueriesResponseType); }
      public:
        /// Constructor with default initializations
        wfs__ListStoredQueriesResponseType() : StoredQuery() { }
        virtual ~wfs__ListStoredQueriesResponseType() { }
        /// Friend allocator used by soap_new_wfs__ListStoredQueriesResponseType(struct soap*, int)
        friend SOAP_FMAC1 wfs__ListStoredQueriesResponseType * SOAP_FMAC2 soap_instantiate_wfs__ListStoredQueriesResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:339 */
#ifndef SOAP_TYPE_wfs__StoredQueryListItemType
#define SOAP_TYPE_wfs__StoredQueryListItemType (79)
/* Type wfs__StoredQueryListItemType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:StoredQueryListItemType': */
class SOAP_CMAC wfs__StoredQueryListItemType : public xsd__anyType {
      public:
        /// Optional element 'wfs:Title' of XML schema type 'wfs:Title'
        std::vector<_wfs__Title *> Title;
        /// Required element 'wfs:ReturnFeatureType' of XML schema type 'xsd:QName'
        std::vector<char *> ReturnFeatureType;
        /// Required attribute 'id' of XML schema type 'xsd:anyURI'
        char *id;
      public:
        /// Return unique type id SOAP_TYPE_wfs__StoredQueryListItemType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__StoredQueryListItemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__StoredQueryListItemType, default initialized and not managed by a soap context
        virtual wfs__StoredQueryListItemType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__StoredQueryListItemType); }
      public:
        /// Constructor with default initializations
        wfs__StoredQueryListItemType() : Title(), ReturnFeatureType(), id() { }
        virtual ~wfs__StoredQueryListItemType() { }
        /// Friend allocator used by soap_new_wfs__StoredQueryListItemType(struct soap*, int)
        friend SOAP_FMAC1 wfs__StoredQueryListItemType * SOAP_FMAC2 soap_instantiate_wfs__StoredQueryListItemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:343 */
#ifndef SOAP_TYPE_wfs__DescribeStoredQueriesResponseType
#define SOAP_TYPE_wfs__DescribeStoredQueriesResponseType (81)
/* Type wfs__DescribeStoredQueriesResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:DescribeStoredQueriesResponseType': */
class SOAP_CMAC wfs__DescribeStoredQueriesResponseType : public xsd__anyType {
      public:
        /// Optional element 'wfs:StoredQueryDescription' of XML schema type 'wfs:StoredQueryDescriptionType'
        std::vector<wfs__StoredQueryDescriptionType *> StoredQueryDescription;
      public:
        /// Return unique type id SOAP_TYPE_wfs__DescribeStoredQueriesResponseType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__DescribeStoredQueriesResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__DescribeStoredQueriesResponseType, default initialized and not managed by a soap context
        virtual wfs__DescribeStoredQueriesResponseType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__DescribeStoredQueriesResponseType); }
      public:
        /// Constructor with default initializations
        wfs__DescribeStoredQueriesResponseType() : StoredQueryDescription() { }
        virtual ~wfs__DescribeStoredQueriesResponseType() { }
        /// Friend allocator used by soap_new_wfs__DescribeStoredQueriesResponseType(struct soap*, int)
        friend SOAP_FMAC1 wfs__DescribeStoredQueriesResponseType * SOAP_FMAC2 soap_instantiate_wfs__DescribeStoredQueriesResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:345 */
#ifndef SOAP_TYPE_wfs__StoredQueryDescriptionType
#define SOAP_TYPE_wfs__StoredQueryDescriptionType (82)
/* Type wfs__StoredQueryDescriptionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:StoredQueryDescriptionType': */
class SOAP_CMAC wfs__StoredQueryDescriptionType : public xsd__anyType {
      public:
        /// Optional element 'wfs:Title' of XML schema type 'wfs:Title'
        std::vector<_wfs__Title *> Title;
        /// Optional element 'wfs:Abstract' of XML schema type 'wfs:Abstract'
        std::vector<_wfs__Abstract *> Abstract;
        /// Optional element 'ows:Metadata' of XML schema type 'ows:MetadataType'
        std::vector<ows__MetadataType *> ows__Metadata;
        /// Optional element 'wfs:Parameter' of XML schema type 'wfs:ParameterExpressionType'
        std::vector<wfs__ParameterExpressionType *> Parameter;
        /// Required element 'wfs:QueryExpressionText' of XML schema type 'wfs:QueryExpressionTextType'
        std::vector<wfs__QueryExpressionTextType *> QueryExpressionText;
        /// Required attribute 'id' of XML schema type 'xsd:anyURI'
        char *id;
      public:
        /// Return unique type id SOAP_TYPE_wfs__StoredQueryDescriptionType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__StoredQueryDescriptionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__StoredQueryDescriptionType, default initialized and not managed by a soap context
        virtual wfs__StoredQueryDescriptionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__StoredQueryDescriptionType); }
      public:
        /// Constructor with default initializations
        wfs__StoredQueryDescriptionType() : Title(), Abstract(), ows__Metadata(), Parameter(), QueryExpressionText(), id() { }
        virtual ~wfs__StoredQueryDescriptionType() { }
        /// Friend allocator used by soap_new_wfs__StoredQueryDescriptionType(struct soap*, int)
        friend SOAP_FMAC1 wfs__StoredQueryDescriptionType * SOAP_FMAC2 soap_instantiate_wfs__StoredQueryDescriptionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:349 */
#ifndef SOAP_TYPE_wfs__ParameterExpressionType
#define SOAP_TYPE_wfs__ParameterExpressionType (84)
/* Type wfs__ParameterExpressionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:ParameterExpressionType': */
class SOAP_CMAC wfs__ParameterExpressionType : public xsd__anyType {
      public:
        /// Optional element 'wfs:Title' of XML schema type 'wfs:Title'
        std::vector<_wfs__Title *> Title;
        /// Optional element 'wfs:Abstract' of XML schema type 'wfs:Abstract'
        std::vector<_wfs__Abstract *> Abstract;
        /// Optional element 'ows:Metadata' of XML schema type 'ows:MetadataType'
        std::vector<ows__MetadataType *> ows__Metadata;
        /// Required attribute 'name' of XML schema type 'xsd:string'
        std::string name;
        /// Required attribute 'type' of XML schema type 'xsd:QName'
        char *type;
      public:
        /// Return unique type id SOAP_TYPE_wfs__ParameterExpressionType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__ParameterExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__ParameterExpressionType, default initialized and not managed by a soap context
        virtual wfs__ParameterExpressionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__ParameterExpressionType); }
      public:
        /// Constructor with default initializations
        wfs__ParameterExpressionType() : Title(), Abstract(), ows__Metadata(), name(), type() { }
        virtual ~wfs__ParameterExpressionType() { }
        /// Friend allocator used by soap_new_wfs__ParameterExpressionType(struct soap*, int)
        friend SOAP_FMAC1 wfs__ParameterExpressionType * SOAP_FMAC2 soap_instantiate_wfs__ParameterExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:3155 */
#ifndef SOAP_TYPE__wfs__union_QueryExpressionTextType
#define SOAP_TYPE__wfs__union_QueryExpressionTextType (505)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _wfs__union_QueryExpressionTextType
{
        #define SOAP_UNION__wfs__union_QueryExpressionTextType___any	(1)	/**< union variant selector value for member __any */
        std::vector<char *> *__any;
        #define SOAP_UNION__wfs__union_QueryExpressionTextType_StoredQuery	(2)	/**< union variant selector value for member StoredQuery */
        std::vector<wfs__StoredQueryType *> *StoredQuery;
        #define SOAP_UNION__wfs__union_QueryExpressionTextType_Query	(3)	/**< union variant selector value for member Query */
        std::vector<wfs__QueryType *> *Query;
};
#endif

/* ws-inspire-wfs2.h:351 */
#ifndef SOAP_TYPE_wfs__QueryExpressionTextType
#define SOAP_TYPE_wfs__QueryExpressionTextType (85)
/* Type wfs__QueryExpressionTextType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:QueryExpressionTextType': */
class SOAP_CMAC wfs__QueryExpressionTextType : public xsd__anyType {
      public:
        /// Union with union _wfs__union_QueryExpressionTextType variant selector __union_QueryExpressionTextType set to one of: SOAP_UNION__wfs__union_QueryExpressionTextType___any SOAP_UNION__wfs__union_QueryExpressionTextType_StoredQuery SOAP_UNION__wfs__union_QueryExpressionTextType_Query
        int __union_QueryExpressionTextType;
        union _wfs__union_QueryExpressionTextType union_QueryExpressionTextType;
        /// Required attribute 'returnFeatureTypes' of XML schema type 'xsd:QName'
        char *returnFeatureTypes;
        /// Required attribute 'language' of XML schema type 'xsd:anyURI'
        char *language;
        /// Optional attribute 'isPrivate' of XML schema type 'xsd:boolean'
        bool isPrivate;	///< initialized with default value = (bool)0
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_wfs__QueryExpressionTextType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__QueryExpressionTextType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__QueryExpressionTextType, default initialized and not managed by a soap context
        virtual wfs__QueryExpressionTextType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__QueryExpressionTextType); }
      public:
        /// Constructor with default initializations
        wfs__QueryExpressionTextType() : __union_QueryExpressionTextType(), returnFeatureTypes(), language(), isPrivate((bool)0), __mixed() { }
        virtual ~wfs__QueryExpressionTextType() { }
        /// Friend allocator used by soap_new_wfs__QueryExpressionTextType(struct soap*, int)
        friend SOAP_FMAC1 wfs__QueryExpressionTextType * SOAP_FMAC2 soap_instantiate_wfs__QueryExpressionTextType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:353 */
#ifndef SOAP_TYPE_wfs__ExecutionStatusType
#define SOAP_TYPE_wfs__ExecutionStatusType (86)
/* Type wfs__ExecutionStatusType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'wfs:ExecutionStatusType': */
class SOAP_CMAC wfs__ExecutionStatusType : public xsd__anyType {
      public:
        /// Optional attribute 'status' of XML schema type 'xsd:string'
        std::string status;	///< initialized with fixed value = "OK"
      public:
        /// Return unique type id SOAP_TYPE_wfs__ExecutionStatusType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__ExecutionStatusType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__ExecutionStatusType, default initialized and not managed by a soap context
        virtual wfs__ExecutionStatusType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__ExecutionStatusType); }
      public:
        /// Constructor with default initializations
        wfs__ExecutionStatusType() : status("OK") { }
        virtual ~wfs__ExecutionStatusType() { }
        /// Friend allocator used by soap_new_wfs__ExecutionStatusType(struct soap*, int)
        friend SOAP_FMAC1 wfs__ExecutionStatusType * SOAP_FMAC2 soap_instantiate_wfs__ExecutionStatusType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:359 */
#ifndef SOAP_TYPE_wfs__LockFeatureResponseType
#define SOAP_TYPE_wfs__LockFeatureResponseType (89)
/* Type wfs__LockFeatureResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:LockFeatureResponseType': */
class SOAP_CMAC wfs__LockFeatureResponseType : public xsd__anyType {
      public:
        /// Optional element 'wfs:FeaturesLocked' of XML schema type 'wfs:FeaturesLockedType'
        wfs__FeaturesLockedType *FeaturesLocked;
        /// Optional element 'wfs:FeaturesNotLocked' of XML schema type 'wfs:FeaturesNotLockedType'
        wfs__FeaturesNotLockedType *FeaturesNotLocked;
        /// Optional attribute 'lockId' of XML schema type 'xsd:string'
        std::string *lockId;
      public:
        /// Return unique type id SOAP_TYPE_wfs__LockFeatureResponseType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__LockFeatureResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__LockFeatureResponseType, default initialized and not managed by a soap context
        virtual wfs__LockFeatureResponseType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__LockFeatureResponseType); }
      public:
        /// Constructor with default initializations
        wfs__LockFeatureResponseType() : FeaturesLocked(), FeaturesNotLocked(), lockId() { }
        virtual ~wfs__LockFeatureResponseType() { }
        /// Friend allocator used by soap_new_wfs__LockFeatureResponseType(struct soap*, int)
        friend SOAP_FMAC1 wfs__LockFeatureResponseType * SOAP_FMAC2 soap_instantiate_wfs__LockFeatureResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:3253 */
#ifndef SOAP_TYPE___wfs__FeaturesLockedType_sequence
#define SOAP_TYPE___wfs__FeaturesLockedType_sequence (515)
/* Wrapper: */
struct SOAP_CMAC __wfs__FeaturesLockedType_sequence {
      public:
        /** Required element 'fes:ResourceId' of XML schema type 'fes:ResourceIdType' */
        fes__ResourceIdType *fes__ResourceId;
      public:
        /** Return unique type id SOAP_TYPE___wfs__FeaturesLockedType_sequence */
        long soap_type() const { return SOAP_TYPE___wfs__FeaturesLockedType_sequence; }
        /** Constructor with member initializations */
        __wfs__FeaturesLockedType_sequence() : fes__ResourceId() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wfs__FeaturesLockedType_sequence * SOAP_FMAC2 soap_instantiate___wfs__FeaturesLockedType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:361 */
#ifndef SOAP_TYPE_wfs__FeaturesLockedType
#define SOAP_TYPE_wfs__FeaturesLockedType (90)
/* Type wfs__FeaturesLockedType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:FeaturesLockedType': */
class SOAP_CMAC wfs__FeaturesLockedType : public xsd__anyType {
      public:
        std::vector<struct __wfs__FeaturesLockedType_sequence> __FeaturesLockedType_sequence;
      public:
        /// Return unique type id SOAP_TYPE_wfs__FeaturesLockedType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__FeaturesLockedType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__FeaturesLockedType, default initialized and not managed by a soap context
        virtual wfs__FeaturesLockedType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__FeaturesLockedType); }
      public:
        /// Constructor with default initializations
        wfs__FeaturesLockedType() : __FeaturesLockedType_sequence() { }
        virtual ~wfs__FeaturesLockedType() { }
        /// Friend allocator used by soap_new_wfs__FeaturesLockedType(struct soap*, int)
        friend SOAP_FMAC1 wfs__FeaturesLockedType * SOAP_FMAC2 soap_instantiate_wfs__FeaturesLockedType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:3278 */
#ifndef SOAP_TYPE___wfs__FeaturesNotLockedType_sequence
#define SOAP_TYPE___wfs__FeaturesNotLockedType_sequence (518)
/* Wrapper: */
struct SOAP_CMAC __wfs__FeaturesNotLockedType_sequence {
      public:
        /** Required element 'fes:ResourceId' of XML schema type 'fes:ResourceIdType' */
        fes__ResourceIdType *fes__ResourceId;
      public:
        /** Return unique type id SOAP_TYPE___wfs__FeaturesNotLockedType_sequence */
        long soap_type() const { return SOAP_TYPE___wfs__FeaturesNotLockedType_sequence; }
        /** Constructor with member initializations */
        __wfs__FeaturesNotLockedType_sequence() : fes__ResourceId() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wfs__FeaturesNotLockedType_sequence * SOAP_FMAC2 soap_instantiate___wfs__FeaturesNotLockedType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:363 */
#ifndef SOAP_TYPE_wfs__FeaturesNotLockedType
#define SOAP_TYPE_wfs__FeaturesNotLockedType (91)
/* Type wfs__FeaturesNotLockedType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:FeaturesNotLockedType': */
class SOAP_CMAC wfs__FeaturesNotLockedType : public xsd__anyType {
      public:
        std::vector<struct __wfs__FeaturesNotLockedType_sequence> __FeaturesNotLockedType_sequence;
      public:
        /// Return unique type id SOAP_TYPE_wfs__FeaturesNotLockedType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__FeaturesNotLockedType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__FeaturesNotLockedType, default initialized and not managed by a soap context
        virtual wfs__FeaturesNotLockedType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__FeaturesNotLockedType); }
      public:
        /// Constructor with default initializations
        wfs__FeaturesNotLockedType() : __FeaturesNotLockedType_sequence() { }
        virtual ~wfs__FeaturesNotLockedType() { }
        /// Friend allocator used by soap_new_wfs__FeaturesNotLockedType(struct soap*, int)
        friend SOAP_FMAC1 wfs__FeaturesNotLockedType * SOAP_FMAC2 soap_instantiate_wfs__FeaturesNotLockedType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:367 */
#ifndef SOAP_TYPE_wfs__AbstractTransactionActionType
#define SOAP_TYPE_wfs__AbstractTransactionActionType (93)
/* Type wfs__AbstractTransactionActionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'wfs:AbstractTransactionActionType': */
class SOAP_CMAC wfs__AbstractTransactionActionType : public xsd__anyType {
      public:
        /// Optional attribute 'handle' of XML schema type 'xsd:string'
        std::string *handle;
      public:
        /// Return unique type id SOAP_TYPE_wfs__AbstractTransactionActionType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__AbstractTransactionActionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__AbstractTransactionActionType, default initialized and not managed by a soap context
        virtual wfs__AbstractTransactionActionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__AbstractTransactionActionType); }
      public:
        /// Constructor with default initializations
        wfs__AbstractTransactionActionType() : handle() { }
        virtual ~wfs__AbstractTransactionActionType() { }
        /// Friend allocator used by soap_new_wfs__AbstractTransactionActionType(struct soap*, int)
        friend SOAP_FMAC1 wfs__AbstractTransactionActionType * SOAP_FMAC2 soap_instantiate_wfs__AbstractTransactionActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:3337 */
#ifndef SOAP_TYPE__wfs__PropertyType_ValueReference
#define SOAP_TYPE__wfs__PropertyType_ValueReference (520)
/* simple XML schema type 'wfs:PropertyType-ValueReference': */
class SOAP_CMAC _wfs__PropertyType_ValueReference {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'action' of XML schema type 'wfs:UpdateActionType'
        enum wfs__UpdateActionType action;	///< initialized with default value = (enum wfs__UpdateActionType)0
      public:
        /// Return unique type id SOAP_TYPE__wfs__PropertyType_ValueReference
        virtual long soap_type(void) const { return SOAP_TYPE__wfs__PropertyType_ValueReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wfs__PropertyType_ValueReference, default initialized and not managed by a soap context
        virtual _wfs__PropertyType_ValueReference *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wfs__PropertyType_ValueReference); }
      public:
        /// Constructor with default initializations
        _wfs__PropertyType_ValueReference() : __item(), action((enum wfs__UpdateActionType)0) { }
        virtual ~_wfs__PropertyType_ValueReference() { }
        /// Friend allocator used by soap_new__wfs__PropertyType_ValueReference(struct soap*, int)
        friend SOAP_FMAC1 _wfs__PropertyType_ValueReference * SOAP_FMAC2 soap_instantiate__wfs__PropertyType_ValueReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:373 */
#ifndef SOAP_TYPE_wfs__PropertyType
#define SOAP_TYPE_wfs__PropertyType (96)
/* Type wfs__PropertyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:PropertyType': */
class SOAP_CMAC wfs__PropertyType : public xsd__anyType {
      public:
        /// Required element 'wfs:ValueReference' of XML schema type 'wfs:PropertyType-ValueReference'
        _wfs__PropertyType_ValueReference ValueReference;
        /// Optional element 'wfs:Value' of XML schema type 'xsd:anyType'
        char *Value;
      public:
        /// Return unique type id SOAP_TYPE_wfs__PropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__PropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__PropertyType, default initialized and not managed by a soap context
        virtual wfs__PropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__PropertyType); }
      public:
        /// Constructor with default initializations
        wfs__PropertyType() : ValueReference(), Value() { }
        virtual ~wfs__PropertyType() { }
        /// Friend allocator used by soap_new_wfs__PropertyType(struct soap*, int)
        friend SOAP_FMAC1 wfs__PropertyType * SOAP_FMAC2 soap_instantiate_wfs__PropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:381 */
#ifndef SOAP_TYPE_wfs__TransactionResponseType
#define SOAP_TYPE_wfs__TransactionResponseType (100)
/* Type wfs__TransactionResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:TransactionResponseType': */
class SOAP_CMAC wfs__TransactionResponseType : public xsd__anyType {
      public:
        /// Required element 'wfs:TransactionSummary' of XML schema type 'wfs:TransactionSummaryType'
        wfs__TransactionSummaryType *TransactionSummary;
        /// Optional element 'wfs:InsertResults' of XML schema type 'wfs:ActionResultsType'
        wfs__ActionResultsType *InsertResults;
        /// Optional element 'wfs:UpdateResults' of XML schema type 'wfs:ActionResultsType'
        wfs__ActionResultsType *UpdateResults;
        /// Optional element 'wfs:ReplaceResults' of XML schema type 'wfs:ActionResultsType'
        wfs__ActionResultsType *ReplaceResults;
        /// Required attribute 'version' of XML schema type 'wfs:VersionStringType'
        std::string version;
      public:
        /// Return unique type id SOAP_TYPE_wfs__TransactionResponseType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__TransactionResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__TransactionResponseType, default initialized and not managed by a soap context
        virtual wfs__TransactionResponseType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__TransactionResponseType); }
      public:
        /// Constructor with default initializations
        wfs__TransactionResponseType() : TransactionSummary(), InsertResults(), UpdateResults(), ReplaceResults(), version() { }
        virtual ~wfs__TransactionResponseType() { }
        /// Friend allocator used by soap_new_wfs__TransactionResponseType(struct soap*, int)
        friend SOAP_FMAC1 wfs__TransactionResponseType * SOAP_FMAC2 soap_instantiate_wfs__TransactionResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:383 */
#ifndef SOAP_TYPE_wfs__TransactionSummaryType
#define SOAP_TYPE_wfs__TransactionSummaryType (101)
/* Type wfs__TransactionSummaryType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:TransactionSummaryType': */
class SOAP_CMAC wfs__TransactionSummaryType : public xsd__anyType {
      public:
        /// Optional element 'wfs:totalInserted' of XML schema type 'xsd:nonNegativeInteger'
        ULONG64 *totalInserted;
        /// Optional element 'wfs:totalUpdated' of XML schema type 'xsd:nonNegativeInteger'
        ULONG64 *totalUpdated;
        /// Optional element 'wfs:totalReplaced' of XML schema type 'xsd:nonNegativeInteger'
        ULONG64 *totalReplaced;
        /// Optional element 'wfs:totalDeleted' of XML schema type 'xsd:nonNegativeInteger'
        ULONG64 *totalDeleted;
      public:
        /// Return unique type id SOAP_TYPE_wfs__TransactionSummaryType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__TransactionSummaryType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__TransactionSummaryType, default initialized and not managed by a soap context
        virtual wfs__TransactionSummaryType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__TransactionSummaryType); }
      public:
        /// Constructor with default initializations
        wfs__TransactionSummaryType() : totalInserted(), totalUpdated(), totalReplaced(), totalDeleted() { }
        virtual ~wfs__TransactionSummaryType() { }
        /// Friend allocator used by soap_new_wfs__TransactionSummaryType(struct soap*, int)
        friend SOAP_FMAC1 wfs__TransactionSummaryType * SOAP_FMAC2 soap_instantiate_wfs__TransactionSummaryType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:385 */
#ifndef SOAP_TYPE_wfs__ActionResultsType
#define SOAP_TYPE_wfs__ActionResultsType (102)
/* Type wfs__ActionResultsType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:ActionResultsType': */
class SOAP_CMAC wfs__ActionResultsType : public xsd__anyType {
      public:
        /// Required element 'wfs:Feature' of XML schema type 'wfs:CreatedOrModifiedFeatureType'
        std::vector<wfs__CreatedOrModifiedFeatureType *> Feature;
      public:
        /// Return unique type id SOAP_TYPE_wfs__ActionResultsType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__ActionResultsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__ActionResultsType, default initialized and not managed by a soap context
        virtual wfs__ActionResultsType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__ActionResultsType); }
      public:
        /// Constructor with default initializations
        wfs__ActionResultsType() : Feature() { }
        virtual ~wfs__ActionResultsType() { }
        /// Friend allocator used by soap_new_wfs__ActionResultsType(struct soap*, int)
        friend SOAP_FMAC1 wfs__ActionResultsType * SOAP_FMAC2 soap_instantiate_wfs__ActionResultsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:3437 */
#ifndef SOAP_TYPE___wfs__CreatedOrModifiedFeatureType_sequence
#define SOAP_TYPE___wfs__CreatedOrModifiedFeatureType_sequence (526)
/* Wrapper: */
struct SOAP_CMAC __wfs__CreatedOrModifiedFeatureType_sequence {
      public:
        /** Required element 'fes:ResourceId' of XML schema type 'fes:ResourceIdType' */
        fes__ResourceIdType *fes__ResourceId;
      public:
        /** Return unique type id SOAP_TYPE___wfs__CreatedOrModifiedFeatureType_sequence */
        long soap_type() const { return SOAP_TYPE___wfs__CreatedOrModifiedFeatureType_sequence; }
        /** Constructor with member initializations */
        __wfs__CreatedOrModifiedFeatureType_sequence() : fes__ResourceId() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wfs__CreatedOrModifiedFeatureType_sequence * SOAP_FMAC2 soap_instantiate___wfs__CreatedOrModifiedFeatureType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:387 */
#ifndef SOAP_TYPE_wfs__CreatedOrModifiedFeatureType
#define SOAP_TYPE_wfs__CreatedOrModifiedFeatureType (103)
/* Type wfs__CreatedOrModifiedFeatureType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:CreatedOrModifiedFeatureType': */
class SOAP_CMAC wfs__CreatedOrModifiedFeatureType : public xsd__anyType {
      public:
        std::vector<struct __wfs__CreatedOrModifiedFeatureType_sequence> __CreatedOrModifiedFeatureType_sequence;
        /// Optional attribute 'handle' of XML schema type 'xsd:string'
        std::string *handle;
      public:
        /// Return unique type id SOAP_TYPE_wfs__CreatedOrModifiedFeatureType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__CreatedOrModifiedFeatureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__CreatedOrModifiedFeatureType, default initialized and not managed by a soap context
        virtual wfs__CreatedOrModifiedFeatureType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__CreatedOrModifiedFeatureType); }
      public:
        /// Constructor with default initializations
        wfs__CreatedOrModifiedFeatureType() : __CreatedOrModifiedFeatureType_sequence(), handle() { }
        virtual ~wfs__CreatedOrModifiedFeatureType() { }
        /// Friend allocator used by soap_new_wfs__CreatedOrModifiedFeatureType(struct soap*, int)
        friend SOAP_FMAC1 wfs__CreatedOrModifiedFeatureType * SOAP_FMAC2 soap_instantiate_wfs__CreatedOrModifiedFeatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:389 */
#ifndef SOAP_TYPE_wfs__EmptyType
#define SOAP_TYPE_wfs__EmptyType (104)
/* Type wfs__EmptyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'wfs:EmptyType': */
class SOAP_CMAC wfs__EmptyType : public xsd__anyType {
      public:
        /// Return unique type id SOAP_TYPE_wfs__EmptyType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__EmptyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__EmptyType, default initialized and not managed by a soap context
        virtual wfs__EmptyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__EmptyType); }
      public:
        /// Constructor with default initializations
        wfs__EmptyType() { }
        virtual ~wfs__EmptyType() { }
        /// Friend allocator used by soap_new_wfs__EmptyType(struct soap*, int)
        friend SOAP_FMAC1 wfs__EmptyType * SOAP_FMAC2 soap_instantiate_wfs__EmptyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:3483 */
#ifndef SOAP_TYPE__wfs__union_additionalValues
#define SOAP_TYPE__wfs__union_additionalValues (528)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _wfs__union_additionalValues
{
        #define SOAP_UNION__wfs__union_additionalValues_ValueCollection	(1)	/**< union variant selector value for member ValueCollection */
        wfs__ValueCollectionType *ValueCollection;
        #define SOAP_UNION__wfs__union_additionalValues_SimpleFeatureCollection	(2)	/**< union variant selector value for member SimpleFeatureCollection */
        wfs__SimpleFeatureCollectionType *SimpleFeatureCollection;
        #define SOAP_UNION__wfs__union_additionalValues_FeatureCollection	(3)	/**< union variant selector value for member FeatureCollection */
        wfs__FeatureCollectionType *FeatureCollection;
};
#endif

/* ws-inspire-wfs2.h:395 */
#ifndef SOAP_TYPE__wfs__additionalValues
#define SOAP_TYPE__wfs__additionalValues (107)
/* Choice: */
class SOAP_CMAC _wfs__additionalValues {
      public:
        /// Union with union _wfs__union_additionalValues variant selector __union_additionalValues set to one of: SOAP_UNION__wfs__union_additionalValues_ValueCollection SOAP_UNION__wfs__union_additionalValues_SimpleFeatureCollection SOAP_UNION__wfs__union_additionalValues_FeatureCollection
        int __union_additionalValues;
        union _wfs__union_additionalValues union_additionalValues;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wfs__additionalValues
        virtual long soap_type(void) const { return SOAP_TYPE__wfs__additionalValues; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wfs__additionalValues, default initialized and not managed by a soap context
        virtual _wfs__additionalValues *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wfs__additionalValues); }
      public:
        /// Constructor with default initializations
        _wfs__additionalValues() : __union_additionalValues(), soap() { }
        virtual ~_wfs__additionalValues() { }
        /// Friend allocator used by soap_new__wfs__additionalValues(struct soap*, int)
        friend SOAP_FMAC1 _wfs__additionalValues * SOAP_FMAC2 soap_instantiate__wfs__additionalValues(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:397 */
#ifndef SOAP_TYPE__wfs__truncatedResponse
#define SOAP_TYPE__wfs__truncatedResponse (108)
/* complex XML schema type 'wfs:truncatedResponse': */
class SOAP_CMAC _wfs__truncatedResponse {
      public:
        /// Required element 'ows:ExceptionReport' of XML schema type 'ows:ExceptionReport'
        _ows__ExceptionReport *ows__ExceptionReport;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wfs__truncatedResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wfs__truncatedResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wfs__truncatedResponse, default initialized and not managed by a soap context
        virtual _wfs__truncatedResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wfs__truncatedResponse); }
      public:
        /// Constructor with default initializations
        _wfs__truncatedResponse() : ows__ExceptionReport(), soap() { }
        virtual ~_wfs__truncatedResponse() { }
        /// Friend allocator used by soap_new__wfs__truncatedResponse(struct soap*, int)
        friend SOAP_FMAC1 _wfs__truncatedResponse * SOAP_FMAC2 soap_instantiate__wfs__truncatedResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:3545 */
#ifndef SOAP_TYPE__wfs__union_additionalObjects
#define SOAP_TYPE__wfs__union_additionalObjects (531)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _wfs__union_additionalObjects
{
        #define SOAP_UNION__wfs__union_additionalObjects_ValueCollection	(1)	/**< union variant selector value for member ValueCollection */
        wfs__ValueCollectionType *ValueCollection;
        #define SOAP_UNION__wfs__union_additionalObjects_SimpleFeatureCollection	(2)	/**< union variant selector value for member SimpleFeatureCollection */
        wfs__SimpleFeatureCollectionType *SimpleFeatureCollection;
        #define SOAP_UNION__wfs__union_additionalObjects_FeatureCollection	(3)	/**< union variant selector value for member FeatureCollection */
        wfs__FeatureCollectionType *FeatureCollection;
};
#endif

/* ws-inspire-wfs2.h:401 */
#ifndef SOAP_TYPE__wfs__additionalObjects
#define SOAP_TYPE__wfs__additionalObjects (110)
/* Choice: */
class SOAP_CMAC _wfs__additionalObjects {
      public:
        /// Union with union _wfs__union_additionalObjects variant selector __union_additionalObjects set to one of: SOAP_UNION__wfs__union_additionalObjects_ValueCollection SOAP_UNION__wfs__union_additionalObjects_SimpleFeatureCollection SOAP_UNION__wfs__union_additionalObjects_FeatureCollection
        int __union_additionalObjects;
        union _wfs__union_additionalObjects union_additionalObjects;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wfs__additionalObjects
        virtual long soap_type(void) const { return SOAP_TYPE__wfs__additionalObjects; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wfs__additionalObjects, default initialized and not managed by a soap context
        virtual _wfs__additionalObjects *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wfs__additionalObjects); }
      public:
        /// Constructor with default initializations
        _wfs__additionalObjects() : __union_additionalObjects(), soap() { }
        virtual ~_wfs__additionalObjects() { }
        /// Friend allocator used by soap_new__wfs__additionalObjects(struct soap*, int)
        friend SOAP_FMAC1 _wfs__additionalObjects * SOAP_FMAC2 soap_instantiate__wfs__additionalObjects(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:405 */
#ifndef SOAP_TYPE_util__DescribeFeatureTypeResponseType
#define SOAP_TYPE_util__DescribeFeatureTypeResponseType (112)
/* Type util__DescribeFeatureTypeResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'util:DescribeFeatureTypeResponseType': */
class SOAP_CMAC util__DescribeFeatureTypeResponseType : public xsd__anyType {
      public:
        /// Required element 'xsd:schema' of XML schema type 'xsd:schema'
        char *xsd__schema;
      public:
        /// Return unique type id SOAP_TYPE_util__DescribeFeatureTypeResponseType
        virtual long soap_type(void) const { return SOAP_TYPE_util__DescribeFeatureTypeResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type util__DescribeFeatureTypeResponseType, default initialized and not managed by a soap context
        virtual util__DescribeFeatureTypeResponseType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(util__DescribeFeatureTypeResponseType); }
      public:
        /// Constructor with default initializations
        util__DescribeFeatureTypeResponseType() : xsd__schema() { }
        virtual ~util__DescribeFeatureTypeResponseType() { }
        /// Friend allocator used by soap_new_util__DescribeFeatureTypeResponseType(struct soap*, int)
        friend SOAP_FMAC1 util__DescribeFeatureTypeResponseType * SOAP_FMAC2 soap_instantiate_util__DescribeFeatureTypeResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:407 */
#ifndef SOAP_TYPE_ows__ExceptionType
#define SOAP_TYPE_ows__ExceptionType (113)
/* Type ows__ExceptionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:ExceptionType': */
class SOAP_CMAC ows__ExceptionType : public xsd__anyType {
      public:
        /// Optional element 'ows:ExceptionText' of XML schema type 'xsd:string'
        std::vector<std::string> ExceptionText;
        /// Required attribute 'exceptionCode' of XML schema type 'xsd:string'
        std::string exceptionCode;
        /// Optional attribute 'locator' of XML schema type 'xsd:string'
        std::string *locator;
      public:
        /// Return unique type id SOAP_TYPE_ows__ExceptionType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__ExceptionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__ExceptionType, default initialized and not managed by a soap context
        virtual ows__ExceptionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__ExceptionType); }
      public:
        /// Constructor with default initializations
        ows__ExceptionType() : ExceptionText(), exceptionCode(), locator() { }
        virtual ~ows__ExceptionType() { }
        /// Friend allocator used by soap_new_ows__ExceptionType(struct soap*, int)
        friend SOAP_FMAC1 ows__ExceptionType * SOAP_FMAC2 soap_instantiate_ows__ExceptionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:409 */
#ifndef SOAP_TYPE_ows__GetResourceByIdType
#define SOAP_TYPE_ows__GetResourceByIdType (114)
/* Type ows__GetResourceByIdType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:GetResourceByIdType': */
class SOAP_CMAC ows__GetResourceByIdType : public xsd__anyType {
      public:
        /// Optional element 'ows:ResourceID' of XML schema type 'xsd:anyURI'
        std::vector<char *> ResourceID;
        /// Optional element 'ows:OutputFormat' of XML schema type 'ows:MimeType'
        std::string *OutputFormat;
        /// Required attribute 'service' of XML schema type 'ows:ServiceType'
        std::string service;
        /// Required attribute 'version' of XML schema type 'ows:VersionType'
        std::string version;
      public:
        /// Return unique type id SOAP_TYPE_ows__GetResourceByIdType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__GetResourceByIdType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__GetResourceByIdType, default initialized and not managed by a soap context
        virtual ows__GetResourceByIdType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__GetResourceByIdType); }
      public:
        /// Constructor with default initializations
        ows__GetResourceByIdType() : ResourceID(), OutputFormat(), service(), version() { }
        virtual ~ows__GetResourceByIdType() { }
        /// Friend allocator used by soap_new_ows__GetResourceByIdType(struct soap*, int)
        friend SOAP_FMAC1 ows__GetResourceByIdType * SOAP_FMAC2 soap_instantiate_ows__GetResourceByIdType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:411 */
#ifndef SOAP_TYPE_ows__DescriptionType
#define SOAP_TYPE_ows__DescriptionType (115)
/* complex XML schema type 'ows:DescriptionType': */
class SOAP_CMAC ows__DescriptionType : public xsd__anyType {
      public:
        /// Optional element 'ows:Title' of XML schema type 'ows:LanguageStringType'
        std::vector<ows__LanguageStringType *> Title;
        /// Optional element 'ows:Abstract' of XML schema type 'ows:LanguageStringType'
        std::vector<ows__LanguageStringType *> Abstract;
        /// Optional element 'ows:Keywords' of XML schema type 'ows:KeywordsType'
        std::vector<ows__KeywordsType *> Keywords;
      public:
        /// Return unique type id SOAP_TYPE_ows__DescriptionType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__DescriptionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__DescriptionType, default initialized and not managed by a soap context
        virtual ows__DescriptionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__DescriptionType); }
      public:
        /// Constructor with default initializations
        ows__DescriptionType() : Title(), Abstract(), Keywords() { }
        virtual ~ows__DescriptionType() { }
        /// Friend allocator used by soap_new_ows__DescriptionType(struct soap*, int)
        friend SOAP_FMAC1 ows__DescriptionType * SOAP_FMAC2 soap_instantiate_ows__DescriptionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:3746 */
#ifndef SOAP_TYPE__ows__union_MetadataType
#define SOAP_TYPE__ows__union_MetadataType (536)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ows__union_MetadataType
{
};
#endif

/* ws-inspire-wfs2.h:417 */
#ifndef SOAP_TYPE_ows__MetadataType
#define SOAP_TYPE_ows__MetadataType (118)
/* complex XML schema type 'ows:MetadataType': */
class SOAP_CMAC ows__MetadataType : public xsd__anyType {
      public:
        /// Union with union _ows__union_MetadataType variant selector __unionAbstractMetaData set to one of:
        int __unionAbstractMetaData;
        union _ows__union_MetadataType union_MetadataType;
        /// Optional attribute 'about' of XML schema type 'xsd:anyURI'
        char **about;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType xlink__type;	///< initialized with fixed value = (enum xlink__typeType)0
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_ows__MetadataType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__MetadataType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__MetadataType, default initialized and not managed by a soap context
        virtual ows__MetadataType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__MetadataType); }
      public:
        /// Constructor with default initializations
        ows__MetadataType() : __unionAbstractMetaData(), about(), xlink__type((enum xlink__typeType)0), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~ows__MetadataType() { }
        /// Friend allocator used by soap_new_ows__MetadataType(struct soap*, int)
        friend SOAP_FMAC1 ows__MetadataType * SOAP_FMAC2 soap_instantiate_ows__MetadataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:419 */
#ifndef SOAP_TYPE_ows__BoundingBoxType
#define SOAP_TYPE_ows__BoundingBoxType (119)
/* Type ows__BoundingBoxType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:BoundingBoxType': */
class SOAP_CMAC ows__BoundingBoxType : public xsd__anyType {
      public:
        /// Required element 'ows:LowerCorner' of XML schema type 'ows:PositionType'
        std::string LowerCorner;
        /// Required element 'ows:UpperCorner' of XML schema type 'ows:PositionType'
        std::string UpperCorner;
        /// Optional attribute 'crs' of XML schema type 'xsd:anyURI'
        char **crs;
        /// Optional attribute 'dimensions' of XML schema type 'xsd:positiveInteger'
        ULONG64 *dimensions;
      public:
        /// Return unique type id SOAP_TYPE_ows__BoundingBoxType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__BoundingBoxType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__BoundingBoxType, default initialized and not managed by a soap context
        virtual ows__BoundingBoxType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__BoundingBoxType); }
      public:
        /// Constructor with default initializations
        ows__BoundingBoxType() : LowerCorner(), UpperCorner(), crs(), dimensions() { }
        virtual ~ows__BoundingBoxType() { }
        /// Friend allocator used by soap_new_ows__BoundingBoxType(struct soap*, int)
        friend SOAP_FMAC1 ows__BoundingBoxType * SOAP_FMAC2 soap_instantiate_ows__BoundingBoxType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:425 */
#ifndef SOAP_TYPE_ows__KeywordsType
#define SOAP_TYPE_ows__KeywordsType (122)
/* complex XML schema type 'ows:KeywordsType': */
class SOAP_CMAC ows__KeywordsType : public xsd__anyType {
      public:
        /// Required element 'ows:Keyword' of XML schema type 'ows:LanguageStringType'
        std::vector<ows__LanguageStringType *> Keyword;
        /// Optional element 'ows:Type' of XML schema type 'ows:CodeType'
        ows__CodeType *Type;
      public:
        /// Return unique type id SOAP_TYPE_ows__KeywordsType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__KeywordsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__KeywordsType, default initialized and not managed by a soap context
        virtual ows__KeywordsType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__KeywordsType); }
      public:
        /// Constructor with default initializations
        ows__KeywordsType() : Keyword(), Type() { }
        virtual ~ows__KeywordsType() { }
        /// Friend allocator used by soap_new_ows__KeywordsType(struct soap*, int)
        friend SOAP_FMAC1 ows__KeywordsType * SOAP_FMAC2 soap_instantiate_ows__KeywordsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:429 */
#ifndef SOAP_TYPE_ows__ResponsiblePartyType
#define SOAP_TYPE_ows__ResponsiblePartyType (124)
/* Type ows__ResponsiblePartyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:ResponsiblePartyType': */
class SOAP_CMAC ows__ResponsiblePartyType : public xsd__anyType {
      public:
        /// Optional element 'ows:IndividualName' of XML schema type 'xsd:string'
        std::string *IndividualName;
        /// Optional element 'ows:OrganisationName' of XML schema type 'xsd:string'
        std::string *OrganisationName;
        /// Optional element 'ows:PositionName' of XML schema type 'xsd:string'
        std::string *PositionName;
        /// Optional element 'ows:ContactInfo' of XML schema type 'ows:ContactType'
        ows__ContactType *ContactInfo;
        /// Required element 'ows:Role' of XML schema type 'ows:CodeType'
        ows__CodeType *Role;
      public:
        /// Return unique type id SOAP_TYPE_ows__ResponsiblePartyType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__ResponsiblePartyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__ResponsiblePartyType, default initialized and not managed by a soap context
        virtual ows__ResponsiblePartyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__ResponsiblePartyType); }
      public:
        /// Constructor with default initializations
        ows__ResponsiblePartyType() : IndividualName(), OrganisationName(), PositionName(), ContactInfo(), Role() { }
        virtual ~ows__ResponsiblePartyType() { }
        /// Friend allocator used by soap_new_ows__ResponsiblePartyType(struct soap*, int)
        friend SOAP_FMAC1 ows__ResponsiblePartyType * SOAP_FMAC2 soap_instantiate_ows__ResponsiblePartyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:431 */
#ifndef SOAP_TYPE_ows__ResponsiblePartySubsetType
#define SOAP_TYPE_ows__ResponsiblePartySubsetType (125)
/* Type ows__ResponsiblePartySubsetType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:ResponsiblePartySubsetType': */
class SOAP_CMAC ows__ResponsiblePartySubsetType : public xsd__anyType {
      public:
        /// Optional element 'ows:IndividualName' of XML schema type 'xsd:string'
        std::string *IndividualName;
        /// Optional element 'ows:PositionName' of XML schema type 'xsd:string'
        std::string *PositionName;
        /// Optional element 'ows:ContactInfo' of XML schema type 'ows:ContactType'
        ows__ContactType *ContactInfo;
        /// Optional element 'ows:Role' of XML schema type 'ows:CodeType'
        ows__CodeType *Role;
      public:
        /// Return unique type id SOAP_TYPE_ows__ResponsiblePartySubsetType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__ResponsiblePartySubsetType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__ResponsiblePartySubsetType, default initialized and not managed by a soap context
        virtual ows__ResponsiblePartySubsetType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__ResponsiblePartySubsetType); }
      public:
        /// Constructor with default initializations
        ows__ResponsiblePartySubsetType() : IndividualName(), PositionName(), ContactInfo(), Role() { }
        virtual ~ows__ResponsiblePartySubsetType() { }
        /// Friend allocator used by soap_new_ows__ResponsiblePartySubsetType(struct soap*, int)
        friend SOAP_FMAC1 ows__ResponsiblePartySubsetType * SOAP_FMAC2 soap_instantiate_ows__ResponsiblePartySubsetType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:433 */
#ifndef SOAP_TYPE_ows__ContactType
#define SOAP_TYPE_ows__ContactType (126)
/* Type ows__ContactType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:ContactType': */
class SOAP_CMAC ows__ContactType : public xsd__anyType {
      public:
        /// Optional element 'ows:Phone' of XML schema type 'ows:TelephoneType'
        ows__TelephoneType *Phone;
        /// Optional element 'ows:Address' of XML schema type 'ows:AddressType'
        ows__AddressType *Address;
        /// Optional element 'ows:OnlineResource' of XML schema type 'ows:OnlineResourceType'
        ows__OnlineResourceType *OnlineResource;
        /// Optional element 'ows:HoursOfService' of XML schema type 'xsd:string'
        std::string *HoursOfService;
        /// Optional element 'ows:ContactInstructions' of XML schema type 'xsd:string'
        std::string *ContactInstructions;
      public:
        /// Return unique type id SOAP_TYPE_ows__ContactType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__ContactType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__ContactType, default initialized and not managed by a soap context
        virtual ows__ContactType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__ContactType); }
      public:
        /// Constructor with default initializations
        ows__ContactType() : Phone(), Address(), OnlineResource(), HoursOfService(), ContactInstructions() { }
        virtual ~ows__ContactType() { }
        /// Friend allocator used by soap_new_ows__ContactType(struct soap*, int)
        friend SOAP_FMAC1 ows__ContactType * SOAP_FMAC2 soap_instantiate_ows__ContactType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:435 */
#ifndef SOAP_TYPE_ows__OnlineResourceType
#define SOAP_TYPE_ows__OnlineResourceType (127)
/* Type ows__OnlineResourceType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'ows:OnlineResourceType': */
class SOAP_CMAC ows__OnlineResourceType : public xsd__anyType {
      public:
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType xlink__type;	///< initialized with fixed value = (enum xlink__typeType)0
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_ows__OnlineResourceType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__OnlineResourceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__OnlineResourceType, default initialized and not managed by a soap context
        virtual ows__OnlineResourceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__OnlineResourceType); }
      public:
        /// Constructor with default initializations
        ows__OnlineResourceType() : xlink__type((enum xlink__typeType)0), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~ows__OnlineResourceType() { }
        /// Friend allocator used by soap_new_ows__OnlineResourceType(struct soap*, int)
        friend SOAP_FMAC1 ows__OnlineResourceType * SOAP_FMAC2 soap_instantiate_ows__OnlineResourceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:437 */
#ifndef SOAP_TYPE_ows__TelephoneType
#define SOAP_TYPE_ows__TelephoneType (128)
/* Type ows__TelephoneType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:TelephoneType': */
class SOAP_CMAC ows__TelephoneType : public xsd__anyType {
      public:
        /// Optional element 'ows:Voice' of XML schema type 'xsd:string'
        std::vector<std::string> Voice;
        /// Optional element 'ows:Facsimile' of XML schema type 'xsd:string'
        std::vector<std::string> Facsimile;
      public:
        /// Return unique type id SOAP_TYPE_ows__TelephoneType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__TelephoneType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__TelephoneType, default initialized and not managed by a soap context
        virtual ows__TelephoneType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__TelephoneType); }
      public:
        /// Constructor with default initializations
        ows__TelephoneType() : Voice(), Facsimile() { }
        virtual ~ows__TelephoneType() { }
        /// Friend allocator used by soap_new_ows__TelephoneType(struct soap*, int)
        friend SOAP_FMAC1 ows__TelephoneType * SOAP_FMAC2 soap_instantiate_ows__TelephoneType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:439 */
#ifndef SOAP_TYPE_ows__AddressType
#define SOAP_TYPE_ows__AddressType (129)
/* Type ows__AddressType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:AddressType': */
class SOAP_CMAC ows__AddressType : public xsd__anyType {
      public:
        /// Optional element 'ows:DeliveryPoint' of XML schema type 'xsd:string'
        std::vector<std::string> DeliveryPoint;
        /// Optional element 'ows:City' of XML schema type 'xsd:string'
        std::string *City;
        /// Optional element 'ows:AdministrativeArea' of XML schema type 'xsd:string'
        std::string *AdministrativeArea;
        /// Optional element 'ows:PostalCode' of XML schema type 'xsd:string'
        std::string *PostalCode;
        /// Optional element 'ows:Country' of XML schema type 'xsd:string'
        std::string *Country;
        /// Optional element 'ows:ElectronicMailAddress' of XML schema type 'xsd:string'
        std::vector<std::string> ElectronicMailAddress;
      public:
        /// Return unique type id SOAP_TYPE_ows__AddressType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__AddressType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__AddressType, default initialized and not managed by a soap context
        virtual ows__AddressType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__AddressType); }
      public:
        /// Constructor with default initializations
        ows__AddressType() : DeliveryPoint(), City(), AdministrativeArea(), PostalCode(), Country(), ElectronicMailAddress() { }
        virtual ~ows__AddressType() { }
        /// Friend allocator used by soap_new_ows__AddressType(struct soap*, int)
        friend SOAP_FMAC1 ows__AddressType * SOAP_FMAC2 soap_instantiate_ows__AddressType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:441 */
#ifndef SOAP_TYPE_ows__CapabilitiesBaseType
#define SOAP_TYPE_ows__CapabilitiesBaseType (130)
/* Type ows__CapabilitiesBaseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:CapabilitiesBaseType': */
class SOAP_CMAC ows__CapabilitiesBaseType : public xsd__anyType {
      public:
        /// Optional element 'ows:ServiceIdentification' of XML schema type 'ows:ServiceIdentification'
        _ows__ServiceIdentification *ServiceIdentification;
        /// Optional element 'ows:ServiceProvider' of XML schema type 'ows:ServiceProvider'
        _ows__ServiceProvider *ServiceProvider;
        /// Optional element 'ows:OperationsMetadata' of XML schema type 'ows:OperationsMetadata'
        _ows__OperationsMetadata *OperationsMetadata;
        /// Required attribute 'version' of XML schema type 'ows:VersionType'
        std::string version;
        /// Optional attribute 'updateSequence' of XML schema type 'ows:UpdateSequenceType'
        std::string *updateSequence;
      public:
        /// Return unique type id SOAP_TYPE_ows__CapabilitiesBaseType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__CapabilitiesBaseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__CapabilitiesBaseType, default initialized and not managed by a soap context
        virtual ows__CapabilitiesBaseType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__CapabilitiesBaseType); }
      public:
        /// Constructor with default initializations
        ows__CapabilitiesBaseType() : ServiceIdentification(), ServiceProvider(), OperationsMetadata(), version(), updateSequence() { }
        virtual ~ows__CapabilitiesBaseType() { }
        /// Friend allocator used by soap_new_ows__CapabilitiesBaseType(struct soap*, int)
        friend SOAP_FMAC1 ows__CapabilitiesBaseType * SOAP_FMAC2 soap_instantiate_ows__CapabilitiesBaseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:443 */
#ifndef SOAP_TYPE_ows__GetCapabilitiesType
#define SOAP_TYPE_ows__GetCapabilitiesType (131)
/* Type ows__GetCapabilitiesType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:GetCapabilitiesType': */
class SOAP_CMAC ows__GetCapabilitiesType : public xsd__anyType {
      public:
        /// Optional element 'ows:AcceptVersions' of XML schema type 'ows:AcceptVersionsType'
        ows__AcceptVersionsType *AcceptVersions;
        /// Optional element 'ows:Sections' of XML schema type 'ows:SectionsType'
        ows__SectionsType *Sections;
        /// Optional element 'ows:AcceptFormats' of XML schema type 'ows:AcceptFormatsType'
        ows__AcceptFormatsType *AcceptFormats;
        /// Optional attribute 'updateSequence' of XML schema type 'ows:UpdateSequenceType'
        std::string *updateSequence;
      public:
        /// Return unique type id SOAP_TYPE_ows__GetCapabilitiesType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__GetCapabilitiesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__GetCapabilitiesType, default initialized and not managed by a soap context
        virtual ows__GetCapabilitiesType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__GetCapabilitiesType); }
      public:
        /// Constructor with default initializations
        ows__GetCapabilitiesType() : AcceptVersions(), Sections(), AcceptFormats(), updateSequence() { }
        virtual ~ows__GetCapabilitiesType() { }
        /// Friend allocator used by soap_new_ows__GetCapabilitiesType(struct soap*, int)
        friend SOAP_FMAC1 ows__GetCapabilitiesType * SOAP_FMAC2 soap_instantiate_ows__GetCapabilitiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:445 */
#ifndef SOAP_TYPE_ows__AcceptVersionsType
#define SOAP_TYPE_ows__AcceptVersionsType (132)
/* Type ows__AcceptVersionsType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:AcceptVersionsType': */
class SOAP_CMAC ows__AcceptVersionsType : public xsd__anyType {
      public:
        /// Required element 'ows:Version' of XML schema type 'ows:VersionType'
        std::vector<std::string> Version;
      public:
        /// Return unique type id SOAP_TYPE_ows__AcceptVersionsType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__AcceptVersionsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__AcceptVersionsType, default initialized and not managed by a soap context
        virtual ows__AcceptVersionsType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__AcceptVersionsType); }
      public:
        /// Constructor with default initializations
        ows__AcceptVersionsType() : Version() { }
        virtual ~ows__AcceptVersionsType() { }
        /// Friend allocator used by soap_new_ows__AcceptVersionsType(struct soap*, int)
        friend SOAP_FMAC1 ows__AcceptVersionsType * SOAP_FMAC2 soap_instantiate_ows__AcceptVersionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:447 */
#ifndef SOAP_TYPE_ows__SectionsType
#define SOAP_TYPE_ows__SectionsType (133)
/* Type ows__SectionsType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:SectionsType': */
class SOAP_CMAC ows__SectionsType : public xsd__anyType {
      public:
        /// Optional element 'ows:Section' of XML schema type 'xsd:string'
        std::vector<std::string> Section;
      public:
        /// Return unique type id SOAP_TYPE_ows__SectionsType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__SectionsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__SectionsType, default initialized and not managed by a soap context
        virtual ows__SectionsType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__SectionsType); }
      public:
        /// Constructor with default initializations
        ows__SectionsType() : Section() { }
        virtual ~ows__SectionsType() { }
        /// Friend allocator used by soap_new_ows__SectionsType(struct soap*, int)
        friend SOAP_FMAC1 ows__SectionsType * SOAP_FMAC2 soap_instantiate_ows__SectionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:449 */
#ifndef SOAP_TYPE_ows__AcceptFormatsType
#define SOAP_TYPE_ows__AcceptFormatsType (134)
/* Type ows__AcceptFormatsType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:AcceptFormatsType': */
class SOAP_CMAC ows__AcceptFormatsType : public xsd__anyType {
      public:
        /// Optional element 'ows:OutputFormat' of XML schema type 'ows:MimeType'
        std::vector<std::string> OutputFormat;
      public:
        /// Return unique type id SOAP_TYPE_ows__AcceptFormatsType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__AcceptFormatsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__AcceptFormatsType, default initialized and not managed by a soap context
        virtual ows__AcceptFormatsType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__AcceptFormatsType); }
      public:
        /// Constructor with default initializations
        ows__AcceptFormatsType() : OutputFormat() { }
        virtual ~ows__AcceptFormatsType() { }
        /// Friend allocator used by soap_new_ows__AcceptFormatsType(struct soap*, int)
        friend SOAP_FMAC1 ows__AcceptFormatsType * SOAP_FMAC2 soap_instantiate_ows__AcceptFormatsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:4344 */
#ifndef SOAP_TYPE__ows__union_UnNamedDomainType
#define SOAP_TYPE__ows__union_UnNamedDomainType (552)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ows__union_UnNamedDomainType
{
        #define SOAP_UNION__ows__union_UnNamedDomainType_AllowedValues	(1)	/**< union variant selector value for member AllowedValues */
        _ows__AllowedValues *AllowedValues;
        #define SOAP_UNION__ows__union_UnNamedDomainType_AnyValue	(2)	/**< union variant selector value for member AnyValue */
        _ows__AnyValue *AnyValue;
        #define SOAP_UNION__ows__union_UnNamedDomainType_NoValues	(3)	/**< union variant selector value for member NoValues */
        _ows__NoValues *NoValues;
        #define SOAP_UNION__ows__union_UnNamedDomainType_ValuesReference	(4)	/**< union variant selector value for member ValuesReference */
        _ows__ValuesReference *ValuesReference;
};
#endif

/* ws-inspire-wfs2.h:4410 */
#ifndef SOAP_TYPE__ows__union_UnNamedDomainType_
#define SOAP_TYPE__ows__union_UnNamedDomainType_ (559)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ows__union_UnNamedDomainType_
{
        #define SOAP_UNION__ows__union_UnNamedDomainType__UOM	(1)	/**< union variant selector value for member UOM */
        ows__DomainMetadataType *UOM;
        #define SOAP_UNION__ows__union_UnNamedDomainType__ReferenceSystem	(2)	/**< union variant selector value for member ReferenceSystem */
        ows__DomainMetadataType *ReferenceSystem;
};
#endif

/* ws-inspire-wfs2.h:455 */
#ifndef SOAP_TYPE_ows__UnNamedDomainType
#define SOAP_TYPE_ows__UnNamedDomainType (137)
/* Type ows__UnNamedDomainType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:UnNamedDomainType': */
class SOAP_CMAC ows__UnNamedDomainType : public xsd__anyType {
      public:
        /// Union with union _ows__union_UnNamedDomainType variant selector __union_UnNamedDomainType set to one of: SOAP_UNION__ows__union_UnNamedDomainType_AllowedValues SOAP_UNION__ows__union_UnNamedDomainType_AnyValue SOAP_UNION__ows__union_UnNamedDomainType_NoValues SOAP_UNION__ows__union_UnNamedDomainType_ValuesReference
        int __union_UnNamedDomainType;
        union _ows__union_UnNamedDomainType union_UnNamedDomainType;
        /// Optional element 'ows:DefaultValue' of XML schema type 'ows:ValueType'
        ows__ValueType *DefaultValue;
        /// Optional element 'ows:Meaning' of XML schema type 'ows:DomainMetadataType'
        ows__DomainMetadataType *Meaning;
        /// Optional element 'ows:DataType' of XML schema type 'ows:DomainMetadataType'
        ows__DomainMetadataType *DataType;
        /// Union with union _ows__union_UnNamedDomainType_ variant selector __union_UnNamedDomainType_ set to one of: SOAP_UNION__ows__union_UnNamedDomainType__UOM SOAP_UNION__ows__union_UnNamedDomainType__ReferenceSystem
        int __union_UnNamedDomainType_;
        union _ows__union_UnNamedDomainType_ union_UnNamedDomainType_;
        /// Optional element 'ows:Metadata' of XML schema type 'ows:MetadataType'
        std::vector<ows__MetadataType *> Metadata;
      public:
        /// Return unique type id SOAP_TYPE_ows__UnNamedDomainType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__UnNamedDomainType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__UnNamedDomainType, default initialized and not managed by a soap context
        virtual ows__UnNamedDomainType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__UnNamedDomainType); }
      public:
        /// Constructor with default initializations
        ows__UnNamedDomainType() : __union_UnNamedDomainType(), DefaultValue(), Meaning(), DataType(), __union_UnNamedDomainType_(), Metadata() { }
        virtual ~ows__UnNamedDomainType() { }
        /// Friend allocator used by soap_new_ows__UnNamedDomainType(struct soap*, int)
        friend SOAP_FMAC1 ows__UnNamedDomainType * SOAP_FMAC2 soap_instantiate_ows__UnNamedDomainType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:459 */
#ifndef SOAP_TYPE_ows__RangeType
#define SOAP_TYPE_ows__RangeType (139)
/* Type ows__RangeType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:RangeType': */
class SOAP_CMAC ows__RangeType : public xsd__anyType {
      public:
        /// Optional element 'ows:MinimumValue' of XML schema type 'ows:ValueType'
        ows__ValueType *MinimumValue;
        /// Optional element 'ows:MaximumValue' of XML schema type 'ows:ValueType'
        ows__ValueType *MaximumValue;
        /// Optional element 'ows:Spacing' of XML schema type 'ows:ValueType'
        ows__ValueType *Spacing;
        /// Optional attribute 'ows:rangeClosure' of XML schema type 'ows:rangeClosure'
        enum _ows__rangeClosure ows__rangeClosure;
      public:
        /// Return unique type id SOAP_TYPE_ows__RangeType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__RangeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__RangeType, default initialized and not managed by a soap context
        virtual ows__RangeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__RangeType); }
      public:
        /// Constructor with default initializations
        ows__RangeType() : MinimumValue(), MaximumValue(), Spacing(), ows__rangeClosure() { }
        virtual ~ows__RangeType() { }
        /// Friend allocator used by soap_new_ows__RangeType(struct soap*, int)
        friend SOAP_FMAC1 ows__RangeType * SOAP_FMAC2 soap_instantiate_ows__RangeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:463 */
#ifndef SOAP_TYPE_ows__ContentsBaseType
#define SOAP_TYPE_ows__ContentsBaseType (141)
/* Type ows__ContentsBaseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:ContentsBaseType': */
class SOAP_CMAC ows__ContentsBaseType : public xsd__anyType {
      public:
        /// Optional element 'ows:DatasetDescriptionSummary' of XML schema type 'ows:DatasetDescriptionSummaryBaseType'
        std::vector<ows__DatasetDescriptionSummaryBaseType *> DatasetDescriptionSummary;
        /// Optional element 'ows:OtherSource' of XML schema type 'ows:MetadataType'
        std::vector<ows__MetadataType *> OtherSource;
      public:
        /// Return unique type id SOAP_TYPE_ows__ContentsBaseType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__ContentsBaseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__ContentsBaseType, default initialized and not managed by a soap context
        virtual ows__ContentsBaseType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__ContentsBaseType); }
      public:
        /// Constructor with default initializations
        ows__ContentsBaseType() : DatasetDescriptionSummary(), OtherSource() { }
        virtual ~ows__ContentsBaseType() { }
        /// Friend allocator used by soap_new_ows__ContentsBaseType(struct soap*, int)
        friend SOAP_FMAC1 ows__ContentsBaseType * SOAP_FMAC2 soap_instantiate_ows__ContentsBaseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:469 */
#ifndef SOAP_TYPE_ows__AbstractReferenceBaseType
#define SOAP_TYPE_ows__AbstractReferenceBaseType (144)
/* simple XML schema type 'ows:AbstractReferenceBaseType': */
class SOAP_CMAC ows__AbstractReferenceBaseType : public xsd__anyType {
      public:
        /// Optional attribute 'ows:type' of XML schema type 'xsd:string'
        std::string ows__type;	///< initialized with fixed value = "simple"
        /// Required attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char *xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_ows__AbstractReferenceBaseType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__AbstractReferenceBaseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__AbstractReferenceBaseType, default initialized and not managed by a soap context
        virtual ows__AbstractReferenceBaseType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__AbstractReferenceBaseType); }
      public:
        /// Constructor with default initializations
        ows__AbstractReferenceBaseType() : ows__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~ows__AbstractReferenceBaseType() { }
        /// Friend allocator used by soap_new_ows__AbstractReferenceBaseType(struct soap*, int)
        friend SOAP_FMAC1 ows__AbstractReferenceBaseType * SOAP_FMAC2 soap_instantiate_ows__AbstractReferenceBaseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:477 */
#ifndef SOAP_TYPE__ows__ExceptionReport
#define SOAP_TYPE__ows__ExceptionReport (148)
/* complex XML schema type 'ows:ExceptionReport': */
class SOAP_CMAC _ows__ExceptionReport {
      public:
        /// Required element 'ows:Exception' of XML schema type 'ows:ExceptionType'
        std::vector<ows__ExceptionType *> Exception;
        /// Required attribute 'version' of XML schema type 'xsd:string'
        std::string version;
        /// Optional attribute 'xml:lang' of XML schema type 'xml:lang'
        char **xml__lang;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ows__ExceptionReport
        virtual long soap_type(void) const { return SOAP_TYPE__ows__ExceptionReport; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ows__ExceptionReport, default initialized and not managed by a soap context
        virtual _ows__ExceptionReport *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ows__ExceptionReport); }
      public:
        /// Constructor with default initializations
        _ows__ExceptionReport() : Exception(), version(), xml__lang(), soap() { }
        virtual ~_ows__ExceptionReport() { }
        /// Friend allocator used by soap_new__ows__ExceptionReport(struct soap*, int)
        friend SOAP_FMAC1 _ows__ExceptionReport * SOAP_FMAC2 soap_instantiate__ows__ExceptionReport(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:484 */
#ifndef SOAP_TYPE__ows__ServiceProvider
#define SOAP_TYPE__ows__ServiceProvider (151)
/* complex XML schema type 'ows:ServiceProvider': */
class SOAP_CMAC _ows__ServiceProvider {
      public:
        /// Required element 'ows:ProviderName' of XML schema type 'xsd:string'
        std::string ProviderName;
        /// Optional element 'ows:ProviderSite' of XML schema type 'ows:OnlineResourceType'
        ows__OnlineResourceType *ProviderSite;
        /// Required element 'ows:ServiceContact' of XML schema type 'ows:ResponsiblePartySubsetType'
        ows__ResponsiblePartySubsetType *ServiceContact;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ows__ServiceProvider
        virtual long soap_type(void) const { return SOAP_TYPE__ows__ServiceProvider; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ows__ServiceProvider, default initialized and not managed by a soap context
        virtual _ows__ServiceProvider *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ows__ServiceProvider); }
      public:
        /// Constructor with default initializations
        _ows__ServiceProvider() : ProviderName(), ProviderSite(), ServiceContact(), soap() { }
        virtual ~_ows__ServiceProvider() { }
        /// Friend allocator used by soap_new__ows__ServiceProvider(struct soap*, int)
        friend SOAP_FMAC1 _ows__ServiceProvider * SOAP_FMAC2 soap_instantiate__ows__ServiceProvider(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:486 */
#ifndef SOAP_TYPE__ows__OperationsMetadata
#define SOAP_TYPE__ows__OperationsMetadata (152)
/* complex XML schema type 'ows:OperationsMetadata': */
class SOAP_CMAC _ows__OperationsMetadata {
      public:
        /// Required element 'ows:Operation' of XML schema type 'ows:Operation'
        std::vector<_ows__Operation *> Operation;
        /// Optional element 'ows:Parameter' of XML schema type 'ows:DomainType'
        std::vector<ows__DomainType *> Parameter;
        /// Optional element 'ows:Constraint' of XML schema type 'ows:DomainType'
        std::vector<ows__DomainType *> Constraint;
        /// Optional element 'ows:ExtendedCapabilities' of XML schema type 'idls:ExtendedCapabilitiesType'
        idls__ExtendedCapabilitiesType *ExtendedCapabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ows__OperationsMetadata
        virtual long soap_type(void) const { return SOAP_TYPE__ows__OperationsMetadata; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ows__OperationsMetadata, default initialized and not managed by a soap context
        virtual _ows__OperationsMetadata *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ows__OperationsMetadata); }
      public:
        /// Constructor with default initializations
        _ows__OperationsMetadata() : Operation(), Parameter(), Constraint(), ExtendedCapabilities(), soap() { }
        virtual ~_ows__OperationsMetadata() { }
        /// Friend allocator used by soap_new__ows__OperationsMetadata(struct soap*, int)
        friend SOAP_FMAC1 _ows__OperationsMetadata * SOAP_FMAC2 soap_instantiate__ows__OperationsMetadata(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:488 */
#ifndef SOAP_TYPE__ows__Operation
#define SOAP_TYPE__ows__Operation (153)
/* complex XML schema type 'ows:Operation': */
class SOAP_CMAC _ows__Operation {
      public:
        /// Required element 'ows:DCP' of XML schema type 'ows:DCP'
        std::vector<_ows__DCP *> DCP;
        /// Optional element 'ows:Parameter' of XML schema type 'ows:DomainType'
        std::vector<ows__DomainType *> Parameter;
        /// Optional element 'ows:Constraint' of XML schema type 'ows:DomainType'
        std::vector<ows__DomainType *> Constraint;
        /// Optional element 'ows:Metadata' of XML schema type 'ows:MetadataType'
        std::vector<ows__MetadataType *> Metadata;
        /// Required attribute 'name' of XML schema type 'xsd:string'
        std::string name;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ows__Operation
        virtual long soap_type(void) const { return SOAP_TYPE__ows__Operation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ows__Operation, default initialized and not managed by a soap context
        virtual _ows__Operation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ows__Operation); }
      public:
        /// Constructor with default initializations
        _ows__Operation() : DCP(), Parameter(), Constraint(), Metadata(), name(), soap() { }
        virtual ~_ows__Operation() { }
        /// Friend allocator used by soap_new__ows__Operation(struct soap*, int)
        friend SOAP_FMAC1 _ows__Operation * SOAP_FMAC2 soap_instantiate__ows__Operation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:4818 */
#ifndef SOAP_TYPE__ows__union_DCP
#define SOAP_TYPE__ows__union_DCP (573)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ows__union_DCP
{
        #define SOAP_UNION__ows__union_DCP_HTTP	(1)	/**< union variant selector value for member HTTP */
        _ows__HTTP *HTTP;
};
#endif

/* ws-inspire-wfs2.h:490 */
#ifndef SOAP_TYPE__ows__DCP
#define SOAP_TYPE__ows__DCP (154)
/* Choice: */
class SOAP_CMAC _ows__DCP {
      public:
        /// Union with union _ows__union_DCP variant selector __union_DCP set to one of: SOAP_UNION__ows__union_DCP_HTTP
        int __union_DCP;
        union _ows__union_DCP union_DCP;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ows__DCP
        virtual long soap_type(void) const { return SOAP_TYPE__ows__DCP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ows__DCP, default initialized and not managed by a soap context
        virtual _ows__DCP *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ows__DCP); }
      public:
        /// Constructor with default initializations
        _ows__DCP() : __union_DCP(), soap() { }
        virtual ~_ows__DCP() { }
        /// Friend allocator used by soap_new__ows__DCP(struct soap*, int)
        friend SOAP_FMAC1 _ows__DCP * SOAP_FMAC2 soap_instantiate__ows__DCP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:4858 */
#ifndef SOAP_TYPE__ows__union_HTTP
#define SOAP_TYPE__ows__union_HTTP (576)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ows__union_HTTP
{
        #define SOAP_UNION__ows__union_HTTP_Get	(1)	/**< union variant selector value for member Get */
        ows__RequestMethodType *Get;
        #define SOAP_UNION__ows__union_HTTP_Post	(2)	/**< union variant selector value for member Post */
        ows__RequestMethodType *Post;
};
#endif

/* ws-inspire-wfs2.h:4853 */
#ifndef SOAP_TYPE___ows__union_HTTP
#define SOAP_TYPE___ows__union_HTTP (575)
/* Wrapper: */
class SOAP_CMAC __ows__union_HTTP {
      public:
        /// Union with union _ows__union_HTTP variant selector __union_HTTP set to one of: SOAP_UNION__ows__union_HTTP_Get SOAP_UNION__ows__union_HTTP_Post
        int __union_HTTP;
        union _ows__union_HTTP union_HTTP;
      public:
        /// Return unique type id SOAP_TYPE___ows__union_HTTP
        virtual long soap_type(void) const { return SOAP_TYPE___ows__union_HTTP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __ows__union_HTTP, default initialized and not managed by a soap context
        virtual __ows__union_HTTP *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__ows__union_HTTP); }
      public:
        /// Constructor with default initializations
        __ows__union_HTTP() : __union_HTTP() { }
        virtual ~__ows__union_HTTP() { }
        /// Friend allocator used by soap_new___ows__union_HTTP(struct soap*, int)
        friend SOAP_FMAC1 __ows__union_HTTP * SOAP_FMAC2 soap_instantiate___ows__union_HTTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:492 */
#ifndef SOAP_TYPE__ows__HTTP
#define SOAP_TYPE__ows__HTTP (155)
/* complex XML schema type 'ows:HTTP': */
class SOAP_CMAC _ows__HTTP {
      public:
        std::vector<__ows__union_HTTP> __union_HTTP;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ows__HTTP
        virtual long soap_type(void) const { return SOAP_TYPE__ows__HTTP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ows__HTTP, default initialized and not managed by a soap context
        virtual _ows__HTTP *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ows__HTTP); }
      public:
        /// Constructor with default initializations
        _ows__HTTP() : __union_HTTP(), soap() { }
        virtual ~_ows__HTTP() { }
        /// Friend allocator used by soap_new__ows__HTTP(struct soap*, int)
        friend SOAP_FMAC1 _ows__HTTP * SOAP_FMAC2 soap_instantiate__ows__HTTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:494 */
#ifndef SOAP_TYPE__ows__AnyValue
#define SOAP_TYPE__ows__AnyValue (156)
/* complex XML schema type 'ows:AnyValue': */
class SOAP_CMAC _ows__AnyValue {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ows__AnyValue
        virtual long soap_type(void) const { return SOAP_TYPE__ows__AnyValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ows__AnyValue, default initialized and not managed by a soap context
        virtual _ows__AnyValue *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ows__AnyValue); }
      public:
        /// Constructor with default initializations
        _ows__AnyValue() : soap() { }
        virtual ~_ows__AnyValue() { }
        /// Friend allocator used by soap_new__ows__AnyValue(struct soap*, int)
        friend SOAP_FMAC1 _ows__AnyValue * SOAP_FMAC2 soap_instantiate__ows__AnyValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:496 */
#ifndef SOAP_TYPE__ows__NoValues
#define SOAP_TYPE__ows__NoValues (157)
/* complex XML schema type 'ows:NoValues': */
class SOAP_CMAC _ows__NoValues {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ows__NoValues
        virtual long soap_type(void) const { return SOAP_TYPE__ows__NoValues; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ows__NoValues, default initialized and not managed by a soap context
        virtual _ows__NoValues *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ows__NoValues); }
      public:
        /// Constructor with default initializations
        _ows__NoValues() : soap() { }
        virtual ~_ows__NoValues() { }
        /// Friend allocator used by soap_new__ows__NoValues(struct soap*, int)
        friend SOAP_FMAC1 _ows__NoValues * SOAP_FMAC2 soap_instantiate__ows__NoValues(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:4953 */
#ifndef SOAP_TYPE__ows__union_AllowedValues
#define SOAP_TYPE__ows__union_AllowedValues (580)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ows__union_AllowedValues
{
        #define SOAP_UNION__ows__union_AllowedValues_Value	(1)	/**< union variant selector value for member Value */
        ows__ValueType *Value;
        #define SOAP_UNION__ows__union_AllowedValues_Range	(2)	/**< union variant selector value for member Range */
        ows__RangeType *Range;
};
#endif

/* ws-inspire-wfs2.h:4948 */
#ifndef SOAP_TYPE___ows__union_AllowedValues
#define SOAP_TYPE___ows__union_AllowedValues (579)
/* Wrapper: */
class SOAP_CMAC __ows__union_AllowedValues {
      public:
        /// Union with union _ows__union_AllowedValues variant selector __union_AllowedValues set to one of: SOAP_UNION__ows__union_AllowedValues_Value SOAP_UNION__ows__union_AllowedValues_Range
        int __union_AllowedValues;
        union _ows__union_AllowedValues union_AllowedValues;
      public:
        /// Return unique type id SOAP_TYPE___ows__union_AllowedValues
        virtual long soap_type(void) const { return SOAP_TYPE___ows__union_AllowedValues; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __ows__union_AllowedValues, default initialized and not managed by a soap context
        virtual __ows__union_AllowedValues *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__ows__union_AllowedValues); }
      public:
        /// Constructor with default initializations
        __ows__union_AllowedValues() : __union_AllowedValues() { }
        virtual ~__ows__union_AllowedValues() { }
        /// Friend allocator used by soap_new___ows__union_AllowedValues(struct soap*, int)
        friend SOAP_FMAC1 __ows__union_AllowedValues * SOAP_FMAC2 soap_instantiate___ows__union_AllowedValues(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:500 */
#ifndef SOAP_TYPE__ows__AllowedValues
#define SOAP_TYPE__ows__AllowedValues (159)
/* complex XML schema type 'ows:AllowedValues': */
class SOAP_CMAC _ows__AllowedValues {
      public:
        std::vector<__ows__union_AllowedValues> __union_AllowedValues;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ows__AllowedValues
        virtual long soap_type(void) const { return SOAP_TYPE__ows__AllowedValues; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ows__AllowedValues, default initialized and not managed by a soap context
        virtual _ows__AllowedValues *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ows__AllowedValues); }
      public:
        /// Constructor with default initializations
        _ows__AllowedValues() : __union_AllowedValues(), soap() { }
        virtual ~_ows__AllowedValues() { }
        /// Friend allocator used by soap_new__ows__AllowedValues(struct soap*, int)
        friend SOAP_FMAC1 _ows__AllowedValues * SOAP_FMAC2 soap_instantiate__ows__AllowedValues(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:504 */
#ifndef SOAP_TYPE_xlink__simple
#define SOAP_TYPE_xlink__simple (161)
/* Type xlink__simple is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'xlink:simple': */
class SOAP_CMAC xlink__simple : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType xlink__type;	///< initialized with fixed value = (enum xlink__typeType)0
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_xlink__simple
        virtual long soap_type(void) const { return SOAP_TYPE_xlink__simple; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__simple, default initialized and not managed by a soap context
        virtual xlink__simple *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__simple); }
      public:
        /// Constructor with default initializations
        xlink__simple() : __any(), xlink__type((enum xlink__typeType)0), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), __mixed() { }
        virtual ~xlink__simple() { }
        /// Friend allocator used by soap_new_xlink__simple(struct soap*, int)
        friend SOAP_FMAC1 xlink__simple * SOAP_FMAC2 soap_instantiate_xlink__simple(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:5064 */
#ifndef SOAP_TYPE__xlink__union_extended
#define SOAP_TYPE__xlink__union_extended (584)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _xlink__union_extended
{
};
#endif

/* ws-inspire-wfs2.h:5060 */
#ifndef SOAP_TYPE___xlink__union_extended
#define SOAP_TYPE___xlink__union_extended (583)
/* Wrapper: */
class SOAP_CMAC __xlink__union_extended {
      public:
        /// Union with union _xlink__union_extended variant selector __union_extended set to one of:
        int __union_extended;
        union _xlink__union_extended union_extended;
      public:
        /// Return unique type id SOAP_TYPE___xlink__union_extended
        virtual long soap_type(void) const { return SOAP_TYPE___xlink__union_extended; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __xlink__union_extended, default initialized and not managed by a soap context
        virtual __xlink__union_extended *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__xlink__union_extended); }
      public:
        /// Constructor with default initializations
        __xlink__union_extended() : __union_extended() { }
        virtual ~__xlink__union_extended() { }
        /// Friend allocator used by soap_new___xlink__union_extended(struct soap*, int)
        friend SOAP_FMAC1 __xlink__union_extended * SOAP_FMAC2 soap_instantiate___xlink__union_extended(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:506 */
#ifndef SOAP_TYPE_xlink__extended
#define SOAP_TYPE_xlink__extended (162)
/* Type xlink__extended is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'xlink:extended': */
class SOAP_CMAC xlink__extended : public xsd__anyType {
      public:
        std::vector<__xlink__union_extended> __union_extended;
        /// Required attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType xlink__type;	///< initialized with fixed value = (enum xlink__typeType)1
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
      public:
        /// Return unique type id SOAP_TYPE_xlink__extended
        virtual long soap_type(void) const { return SOAP_TYPE_xlink__extended; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__extended, default initialized and not managed by a soap context
        virtual xlink__extended *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__extended); }
      public:
        /// Constructor with default initializations
        xlink__extended() : __union_extended(), xlink__type((enum xlink__typeType)1), xlink__role(), xlink__title() { }
        virtual ~xlink__extended() { }
        /// Friend allocator used by soap_new_xlink__extended(struct soap*, int)
        friend SOAP_FMAC1 xlink__extended * SOAP_FMAC2 soap_instantiate_xlink__extended(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:508 */
#ifndef SOAP_TYPE_xlink__titleEltType
#define SOAP_TYPE_xlink__titleEltType (163)
/* Type xlink__titleEltType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'xlink:titleEltType': */
class SOAP_CMAC xlink__titleEltType : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Required attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType xlink__type;	///< initialized with fixed value = (enum xlink__typeType)2
        /// Optional attribute 'xml:lang' of XML schema type 'xml:lang'
        char **xml__lang;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_xlink__titleEltType
        virtual long soap_type(void) const { return SOAP_TYPE_xlink__titleEltType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__titleEltType, default initialized and not managed by a soap context
        virtual xlink__titleEltType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__titleEltType); }
      public:
        /// Constructor with default initializations
        xlink__titleEltType() : __any(), xlink__type((enum xlink__typeType)2), xml__lang(), __mixed() { }
        virtual ~xlink__titleEltType() { }
        /// Friend allocator used by soap_new_xlink__titleEltType(struct soap*, int)
        friend SOAP_FMAC1 xlink__titleEltType * SOAP_FMAC2 soap_instantiate_xlink__titleEltType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:510 */
#ifndef SOAP_TYPE_xlink__resourceType
#define SOAP_TYPE_xlink__resourceType (164)
/* Type xlink__resourceType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'xlink:resourceType': */
class SOAP_CMAC xlink__resourceType : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Required attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType xlink__type;	///< initialized with fixed value = (enum xlink__typeType)3
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:label' of XML schema type 'xlink:labelType'
        char **xlink__label;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_xlink__resourceType
        virtual long soap_type(void) const { return SOAP_TYPE_xlink__resourceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__resourceType, default initialized and not managed by a soap context
        virtual xlink__resourceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__resourceType); }
      public:
        /// Constructor with default initializations
        xlink__resourceType() : __any(), xlink__type((enum xlink__typeType)3), xlink__role(), xlink__title(), xlink__label(), __mixed() { }
        virtual ~xlink__resourceType() { }
        /// Friend allocator used by soap_new_xlink__resourceType(struct soap*, int)
        friend SOAP_FMAC1 xlink__resourceType * SOAP_FMAC2 soap_instantiate_xlink__resourceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:5206 */
#ifndef SOAP_TYPE__xlink__union_locatorType
#define SOAP_TYPE__xlink__union_locatorType (588)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _xlink__union_locatorType
{
};
#endif

/* ws-inspire-wfs2.h:5201 */
#ifndef SOAP_TYPE___xlink__union_locatorType
#define SOAP_TYPE___xlink__union_locatorType (587)
/* Wrapper: */
class SOAP_CMAC __xlink__union_locatorType {
      public:
        /// Union with union _xlink__union_locatorType variant selector __uniontitle set to one of:
        int __uniontitle;
        union _xlink__union_locatorType union_locatorType;
      public:
        /// Return unique type id SOAP_TYPE___xlink__union_locatorType
        virtual long soap_type(void) const { return SOAP_TYPE___xlink__union_locatorType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __xlink__union_locatorType, default initialized and not managed by a soap context
        virtual __xlink__union_locatorType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__xlink__union_locatorType); }
      public:
        /// Constructor with default initializations
        __xlink__union_locatorType() : __uniontitle() { }
        virtual ~__xlink__union_locatorType() { }
        /// Friend allocator used by soap_new___xlink__union_locatorType(struct soap*, int)
        friend SOAP_FMAC1 __xlink__union_locatorType * SOAP_FMAC2 soap_instantiate___xlink__union_locatorType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:512 */
#ifndef SOAP_TYPE_xlink__locatorType
#define SOAP_TYPE_xlink__locatorType (165)
/* Type xlink__locatorType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'xlink:locatorType': */
class SOAP_CMAC xlink__locatorType : public xsd__anyType {
      public:
        /// Sequence of elements '-union-locatorType' of XML schema type '-xlink:union-locatorType' stored in dynamic array __union_locatorType of length __sizetitle
        int __sizetitle;
        __xlink__union_locatorType *__union_locatorType;
        /// Required attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType xlink__type;	///< initialized with fixed value = (enum xlink__typeType)4
        /// Required attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char *xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:label' of XML schema type 'xlink:labelType'
        char **xlink__label;
      public:
        /// Return unique type id SOAP_TYPE_xlink__locatorType
        virtual long soap_type(void) const { return SOAP_TYPE_xlink__locatorType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__locatorType, default initialized and not managed by a soap context
        virtual xlink__locatorType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__locatorType); }
      public:
        /// Constructor with default initializations
        xlink__locatorType() : __sizetitle(), __union_locatorType(), xlink__type((enum xlink__typeType)4), xlink__href(), xlink__role(), xlink__title(), xlink__label() { }
        virtual ~xlink__locatorType() { }
        /// Friend allocator used by soap_new_xlink__locatorType(struct soap*, int)
        friend SOAP_FMAC1 xlink__locatorType * SOAP_FMAC2 soap_instantiate_xlink__locatorType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:5255 */
#ifndef SOAP_TYPE__xlink__union_arcType
#define SOAP_TYPE__xlink__union_arcType (591)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _xlink__union_arcType
{
};
#endif

/* ws-inspire-wfs2.h:5250 */
#ifndef SOAP_TYPE___xlink__union_arcType
#define SOAP_TYPE___xlink__union_arcType (590)
/* Wrapper: */
class SOAP_CMAC __xlink__union_arcType {
      public:
        /// Union with union _xlink__union_arcType variant selector __uniontitle set to one of:
        int __uniontitle;
        union _xlink__union_arcType union_arcType;
      public:
        /// Return unique type id SOAP_TYPE___xlink__union_arcType
        virtual long soap_type(void) const { return SOAP_TYPE___xlink__union_arcType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __xlink__union_arcType, default initialized and not managed by a soap context
        virtual __xlink__union_arcType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__xlink__union_arcType); }
      public:
        /// Constructor with default initializations
        __xlink__union_arcType() : __uniontitle() { }
        virtual ~__xlink__union_arcType() { }
        /// Friend allocator used by soap_new___xlink__union_arcType(struct soap*, int)
        friend SOAP_FMAC1 __xlink__union_arcType * SOAP_FMAC2 soap_instantiate___xlink__union_arcType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:514 */
#ifndef SOAP_TYPE_xlink__arcType
#define SOAP_TYPE_xlink__arcType (166)
/* Type xlink__arcType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'xlink:arcType': */
class SOAP_CMAC xlink__arcType : public xsd__anyType {
      public:
        /// Sequence of elements '-union-arcType' of XML schema type '-xlink:union-arcType' stored in dynamic array __union_arcType of length __sizetitle
        int __sizetitle;
        __xlink__union_arcType *__union_arcType;
        /// Required attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType xlink__type;	///< initialized with fixed value = (enum xlink__typeType)5
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'xlink:from' of XML schema type 'xlink:fromType'
        char **xlink__from;
        /// Optional attribute 'xlink:to' of XML schema type 'xlink:toType'
        char **xlink__to;
      public:
        /// Return unique type id SOAP_TYPE_xlink__arcType
        virtual long soap_type(void) const { return SOAP_TYPE_xlink__arcType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__arcType, default initialized and not managed by a soap context
        virtual xlink__arcType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__arcType); }
      public:
        /// Constructor with default initializations
        xlink__arcType() : __sizetitle(), __union_arcType(), xlink__type((enum xlink__typeType)5), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), xlink__from(), xlink__to() { }
        virtual ~xlink__arcType() { }
        /// Friend allocator used by soap_new_xlink__arcType(struct soap*, int)
        friend SOAP_FMAC1 xlink__arcType * SOAP_FMAC2 soap_instantiate_xlink__arcType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:516 */
#ifndef SOAP_TYPE_fes__AbstractQueryExpressionType
#define SOAP_TYPE_fes__AbstractQueryExpressionType (167)
/* Type fes__AbstractQueryExpressionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'fes:AbstractQueryExpressionType': */
class SOAP_CMAC fes__AbstractQueryExpressionType : public xsd__anyType {
      public:
        /// Optional attribute 'handle' of XML schema type 'xsd:string'
        std::string *handle;
      public:
        /// Return unique type id SOAP_TYPE_fes__AbstractQueryExpressionType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__AbstractQueryExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__AbstractQueryExpressionType, default initialized and not managed by a soap context
        virtual fes__AbstractQueryExpressionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__AbstractQueryExpressionType); }
      public:
        /// Constructor with default initializations
        fes__AbstractQueryExpressionType() : handle() { }
        virtual ~fes__AbstractQueryExpressionType() { }
        /// Friend allocator used by soap_new_fes__AbstractQueryExpressionType(struct soap*, int)
        friend SOAP_FMAC1 fes__AbstractQueryExpressionType * SOAP_FMAC2 soap_instantiate_fes__AbstractQueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:520 */
#ifndef SOAP_TYPE_fes__AbstractProjectionClauseType
#define SOAP_TYPE_fes__AbstractProjectionClauseType (169)
/* Type fes__AbstractProjectionClauseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'fes:AbstractProjectionClauseType': */
class SOAP_CMAC fes__AbstractProjectionClauseType : public xsd__anyType {
      public:
        /// Return unique type id SOAP_TYPE_fes__AbstractProjectionClauseType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__AbstractProjectionClauseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__AbstractProjectionClauseType, default initialized and not managed by a soap context
        virtual fes__AbstractProjectionClauseType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__AbstractProjectionClauseType); }
      public:
        /// Constructor with default initializations
        fes__AbstractProjectionClauseType() { }
        virtual ~fes__AbstractProjectionClauseType() { }
        /// Friend allocator used by soap_new_fes__AbstractProjectionClauseType(struct soap*, int)
        friend SOAP_FMAC1 fes__AbstractProjectionClauseType * SOAP_FMAC2 soap_instantiate_fes__AbstractProjectionClauseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:522 */
#ifndef SOAP_TYPE_fes__AbstractSelectionClauseType
#define SOAP_TYPE_fes__AbstractSelectionClauseType (170)
/* Type fes__AbstractSelectionClauseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'fes:AbstractSelectionClauseType': */
class SOAP_CMAC fes__AbstractSelectionClauseType : public xsd__anyType {
      public:
        /// Return unique type id SOAP_TYPE_fes__AbstractSelectionClauseType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__AbstractSelectionClauseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__AbstractSelectionClauseType, default initialized and not managed by a soap context
        virtual fes__AbstractSelectionClauseType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__AbstractSelectionClauseType); }
      public:
        /// Constructor with default initializations
        fes__AbstractSelectionClauseType() { }
        virtual ~fes__AbstractSelectionClauseType() { }
        /// Friend allocator used by soap_new_fes__AbstractSelectionClauseType(struct soap*, int)
        friend SOAP_FMAC1 fes__AbstractSelectionClauseType * SOAP_FMAC2 soap_instantiate_fes__AbstractSelectionClauseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:524 */
#ifndef SOAP_TYPE_fes__AbstractSortingClauseType
#define SOAP_TYPE_fes__AbstractSortingClauseType (171)
/* Type fes__AbstractSortingClauseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'fes:AbstractSortingClauseType': */
class SOAP_CMAC fes__AbstractSortingClauseType : public xsd__anyType {
      public:
        /// Return unique type id SOAP_TYPE_fes__AbstractSortingClauseType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__AbstractSortingClauseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__AbstractSortingClauseType, default initialized and not managed by a soap context
        virtual fes__AbstractSortingClauseType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__AbstractSortingClauseType); }
      public:
        /// Constructor with default initializations
        fes__AbstractSortingClauseType() { }
        virtual ~fes__AbstractSortingClauseType() { }
        /// Friend allocator used by soap_new_fes__AbstractSortingClauseType(struct soap*, int)
        friend SOAP_FMAC1 fes__AbstractSortingClauseType * SOAP_FMAC2 soap_instantiate_fes__AbstractSortingClauseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:528 */
#ifndef SOAP_TYPE_fes__ComparisonOpsType
#define SOAP_TYPE_fes__ComparisonOpsType (173)
/* simple XML schema type 'fes:ComparisonOpsType': */
class SOAP_CMAC fes__ComparisonOpsType : public xsd__anyType {
      public:
        /// Return unique type id SOAP_TYPE_fes__ComparisonOpsType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__ComparisonOpsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__ComparisonOpsType, default initialized and not managed by a soap context
        virtual fes__ComparisonOpsType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__ComparisonOpsType); }
      public:
        /// Constructor with default initializations
        fes__ComparisonOpsType() { }
        virtual ~fes__ComparisonOpsType() { }
        /// Friend allocator used by soap_new_fes__ComparisonOpsType(struct soap*, int)
        friend SOAP_FMAC1 fes__ComparisonOpsType * SOAP_FMAC2 soap_instantiate_fes__ComparisonOpsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:530 */
#ifndef SOAP_TYPE_fes__SpatialOpsType
#define SOAP_TYPE_fes__SpatialOpsType (174)
/* simple XML schema type 'fes:SpatialOpsType': */
class SOAP_CMAC fes__SpatialOpsType : public xsd__anyType {
      public:
        /// Return unique type id SOAP_TYPE_fes__SpatialOpsType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__SpatialOpsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__SpatialOpsType, default initialized and not managed by a soap context
        virtual fes__SpatialOpsType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__SpatialOpsType); }
      public:
        /// Constructor with default initializations
        fes__SpatialOpsType() { }
        virtual ~fes__SpatialOpsType() { }
        /// Friend allocator used by soap_new_fes__SpatialOpsType(struct soap*, int)
        friend SOAP_FMAC1 fes__SpatialOpsType * SOAP_FMAC2 soap_instantiate_fes__SpatialOpsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:532 */
#ifndef SOAP_TYPE_fes__TemporalOpsType
#define SOAP_TYPE_fes__TemporalOpsType (175)
/* simple XML schema type 'fes:TemporalOpsType': */
class SOAP_CMAC fes__TemporalOpsType : public xsd__anyType {
      public:
        /// Return unique type id SOAP_TYPE_fes__TemporalOpsType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__TemporalOpsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__TemporalOpsType, default initialized and not managed by a soap context
        virtual fes__TemporalOpsType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__TemporalOpsType); }
      public:
        /// Constructor with default initializations
        fes__TemporalOpsType() { }
        virtual ~fes__TemporalOpsType() { }
        /// Friend allocator used by soap_new_fes__TemporalOpsType(struct soap*, int)
        friend SOAP_FMAC1 fes__TemporalOpsType * SOAP_FMAC2 soap_instantiate_fes__TemporalOpsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:534 */
#ifndef SOAP_TYPE_fes__LogicOpsType
#define SOAP_TYPE_fes__LogicOpsType (176)
/* simple XML schema type 'fes:LogicOpsType': */
class SOAP_CMAC fes__LogicOpsType : public xsd__anyType {
      public:
        /// Return unique type id SOAP_TYPE_fes__LogicOpsType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__LogicOpsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__LogicOpsType, default initialized and not managed by a soap context
        virtual fes__LogicOpsType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__LogicOpsType); }
      public:
        /// Constructor with default initializations
        fes__LogicOpsType() { }
        virtual ~fes__LogicOpsType() { }
        /// Friend allocator used by soap_new_fes__LogicOpsType(struct soap*, int)
        friend SOAP_FMAC1 fes__LogicOpsType * SOAP_FMAC2 soap_instantiate_fes__LogicOpsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:536 */
#ifndef SOAP_TYPE_fes__ExtensionOpsType
#define SOAP_TYPE_fes__ExtensionOpsType (177)
/* Type fes__ExtensionOpsType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'fes:ExtensionOpsType': */
class SOAP_CMAC fes__ExtensionOpsType : public xsd__anyType {
      public:
        /// Return unique type id SOAP_TYPE_fes__ExtensionOpsType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__ExtensionOpsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__ExtensionOpsType, default initialized and not managed by a soap context
        virtual fes__ExtensionOpsType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__ExtensionOpsType); }
      public:
        /// Constructor with default initializations
        fes__ExtensionOpsType() { }
        virtual ~fes__ExtensionOpsType() { }
        /// Friend allocator used by soap_new_fes__ExtensionOpsType(struct soap*, int)
        friend SOAP_FMAC1 fes__ExtensionOpsType * SOAP_FMAC2 soap_instantiate_fes__ExtensionOpsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:538 */
#ifndef SOAP_TYPE_fes__AbstractIdType
#define SOAP_TYPE_fes__AbstractIdType (178)
/* simple XML schema type 'fes:AbstractIdType': */
class SOAP_CMAC fes__AbstractIdType : public xsd__anyType {
      public:
        /// Return unique type id SOAP_TYPE_fes__AbstractIdType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__AbstractIdType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__AbstractIdType, default initialized and not managed by a soap context
        virtual fes__AbstractIdType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__AbstractIdType); }
      public:
        /// Constructor with default initializations
        fes__AbstractIdType() { }
        virtual ~fes__AbstractIdType() { }
        /// Friend allocator used by soap_new_fes__AbstractIdType(struct soap*, int)
        friend SOAP_FMAC1 fes__AbstractIdType * SOAP_FMAC2 soap_instantiate_fes__AbstractIdType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:5510 */
#ifndef SOAP_TYPE__fes__union_LowerBoundaryType
#define SOAP_TYPE__fes__union_LowerBoundaryType (595)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _fes__union_LowerBoundaryType
{
        #define SOAP_UNION__fes__union_LowerBoundaryType_ValueReference	(1)	/**< union variant selector value for member ValueReference */
        std::string *ValueReference;
        #define SOAP_UNION__fes__union_LowerBoundaryType_Function	(2)	/**< union variant selector value for member Function */
        fes__FunctionType *Function;
        #define SOAP_UNION__fes__union_LowerBoundaryType_Literal	(3)	/**< union variant selector value for member Literal */
        fes__LiteralType *Literal;
};
#endif

/* ws-inspire-wfs2.h:552 */
#ifndef SOAP_TYPE_fes__LowerBoundaryType
#define SOAP_TYPE_fes__LowerBoundaryType (185)
/* complex XML schema type 'fes:LowerBoundaryType': */
class SOAP_CMAC fes__LowerBoundaryType : public xsd__anyType {
      public:
        /// Union with union _fes__union_LowerBoundaryType variant selector __union_LowerBoundaryType set to one of: SOAP_UNION__fes__union_LowerBoundaryType_ValueReference SOAP_UNION__fes__union_LowerBoundaryType_Function SOAP_UNION__fes__union_LowerBoundaryType_Literal
        int __union_LowerBoundaryType;
        union _fes__union_LowerBoundaryType union_LowerBoundaryType;
      public:
        /// Return unique type id SOAP_TYPE_fes__LowerBoundaryType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__LowerBoundaryType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__LowerBoundaryType, default initialized and not managed by a soap context
        virtual fes__LowerBoundaryType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__LowerBoundaryType); }
      public:
        /// Constructor with default initializations
        fes__LowerBoundaryType() : __union_LowerBoundaryType() { }
        virtual ~fes__LowerBoundaryType() { }
        /// Friend allocator used by soap_new_fes__LowerBoundaryType(struct soap*, int)
        friend SOAP_FMAC1 fes__LowerBoundaryType * SOAP_FMAC2 soap_instantiate_fes__LowerBoundaryType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:5546 */
#ifndef SOAP_TYPE__fes__union_UpperBoundaryType
#define SOAP_TYPE__fes__union_UpperBoundaryType (598)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _fes__union_UpperBoundaryType
{
        #define SOAP_UNION__fes__union_UpperBoundaryType_ValueReference	(1)	/**< union variant selector value for member ValueReference */
        std::string *ValueReference;
        #define SOAP_UNION__fes__union_UpperBoundaryType_Function	(2)	/**< union variant selector value for member Function */
        fes__FunctionType *Function;
        #define SOAP_UNION__fes__union_UpperBoundaryType_Literal	(3)	/**< union variant selector value for member Literal */
        fes__LiteralType *Literal;
};
#endif

/* ws-inspire-wfs2.h:554 */
#ifndef SOAP_TYPE_fes__UpperBoundaryType
#define SOAP_TYPE_fes__UpperBoundaryType (186)
/* complex XML schema type 'fes:UpperBoundaryType': */
class SOAP_CMAC fes__UpperBoundaryType : public xsd__anyType {
      public:
        /// Union with union _fes__union_UpperBoundaryType variant selector __unionexpression set to one of: SOAP_UNION__fes__union_UpperBoundaryType_ValueReference SOAP_UNION__fes__union_UpperBoundaryType_Function SOAP_UNION__fes__union_UpperBoundaryType_Literal
        int __unionexpression;
        union _fes__union_UpperBoundaryType union_UpperBoundaryType;
      public:
        /// Return unique type id SOAP_TYPE_fes__UpperBoundaryType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__UpperBoundaryType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__UpperBoundaryType, default initialized and not managed by a soap context
        virtual fes__UpperBoundaryType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__UpperBoundaryType); }
      public:
        /// Constructor with default initializations
        fes__UpperBoundaryType() : __unionexpression() { }
        virtual ~fes__UpperBoundaryType() { }
        /// Friend allocator used by soap_new_fes__UpperBoundaryType(struct soap*, int)
        friend SOAP_FMAC1 fes__UpperBoundaryType * SOAP_FMAC2 soap_instantiate_fes__UpperBoundaryType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:5581 */
#ifndef SOAP_TYPE__fes__union_FunctionType
#define SOAP_TYPE__fes__union_FunctionType (600)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _fes__union_FunctionType
{
        #define SOAP_UNION__fes__union_FunctionType_ValueReference	(1)	/**< union variant selector value for member ValueReference */
        std::string *ValueReference;
        #define SOAP_UNION__fes__union_FunctionType_Function	(2)	/**< union variant selector value for member Function */
        fes__FunctionType *Function;
        #define SOAP_UNION__fes__union_FunctionType_Literal	(3)	/**< union variant selector value for member Literal */
        fes__LiteralType *Literal;
};
#endif

/* ws-inspire-wfs2.h:5576 */
#ifndef SOAP_TYPE___fes__union_FunctionType
#define SOAP_TYPE___fes__union_FunctionType (599)
/* Type __fes__union_FunctionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* Wrapper: */
class SOAP_CMAC __fes__union_FunctionType {
      public:
        /// Union with union _fes__union_FunctionType variant selector __unionexpression set to one of: SOAP_UNION__fes__union_FunctionType_ValueReference SOAP_UNION__fes__union_FunctionType_Function SOAP_UNION__fes__union_FunctionType_Literal
        int __unionexpression;
        union _fes__union_FunctionType union_FunctionType;
      public:
        /// Return unique type id SOAP_TYPE___fes__union_FunctionType
        virtual long soap_type(void) const { return SOAP_TYPE___fes__union_FunctionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __fes__union_FunctionType, default initialized and not managed by a soap context
        virtual __fes__union_FunctionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__fes__union_FunctionType); }
      public:
        /// Constructor with default initializations
        __fes__union_FunctionType() : __unionexpression() { }
        virtual ~__fes__union_FunctionType() { }
        /// Friend allocator used by soap_new___fes__union_FunctionType(struct soap*, int)
        friend SOAP_FMAC1 __fes__union_FunctionType * SOAP_FMAC2 soap_instantiate___fes__union_FunctionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:570 */
#ifndef SOAP_TYPE_fes__FunctionType
#define SOAP_TYPE_fes__FunctionType (194)
/* complex XML schema type 'fes:FunctionType': */
class SOAP_CMAC fes__FunctionType : public xsd__anyType {
      public:
        /// Sequence of elements '-union-FunctionType' of XML schema type '-fes:union-FunctionType' stored in dynamic array __union_FunctionType of length __sizeexpression
        int __sizeexpression;
        __fes__union_FunctionType *__union_FunctionType;
        /// Required attribute 'name' of XML schema type 'xsd:string'
        std::string name;
      public:
        /// Return unique type id SOAP_TYPE_fes__FunctionType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__FunctionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__FunctionType, default initialized and not managed by a soap context
        virtual fes__FunctionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__FunctionType); }
      public:
        /// Constructor with default initializations
        fes__FunctionType() : __sizeexpression(), __union_FunctionType(), name() { }
        virtual ~fes__FunctionType() { }
        /// Friend allocator used by soap_new_fes__FunctionType(struct soap*, int)
        friend SOAP_FMAC1 fes__FunctionType * SOAP_FMAC2 soap_instantiate_fes__FunctionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:572 */
#ifndef SOAP_TYPE_fes__LiteralType
#define SOAP_TYPE_fes__LiteralType (195)
/* complex XML schema type 'fes:LiteralType': */
class SOAP_CMAC fes__LiteralType : public xsd__anyType {
      public:
        char *__any;
        /// Optional attribute 'type' of XML schema type 'xsd:QName'
        char **type;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_fes__LiteralType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__LiteralType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__LiteralType, default initialized and not managed by a soap context
        virtual fes__LiteralType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__LiteralType); }
      public:
        /// Constructor with default initializations
        fes__LiteralType() : __any(), type(), __mixed() { }
        virtual ~fes__LiteralType() { }
        /// Friend allocator used by soap_new_fes__LiteralType(struct soap*, int)
        friend SOAP_FMAC1 fes__LiteralType * SOAP_FMAC2 soap_instantiate_fes__LiteralType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:574 */
#ifndef SOAP_TYPE_fes__ConformanceType
#define SOAP_TYPE_fes__ConformanceType (196)
/* Type fes__ConformanceType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:ConformanceType': */
class SOAP_CMAC fes__ConformanceType : public xsd__anyType {
      public:
        /// Required element 'fes:Constraint' of XML schema type 'ows:DomainType'
        std::vector<ows__DomainType *> Constraint;
      public:
        /// Return unique type id SOAP_TYPE_fes__ConformanceType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__ConformanceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__ConformanceType, default initialized and not managed by a soap context
        virtual fes__ConformanceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__ConformanceType); }
      public:
        /// Constructor with default initializations
        fes__ConformanceType() : Constraint() { }
        virtual ~fes__ConformanceType() { }
        /// Friend allocator used by soap_new_fes__ConformanceType(struct soap*, int)
        friend SOAP_FMAC1 fes__ConformanceType * SOAP_FMAC2 soap_instantiate_fes__ConformanceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:576 */
#ifndef SOAP_TYPE_fes__Id_x005fCapabilitiesType
#define SOAP_TYPE_fes__Id_x005fCapabilitiesType (197)
/* Type fes__Id_x005fCapabilitiesType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:Id_CapabilitiesType': */
class SOAP_CMAC fes__Id_x005fCapabilitiesType : public xsd__anyType {
      public:
        /// Required element 'fes:ResourceIdentifier' of XML schema type 'fes:ResourceIdentifierType'
        std::vector<fes__ResourceIdentifierType *> ResourceIdentifier;
      public:
        /// Return unique type id SOAP_TYPE_fes__Id_x005fCapabilitiesType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__Id_x005fCapabilitiesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__Id_x005fCapabilitiesType, default initialized and not managed by a soap context
        virtual fes__Id_x005fCapabilitiesType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__Id_x005fCapabilitiesType); }
      public:
        /// Constructor with default initializations
        fes__Id_x005fCapabilitiesType() : ResourceIdentifier() { }
        virtual ~fes__Id_x005fCapabilitiesType() { }
        /// Friend allocator used by soap_new_fes__Id_x005fCapabilitiesType(struct soap*, int)
        friend SOAP_FMAC1 fes__Id_x005fCapabilitiesType * SOAP_FMAC2 soap_instantiate_fes__Id_x005fCapabilitiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:578 */
#ifndef SOAP_TYPE_fes__ResourceIdentifierType
#define SOAP_TYPE_fes__ResourceIdentifierType (198)
/* Type fes__ResourceIdentifierType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:ResourceIdentifierType': */
class SOAP_CMAC fes__ResourceIdentifierType : public xsd__anyType {
      public:
        /// Optional element 'ows:Metadata' of XML schema type 'ows:MetadataType'
        ows__MetadataType *ows__Metadata;
        /// Required attribute 'name' of XML schema type 'xsd:QName'
        char *name;
      public:
        /// Return unique type id SOAP_TYPE_fes__ResourceIdentifierType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__ResourceIdentifierType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__ResourceIdentifierType, default initialized and not managed by a soap context
        virtual fes__ResourceIdentifierType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__ResourceIdentifierType); }
      public:
        /// Constructor with default initializations
        fes__ResourceIdentifierType() : ows__Metadata(), name() { }
        virtual ~fes__ResourceIdentifierType() { }
        /// Friend allocator used by soap_new_fes__ResourceIdentifierType(struct soap*, int)
        friend SOAP_FMAC1 fes__ResourceIdentifierType * SOAP_FMAC2 soap_instantiate_fes__ResourceIdentifierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:580 */
#ifndef SOAP_TYPE_fes__Scalar_x005fCapabilitiesType
#define SOAP_TYPE_fes__Scalar_x005fCapabilitiesType (199)
/* Type fes__Scalar_x005fCapabilitiesType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:Scalar_CapabilitiesType': */
class SOAP_CMAC fes__Scalar_x005fCapabilitiesType : public xsd__anyType {
      public:
        /// Optional element 'fes:LogicalOperators' of XML schema type 'fes:LogicalOperators'
        _fes__LogicalOperators *LogicalOperators;
        /// Optional element 'fes:ComparisonOperators' of XML schema type 'fes:ComparisonOperatorsType'
        fes__ComparisonOperatorsType *ComparisonOperators;
      public:
        /// Return unique type id SOAP_TYPE_fes__Scalar_x005fCapabilitiesType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__Scalar_x005fCapabilitiesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__Scalar_x005fCapabilitiesType, default initialized and not managed by a soap context
        virtual fes__Scalar_x005fCapabilitiesType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__Scalar_x005fCapabilitiesType); }
      public:
        /// Constructor with default initializations
        fes__Scalar_x005fCapabilitiesType() : LogicalOperators(), ComparisonOperators() { }
        virtual ~fes__Scalar_x005fCapabilitiesType() { }
        /// Friend allocator used by soap_new_fes__Scalar_x005fCapabilitiesType(struct soap*, int)
        friend SOAP_FMAC1 fes__Scalar_x005fCapabilitiesType * SOAP_FMAC2 soap_instantiate_fes__Scalar_x005fCapabilitiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:5724 */
#ifndef SOAP_TYPE___fes__ComparisonOperatorsType_sequence
#define SOAP_TYPE___fes__ComparisonOperatorsType_sequence (607)
/* Wrapper: */
struct SOAP_CMAC __fes__ComparisonOperatorsType_sequence {
      public:
        /** Required element 'fes:ComparisonOperator' of XML schema type 'fes:ComparisonOperatorType' */
        fes__ComparisonOperatorType *ComparisonOperator;
      public:
        /** Return unique type id SOAP_TYPE___fes__ComparisonOperatorsType_sequence */
        long soap_type() const { return SOAP_TYPE___fes__ComparisonOperatorsType_sequence; }
        /** Constructor with member initializations */
        __fes__ComparisonOperatorsType_sequence() : ComparisonOperator() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __fes__ComparisonOperatorsType_sequence * SOAP_FMAC2 soap_instantiate___fes__ComparisonOperatorsType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:582 */
#ifndef SOAP_TYPE_fes__ComparisonOperatorsType
#define SOAP_TYPE_fes__ComparisonOperatorsType (200)
/* Type fes__ComparisonOperatorsType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:ComparisonOperatorsType': */
class SOAP_CMAC fes__ComparisonOperatorsType : public xsd__anyType {
      public:
        std::vector<struct __fes__ComparisonOperatorsType_sequence> __ComparisonOperatorsType_sequence;
      public:
        /// Return unique type id SOAP_TYPE_fes__ComparisonOperatorsType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__ComparisonOperatorsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__ComparisonOperatorsType, default initialized and not managed by a soap context
        virtual fes__ComparisonOperatorsType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__ComparisonOperatorsType); }
      public:
        /// Constructor with default initializations
        fes__ComparisonOperatorsType() : __ComparisonOperatorsType_sequence() { }
        virtual ~fes__ComparisonOperatorsType() { }
        /// Friend allocator used by soap_new_fes__ComparisonOperatorsType(struct soap*, int)
        friend SOAP_FMAC1 fes__ComparisonOperatorsType * SOAP_FMAC2 soap_instantiate_fes__ComparisonOperatorsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:584 */
#ifndef SOAP_TYPE_fes__ComparisonOperatorType
#define SOAP_TYPE_fes__ComparisonOperatorType (201)
/* Type fes__ComparisonOperatorType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'fes:ComparisonOperatorType': */
class SOAP_CMAC fes__ComparisonOperatorType : public xsd__anyType {
      public:
        /// Required attribute 'name' of XML schema type 'fes:ComparisonOperatorNameType'
        std::string name;
      public:
        /// Return unique type id SOAP_TYPE_fes__ComparisonOperatorType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__ComparisonOperatorType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__ComparisonOperatorType, default initialized and not managed by a soap context
        virtual fes__ComparisonOperatorType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__ComparisonOperatorType); }
      public:
        /// Constructor with default initializations
        fes__ComparisonOperatorType() : name() { }
        virtual ~fes__ComparisonOperatorType() { }
        /// Friend allocator used by soap_new_fes__ComparisonOperatorType(struct soap*, int)
        friend SOAP_FMAC1 fes__ComparisonOperatorType * SOAP_FMAC2 soap_instantiate_fes__ComparisonOperatorType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:586 */
#ifndef SOAP_TYPE_fes__AvailableFunctionsType
#define SOAP_TYPE_fes__AvailableFunctionsType (202)
/* Type fes__AvailableFunctionsType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:AvailableFunctionsType': */
class SOAP_CMAC fes__AvailableFunctionsType : public xsd__anyType {
      public:
        /// Required element 'fes:Function' of XML schema type 'fes:AvailableFunctionType'
        std::vector<fes__AvailableFunctionType *> Function;
      public:
        /// Return unique type id SOAP_TYPE_fes__AvailableFunctionsType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__AvailableFunctionsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__AvailableFunctionsType, default initialized and not managed by a soap context
        virtual fes__AvailableFunctionsType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__AvailableFunctionsType); }
      public:
        /// Constructor with default initializations
        fes__AvailableFunctionsType() : Function() { }
        virtual ~fes__AvailableFunctionsType() { }
        /// Friend allocator used by soap_new_fes__AvailableFunctionsType(struct soap*, int)
        friend SOAP_FMAC1 fes__AvailableFunctionsType * SOAP_FMAC2 soap_instantiate_fes__AvailableFunctionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:588 */
#ifndef SOAP_TYPE_fes__AvailableFunctionType
#define SOAP_TYPE_fes__AvailableFunctionType (203)
/* Type fes__AvailableFunctionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:AvailableFunctionType': */
class SOAP_CMAC fes__AvailableFunctionType : public xsd__anyType {
      public:
        /// Optional element 'ows:Metadata' of XML schema type 'ows:MetadataType'
        ows__MetadataType *ows__Metadata;
        /// Required element 'fes:Returns' of XML schema type 'xsd:QName'
        char *Returns;
        /// Optional element 'fes:Arguments' of XML schema type 'fes:ArgumentsType'
        fes__ArgumentsType *Arguments;
        /// Required attribute 'name' of XML schema type 'xsd:string'
        std::string name;
      public:
        /// Return unique type id SOAP_TYPE_fes__AvailableFunctionType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__AvailableFunctionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__AvailableFunctionType, default initialized and not managed by a soap context
        virtual fes__AvailableFunctionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__AvailableFunctionType); }
      public:
        /// Constructor with default initializations
        fes__AvailableFunctionType() : ows__Metadata(), Returns(), Arguments(), name() { }
        virtual ~fes__AvailableFunctionType() { }
        /// Friend allocator used by soap_new_fes__AvailableFunctionType(struct soap*, int)
        friend SOAP_FMAC1 fes__AvailableFunctionType * SOAP_FMAC2 soap_instantiate_fes__AvailableFunctionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:590 */
#ifndef SOAP_TYPE_fes__ArgumentsType
#define SOAP_TYPE_fes__ArgumentsType (204)
/* Type fes__ArgumentsType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:ArgumentsType': */
class SOAP_CMAC fes__ArgumentsType : public xsd__anyType {
      public:
        /// Required element 'fes:Argument' of XML schema type 'fes:ArgumentType'
        std::vector<fes__ArgumentType *> Argument;
      public:
        /// Return unique type id SOAP_TYPE_fes__ArgumentsType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__ArgumentsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__ArgumentsType, default initialized and not managed by a soap context
        virtual fes__ArgumentsType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__ArgumentsType); }
      public:
        /// Constructor with default initializations
        fes__ArgumentsType() : Argument() { }
        virtual ~fes__ArgumentsType() { }
        /// Friend allocator used by soap_new_fes__ArgumentsType(struct soap*, int)
        friend SOAP_FMAC1 fes__ArgumentsType * SOAP_FMAC2 soap_instantiate_fes__ArgumentsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:592 */
#ifndef SOAP_TYPE_fes__ArgumentType
#define SOAP_TYPE_fes__ArgumentType (205)
/* Type fes__ArgumentType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:ArgumentType': */
class SOAP_CMAC fes__ArgumentType : public xsd__anyType {
      public:
        /// Optional element 'ows:Metadata' of XML schema type 'ows:MetadataType'
        ows__MetadataType *ows__Metadata;
        /// Required element 'fes:Type' of XML schema type 'xsd:QName'
        char *Type;
        /// Required attribute 'name' of XML schema type 'xsd:string'
        std::string name;
      public:
        /// Return unique type id SOAP_TYPE_fes__ArgumentType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__ArgumentType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__ArgumentType, default initialized and not managed by a soap context
        virtual fes__ArgumentType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__ArgumentType); }
      public:
        /// Constructor with default initializations
        fes__ArgumentType() : ows__Metadata(), Type(), name() { }
        virtual ~fes__ArgumentType() { }
        /// Friend allocator used by soap_new_fes__ArgumentType(struct soap*, int)
        friend SOAP_FMAC1 fes__ArgumentType * SOAP_FMAC2 soap_instantiate_fes__ArgumentType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:594 */
#ifndef SOAP_TYPE_fes__Spatial_x005fCapabilitiesType
#define SOAP_TYPE_fes__Spatial_x005fCapabilitiesType (206)
/* Type fes__Spatial_x005fCapabilitiesType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:Spatial_CapabilitiesType': */
class SOAP_CMAC fes__Spatial_x005fCapabilitiesType : public xsd__anyType {
      public:
        /// Required element 'fes:GeometryOperands' of XML schema type 'fes:GeometryOperandsType'
        fes__GeometryOperandsType *GeometryOperands;
        /// Required element 'fes:SpatialOperators' of XML schema type 'fes:SpatialOperatorsType'
        fes__SpatialOperatorsType *SpatialOperators;
      public:
        /// Return unique type id SOAP_TYPE_fes__Spatial_x005fCapabilitiesType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__Spatial_x005fCapabilitiesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__Spatial_x005fCapabilitiesType, default initialized and not managed by a soap context
        virtual fes__Spatial_x005fCapabilitiesType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__Spatial_x005fCapabilitiesType); }
      public:
        /// Constructor with default initializations
        fes__Spatial_x005fCapabilitiesType() : GeometryOperands(), SpatialOperators() { }
        virtual ~fes__Spatial_x005fCapabilitiesType() { }
        /// Friend allocator used by soap_new_fes__Spatial_x005fCapabilitiesType(struct soap*, int)
        friend SOAP_FMAC1 fes__Spatial_x005fCapabilitiesType * SOAP_FMAC2 soap_instantiate_fes__Spatial_x005fCapabilitiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:5885 */
#ifndef SOAP_TYPE__fes__GeometryOperandsType_GeometryOperand
#define SOAP_TYPE__fes__GeometryOperandsType_GeometryOperand (617)
/* complex XML schema type 'fes:GeometryOperandsType-GeometryOperand': */
class SOAP_CMAC _fes__GeometryOperandsType_GeometryOperand {
      public:
        /// Required attribute 'name' of XML schema type 'xsd:QName'
        char *name;
      public:
        /// Return unique type id SOAP_TYPE__fes__GeometryOperandsType_GeometryOperand
        virtual long soap_type(void) const { return SOAP_TYPE__fes__GeometryOperandsType_GeometryOperand; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _fes__GeometryOperandsType_GeometryOperand, default initialized and not managed by a soap context
        virtual _fes__GeometryOperandsType_GeometryOperand *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_fes__GeometryOperandsType_GeometryOperand); }
      public:
        /// Constructor with default initializations
        _fes__GeometryOperandsType_GeometryOperand() : name() { }
        virtual ~_fes__GeometryOperandsType_GeometryOperand() { }
        /// Friend allocator used by soap_new__fes__GeometryOperandsType_GeometryOperand(struct soap*, int)
        friend SOAP_FMAC1 _fes__GeometryOperandsType_GeometryOperand * SOAP_FMAC2 soap_instantiate__fes__GeometryOperandsType_GeometryOperand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:596 */
#ifndef SOAP_TYPE_fes__GeometryOperandsType
#define SOAP_TYPE_fes__GeometryOperandsType (207)
/* Type fes__GeometryOperandsType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:GeometryOperandsType': */
class SOAP_CMAC fes__GeometryOperandsType : public xsd__anyType {
      public:
        /// Required element 'fes:GeometryOperand' of XML schema type 'fes:GeometryOperandsType-GeometryOperand'
        std::vector<_fes__GeometryOperandsType_GeometryOperand> GeometryOperand;
      public:
        /// Return unique type id SOAP_TYPE_fes__GeometryOperandsType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__GeometryOperandsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__GeometryOperandsType, default initialized and not managed by a soap context
        virtual fes__GeometryOperandsType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__GeometryOperandsType); }
      public:
        /// Constructor with default initializations
        fes__GeometryOperandsType() : GeometryOperand() { }
        virtual ~fes__GeometryOperandsType() { }
        /// Friend allocator used by soap_new_fes__GeometryOperandsType(struct soap*, int)
        friend SOAP_FMAC1 fes__GeometryOperandsType * SOAP_FMAC2 soap_instantiate_fes__GeometryOperandsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:598 */
#ifndef SOAP_TYPE_fes__SpatialOperatorsType
#define SOAP_TYPE_fes__SpatialOperatorsType (208)
/* Type fes__SpatialOperatorsType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:SpatialOperatorsType': */
class SOAP_CMAC fes__SpatialOperatorsType : public xsd__anyType {
      public:
        /// Required element 'fes:SpatialOperator' of XML schema type 'fes:SpatialOperatorType'
        std::vector<fes__SpatialOperatorType *> SpatialOperator;
      public:
        /// Return unique type id SOAP_TYPE_fes__SpatialOperatorsType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__SpatialOperatorsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__SpatialOperatorsType, default initialized and not managed by a soap context
        virtual fes__SpatialOperatorsType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__SpatialOperatorsType); }
      public:
        /// Constructor with default initializations
        fes__SpatialOperatorsType() : SpatialOperator() { }
        virtual ~fes__SpatialOperatorsType() { }
        /// Friend allocator used by soap_new_fes__SpatialOperatorsType(struct soap*, int)
        friend SOAP_FMAC1 fes__SpatialOperatorsType * SOAP_FMAC2 soap_instantiate_fes__SpatialOperatorsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:600 */
#ifndef SOAP_TYPE_fes__SpatialOperatorType
#define SOAP_TYPE_fes__SpatialOperatorType (209)
/* Type fes__SpatialOperatorType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:SpatialOperatorType': */
class SOAP_CMAC fes__SpatialOperatorType : public xsd__anyType {
      public:
        /// Optional element 'fes:GeometryOperands' of XML schema type 'fes:GeometryOperandsType'
        fes__GeometryOperandsType *GeometryOperands;
        /// Optional attribute 'name' of XML schema type 'fes:SpatialOperatorNameType'
        std::string *name;
      public:
        /// Return unique type id SOAP_TYPE_fes__SpatialOperatorType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__SpatialOperatorType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__SpatialOperatorType, default initialized and not managed by a soap context
        virtual fes__SpatialOperatorType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__SpatialOperatorType); }
      public:
        /// Constructor with default initializations
        fes__SpatialOperatorType() : GeometryOperands(), name() { }
        virtual ~fes__SpatialOperatorType() { }
        /// Friend allocator used by soap_new_fes__SpatialOperatorType(struct soap*, int)
        friend SOAP_FMAC1 fes__SpatialOperatorType * SOAP_FMAC2 soap_instantiate_fes__SpatialOperatorType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:602 */
#ifndef SOAP_TYPE_fes__Temporal_x005fCapabilitiesType
#define SOAP_TYPE_fes__Temporal_x005fCapabilitiesType (210)
/* Type fes__Temporal_x005fCapabilitiesType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:Temporal_CapabilitiesType': */
class SOAP_CMAC fes__Temporal_x005fCapabilitiesType : public xsd__anyType {
      public:
        /// Required element 'fes:TemporalOperands' of XML schema type 'fes:TemporalOperandsType'
        fes__TemporalOperandsType *TemporalOperands;
        /// Required element 'fes:TemporalOperators' of XML schema type 'fes:TemporalOperatorsType'
        fes__TemporalOperatorsType *TemporalOperators;
      public:
        /// Return unique type id SOAP_TYPE_fes__Temporal_x005fCapabilitiesType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__Temporal_x005fCapabilitiesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__Temporal_x005fCapabilitiesType, default initialized and not managed by a soap context
        virtual fes__Temporal_x005fCapabilitiesType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__Temporal_x005fCapabilitiesType); }
      public:
        /// Constructor with default initializations
        fes__Temporal_x005fCapabilitiesType() : TemporalOperands(), TemporalOperators() { }
        virtual ~fes__Temporal_x005fCapabilitiesType() { }
        /// Friend allocator used by soap_new_fes__Temporal_x005fCapabilitiesType(struct soap*, int)
        friend SOAP_FMAC1 fes__Temporal_x005fCapabilitiesType * SOAP_FMAC2 soap_instantiate_fes__Temporal_x005fCapabilitiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:5981 */
#ifndef SOAP_TYPE__fes__TemporalOperandsType_TemporalOperand
#define SOAP_TYPE__fes__TemporalOperandsType_TemporalOperand (624)
/* complex XML schema type 'fes:TemporalOperandsType-TemporalOperand': */
class SOAP_CMAC _fes__TemporalOperandsType_TemporalOperand {
      public:
        /// Required attribute 'name' of XML schema type 'xsd:QName'
        char *name;
      public:
        /// Return unique type id SOAP_TYPE__fes__TemporalOperandsType_TemporalOperand
        virtual long soap_type(void) const { return SOAP_TYPE__fes__TemporalOperandsType_TemporalOperand; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _fes__TemporalOperandsType_TemporalOperand, default initialized and not managed by a soap context
        virtual _fes__TemporalOperandsType_TemporalOperand *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_fes__TemporalOperandsType_TemporalOperand); }
      public:
        /// Constructor with default initializations
        _fes__TemporalOperandsType_TemporalOperand() : name() { }
        virtual ~_fes__TemporalOperandsType_TemporalOperand() { }
        /// Friend allocator used by soap_new__fes__TemporalOperandsType_TemporalOperand(struct soap*, int)
        friend SOAP_FMAC1 _fes__TemporalOperandsType_TemporalOperand * SOAP_FMAC2 soap_instantiate__fes__TemporalOperandsType_TemporalOperand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:604 */
#ifndef SOAP_TYPE_fes__TemporalOperandsType
#define SOAP_TYPE_fes__TemporalOperandsType (211)
/* Type fes__TemporalOperandsType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:TemporalOperandsType': */
class SOAP_CMAC fes__TemporalOperandsType : public xsd__anyType {
      public:
        /// Required element 'fes:TemporalOperand' of XML schema type 'fes:TemporalOperandsType-TemporalOperand'
        std::vector<_fes__TemporalOperandsType_TemporalOperand> TemporalOperand;
      public:
        /// Return unique type id SOAP_TYPE_fes__TemporalOperandsType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__TemporalOperandsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__TemporalOperandsType, default initialized and not managed by a soap context
        virtual fes__TemporalOperandsType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__TemporalOperandsType); }
      public:
        /// Constructor with default initializations
        fes__TemporalOperandsType() : TemporalOperand() { }
        virtual ~fes__TemporalOperandsType() { }
        /// Friend allocator used by soap_new_fes__TemporalOperandsType(struct soap*, int)
        friend SOAP_FMAC1 fes__TemporalOperandsType * SOAP_FMAC2 soap_instantiate_fes__TemporalOperandsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:606 */
#ifndef SOAP_TYPE_fes__TemporalOperatorsType
#define SOAP_TYPE_fes__TemporalOperatorsType (212)
/* Type fes__TemporalOperatorsType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:TemporalOperatorsType': */
class SOAP_CMAC fes__TemporalOperatorsType : public xsd__anyType {
      public:
        /// Required element 'fes:TemporalOperator' of XML schema type 'fes:TemporalOperatorType'
        std::vector<fes__TemporalOperatorType *> TemporalOperator;
      public:
        /// Return unique type id SOAP_TYPE_fes__TemporalOperatorsType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__TemporalOperatorsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__TemporalOperatorsType, default initialized and not managed by a soap context
        virtual fes__TemporalOperatorsType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__TemporalOperatorsType); }
      public:
        /// Constructor with default initializations
        fes__TemporalOperatorsType() : TemporalOperator() { }
        virtual ~fes__TemporalOperatorsType() { }
        /// Friend allocator used by soap_new_fes__TemporalOperatorsType(struct soap*, int)
        friend SOAP_FMAC1 fes__TemporalOperatorsType * SOAP_FMAC2 soap_instantiate_fes__TemporalOperatorsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:608 */
#ifndef SOAP_TYPE_fes__TemporalOperatorType
#define SOAP_TYPE_fes__TemporalOperatorType (213)
/* Type fes__TemporalOperatorType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:TemporalOperatorType': */
class SOAP_CMAC fes__TemporalOperatorType : public xsd__anyType {
      public:
        /// Optional element 'fes:TemporalOperands' of XML schema type 'fes:TemporalOperandsType'
        fes__TemporalOperandsType *TemporalOperands;
        /// Required attribute 'name' of XML schema type 'fes:TemporalOperatorNameType'
        std::string name;
      public:
        /// Return unique type id SOAP_TYPE_fes__TemporalOperatorType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__TemporalOperatorType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__TemporalOperatorType, default initialized and not managed by a soap context
        virtual fes__TemporalOperatorType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__TemporalOperatorType); }
      public:
        /// Constructor with default initializations
        fes__TemporalOperatorType() : TemporalOperands(), name() { }
        virtual ~fes__TemporalOperatorType() { }
        /// Friend allocator used by soap_new_fes__TemporalOperatorType(struct soap*, int)
        friend SOAP_FMAC1 fes__TemporalOperatorType * SOAP_FMAC2 soap_instantiate_fes__TemporalOperatorType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:610 */
#ifndef SOAP_TYPE_fes__Extended_x005fCapabilitiesType
#define SOAP_TYPE_fes__Extended_x005fCapabilitiesType (214)
/* Type fes__Extended_x005fCapabilitiesType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:Extended_CapabilitiesType': */
class SOAP_CMAC fes__Extended_x005fCapabilitiesType : public xsd__anyType {
      public:
        /// Optional element 'fes:AdditionalOperators' of XML schema type 'fes:AdditionalOperatorsType'
        fes__AdditionalOperatorsType *AdditionalOperators;
      public:
        /// Return unique type id SOAP_TYPE_fes__Extended_x005fCapabilitiesType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__Extended_x005fCapabilitiesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__Extended_x005fCapabilitiesType, default initialized and not managed by a soap context
        virtual fes__Extended_x005fCapabilitiesType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__Extended_x005fCapabilitiesType); }
      public:
        /// Constructor with default initializations
        fes__Extended_x005fCapabilitiesType() : AdditionalOperators() { }
        virtual ~fes__Extended_x005fCapabilitiesType() { }
        /// Friend allocator used by soap_new_fes__Extended_x005fCapabilitiesType(struct soap*, int)
        friend SOAP_FMAC1 fes__Extended_x005fCapabilitiesType * SOAP_FMAC2 soap_instantiate_fes__Extended_x005fCapabilitiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:612 */
#ifndef SOAP_TYPE_fes__AdditionalOperatorsType
#define SOAP_TYPE_fes__AdditionalOperatorsType (215)
/* Type fes__AdditionalOperatorsType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:AdditionalOperatorsType': */
class SOAP_CMAC fes__AdditionalOperatorsType : public xsd__anyType {
      public:
        /// Optional element 'fes:Operator' of XML schema type 'fes:ExtensionOperatorType'
        std::vector<fes__ExtensionOperatorType *> Operator;
      public:
        /// Return unique type id SOAP_TYPE_fes__AdditionalOperatorsType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__AdditionalOperatorsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__AdditionalOperatorsType, default initialized and not managed by a soap context
        virtual fes__AdditionalOperatorsType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__AdditionalOperatorsType); }
      public:
        /// Constructor with default initializations
        fes__AdditionalOperatorsType() : Operator() { }
        virtual ~fes__AdditionalOperatorsType() { }
        /// Friend allocator used by soap_new_fes__AdditionalOperatorsType(struct soap*, int)
        friend SOAP_FMAC1 fes__AdditionalOperatorsType * SOAP_FMAC2 soap_instantiate_fes__AdditionalOperatorsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:614 */
#ifndef SOAP_TYPE_fes__ExtensionOperatorType
#define SOAP_TYPE_fes__ExtensionOperatorType (216)
/* Type fes__ExtensionOperatorType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'fes:ExtensionOperatorType': */
class SOAP_CMAC fes__ExtensionOperatorType : public xsd__anyType {
      public:
        /// Required attribute 'name' of XML schema type 'xsd:QName'
        char *name;
      public:
        /// Return unique type id SOAP_TYPE_fes__ExtensionOperatorType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__ExtensionOperatorType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__ExtensionOperatorType, default initialized and not managed by a soap context
        virtual fes__ExtensionOperatorType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__ExtensionOperatorType); }
      public:
        /// Constructor with default initializations
        fes__ExtensionOperatorType() : name() { }
        virtual ~fes__ExtensionOperatorType() { }
        /// Friend allocator used by soap_new_fes__ExtensionOperatorType(struct soap*, int)
        friend SOAP_FMAC1 fes__ExtensionOperatorType * SOAP_FMAC2 soap_instantiate_fes__ExtensionOperatorType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:616 */
#ifndef SOAP_TYPE_fes__SortByType
#define SOAP_TYPE_fes__SortByType (217)
/* Type fes__SortByType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:SortByType': */
class SOAP_CMAC fes__SortByType : public xsd__anyType {
      public:
        /// Required element 'fes:SortProperty' of XML schema type 'fes:SortPropertyType'
        std::vector<fes__SortPropertyType *> SortProperty;
      public:
        /// Return unique type id SOAP_TYPE_fes__SortByType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__SortByType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__SortByType, default initialized and not managed by a soap context
        virtual fes__SortByType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__SortByType); }
      public:
        /// Constructor with default initializations
        fes__SortByType() : SortProperty() { }
        virtual ~fes__SortByType() { }
        /// Friend allocator used by soap_new_fes__SortByType(struct soap*, int)
        friend SOAP_FMAC1 fes__SortByType * SOAP_FMAC2 soap_instantiate_fes__SortByType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:618 */
#ifndef SOAP_TYPE_fes__SortPropertyType
#define SOAP_TYPE_fes__SortPropertyType (218)
/* complex XML schema type 'fes:SortPropertyType': */
class SOAP_CMAC fes__SortPropertyType : public xsd__anyType {
      public:
        /// Required element 'fes:ValueReference' of XML schema type 'xsd:string'
        std::string ValueReference;
        /// Optional element 'fes:SortOrder' of XML schema type 'fes:SortOrderType'
        enum fes__SortOrderType *SortOrder;
      public:
        /// Return unique type id SOAP_TYPE_fes__SortPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__SortPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__SortPropertyType, default initialized and not managed by a soap context
        virtual fes__SortPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__SortPropertyType); }
      public:
        /// Constructor with default initializations
        fes__SortPropertyType() : ValueReference(), SortOrder() { }
        virtual ~fes__SortPropertyType() { }
        /// Friend allocator used by soap_new_fes__SortPropertyType(struct soap*, int)
        friend SOAP_FMAC1 fes__SortPropertyType * SOAP_FMAC2 soap_instantiate_fes__SortPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:620 */
#ifndef SOAP_TYPE__fes__Filter_x005fCapabilities
#define SOAP_TYPE__fes__Filter_x005fCapabilities (219)
/* complex XML schema type 'fes:Filter_Capabilities': */
class SOAP_CMAC _fes__Filter_x005fCapabilities {
      public:
        /// Required element 'fes:Conformance' of XML schema type 'fes:ConformanceType'
        fes__ConformanceType *Conformance;
        /// Optional element 'fes:Id_Capabilities' of XML schema type 'fes:Id_CapabilitiesType'
        fes__Id_x005fCapabilitiesType *Id_x005fCapabilities;
        /// Optional element 'fes:Scalar_Capabilities' of XML schema type 'fes:Scalar_CapabilitiesType'
        fes__Scalar_x005fCapabilitiesType *Scalar_x005fCapabilities;
        /// Optional element 'fes:Spatial_Capabilities' of XML schema type 'fes:Spatial_CapabilitiesType'
        fes__Spatial_x005fCapabilitiesType *Spatial_x005fCapabilities;
        /// Optional element 'fes:Temporal_Capabilities' of XML schema type 'fes:Temporal_CapabilitiesType'
        fes__Temporal_x005fCapabilitiesType *Temporal_x005fCapabilities;
        /// Optional element 'fes:Functions' of XML schema type 'fes:AvailableFunctionsType'
        fes__AvailableFunctionsType *Functions;
        /// Optional element 'fes:Extended_Capabilities' of XML schema type 'fes:Extended_CapabilitiesType'
        fes__Extended_x005fCapabilitiesType *Extended_x005fCapabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__fes__Filter_x005fCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE__fes__Filter_x005fCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _fes__Filter_x005fCapabilities, default initialized and not managed by a soap context
        virtual _fes__Filter_x005fCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_fes__Filter_x005fCapabilities); }
      public:
        /// Constructor with default initializations
        _fes__Filter_x005fCapabilities() : Conformance(), Id_x005fCapabilities(), Scalar_x005fCapabilities(), Spatial_x005fCapabilities(), Temporal_x005fCapabilities(), Functions(), Extended_x005fCapabilities(), soap() { }
        virtual ~_fes__Filter_x005fCapabilities() { }
        /// Friend allocator used by soap_new__fes__Filter_x005fCapabilities(struct soap*, int)
        friend SOAP_FMAC1 _fes__Filter_x005fCapabilities * SOAP_FMAC2 soap_instantiate__fes__Filter_x005fCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:622 */
#ifndef SOAP_TYPE__fes__LogicalOperators
#define SOAP_TYPE__fes__LogicalOperators (220)
/* complex XML schema type 'fes:LogicalOperators': */
class SOAP_CMAC _fes__LogicalOperators {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__fes__LogicalOperators
        virtual long soap_type(void) const { return SOAP_TYPE__fes__LogicalOperators; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _fes__LogicalOperators, default initialized and not managed by a soap context
        virtual _fes__LogicalOperators *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_fes__LogicalOperators); }
      public:
        /// Constructor with default initializations
        _fes__LogicalOperators() : soap() { }
        virtual ~_fes__LogicalOperators() { }
        /// Friend allocator used by soap_new__fes__LogicalOperators(struct soap*, int)
        friend SOAP_FMAC1 _fes__LogicalOperators * SOAP_FMAC2 soap_instantiate__fes__LogicalOperators(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:624 */
#ifndef SOAP_TYPE_icommon__resource
#define SOAP_TYPE_icommon__resource (221)
/* Type icommon__resource is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resource': */
class SOAP_CMAC icommon__resource : public xsd__anyType {
      public:
        /// Required element 'icommon:ResourceTitle' of XML schema type 'icommon:notEmptyString'
        std::string ResourceTitle;
        /// Required element 'icommon:ResourceAbstract' of XML schema type 'icommon:notEmptyString'
        std::string ResourceAbstract;
        /// Required element 'icommon:ResourceType' of XML schema type 'icommon:resourceType'
        enum icommon__resourceType ResourceType;
        /// Optional element 'icommon:ResourceLocator' of XML schema type 'icommon:resourceLocatorType'
        std::vector<icommon__resourceLocatorType *> ResourceLocator;
        /// Required element 'icommon:MandatoryKeyword' of XML schema type 'icommon:keyword'
        std::vector<icommon__keyword *> MandatoryKeyword;
        /// Optional element 'icommon:Keyword' of XML schema type 'icommon:keyword'
        std::vector<icommon__keyword *> Keyword;
        /// Optional element 'icommon:GeographicBoundingBox' of XML schema type 'icommon:geographicBoundingBox'
        std::vector<icommon__geographicBoundingBox *> GeographicBoundingBox;
        /// Required element 'icommon:TemporalReference' of XML schema type 'icommon:temporalReference'
        std::vector<icommon__temporalReference *> TemporalReference;
        /// Optional element 'icommon:SpatialResolution' of XML schema type 'icommon:spatialResolution'
        std::vector<icommon__spatialResolution *> SpatialResolution;
        /// Required element 'icommon:Conformity' of XML schema type 'icommon:conformity'
        std::vector<icommon__conformity *> Conformity;
        /// Required element 'icommon:ConditionsForAccessAndUse' of XML schema type 'icommon:notEmptyString'
        std::vector<std::string> ConditionsForAccessAndUse;
        /// Required element 'icommon:LimitationsOnPublicAccess' of XML schema type 'icommon:notEmptyString'
        std::vector<std::string> LimitationsOnPublicAccess;
        /// Required element 'icommon:ResponsibleOrganisation' of XML schema type 'icommon:responsibleOrganisation'
        std::vector<icommon__responsibleOrganisation *> ResponsibleOrganisation;
        /// Required element 'icommon:MetadataPointOfContact' of XML schema type 'icommon:metadataPointOfContact'
        std::vector<icommon__metadataPointOfContact *> MetadataPointOfContact;
        /// Required element 'icommon:MetadataDate' of XML schema type 'icommon:iso8601Date'
        std::string MetadataDate;
        /// Required element 'icommon:MetadataLanguage' of XML schema type 'icommon:euLanguageISO6392B'
        enum icommon__euLanguageISO6392B MetadataLanguage;
        /// Optional attribute 'xml:lang' of XML schema type 'xml:lang'
        char **xml__lang;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resource
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resource; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resource, default initialized and not managed by a soap context
        virtual icommon__resource *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resource); }
      public:
        /// Constructor with default initializations
        icommon__resource() : ResourceTitle(), ResourceAbstract(), ResourceType(), ResourceLocator(), MandatoryKeyword(), Keyword(), GeographicBoundingBox(), TemporalReference(), SpatialResolution(), Conformity(), ConditionsForAccessAndUse(), LimitationsOnPublicAccess(), ResponsibleOrganisation(), MetadataPointOfContact(), MetadataDate(), MetadataLanguage(), xml__lang() { }
        virtual ~icommon__resource() { }
        /// Friend allocator used by soap_new_icommon__resource(struct soap*, int)
        friend SOAP_FMAC1 icommon__resource * SOAP_FMAC2 soap_instantiate_icommon__resource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:636 */
#ifndef SOAP_TYPE_icommon__metadataPointOfContact
#define SOAP_TYPE_icommon__metadataPointOfContact (227)
/* complex XML schema type 'icommon:metadataPointOfContact': */
class SOAP_CMAC icommon__metadataPointOfContact : public xsd__anyType {
      public:
        /// Required element 'icommon:OrganisationName' of XML schema type 'xsd:string'
        std::string OrganisationName;
        /// Required element 'icommon:EmailAddress' of XML schema type 'icommon:emailType'
        std::string EmailAddress;
      public:
        /// Return unique type id SOAP_TYPE_icommon__metadataPointOfContact
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__metadataPointOfContact; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__metadataPointOfContact, default initialized and not managed by a soap context
        virtual icommon__metadataPointOfContact *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__metadataPointOfContact); }
      public:
        /// Constructor with default initializations
        icommon__metadataPointOfContact() : OrganisationName(), EmailAddress() { }
        virtual ~icommon__metadataPointOfContact() { }
        /// Friend allocator used by soap_new_icommon__metadataPointOfContact(struct soap*, int)
        friend SOAP_FMAC1 icommon__metadataPointOfContact * SOAP_FMAC2 soap_instantiate_icommon__metadataPointOfContact(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:6302 */
#ifndef SOAP_TYPE__icommon__responsibleOrganisation_ResponsibleParty
#define SOAP_TYPE__icommon__responsibleOrganisation_ResponsibleParty (658)
/* complex XML schema type 'icommon:responsibleOrganisation-ResponsibleParty': */
class SOAP_CMAC _icommon__responsibleOrganisation_ResponsibleParty {
      public:
        /// Required element 'icommon:OrganisationName' of XML schema type 'icommon:notEmptyString'
        std::string OrganisationName;
        /// Required element 'icommon:EmailAddress' of XML schema type 'icommon:emailType'
        std::string EmailAddress;
      public:
        /// Return unique type id SOAP_TYPE__icommon__responsibleOrganisation_ResponsibleParty
        virtual long soap_type(void) const { return SOAP_TYPE__icommon__responsibleOrganisation_ResponsibleParty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _icommon__responsibleOrganisation_ResponsibleParty, default initialized and not managed by a soap context
        virtual _icommon__responsibleOrganisation_ResponsibleParty *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_icommon__responsibleOrganisation_ResponsibleParty); }
      public:
        /// Constructor with default initializations
        _icommon__responsibleOrganisation_ResponsibleParty() : OrganisationName(), EmailAddress() { }
        virtual ~_icommon__responsibleOrganisation_ResponsibleParty() { }
        /// Friend allocator used by soap_new__icommon__responsibleOrganisation_ResponsibleParty(struct soap*, int)
        friend SOAP_FMAC1 _icommon__responsibleOrganisation_ResponsibleParty * SOAP_FMAC2 soap_instantiate__icommon__responsibleOrganisation_ResponsibleParty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:638 */
#ifndef SOAP_TYPE_icommon__responsibleOrganisation
#define SOAP_TYPE_icommon__responsibleOrganisation (228)
/* complex XML schema type 'icommon:responsibleOrganisation': */
class SOAP_CMAC icommon__responsibleOrganisation : public xsd__anyType {
      public:
        /// Required element 'icommon:ResponsibleParty' of XML schema type 'icommon:responsibleOrganisation-ResponsibleParty'
        _icommon__responsibleOrganisation_ResponsibleParty ResponsibleParty;
        /// Required element 'icommon:ResponsiblePartyRole' of XML schema type 'icommon:responsiblePartyRole'
        enum icommon__responsiblePartyRole ResponsiblePartyRole;
      public:
        /// Return unique type id SOAP_TYPE_icommon__responsibleOrganisation
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__responsibleOrganisation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__responsibleOrganisation, default initialized and not managed by a soap context
        virtual icommon__responsibleOrganisation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__responsibleOrganisation); }
      public:
        /// Constructor with default initializations
        icommon__responsibleOrganisation() : ResponsibleParty(), ResponsiblePartyRole() { }
        virtual ~icommon__responsibleOrganisation() { }
        /// Friend allocator used by soap_new_icommon__responsibleOrganisation(struct soap*, int)
        friend SOAP_FMAC1 icommon__responsibleOrganisation * SOAP_FMAC2 soap_instantiate_icommon__responsibleOrganisation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:6338 */
#ifndef SOAP_TYPE__icommon__union_citation
#define SOAP_TYPE__icommon__union_citation (659)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citation
{
        #define SOAP_UNION__icommon__union_citation_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        std::string *DateOfPublication;
        #define SOAP_UNION__icommon__union_citation_DateOfCreation	(2)	/**< union variant selector value for member DateOfCreation */
        std::string *DateOfCreation;
        #define SOAP_UNION__icommon__union_citation_DateOfLastRevision	(3)	/**< union variant selector value for member DateOfLastRevision */
        std::string *DateOfLastRevision;
};
#endif

/* ws-inspire-wfs2.h:640 */
#ifndef SOAP_TYPE_icommon__citation
#define SOAP_TYPE_icommon__citation (229)
/* Type icommon__citation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citation': */
class SOAP_CMAC icommon__citation : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:notEmptyString'
        std::string Title;
        /// Union with union _icommon__union_citation variant selector __union_citation set to one of: SOAP_UNION__icommon__union_citation_DateOfPublication SOAP_UNION__icommon__union_citation_DateOfCreation SOAP_UNION__icommon__union_citation_DateOfLastRevision
        int __union_citation;
        union _icommon__union_citation union_citation;
        /// Optional element 'icommon:URI' of XML schema type 'xsd:anyURI'
        std::vector<char *> URI;
        /// Optional element 'icommon:ResourceLocator' of XML schema type 'icommon:resourceLocatorType'
        std::vector<icommon__resourceLocatorType *> ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citation
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citation, default initialized and not managed by a soap context
        virtual icommon__citation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citation); }
      public:
        /// Constructor with default initializations
        icommon__citation() : Title(), __union_citation(), URI(), ResourceLocator() { }
        virtual ~icommon__citation() { }
        /// Friend allocator used by soap_new_icommon__citation(struct soap*, int)
        friend SOAP_FMAC1 icommon__citation * SOAP_FMAC2 soap_instantiate_icommon__citation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:644 */
#ifndef SOAP_TYPE_icommon__conformity
#define SOAP_TYPE_icommon__conformity (231)
/* complex XML schema type 'icommon:conformity': */
class SOAP_CMAC icommon__conformity : public xsd__anyType {
      public:
        /// Required element 'icommon:Specification' of XML schema type 'icommon:citationConformity'
        icommon__citationConformity *Specification;
        /// Required element 'icommon:Degree' of XML schema type 'icommon:degreeOfConformity'
        enum icommon__degreeOfConformity Degree;
      public:
        /// Return unique type id SOAP_TYPE_icommon__conformity
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__conformity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__conformity, default initialized and not managed by a soap context
        virtual icommon__conformity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__conformity); }
      public:
        /// Constructor with default initializations
        icommon__conformity() : Specification(), Degree() { }
        virtual ~icommon__conformity() { }
        /// Friend allocator used by soap_new_icommon__conformity(struct soap*, int)
        friend SOAP_FMAC1 icommon__conformity * SOAP_FMAC2 soap_instantiate_icommon__conformity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:652 */
#ifndef SOAP_TYPE_icommon__temporalReference
#define SOAP_TYPE_icommon__temporalReference (235)
/* complex XML schema type 'icommon:temporalReference': */
class SOAP_CMAC icommon__temporalReference : public xsd__anyType {
      public:
        /// Optional element 'icommon:DateOfCreation' of XML schema type 'icommon:iso8601Date'
        std::string *DateOfCreation;
        /// Optional element 'icommon:DateOfLastRevision' of XML schema type 'icommon:iso8601Date'
        std::string *DateOfLastRevision;
        /// Optional element 'icommon:DateOfPublication' of XML schema type 'icommon:iso8601Date'
        std::vector<std::string> DateOfPublication;
        /// Optional element 'icommon:TemporalExtent' of XML schema type 'icommon:temporalExtent'
        std::vector<icommon__temporalExtent *> TemporalExtent;
      public:
        /// Return unique type id SOAP_TYPE_icommon__temporalReference
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__temporalReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__temporalReference, default initialized and not managed by a soap context
        virtual icommon__temporalReference *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__temporalReference); }
      public:
        /// Constructor with default initializations
        icommon__temporalReference() : DateOfCreation(), DateOfLastRevision(), DateOfPublication(), TemporalExtent() { }
        virtual ~icommon__temporalReference() { }
        /// Friend allocator used by soap_new_icommon__temporalReference(struct soap*, int)
        friend SOAP_FMAC1 icommon__temporalReference * SOAP_FMAC2 soap_instantiate_icommon__temporalReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:6431 */
#ifndef SOAP_TYPE__icommon__union_temporalExtent
#define SOAP_TYPE__icommon__union_temporalExtent (666)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_temporalExtent
{
        #define SOAP_UNION__icommon__union_temporalExtent_IndividualDate	(1)	/**< union variant selector value for member IndividualDate */
        std::string *IndividualDate;
        #define SOAP_UNION__icommon__union_temporalExtent_IntervalOfDates	(2)	/**< union variant selector value for member IntervalOfDates */
        _icommon__IntervalOfDates *IntervalOfDates;
};
#endif

/* ws-inspire-wfs2.h:6426 */
#ifndef SOAP_TYPE___icommon__union_temporalExtent
#define SOAP_TYPE___icommon__union_temporalExtent (665)
/* Wrapper: */
class SOAP_CMAC __icommon__union_temporalExtent {
      public:
        /// Union with union _icommon__union_temporalExtent variant selector __unionTemporalExtentElement set to one of: SOAP_UNION__icommon__union_temporalExtent_IndividualDate SOAP_UNION__icommon__union_temporalExtent_IntervalOfDates
        int __unionTemporalExtentElement;
        union _icommon__union_temporalExtent union_temporalExtent;
      public:
        /// Return unique type id SOAP_TYPE___icommon__union_temporalExtent
        virtual long soap_type(void) const { return SOAP_TYPE___icommon__union_temporalExtent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __icommon__union_temporalExtent, default initialized and not managed by a soap context
        virtual __icommon__union_temporalExtent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__icommon__union_temporalExtent); }
      public:
        /// Constructor with default initializations
        __icommon__union_temporalExtent() : __unionTemporalExtentElement() { }
        virtual ~__icommon__union_temporalExtent() { }
        /// Friend allocator used by soap_new___icommon__union_temporalExtent(struct soap*, int)
        friend SOAP_FMAC1 __icommon__union_temporalExtent * SOAP_FMAC2 soap_instantiate___icommon__union_temporalExtent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:654 */
#ifndef SOAP_TYPE_icommon__temporalExtent
#define SOAP_TYPE_icommon__temporalExtent (236)
/* complex XML schema type 'icommon:temporalExtent': */
class SOAP_CMAC icommon__temporalExtent : public xsd__anyType {
      public:
        /// Sequence of elements '-union-temporalExtent' of XML schema type '-icommon:union-temporalExtent' stored in dynamic array __union_temporalExtent of length __sizeTemporalExtentElement
        int __sizeTemporalExtentElement;
        __icommon__union_temporalExtent *__union_temporalExtent;
      public:
        /// Return unique type id SOAP_TYPE_icommon__temporalExtent
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__temporalExtent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__temporalExtent, default initialized and not managed by a soap context
        virtual icommon__temporalExtent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__temporalExtent); }
      public:
        /// Constructor with default initializations
        icommon__temporalExtent() : __sizeTemporalExtentElement(), __union_temporalExtent() { }
        virtual ~icommon__temporalExtent() { }
        /// Friend allocator used by soap_new_icommon__temporalExtent(struct soap*, int)
        friend SOAP_FMAC1 icommon__temporalExtent * SOAP_FMAC2 soap_instantiate_icommon__temporalExtent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:656 */
#ifndef SOAP_TYPE_icommon__keyword
#define SOAP_TYPE_icommon__keyword (237)
/* complex XML schema type 'icommon:keyword': */
class SOAP_CMAC icommon__keyword : public xsd__anyType {
      public:
        /// Optional element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabulary'
        icommon__originatingControlledVocabulary *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'xsd:string'
        std::string KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__keyword
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__keyword; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__keyword, default initialized and not managed by a soap context
        virtual icommon__keyword *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__keyword); }
      public:
        /// Constructor with default initializations
        icommon__keyword() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__keyword() { }
        /// Friend allocator used by soap_new_icommon__keyword(struct soap*, int)
        friend SOAP_FMAC1 icommon__keyword * SOAP_FMAC2 soap_instantiate_icommon__keyword(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:660 */
#ifndef SOAP_TYPE_icommon__resourceLocatorType
#define SOAP_TYPE_icommon__resourceLocatorType (239)
/* complex XML schema type 'icommon:resourceLocatorType': */
class SOAP_CMAC icommon__resourceLocatorType : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'xsd:anyURI'
        char *URL;
        /// Optional element 'icommon:MediaType' of XML schema type 'icommon:mediaType'
        std::vector<enum icommon__mediaType> MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resourceLocatorType
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resourceLocatorType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resourceLocatorType, default initialized and not managed by a soap context
        virtual icommon__resourceLocatorType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resourceLocatorType); }
      public:
        /// Constructor with default initializations
        icommon__resourceLocatorType() : URL(), MediaType() { }
        virtual ~icommon__resourceLocatorType() { }
        /// Friend allocator used by soap_new_icommon__resourceLocatorType(struct soap*, int)
        friend SOAP_FMAC1 icommon__resourceLocatorType * SOAP_FMAC2 soap_instantiate_icommon__resourceLocatorType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:662 */
#ifndef SOAP_TYPE_icommon__languageElement
#define SOAP_TYPE_icommon__languageElement (240)
/* Type icommon__languageElement is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:languageElement': */
class SOAP_CMAC icommon__languageElement : public xsd__anyType {
      public:
        /// Required element 'icommon:Language' of XML schema type 'xsd:string'
        std::string Language;
      public:
        /// Return unique type id SOAP_TYPE_icommon__languageElement
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__languageElement; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__languageElement, default initialized and not managed by a soap context
        virtual icommon__languageElement *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__languageElement); }
      public:
        /// Constructor with default initializations
        icommon__languageElement() : Language() { }
        virtual ~icommon__languageElement() { }
        /// Friend allocator used by soap_new_icommon__languageElement(struct soap*, int)
        friend SOAP_FMAC1 icommon__languageElement * SOAP_FMAC2 soap_instantiate_icommon__languageElement(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:668 */
#ifndef SOAP_TYPE_icommon__geographicBoundingBox
#define SOAP_TYPE_icommon__geographicBoundingBox (243)
/* complex XML schema type 'icommon:geographicBoundingBox': */
class SOAP_CMAC icommon__geographicBoundingBox : public xsd__anyType {
      public:
        /// Required element 'icommon:East' of XML schema type 'icommon:geoBoxDigits'
        std::string East;
        /// Required element 'icommon:West' of XML schema type 'icommon:geoBoxDigits'
        std::string West;
        /// Required element 'icommon:North' of XML schema type 'icommon:geoBoxDigits'
        std::string North;
        /// Required element 'icommon:South' of XML schema type 'icommon:geoBoxDigits'
        std::string South;
      public:
        /// Return unique type id SOAP_TYPE_icommon__geographicBoundingBox
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__geographicBoundingBox; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__geographicBoundingBox, default initialized and not managed by a soap context
        virtual icommon__geographicBoundingBox *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__geographicBoundingBox); }
      public:
        /// Constructor with default initializations
        icommon__geographicBoundingBox() : East(), West(), North(), South() { }
        virtual ~icommon__geographicBoundingBox() { }
        /// Friend allocator used by soap_new_icommon__geographicBoundingBox(struct soap*, int)
        friend SOAP_FMAC1 icommon__geographicBoundingBox * SOAP_FMAC2 soap_instantiate_icommon__geographicBoundingBox(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:670 */
#ifndef SOAP_TYPE_icommon__spatialResolution
#define SOAP_TYPE_icommon__spatialResolution (244)
/* complex XML schema type 'icommon:spatialResolution': */
class SOAP_CMAC icommon__spatialResolution : public xsd__anyType {
      public:
        /// Optional element 'icommon:EquivalentScale' of XML schema type 'xsd:long'
        long *EquivalentScale;
        /// Optional element 'icommon:ResolutionDistance' of XML schema type 'xsd:long'
        long *ResolutionDistance;
        /// Optional element 'icommon:UnitOfMeasure' of XML schema type 'xsd:string'
        std::string *UnitOfMeasure;
        /// Optional attribute 'abstract' of XML schema type 'xsd:string'
        std::string *abstract;
      public:
        /// Return unique type id SOAP_TYPE_icommon__spatialResolution
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__spatialResolution; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__spatialResolution, default initialized and not managed by a soap context
        virtual icommon__spatialResolution *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__spatialResolution); }
      public:
        /// Constructor with default initializations
        icommon__spatialResolution() : EquivalentScale(), ResolutionDistance(), UnitOfMeasure(), abstract() { }
        virtual ~icommon__spatialResolution() { }
        /// Friend allocator used by soap_new_icommon__spatialResolution(struct soap*, int)
        friend SOAP_FMAC1 icommon__spatialResolution * SOAP_FMAC2 soap_instantiate_icommon__spatialResolution(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:672 */
#ifndef SOAP_TYPE_icommon__uniqueResourceIdentifier
#define SOAP_TYPE_icommon__uniqueResourceIdentifier (245)
/* complex XML schema type 'icommon:uniqueResourceIdentifier': */
class SOAP_CMAC icommon__uniqueResourceIdentifier : public xsd__anyType {
      public:
        /// Required element 'icommon:Code' of XML schema type 'icommon:notEmptyString'
        std::string Code;
        /// Optional element 'icommon:Namespace' of XML schema type 'xsd:anyURI'
        char **Namespace;
        /// Optional attribute 'metadataURL' of XML schema type 'xsd:anyURI'
        char **metadataURL;
      public:
        /// Return unique type id SOAP_TYPE_icommon__uniqueResourceIdentifier
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__uniqueResourceIdentifier; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__uniqueResourceIdentifier, default initialized and not managed by a soap context
        virtual icommon__uniqueResourceIdentifier *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__uniqueResourceIdentifier); }
      public:
        /// Constructor with default initializations
        icommon__uniqueResourceIdentifier() : Code(), Namespace(), metadataURL() { }
        virtual ~icommon__uniqueResourceIdentifier() { }
        /// Friend allocator used by soap_new_icommon__uniqueResourceIdentifier(struct soap*, int)
        friend SOAP_FMAC1 icommon__uniqueResourceIdentifier * SOAP_FMAC2 soap_instantiate_icommon__uniqueResourceIdentifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:676 */
#ifndef SOAP_TYPE_icommon__ExtendedCapabilitiesType
#define SOAP_TYPE_icommon__ExtendedCapabilitiesType (247)
/* Type icommon__ExtendedCapabilitiesType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:ExtendedCapabilitiesType': */
class SOAP_CMAC icommon__ExtendedCapabilitiesType : public xsd__anyType {
      public:
        /// Optional element 'icommon:MetadataUrl' of XML schema type 'icommon:resourceLocatorType'
        icommon__resourceLocatorType *MetadataUrl;
        /// Optional element 'icommon:SupportedLanguages' of XML schema type 'icommon:supportedLanguagesType'
        icommon__supportedLanguagesType *SupportedLanguages;
        /// Optional element 'icommon:ResponseLanguage' of XML schema type 'icommon:languageElementISO6392B'
        icommon__languageElementISO6392B *ResponseLanguage;
        /// Optional element 'icommon:ResourceLocator' of XML schema type 'icommon:resourceLocatorType'
        std::vector<icommon__resourceLocatorType *> ResourceLocator;
        /// Optional element 'icommon:ResourceType' of XML schema type 'icommon:serviceSpatialDataResourceType'
        enum icommon__serviceSpatialDataResourceType *ResourceType;
        /// Optional element 'icommon:TemporalReference' of XML schema type 'icommon:temporalReference'
        std::vector<icommon__temporalReference *> TemporalReference;
        /// Optional element 'icommon:Conformity' of XML schema type 'icommon:conformity'
        std::vector<icommon__conformity *> Conformity;
        /// Optional element 'icommon:MetadataPointOfContact' of XML schema type 'icommon:metadataPointOfContact'
        std::vector<icommon__metadataPointOfContact *> MetadataPointOfContact;
        /// Optional element 'icommon:MetadataDate' of XML schema type 'icommon:iso8601Date'
        std::string *MetadataDate;
        /// Optional element 'icommon:SpatialDataServiceType' of XML schema type 'icommon:spatialDataServiceType'
        enum icommon__spatialDataServiceType *SpatialDataServiceType;
        /// Optional element 'icommon:MandatoryKeyword' of XML schema type 'icommon:classificationOfSpatialDataService'
        std::vector<icommon__classificationOfSpatialDataService *> MandatoryKeyword;
        /// Optional element 'icommon:Keyword' of XML schema type 'icommon:keyword'
        std::vector<icommon__keyword *> Keyword;
        /// Optional element 'icommon:SupportedLanguages' of XML schema type 'icommon:supportedLanguagesType'
        icommon__supportedLanguagesType *SupportedLanguages_;
        /// Optional element 'icommon:ResponseLanguage' of XML schema type 'icommon:languageElementISO6392B'
        icommon__languageElementISO6392B *ResponseLanguage_;
        /// Optional element 'icommon:MetadataUrl' of XML schema type 'icommon:resourceLocatorType'
        icommon__resourceLocatorType *MetadataUrl_;
      public:
        /// Return unique type id SOAP_TYPE_icommon__ExtendedCapabilitiesType
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__ExtendedCapabilitiesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__ExtendedCapabilitiesType, default initialized and not managed by a soap context
        virtual icommon__ExtendedCapabilitiesType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__ExtendedCapabilitiesType); }
      public:
        /// Constructor with default initializations
        icommon__ExtendedCapabilitiesType() : MetadataUrl(), SupportedLanguages(), ResponseLanguage(), ResourceLocator(), ResourceType(), TemporalReference(), Conformity(), MetadataPointOfContact(), MetadataDate(), SpatialDataServiceType(), MandatoryKeyword(), Keyword(), SupportedLanguages_(), ResponseLanguage_(), MetadataUrl_() { }
        virtual ~icommon__ExtendedCapabilitiesType() { }
        /// Friend allocator used by soap_new_icommon__ExtendedCapabilitiesType(struct soap*, int)
        friend SOAP_FMAC1 icommon__ExtendedCapabilitiesType * SOAP_FMAC2 soap_instantiate_icommon__ExtendedCapabilitiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:678 */
#ifndef SOAP_TYPE_icommon__supportedLanguagesType
#define SOAP_TYPE_icommon__supportedLanguagesType (248)
/* complex XML schema type 'icommon:supportedLanguagesType': */
class SOAP_CMAC icommon__supportedLanguagesType : public xsd__anyType {
      public:
        /// Required element 'icommon:DefaultLanguage' of XML schema type 'icommon:languageElementISO6392B'
        icommon__languageElementISO6392B *DefaultLanguage;
        /// Optional element 'icommon:SupportedLanguage' of XML schema type 'icommon:languageElementISO6392B'
        std::vector<icommon__languageElementISO6392B *> SupportedLanguage;
      public:
        /// Return unique type id SOAP_TYPE_icommon__supportedLanguagesType
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__supportedLanguagesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__supportedLanguagesType, default initialized and not managed by a soap context
        virtual icommon__supportedLanguagesType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__supportedLanguagesType); }
      public:
        /// Constructor with default initializations
        icommon__supportedLanguagesType() : DefaultLanguage(), SupportedLanguage() { }
        virtual ~icommon__supportedLanguagesType() { }
        /// Friend allocator used by soap_new_icommon__supportedLanguagesType(struct soap*, int)
        friend SOAP_FMAC1 icommon__supportedLanguagesType * SOAP_FMAC2 soap_instantiate_icommon__supportedLanguagesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:6824 */
#ifndef SOAP_TYPE__icommon__layers_Layer_CoordinateReferenceSystems_CRS
#define SOAP_TYPE__icommon__layers_Layer_CoordinateReferenceSystems_CRS (684)
/* complex XML schema type 'icommon:layers-Layer-CoordinateReferenceSystems-CRS': */
class SOAP_CMAC _icommon__layers_Layer_CoordinateReferenceSystems_CRS {
      public:
        /// Required element 'icommon:CRSName' of XML schema type 'xsd:string'
        std::string CRSName;
        /// Required element 'icommon:CRSLabel' of XML schema type 'xsd:string'
        std::string CRSLabel;
      public:
        /// Return unique type id SOAP_TYPE__icommon__layers_Layer_CoordinateReferenceSystems_CRS
        virtual long soap_type(void) const { return SOAP_TYPE__icommon__layers_Layer_CoordinateReferenceSystems_CRS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _icommon__layers_Layer_CoordinateReferenceSystems_CRS, default initialized and not managed by a soap context
        virtual _icommon__layers_Layer_CoordinateReferenceSystems_CRS *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_icommon__layers_Layer_CoordinateReferenceSystems_CRS); }
      public:
        /// Constructor with default initializations
        _icommon__layers_Layer_CoordinateReferenceSystems_CRS() : CRSName(), CRSLabel() { }
        virtual ~_icommon__layers_Layer_CoordinateReferenceSystems_CRS() { }
        /// Friend allocator used by soap_new__icommon__layers_Layer_CoordinateReferenceSystems_CRS(struct soap*, int)
        friend SOAP_FMAC1 _icommon__layers_Layer_CoordinateReferenceSystems_CRS * SOAP_FMAC2 soap_instantiate__icommon__layers_Layer_CoordinateReferenceSystems_CRS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:6809 */
#ifndef SOAP_TYPE__icommon__layers_Layer_CoordinateReferenceSystems
#define SOAP_TYPE__icommon__layers_Layer_CoordinateReferenceSystems (683)
/* complex XML schema type 'icommon:layers-Layer-CoordinateReferenceSystems': */
class SOAP_CMAC _icommon__layers_Layer_CoordinateReferenceSystems {
      public:
        /// Required element 'icommon:CRS' of XML schema type 'icommon:layers-Layer-CoordinateReferenceSystems-CRS'
        std::vector<_icommon__layers_Layer_CoordinateReferenceSystems_CRS> CRS;
      public:
        /// Return unique type id SOAP_TYPE__icommon__layers_Layer_CoordinateReferenceSystems
        virtual long soap_type(void) const { return SOAP_TYPE__icommon__layers_Layer_CoordinateReferenceSystems; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _icommon__layers_Layer_CoordinateReferenceSystems, default initialized and not managed by a soap context
        virtual _icommon__layers_Layer_CoordinateReferenceSystems *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_icommon__layers_Layer_CoordinateReferenceSystems); }
      public:
        /// Constructor with default initializations
        _icommon__layers_Layer_CoordinateReferenceSystems() : CRS() { }
        virtual ~_icommon__layers_Layer_CoordinateReferenceSystems() { }
        /// Friend allocator used by soap_new__icommon__layers_Layer_CoordinateReferenceSystems(struct soap*, int)
        friend SOAP_FMAC1 _icommon__layers_Layer_CoordinateReferenceSystems * SOAP_FMAC2 soap_instantiate__icommon__layers_Layer_CoordinateReferenceSystems(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:6873 */
#ifndef SOAP_TYPE__icommon__layers_Layer_Styles_Style_StyleAbstract
#define SOAP_TYPE__icommon__layers_Layer_Styles_Style_StyleAbstract (688)
/* complex XML schema type 'icommon:layers-Layer-Styles-Style-StyleAbstract': */
class SOAP_CMAC _icommon__layers_Layer_Styles_Style_StyleAbstract {
      public:
        /// Return unique type id SOAP_TYPE__icommon__layers_Layer_Styles_Style_StyleAbstract
        virtual long soap_type(void) const { return SOAP_TYPE__icommon__layers_Layer_Styles_Style_StyleAbstract; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _icommon__layers_Layer_Styles_Style_StyleAbstract, default initialized and not managed by a soap context
        virtual _icommon__layers_Layer_Styles_Style_StyleAbstract *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_icommon__layers_Layer_Styles_Style_StyleAbstract); }
      public:
        /// Constructor with default initializations
        _icommon__layers_Layer_Styles_Style_StyleAbstract() { }
        virtual ~_icommon__layers_Layer_Styles_Style_StyleAbstract() { }
        /// Friend allocator used by soap_new__icommon__layers_Layer_Styles_Style_StyleAbstract(struct soap*, int)
        friend SOAP_FMAC1 _icommon__layers_Layer_Styles_Style_StyleAbstract * SOAP_FMAC2 soap_instantiate__icommon__layers_Layer_Styles_Style_StyleAbstract(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:6887 */
#ifndef SOAP_TYPE__icommon__layers_Layer_Styles_Style_StyleFormat
#define SOAP_TYPE__icommon__layers_Layer_Styles_Style_StyleFormat (689)
/* complex XML schema type 'icommon:layers-Layer-Styles-Style-StyleFormat': */
class SOAP_CMAC _icommon__layers_Layer_Styles_Style_StyleFormat {
      public:
        /// Return unique type id SOAP_TYPE__icommon__layers_Layer_Styles_Style_StyleFormat
        virtual long soap_type(void) const { return SOAP_TYPE__icommon__layers_Layer_Styles_Style_StyleFormat; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _icommon__layers_Layer_Styles_Style_StyleFormat, default initialized and not managed by a soap context
        virtual _icommon__layers_Layer_Styles_Style_StyleFormat *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_icommon__layers_Layer_Styles_Style_StyleFormat); }
      public:
        /// Constructor with default initializations
        _icommon__layers_Layer_Styles_Style_StyleFormat() { }
        virtual ~_icommon__layers_Layer_Styles_Style_StyleFormat() { }
        /// Friend allocator used by soap_new__icommon__layers_Layer_Styles_Style_StyleFormat(struct soap*, int)
        friend SOAP_FMAC1 _icommon__layers_Layer_Styles_Style_StyleFormat * SOAP_FMAC2 soap_instantiate__icommon__layers_Layer_Styles_Style_StyleFormat(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:6901 */
#ifndef SOAP_TYPE__icommon__layers_Layer_Styles_Style_StyleURL
#define SOAP_TYPE__icommon__layers_Layer_Styles_Style_StyleURL (690)
/* complex XML schema type 'icommon:layers-Layer-Styles-Style-StyleURL': */
class SOAP_CMAC _icommon__layers_Layer_Styles_Style_StyleURL {
      public:
        /// Return unique type id SOAP_TYPE__icommon__layers_Layer_Styles_Style_StyleURL
        virtual long soap_type(void) const { return SOAP_TYPE__icommon__layers_Layer_Styles_Style_StyleURL; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _icommon__layers_Layer_Styles_Style_StyleURL, default initialized and not managed by a soap context
        virtual _icommon__layers_Layer_Styles_Style_StyleURL *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_icommon__layers_Layer_Styles_Style_StyleURL); }
      public:
        /// Constructor with default initializations
        _icommon__layers_Layer_Styles_Style_StyleURL() { }
        virtual ~_icommon__layers_Layer_Styles_Style_StyleURL() { }
        /// Friend allocator used by soap_new__icommon__layers_Layer_Styles_Style_StyleURL(struct soap*, int)
        friend SOAP_FMAC1 _icommon__layers_Layer_Styles_Style_StyleURL * SOAP_FMAC2 soap_instantiate__icommon__layers_Layer_Styles_Style_StyleURL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:6941 */
#ifndef SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendFormat
#define SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendFormat (693)
/* complex XML schema type 'icommon:layers-Layer-Styles-Style-LegendList-Legend-LegendFormat': */
class SOAP_CMAC _icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendFormat {
      public:
        /// Return unique type id SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendFormat
        virtual long soap_type(void) const { return SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendFormat; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendFormat, default initialized and not managed by a soap context
        virtual _icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendFormat *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendFormat); }
      public:
        /// Constructor with default initializations
        _icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendFormat() { }
        virtual ~_icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendFormat() { }
        /// Friend allocator used by soap_new__icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendFormat(struct soap*, int)
        friend SOAP_FMAC1 _icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendFormat * SOAP_FMAC2 soap_instantiate__icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendFormat(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:6959 */
#ifndef SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendURL
#define SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendURL (694)
/* complex XML schema type 'icommon:layers-Layer-Styles-Style-LegendList-Legend-LegendURL': */
class SOAP_CMAC _icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendURL {
      public:
        /// Return unique type id SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendURL
        virtual long soap_type(void) const { return SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendURL; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendURL, default initialized and not managed by a soap context
        virtual _icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendURL *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendURL); }
      public:
        /// Constructor with default initializations
        _icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendURL() { }
        virtual ~_icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendURL() { }
        /// Friend allocator used by soap_new__icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendURL(struct soap*, int)
        friend SOAP_FMAC1 _icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendURL * SOAP_FMAC2 soap_instantiate__icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendURL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:6928 */
#ifndef SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList_Legend
#define SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList_Legend (692)
/* complex XML schema type 'icommon:layers-Layer-Styles-Style-LegendList-Legend': */
class SOAP_CMAC _icommon__layers_Layer_Styles_Style_LegendList_Legend {
      public:
        /// Required element 'icommon:LegendFormat' of XML schema type 'icommon:layers-Layer-Styles-Style-LegendList-Legend-LegendFormat'
        _icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendFormat LegendFormat;
        /// Required element 'icommon:LegendHeight' of XML schema type 'xsd:byte'
        char LegendHeight;
        /// Required element 'icommon:LegendWidth' of XML schema type 'xsd:byte'
        char LegendWidth;
        /// Required element 'icommon:LegendURL' of XML schema type 'icommon:layers-Layer-Styles-Style-LegendList-Legend-LegendURL'
        _icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendURL LegendURL;
      public:
        /// Return unique type id SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList_Legend
        virtual long soap_type(void) const { return SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList_Legend; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _icommon__layers_Layer_Styles_Style_LegendList_Legend, default initialized and not managed by a soap context
        virtual _icommon__layers_Layer_Styles_Style_LegendList_Legend *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_icommon__layers_Layer_Styles_Style_LegendList_Legend); }
      public:
        /// Constructor with default initializations
        _icommon__layers_Layer_Styles_Style_LegendList_Legend() : LegendFormat(), LegendHeight(), LegendWidth(), LegendURL() { }
        virtual ~_icommon__layers_Layer_Styles_Style_LegendList_Legend() { }
        /// Friend allocator used by soap_new__icommon__layers_Layer_Styles_Style_LegendList_Legend(struct soap*, int)
        friend SOAP_FMAC1 _icommon__layers_Layer_Styles_Style_LegendList_Legend * SOAP_FMAC2 soap_instantiate__icommon__layers_Layer_Styles_Style_LegendList_Legend(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:6915 */
#ifndef SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList
#define SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList (691)
/* complex XML schema type 'icommon:layers-Layer-Styles-Style-LegendList': */
class SOAP_CMAC _icommon__layers_Layer_Styles_Style_LegendList {
      public:
        /// Required element 'icommon:Legend' of XML schema type 'icommon:layers-Layer-Styles-Style-LegendList-Legend'
        _icommon__layers_Layer_Styles_Style_LegendList_Legend Legend;
      public:
        /// Return unique type id SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList
        virtual long soap_type(void) const { return SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _icommon__layers_Layer_Styles_Style_LegendList, default initialized and not managed by a soap context
        virtual _icommon__layers_Layer_Styles_Style_LegendList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_icommon__layers_Layer_Styles_Style_LegendList); }
      public:
        /// Constructor with default initializations
        _icommon__layers_Layer_Styles_Style_LegendList() : Legend() { }
        virtual ~_icommon__layers_Layer_Styles_Style_LegendList() { }
        /// Friend allocator used by soap_new__icommon__layers_Layer_Styles_Style_LegendList(struct soap*, int)
        friend SOAP_FMAC1 _icommon__layers_Layer_Styles_Style_LegendList * SOAP_FMAC2 soap_instantiate__icommon__layers_Layer_Styles_Style_LegendList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:6856 */
#ifndef SOAP_TYPE__icommon__layers_Layer_Styles_Style
#define SOAP_TYPE__icommon__layers_Layer_Styles_Style (687)
/* complex XML schema type 'icommon:layers-Layer-Styles-Style': */
class SOAP_CMAC _icommon__layers_Layer_Styles_Style {
      public:
        /// Required element 'icommon:StyleName' of XML schema type 'xsd:string'
        std::string StyleName;
        /// Required element 'icommon:StyleTitle' of XML schema type 'xsd:string'
        std::string StyleTitle;
        /// Required element 'icommon:StyleAbstract' of XML schema type 'icommon:layers-Layer-Styles-Style-StyleAbstract'
        _icommon__layers_Layer_Styles_Style_StyleAbstract StyleAbstract;
        /// Required element 'icommon:StyleFormat' of XML schema type 'icommon:layers-Layer-Styles-Style-StyleFormat'
        _icommon__layers_Layer_Styles_Style_StyleFormat StyleFormat;
        /// Required element 'icommon:StyleURL' of XML schema type 'icommon:layers-Layer-Styles-Style-StyleURL'
        _icommon__layers_Layer_Styles_Style_StyleURL StyleURL;
        /// Required element 'icommon:LegendList' of XML schema type 'icommon:layers-Layer-Styles-Style-LegendList'
        _icommon__layers_Layer_Styles_Style_LegendList LegendList;
        /// Required attribute 'name' of XML schema type 'xsd:string'
        std::string name;
      public:
        /// Return unique type id SOAP_TYPE__icommon__layers_Layer_Styles_Style
        virtual long soap_type(void) const { return SOAP_TYPE__icommon__layers_Layer_Styles_Style; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _icommon__layers_Layer_Styles_Style, default initialized and not managed by a soap context
        virtual _icommon__layers_Layer_Styles_Style *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_icommon__layers_Layer_Styles_Style); }
      public:
        /// Constructor with default initializations
        _icommon__layers_Layer_Styles_Style() : StyleName(), StyleTitle(), StyleAbstract(), StyleFormat(), StyleURL(), LegendList(), name() { }
        virtual ~_icommon__layers_Layer_Styles_Style() { }
        /// Friend allocator used by soap_new__icommon__layers_Layer_Styles_Style(struct soap*, int)
        friend SOAP_FMAC1 _icommon__layers_Layer_Styles_Style * SOAP_FMAC2 soap_instantiate__icommon__layers_Layer_Styles_Style(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:6843 */
#ifndef SOAP_TYPE__icommon__layers_Layer_Styles
#define SOAP_TYPE__icommon__layers_Layer_Styles (686)
/* complex XML schema type 'icommon:layers-Layer-Styles': */
class SOAP_CMAC _icommon__layers_Layer_Styles {
      public:
        /// Required element 'icommon:Style' of XML schema type 'icommon:layers-Layer-Styles-Style'
        _icommon__layers_Layer_Styles_Style Style;
      public:
        /// Return unique type id SOAP_TYPE__icommon__layers_Layer_Styles
        virtual long soap_type(void) const { return SOAP_TYPE__icommon__layers_Layer_Styles; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _icommon__layers_Layer_Styles, default initialized and not managed by a soap context
        virtual _icommon__layers_Layer_Styles *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_icommon__layers_Layer_Styles); }
      public:
        /// Constructor with default initializations
        _icommon__layers_Layer_Styles() : Style() { }
        virtual ~_icommon__layers_Layer_Styles() { }
        /// Friend allocator used by soap_new__icommon__layers_Layer_Styles(struct soap*, int)
        friend SOAP_FMAC1 _icommon__layers_Layer_Styles * SOAP_FMAC2 soap_instantiate__icommon__layers_Layer_Styles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:6772 */
#ifndef SOAP_TYPE__icommon__layers_Layer
#define SOAP_TYPE__icommon__layers_Layer (680)
/* complex XML schema type 'icommon:layers-Layer': */
class SOAP_CMAC _icommon__layers_Layer {
      public:
        /// Required element 'icommon:Name' of XML schema type 'xsd:string'
        std::string Name;
        /// Required element 'icommon:ResourceTitle' of XML schema type 'xsd:string'
        std::string ResourceTitle;
        /// Required element 'icommon:ResourceAbstract' of XML schema type 'xsd:string'
        std::string ResourceAbstract;
        /// Optional element 'icommon:Keyword' of XML schema type 'icommon:keyword'
        std::vector<icommon__keyword *> Keyword;
        /// Required element 'icommon:GeographicBoundingBox' of XML schema type 'icommon:geographicBoundingBox'
        std::vector<icommon__geographicBoundingBox *> GeographicBoundingBox;
        /// Required element 'icommon:UniqueResourceIdentifier' of XML schema type 'icommon:uniqueResourceIdentifier'
        std::vector<icommon__uniqueResourceIdentifier *> UniqueResourceIdentifier;
        /// Required element 'icommon:CoordinateReferenceSystems' of XML schema type 'icommon:layers-Layer-CoordinateReferenceSystems'
        _icommon__layers_Layer_CoordinateReferenceSystems CoordinateReferenceSystems;
        /// Required element 'icommon:Styles' of XML schema type 'icommon:layers-Layer-Styles'
        _icommon__layers_Layer_Styles Styles;
        /// Optional attribute 'layerName' of XML schema type 'xsd:string'
        std::string *layerName;
        /// Optional attribute 'queryable' of XML schema type 'xsd:boolean'
        bool *queryable;
      public:
        /// Return unique type id SOAP_TYPE__icommon__layers_Layer
        virtual long soap_type(void) const { return SOAP_TYPE__icommon__layers_Layer; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _icommon__layers_Layer, default initialized and not managed by a soap context
        virtual _icommon__layers_Layer *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_icommon__layers_Layer); }
      public:
        /// Constructor with default initializations
        _icommon__layers_Layer() : Name(), ResourceTitle(), ResourceAbstract(), Keyword(), GeographicBoundingBox(), UniqueResourceIdentifier(), CoordinateReferenceSystems(), Styles(), layerName(), queryable() { }
        virtual ~_icommon__layers_Layer() { }
        /// Friend allocator used by soap_new__icommon__layers_Layer(struct soap*, int)
        friend SOAP_FMAC1 _icommon__layers_Layer * SOAP_FMAC2 soap_instantiate__icommon__layers_Layer(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:684 */
#ifndef SOAP_TYPE_icommon__layers
#define SOAP_TYPE_icommon__layers (251)
/* complex XML schema type 'icommon:layers': */
class SOAP_CMAC icommon__layers : public xsd__anyType {
      public:
        /// Required element 'icommon:Layer' of XML schema type 'icommon:layers-Layer'
        _icommon__layers_Layer Layer;
      public:
        /// Return unique type id SOAP_TYPE_icommon__layers
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__layers; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__layers, default initialized and not managed by a soap context
        virtual icommon__layers *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__layers); }
      public:
        /// Constructor with default initializations
        icommon__layers() : Layer() { }
        virtual ~icommon__layers() { }
        /// Friend allocator used by soap_new_icommon__layers(struct soap*, int)
        friend SOAP_FMAC1 icommon__layers * SOAP_FMAC2 soap_instantiate_icommon__layers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:848 */
#ifndef SOAP_TYPE__icommon__IntervalOfDates
#define SOAP_TYPE__icommon__IntervalOfDates (333)
/* complex XML schema type 'icommon:IntervalOfDates': */
class SOAP_CMAC _icommon__IntervalOfDates {
      public:
        /// Required element 'icommon:StartingDate' of XML schema type 'icommon:iso8601Date'
        std::string StartingDate;
        /// Required element 'icommon:EndDate' of XML schema type 'icommon:iso8601Date'
        std::string EndDate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__icommon__IntervalOfDates
        virtual long soap_type(void) const { return SOAP_TYPE__icommon__IntervalOfDates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _icommon__IntervalOfDates, default initialized and not managed by a soap context
        virtual _icommon__IntervalOfDates *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_icommon__IntervalOfDates); }
      public:
        /// Constructor with default initializations
        _icommon__IntervalOfDates() : StartingDate(), EndDate(), soap() { }
        virtual ~_icommon__IntervalOfDates() { }
        /// Friend allocator used by soap_new__icommon__IntervalOfDates(struct soap*, int)
        friend SOAP_FMAC1 _icommon__IntervalOfDates * SOAP_FMAC2 soap_instantiate__icommon__IntervalOfDates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:293 */
#ifndef SOAP_TYPE_wfs__StoredQueryType
#define SOAP_TYPE_wfs__StoredQueryType (56)
/* Type wfs__StoredQueryType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:StoredQueryType': */
class SOAP_CMAC wfs__StoredQueryType : public fes__AbstractQueryExpressionType {
      public:
        /// Optional element 'wfs:Parameter' of XML schema type 'wfs:ParameterType'
        std::vector<wfs__ParameterType *> Parameter;
        /// Required attribute 'id' of XML schema type 'xsd:anyURI'
        char *id;
      public:
        /// Return unique type id SOAP_TYPE_wfs__StoredQueryType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__StoredQueryType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__StoredQueryType, default initialized and not managed by a soap context
        virtual wfs__StoredQueryType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__StoredQueryType); }
      public:
        /// Constructor with default initializations
        wfs__StoredQueryType() : Parameter(), id() { }
        virtual ~wfs__StoredQueryType() { }
        /// Friend allocator used by soap_new_wfs__StoredQueryType(struct soap*, int)
        friend SOAP_FMAC1 wfs__StoredQueryType * SOAP_FMAC2 soap_instantiate_wfs__StoredQueryType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:297 */
#ifndef SOAP_TYPE_wfs__GetCapabilitiesType
#define SOAP_TYPE_wfs__GetCapabilitiesType (58)
/* Type wfs__GetCapabilitiesType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:GetCapabilitiesType': */
class SOAP_CMAC wfs__GetCapabilitiesType : public ows__GetCapabilitiesType {
      public:
        /// Required attribute 'service' of XML schema type 'ows:ServiceType'
        std::string service;	///< initialized with fixed value = "WFS"
      public:
        /// Return unique type id SOAP_TYPE_wfs__GetCapabilitiesType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__GetCapabilitiesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__GetCapabilitiesType, default initialized and not managed by a soap context
        virtual wfs__GetCapabilitiesType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__GetCapabilitiesType); }
      public:
        /// Constructor with default initializations
        wfs__GetCapabilitiesType() : service("WFS") { }
        virtual ~wfs__GetCapabilitiesType() { }
        /// Friend allocator used by soap_new_wfs__GetCapabilitiesType(struct soap*, int)
        friend SOAP_FMAC1 wfs__GetCapabilitiesType * SOAP_FMAC2 soap_instantiate_wfs__GetCapabilitiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:7123 */
#ifndef SOAP_TYPE__wfs__WFS_x005fCapabilitiesType_WSDL
#define SOAP_TYPE__wfs__WFS_x005fCapabilitiesType_WSDL (698)
/* complex XML schema type 'wfs:WFS_CapabilitiesType-WSDL': */
class SOAP_CMAC _wfs__WFS_x005fCapabilitiesType_WSDL {
      public:
        /// Return unique type id SOAP_TYPE__wfs__WFS_x005fCapabilitiesType_WSDL
        virtual long soap_type(void) const { return SOAP_TYPE__wfs__WFS_x005fCapabilitiesType_WSDL; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wfs__WFS_x005fCapabilitiesType_WSDL, default initialized and not managed by a soap context
        virtual _wfs__WFS_x005fCapabilitiesType_WSDL *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wfs__WFS_x005fCapabilitiesType_WSDL); }
      public:
        /// Constructor with default initializations
        _wfs__WFS_x005fCapabilitiesType_WSDL() { }
        virtual ~_wfs__WFS_x005fCapabilitiesType_WSDL() { }
        /// Friend allocator used by soap_new__wfs__WFS_x005fCapabilitiesType_WSDL(struct soap*, int)
        friend SOAP_FMAC1 _wfs__WFS_x005fCapabilitiesType_WSDL * SOAP_FMAC2 soap_instantiate__wfs__WFS_x005fCapabilitiesType_WSDL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:299 */
#ifndef SOAP_TYPE_wfs__WFS_x005fCapabilitiesType
#define SOAP_TYPE_wfs__WFS_x005fCapabilitiesType (59)
/* Type wfs__WFS_x005fCapabilitiesType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:WFS_CapabilitiesType': */
class SOAP_CMAC wfs__WFS_x005fCapabilitiesType : public ows__CapabilitiesBaseType {
      public:
        /// Optional element 'wfs:WSDL' of XML schema type 'wfs:WFS_CapabilitiesType-WSDL'
        _wfs__WFS_x005fCapabilitiesType_WSDL *WSDL;
        /// Optional element 'wfs:FeatureTypeList' of XML schema type 'wfs:FeatureTypeListType'
        wfs__FeatureTypeListType *FeatureTypeList;
        /// Optional element 'fes:Filter_Capabilities' of XML schema type 'fes:Filter_Capabilities'
        _fes__Filter_x005fCapabilities *fes__Filter_x005fCapabilities;
      public:
        /// Return unique type id SOAP_TYPE_wfs__WFS_x005fCapabilitiesType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__WFS_x005fCapabilitiesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__WFS_x005fCapabilitiesType, default initialized and not managed by a soap context
        virtual wfs__WFS_x005fCapabilitiesType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__WFS_x005fCapabilitiesType); }
      public:
        /// Constructor with default initializations
        wfs__WFS_x005fCapabilitiesType() : WSDL(), FeatureTypeList(), fes__Filter_x005fCapabilities() { }
        virtual ~wfs__WFS_x005fCapabilitiesType() { }
        /// Friend allocator used by soap_new_wfs__WFS_x005fCapabilitiesType(struct soap*, int)
        friend SOAP_FMAC1 wfs__WFS_x005fCapabilitiesType * SOAP_FMAC2 soap_instantiate_wfs__WFS_x005fCapabilitiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:315 */
#ifndef SOAP_TYPE_wfs__DescribeFeatureTypeType
#define SOAP_TYPE_wfs__DescribeFeatureTypeType (67)
/* Type wfs__DescribeFeatureTypeType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:DescribeFeatureTypeType': */
class SOAP_CMAC wfs__DescribeFeatureTypeType : public wfs__BaseRequestType {
      public:
        /// Optional element 'wfs:TypeName' of XML schema type 'xsd:QName'
        std::vector<char *> TypeName;
        /// Optional attribute 'outputFormat' of XML schema type 'xsd:string'
        std::string outputFormat;	///< initialized with default value = "application/gml+xml; version=3.2"
      public:
        /// Return unique type id SOAP_TYPE_wfs__DescribeFeatureTypeType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__DescribeFeatureTypeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__DescribeFeatureTypeType, default initialized and not managed by a soap context
        virtual wfs__DescribeFeatureTypeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__DescribeFeatureTypeType); }
      public:
        /// Constructor with default initializations
        wfs__DescribeFeatureTypeType() : TypeName(), outputFormat("application/gml+xml; version=3.2") { }
        virtual ~wfs__DescribeFeatureTypeType() { }
        /// Friend allocator used by soap_new_wfs__DescribeFeatureTypeType(struct soap*, int)
        friend SOAP_FMAC1 wfs__DescribeFeatureTypeType * SOAP_FMAC2 soap_instantiate_wfs__DescribeFeatureTypeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:7190 */
#ifndef SOAP_TYPE__wfs__union_GetPropertyValueType
#define SOAP_TYPE__wfs__union_GetPropertyValueType (702)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _wfs__union_GetPropertyValueType
{
        #define SOAP_UNION__wfs__union_GetPropertyValueType_StoredQuery	(1)	/**< union variant selector value for member StoredQuery */
        wfs__StoredQueryType *StoredQuery;
        #define SOAP_UNION__wfs__union_GetPropertyValueType_StoredQuery_	(2)	/**< union variant selector value for member StoredQuery_ */
        wfs__StoredQueryType *StoredQuery_;
};
#endif

/* ws-inspire-wfs2.h:317 */
#ifndef SOAP_TYPE_wfs__GetPropertyValueType
#define SOAP_TYPE_wfs__GetPropertyValueType (68)
/* Type wfs__GetPropertyValueType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:GetPropertyValueType': */
class SOAP_CMAC wfs__GetPropertyValueType : public wfs__BaseRequestType {
      public:
        /// Union with union _wfs__union_GetPropertyValueType variant selector __unionAbstractQueryExpression set to one of: SOAP_UNION__wfs__union_GetPropertyValueType_StoredQuery SOAP_UNION__wfs__union_GetPropertyValueType_StoredQuery_
        int __unionAbstractQueryExpression;
        union _wfs__union_GetPropertyValueType union_GetPropertyValueType;
        /// Required attribute 'valueReference' of XML schema type 'xsd:string'
        std::string valueReference;
        /// Optional attribute 'resolvePath' of XML schema type 'xsd:string'
        std::string *resolvePath;
        /// Optional attribute 'startIndex' of XML schema type 'xsd:nonNegativeInteger'
        ULONG64 startIndex;
        /// Optional attribute 'count' of XML schema type 'xsd:nonNegativeInteger'
        ULONG64 *count;
        /// Optional attribute 'resultType' of XML schema type 'wfs:ResultTypeType'
        enum wfs__ResultTypeType resultType;	///< initialized with default value = (enum wfs__ResultTypeType)0
        /// Optional attribute 'outputFormat' of XML schema type 'xsd:string'
        std::string outputFormat;	///< initialized with default value = "application/gml+xml; version=3.2"
        /// Optional attribute 'resolve' of XML schema type 'wfs:ResolveValueType'
        enum wfs__ResolveValueType resolve;	///< initialized with default value = (enum wfs__ResolveValueType)3
        /// Optional attribute 'resolveDepth' of XML schema type 'wfs:positiveIntegerWithStar'
        std::string resolveDepth;	///< initialized with default value = "*"
        /// Optional attribute 'resolveTimeout' of XML schema type 'xsd:positiveInteger'
        ULONG64 resolveTimeout;
      public:
        /// Return unique type id SOAP_TYPE_wfs__GetPropertyValueType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__GetPropertyValueType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__GetPropertyValueType, default initialized and not managed by a soap context
        virtual wfs__GetPropertyValueType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__GetPropertyValueType); }
      public:
        /// Constructor with default initializations
        wfs__GetPropertyValueType() : __unionAbstractQueryExpression(), valueReference(), resolvePath(), startIndex(), count(), resultType((enum wfs__ResultTypeType)0), outputFormat("application/gml+xml; version=3.2"), resolve((enum wfs__ResolveValueType)3), resolveDepth("*"), resolveTimeout() { }
        virtual ~wfs__GetPropertyValueType() { }
        /// Friend allocator used by soap_new_wfs__GetPropertyValueType(struct soap*, int)
        friend SOAP_FMAC1 wfs__GetPropertyValueType * SOAP_FMAC2 soap_instantiate_wfs__GetPropertyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:7253 */
#ifndef SOAP_TYPE__wfs__union_GetFeatureType
#define SOAP_TYPE__wfs__union_GetFeatureType (704)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _wfs__union_GetFeatureType
{
        #define SOAP_UNION__wfs__union_GetFeatureType_StoredQuery	(1)	/**< union variant selector value for member StoredQuery */
        wfs__StoredQueryType *StoredQuery;
        #define SOAP_UNION__wfs__union_GetFeatureType_StoredQuery_	(2)	/**< union variant selector value for member StoredQuery_ */
        wfs__StoredQueryType *StoredQuery_;
};
#endif

/* ws-inspire-wfs2.h:7248 */
#ifndef SOAP_TYPE___wfs__union_GetFeatureType
#define SOAP_TYPE___wfs__union_GetFeatureType (703)
/* Wrapper: */
class SOAP_CMAC __wfs__union_GetFeatureType {
      public:
        /// Union with union _wfs__union_GetFeatureType variant selector __unionAbstractQueryExpression set to one of: SOAP_UNION__wfs__union_GetFeatureType_StoredQuery SOAP_UNION__wfs__union_GetFeatureType_StoredQuery_
        int __unionAbstractQueryExpression;
        union _wfs__union_GetFeatureType union_GetFeatureType;
      public:
        /// Return unique type id SOAP_TYPE___wfs__union_GetFeatureType
        virtual long soap_type(void) const { return SOAP_TYPE___wfs__union_GetFeatureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __wfs__union_GetFeatureType, default initialized and not managed by a soap context
        virtual __wfs__union_GetFeatureType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__wfs__union_GetFeatureType); }
      public:
        /// Constructor with default initializations
        __wfs__union_GetFeatureType() : __unionAbstractQueryExpression() { }
        virtual ~__wfs__union_GetFeatureType() { }
        /// Friend allocator used by soap_new___wfs__union_GetFeatureType(struct soap*, int)
        friend SOAP_FMAC1 __wfs__union_GetFeatureType * SOAP_FMAC2 soap_instantiate___wfs__union_GetFeatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:325 */
#ifndef SOAP_TYPE_wfs__GetFeatureType
#define SOAP_TYPE_wfs__GetFeatureType (72)
/* Type wfs__GetFeatureType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:GetFeatureType': */
class SOAP_CMAC wfs__GetFeatureType : public wfs__BaseRequestType {
      public:
        /// Sequence of elements '-union-GetFeatureType' of XML schema type '-wfs:union-GetFeatureType' stored in dynamic array __union_GetFeatureType of length __sizeAbstractQueryExpression
        int __sizeAbstractQueryExpression;
        __wfs__union_GetFeatureType *__union_GetFeatureType;
        /// Optional attribute 'startIndex' of XML schema type 'xsd:nonNegativeInteger'
        ULONG64 startIndex;
        /// Optional attribute 'count' of XML schema type 'xsd:nonNegativeInteger'
        ULONG64 *count;
        /// Optional attribute 'resultType' of XML schema type 'wfs:ResultTypeType'
        enum wfs__ResultTypeType resultType;	///< initialized with default value = (enum wfs__ResultTypeType)0
        /// Optional attribute 'outputFormat' of XML schema type 'xsd:string'
        std::string outputFormat;	///< initialized with default value = "application/gml+xml; version=3.2"
        /// Optional attribute 'resolve' of XML schema type 'wfs:ResolveValueType'
        enum wfs__ResolveValueType resolve;	///< initialized with default value = (enum wfs__ResolveValueType)3
        /// Optional attribute 'resolveDepth' of XML schema type 'wfs:positiveIntegerWithStar'
        std::string resolveDepth;	///< initialized with default value = "*"
        /// Optional attribute 'resolveTimeout' of XML schema type 'xsd:positiveInteger'
        ULONG64 resolveTimeout;
      public:
        /// Return unique type id SOAP_TYPE_wfs__GetFeatureType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__GetFeatureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__GetFeatureType, default initialized and not managed by a soap context
        virtual wfs__GetFeatureType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__GetFeatureType); }
      public:
        /// Constructor with default initializations
        wfs__GetFeatureType() : __sizeAbstractQueryExpression(), __union_GetFeatureType(), startIndex(), count(), resultType((enum wfs__ResultTypeType)0), outputFormat("application/gml+xml; version=3.2"), resolve((enum wfs__ResolveValueType)3), resolveDepth("*"), resolveTimeout() { }
        virtual ~wfs__GetFeatureType() { }
        /// Friend allocator used by soap_new_wfs__GetFeatureType(struct soap*, int)
        friend SOAP_FMAC1 wfs__GetFeatureType * SOAP_FMAC2 soap_instantiate_wfs__GetFeatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:329 */
#ifndef SOAP_TYPE_wfs__FeatureCollectionType
#define SOAP_TYPE_wfs__FeatureCollectionType (74)
/* Type wfs__FeatureCollectionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:FeatureCollectionType': */
class SOAP_CMAC wfs__FeatureCollectionType : public wfs__SimpleFeatureCollectionType {
      public:
        /// Optional element 'wfs:additionalObjects' of XML schema type 'wfs:additionalObjects'
        _wfs__additionalObjects *additionalObjects;
        /// Optional element 'wfs:truncatedResponse' of XML schema type 'wfs:truncatedResponse'
        _wfs__truncatedResponse *truncatedResponse;
        /// Optional attribute 'lockId' of XML schema type 'xsd:string'
        std::string *lockId;
        /// Required attribute 'timeStamp' of XML schema type 'xsd:dateTime'
        time_t timeStamp;
        /// Required attribute 'numberMatched' of XML schema type 'wfs:nonNegativeIntegerOrUnknown'
        std::string numberMatched;
        /// Required attribute 'numberReturned' of XML schema type 'xsd:nonNegativeInteger'
        ULONG64 numberReturned;
        /// Optional attribute 'next' of XML schema type 'xsd:anyURI'
        char **next;
        /// Optional attribute 'previous' of XML schema type 'xsd:anyURI'
        char **previous;
      public:
        /// Return unique type id SOAP_TYPE_wfs__FeatureCollectionType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__FeatureCollectionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__FeatureCollectionType, default initialized and not managed by a soap context
        virtual wfs__FeatureCollectionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__FeatureCollectionType); }
      public:
        /// Constructor with default initializations
        wfs__FeatureCollectionType() : additionalObjects(), truncatedResponse(), lockId(), timeStamp(), numberMatched(), numberReturned(), next(), previous() { }
        virtual ~wfs__FeatureCollectionType() { }
        /// Friend allocator used by soap_new_wfs__FeatureCollectionType(struct soap*, int)
        friend SOAP_FMAC1 wfs__FeatureCollectionType * SOAP_FMAC2 soap_instantiate_wfs__FeatureCollectionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:335 */
#ifndef SOAP_TYPE_wfs__ListStoredQueriesType
#define SOAP_TYPE_wfs__ListStoredQueriesType (77)
/* Type wfs__ListStoredQueriesType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'wfs:ListStoredQueriesType': */
class SOAP_CMAC wfs__ListStoredQueriesType : public wfs__BaseRequestType {
      public:
        /// Return unique type id SOAP_TYPE_wfs__ListStoredQueriesType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__ListStoredQueriesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__ListStoredQueriesType, default initialized and not managed by a soap context
        virtual wfs__ListStoredQueriesType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__ListStoredQueriesType); }
      public:
        /// Constructor with default initializations
        wfs__ListStoredQueriesType() { }
        virtual ~wfs__ListStoredQueriesType() { }
        /// Friend allocator used by soap_new_wfs__ListStoredQueriesType(struct soap*, int)
        friend SOAP_FMAC1 wfs__ListStoredQueriesType * SOAP_FMAC2 soap_instantiate_wfs__ListStoredQueriesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:341 */
#ifndef SOAP_TYPE_wfs__DescribeStoredQueriesType
#define SOAP_TYPE_wfs__DescribeStoredQueriesType (80)
/* Type wfs__DescribeStoredQueriesType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:DescribeStoredQueriesType': */
class SOAP_CMAC wfs__DescribeStoredQueriesType : public wfs__BaseRequestType {
      public:
        /// Optional element 'wfs:StoredQueryId' of XML schema type 'xsd:anyURI'
        std::vector<char *> StoredQueryId;
      public:
        /// Return unique type id SOAP_TYPE_wfs__DescribeStoredQueriesType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__DescribeStoredQueriesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__DescribeStoredQueriesType, default initialized and not managed by a soap context
        virtual wfs__DescribeStoredQueriesType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__DescribeStoredQueriesType); }
      public:
        /// Constructor with default initializations
        wfs__DescribeStoredQueriesType() : StoredQueryId() { }
        virtual ~wfs__DescribeStoredQueriesType() { }
        /// Friend allocator used by soap_new_wfs__DescribeStoredQueriesType(struct soap*, int)
        friend SOAP_FMAC1 wfs__DescribeStoredQueriesType * SOAP_FMAC2 soap_instantiate_wfs__DescribeStoredQueriesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:347 */
#ifndef SOAP_TYPE_wfs__CreateStoredQueryType
#define SOAP_TYPE_wfs__CreateStoredQueryType (83)
/* Type wfs__CreateStoredQueryType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:CreateStoredQueryType': */
class SOAP_CMAC wfs__CreateStoredQueryType : public wfs__BaseRequestType {
      public:
        /// Optional element 'wfs:StoredQueryDefinition' of XML schema type 'wfs:StoredQueryDescriptionType'
        std::vector<wfs__StoredQueryDescriptionType *> StoredQueryDefinition;
      public:
        /// Return unique type id SOAP_TYPE_wfs__CreateStoredQueryType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__CreateStoredQueryType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__CreateStoredQueryType, default initialized and not managed by a soap context
        virtual wfs__CreateStoredQueryType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__CreateStoredQueryType); }
      public:
        /// Constructor with default initializations
        wfs__CreateStoredQueryType() : StoredQueryDefinition() { }
        virtual ~wfs__CreateStoredQueryType() { }
        /// Friend allocator used by soap_new_wfs__CreateStoredQueryType(struct soap*, int)
        friend SOAP_FMAC1 wfs__CreateStoredQueryType * SOAP_FMAC2 soap_instantiate_wfs__CreateStoredQueryType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:355 */
#ifndef SOAP_TYPE_wfs__CreateStoredQueryResponseType
#define SOAP_TYPE_wfs__CreateStoredQueryResponseType (87)
/* Type wfs__CreateStoredQueryResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'wfs:CreateStoredQueryResponseType': */
class SOAP_CMAC wfs__CreateStoredQueryResponseType : public wfs__ExecutionStatusType {
      public:
        /// Return unique type id SOAP_TYPE_wfs__CreateStoredQueryResponseType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__CreateStoredQueryResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__CreateStoredQueryResponseType, default initialized and not managed by a soap context
        virtual wfs__CreateStoredQueryResponseType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__CreateStoredQueryResponseType); }
      public:
        /// Constructor with default initializations
        wfs__CreateStoredQueryResponseType() { }
        virtual ~wfs__CreateStoredQueryResponseType() { }
        /// Friend allocator used by soap_new_wfs__CreateStoredQueryResponseType(struct soap*, int)
        friend SOAP_FMAC1 wfs__CreateStoredQueryResponseType * SOAP_FMAC2 soap_instantiate_wfs__CreateStoredQueryResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:7454 */
#ifndef SOAP_TYPE__wfs__union_LockFeatureType
#define SOAP_TYPE__wfs__union_LockFeatureType (708)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _wfs__union_LockFeatureType
{
        #define SOAP_UNION__wfs__union_LockFeatureType_StoredQuery	(1)	/**< union variant selector value for member StoredQuery */
        wfs__StoredQueryType *StoredQuery;
        #define SOAP_UNION__wfs__union_LockFeatureType_StoredQuery_	(2)	/**< union variant selector value for member StoredQuery_ */
        wfs__StoredQueryType *StoredQuery_;
};
#endif

/* ws-inspire-wfs2.h:7449 */
#ifndef SOAP_TYPE___wfs__union_LockFeatureType
#define SOAP_TYPE___wfs__union_LockFeatureType (707)
/* Wrapper: */
class SOAP_CMAC __wfs__union_LockFeatureType {
      public:
        /// Union with union _wfs__union_LockFeatureType variant selector __unionAbstractQueryExpression set to one of: SOAP_UNION__wfs__union_LockFeatureType_StoredQuery SOAP_UNION__wfs__union_LockFeatureType_StoredQuery_
        int __unionAbstractQueryExpression;
        union _wfs__union_LockFeatureType union_LockFeatureType;
      public:
        /// Return unique type id SOAP_TYPE___wfs__union_LockFeatureType
        virtual long soap_type(void) const { return SOAP_TYPE___wfs__union_LockFeatureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __wfs__union_LockFeatureType, default initialized and not managed by a soap context
        virtual __wfs__union_LockFeatureType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__wfs__union_LockFeatureType); }
      public:
        /// Constructor with default initializations
        __wfs__union_LockFeatureType() : __unionAbstractQueryExpression() { }
        virtual ~__wfs__union_LockFeatureType() { }
        /// Friend allocator used by soap_new___wfs__union_LockFeatureType(struct soap*, int)
        friend SOAP_FMAC1 __wfs__union_LockFeatureType * SOAP_FMAC2 soap_instantiate___wfs__union_LockFeatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:357 */
#ifndef SOAP_TYPE_wfs__LockFeatureType
#define SOAP_TYPE_wfs__LockFeatureType (88)
/* Type wfs__LockFeatureType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:LockFeatureType': */
class SOAP_CMAC wfs__LockFeatureType : public wfs__BaseRequestType {
      public:
        /// Sequence of elements '-union-LockFeatureType' of XML schema type '-wfs:union-LockFeatureType' stored in dynamic array __union_LockFeatureType of length __sizeAbstractQueryExpression
        int __sizeAbstractQueryExpression;
        __wfs__union_LockFeatureType *__union_LockFeatureType;
        /// Optional attribute 'lockId' of XML schema type 'xsd:string'
        std::string *lockId;
        /// Optional attribute 'expiry' of XML schema type 'xsd:positiveInteger'
        ULONG64 expiry;
        /// Optional attribute 'lockAction' of XML schema type 'wfs:AllSomeType'
        enum wfs__AllSomeType lockAction;	///< initialized with default value = (enum wfs__AllSomeType)0
      public:
        /// Return unique type id SOAP_TYPE_wfs__LockFeatureType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__LockFeatureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__LockFeatureType, default initialized and not managed by a soap context
        virtual wfs__LockFeatureType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__LockFeatureType); }
      public:
        /// Constructor with default initializations
        wfs__LockFeatureType() : __sizeAbstractQueryExpression(), __union_LockFeatureType(), lockId(), expiry(), lockAction((enum wfs__AllSomeType)0) { }
        virtual ~wfs__LockFeatureType() { }
        /// Friend allocator used by soap_new_wfs__LockFeatureType(struct soap*, int)
        friend SOAP_FMAC1 wfs__LockFeatureType * SOAP_FMAC2 soap_instantiate_wfs__LockFeatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:7503 */
#ifndef SOAP_TYPE__wfs__union_TransactionType
#define SOAP_TYPE__wfs__union_TransactionType (711)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _wfs__union_TransactionType
{
        #define SOAP_UNION__wfs__union_TransactionType_Insert	(1)	/**< union variant selector value for member Insert */
        wfs__InsertType *Insert;
        #define SOAP_UNION__wfs__union_TransactionType_Update	(2)	/**< union variant selector value for member Update */
        wfs__UpdateType *Update;
        #define SOAP_UNION__wfs__union_TransactionType_Replace	(3)	/**< union variant selector value for member Replace */
        wfs__ReplaceType *Replace;
        #define SOAP_UNION__wfs__union_TransactionType_Delete	(4)	/**< union variant selector value for member Delete */
        wfs__DeleteType *Delete;
        #define SOAP_UNION__wfs__union_TransactionType_Native	(5)	/**< union variant selector value for member Native */
        wfs__NativeType *Native;
};
#endif

/* ws-inspire-wfs2.h:7496 */
#ifndef SOAP_TYPE___wfs__TransactionType_sequence
#define SOAP_TYPE___wfs__TransactionType_sequence (710)
/* Wrapper: */
struct SOAP_CMAC __wfs__TransactionType_sequence {
      public:
        /** Union with union _wfs__union_TransactionType variant selector __unionAbstractTransactionAction set to one of: SOAP_UNION__wfs__union_TransactionType_Insert SOAP_UNION__wfs__union_TransactionType_Update SOAP_UNION__wfs__union_TransactionType_Replace SOAP_UNION__wfs__union_TransactionType_Delete SOAP_UNION__wfs__union_TransactionType_Native */
        int __unionAbstractTransactionAction;
        union _wfs__union_TransactionType union_TransactionType;
      public:
        /** Return unique type id SOAP_TYPE___wfs__TransactionType_sequence */
        long soap_type() const { return SOAP_TYPE___wfs__TransactionType_sequence; }
        /** Constructor with member initializations */
        __wfs__TransactionType_sequence() : __unionAbstractTransactionAction() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wfs__TransactionType_sequence * SOAP_FMAC2 soap_instantiate___wfs__TransactionType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:365 */
#ifndef SOAP_TYPE_wfs__TransactionType
#define SOAP_TYPE_wfs__TransactionType (92)
/* Type wfs__TransactionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:TransactionType': */
class SOAP_CMAC wfs__TransactionType : public wfs__BaseRequestType {
      public:
        std::vector<struct __wfs__TransactionType_sequence> __TransactionType_sequence;
        /// Optional attribute 'lockId' of XML schema type 'xsd:string'
        std::string *lockId;
        /// Optional attribute 'releaseAction' of XML schema type 'wfs:AllSomeType'
        enum wfs__AllSomeType releaseAction;	///< initialized with default value = (enum wfs__AllSomeType)0
        /// Optional attribute 'srsName' of XML schema type 'xsd:anyURI'
        char **srsName;
      public:
        /// Return unique type id SOAP_TYPE_wfs__TransactionType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__TransactionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__TransactionType, default initialized and not managed by a soap context
        virtual wfs__TransactionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__TransactionType); }
      public:
        /// Constructor with default initializations
        wfs__TransactionType() : __TransactionType_sequence(), lockId(), releaseAction((enum wfs__AllSomeType)0), srsName() { }
        virtual ~wfs__TransactionType() { }
        /// Friend allocator used by soap_new_wfs__TransactionType(struct soap*, int)
        friend SOAP_FMAC1 wfs__TransactionType * SOAP_FMAC2 soap_instantiate_wfs__TransactionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:369 */
#ifndef SOAP_TYPE_wfs__InsertType
#define SOAP_TYPE_wfs__InsertType (94)
/* Type wfs__InsertType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:InsertType': */
class SOAP_CMAC wfs__InsertType : public wfs__AbstractTransactionActionType {
      public:
        std::vector<char *> __any;
        /// Optional attribute 'inputFormat' of XML schema type 'xsd:string'
        std::string inputFormat;	///< initialized with default value = "application/gml+xml; version=3.2"
        /// Optional attribute 'srsName' of XML schema type 'xsd:anyURI'
        char **srsName;
      public:
        /// Return unique type id SOAP_TYPE_wfs__InsertType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__InsertType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__InsertType, default initialized and not managed by a soap context
        virtual wfs__InsertType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__InsertType); }
      public:
        /// Constructor with default initializations
        wfs__InsertType() : __any(), inputFormat("application/gml+xml; version=3.2"), srsName() { }
        virtual ~wfs__InsertType() { }
        /// Friend allocator used by soap_new_wfs__InsertType(struct soap*, int)
        friend SOAP_FMAC1 wfs__InsertType * SOAP_FMAC2 soap_instantiate_wfs__InsertType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:371 */
#ifndef SOAP_TYPE_wfs__UpdateType
#define SOAP_TYPE_wfs__UpdateType (95)
/* Type wfs__UpdateType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:UpdateType': */
class SOAP_CMAC wfs__UpdateType : public wfs__AbstractTransactionActionType {
      public:
        /// Required element 'wfs:Property' of XML schema type 'wfs:PropertyType'
        std::vector<wfs__PropertyType *> Property;
        /// Optional element 'fes:Filter' of XML schema type 'fes:FilterType'
        fes__FilterType *fes__Filter;
        /// Required attribute 'typeName' of XML schema type 'xsd:QName'
        char *typeName;
        /// Optional attribute 'inputFormat' of XML schema type 'xsd:string'
        std::string inputFormat;	///< initialized with default value = "application/gml+xml; version=3.2"
        /// Optional attribute 'srsName' of XML schema type 'xsd:anyURI'
        char **srsName;
      public:
        /// Return unique type id SOAP_TYPE_wfs__UpdateType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__UpdateType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__UpdateType, default initialized and not managed by a soap context
        virtual wfs__UpdateType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__UpdateType); }
      public:
        /// Constructor with default initializations
        wfs__UpdateType() : Property(), fes__Filter(), typeName(), inputFormat("application/gml+xml; version=3.2"), srsName() { }
        virtual ~wfs__UpdateType() { }
        /// Friend allocator used by soap_new_wfs__UpdateType(struct soap*, int)
        friend SOAP_FMAC1 wfs__UpdateType * SOAP_FMAC2 soap_instantiate_wfs__UpdateType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:375 */
#ifndef SOAP_TYPE_wfs__ReplaceType
#define SOAP_TYPE_wfs__ReplaceType (97)
/* Type wfs__ReplaceType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:ReplaceType': */
class SOAP_CMAC wfs__ReplaceType : public wfs__AbstractTransactionActionType {
      public:
        char *__any;
        /// Required element 'fes:Filter' of XML schema type 'fes:FilterType'
        fes__FilterType *fes__Filter;
        /// Optional attribute 'inputFormat' of XML schema type 'xsd:string'
        std::string inputFormat;	///< initialized with default value = "application/gml+xml; version=3.2"
        /// Optional attribute 'srsName' of XML schema type 'xsd:anyURI'
        char **srsName;
      public:
        /// Return unique type id SOAP_TYPE_wfs__ReplaceType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__ReplaceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__ReplaceType, default initialized and not managed by a soap context
        virtual wfs__ReplaceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__ReplaceType); }
      public:
        /// Constructor with default initializations
        wfs__ReplaceType() : __any(), fes__Filter(), inputFormat("application/gml+xml; version=3.2"), srsName() { }
        virtual ~wfs__ReplaceType() { }
        /// Friend allocator used by soap_new_wfs__ReplaceType(struct soap*, int)
        friend SOAP_FMAC1 wfs__ReplaceType * SOAP_FMAC2 soap_instantiate_wfs__ReplaceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:377 */
#ifndef SOAP_TYPE_wfs__DeleteType
#define SOAP_TYPE_wfs__DeleteType (98)
/* Type wfs__DeleteType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:DeleteType': */
class SOAP_CMAC wfs__DeleteType : public wfs__AbstractTransactionActionType {
      public:
        /// Required element 'fes:Filter' of XML schema type 'fes:FilterType'
        fes__FilterType *fes__Filter;
        /// Required attribute 'typeName' of XML schema type 'xsd:QName'
        char *typeName;
      public:
        /// Return unique type id SOAP_TYPE_wfs__DeleteType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__DeleteType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__DeleteType, default initialized and not managed by a soap context
        virtual wfs__DeleteType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__DeleteType); }
      public:
        /// Constructor with default initializations
        wfs__DeleteType() : fes__Filter(), typeName() { }
        virtual ~wfs__DeleteType() { }
        /// Friend allocator used by soap_new_wfs__DeleteType(struct soap*, int)
        friend SOAP_FMAC1 wfs__DeleteType * SOAP_FMAC2 soap_instantiate_wfs__DeleteType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:379 */
#ifndef SOAP_TYPE_wfs__NativeType
#define SOAP_TYPE_wfs__NativeType (99)
/* Type wfs__NativeType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:NativeType': */
class SOAP_CMAC wfs__NativeType : public wfs__AbstractTransactionActionType {
      public:
        char *__any;
        /// Required attribute 'vendorId' of XML schema type 'xsd:string'
        std::string vendorId;
        /// Required attribute 'safeToIgnore' of XML schema type 'xsd:boolean'
        bool safeToIgnore;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_wfs__NativeType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__NativeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__NativeType, default initialized and not managed by a soap context
        virtual wfs__NativeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__NativeType); }
      public:
        /// Constructor with default initializations
        wfs__NativeType() : __any(), vendorId(), safeToIgnore(), __mixed() { }
        virtual ~wfs__NativeType() { }
        /// Friend allocator used by soap_new_wfs__NativeType(struct soap*, int)
        friend SOAP_FMAC1 wfs__NativeType * SOAP_FMAC2 soap_instantiate_wfs__NativeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:391 */
#ifndef SOAP_TYPE__wfs__Title
#define SOAP_TYPE__wfs__Title (105)
/* simple XML schema type 'wfs:Title': */
class SOAP_CMAC _wfs__Title {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'xml:lang' of XML schema type 'xml:lang'
        char *xml__lang;	///< initialized with default value = (char*)"en"
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wfs__Title
        virtual long soap_type(void) const { return SOAP_TYPE__wfs__Title; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wfs__Title, default initialized and not managed by a soap context
        virtual _wfs__Title *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wfs__Title); }
      public:
        /// Constructor with default initializations
        _wfs__Title() : __item(), xml__lang((char*)"en"), soap() { }
        virtual ~_wfs__Title() { }
        /// Friend allocator used by soap_new__wfs__Title(struct soap*, int)
        friend SOAP_FMAC1 _wfs__Title * SOAP_FMAC2 soap_instantiate__wfs__Title(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:393 */
#ifndef SOAP_TYPE__wfs__Abstract
#define SOAP_TYPE__wfs__Abstract (106)
/* simple XML schema type 'wfs:Abstract': */
class SOAP_CMAC _wfs__Abstract {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'xml:lang' of XML schema type 'xml:lang'
        char *xml__lang;	///< initialized with default value = (char*)"en"
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wfs__Abstract
        virtual long soap_type(void) const { return SOAP_TYPE__wfs__Abstract; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wfs__Abstract, default initialized and not managed by a soap context
        virtual _wfs__Abstract *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wfs__Abstract); }
      public:
        /// Constructor with default initializations
        _wfs__Abstract() : __item(), xml__lang((char*)"en"), soap() { }
        virtual ~_wfs__Abstract() { }
        /// Friend allocator used by soap_new__wfs__Abstract(struct soap*, int)
        friend SOAP_FMAC1 _wfs__Abstract * SOAP_FMAC2 soap_instantiate__wfs__Abstract(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:399 */
#ifndef SOAP_TYPE__wfs__PropertyName
#define SOAP_TYPE__wfs__PropertyName (109)
/* simple XML schema type 'wfs:PropertyName': */
class SOAP_CMAC _wfs__PropertyName {
      public:
        /// Simple content of XML schema type 'xsd:QName' wrapped by this struct
        char *__item;
        /// Optional attribute 'resolvePath' of XML schema type 'xsd:string'
        std::string *resolvePath;
        /// Optional attribute 'resolve' of XML schema type 'wfs:ResolveValueType'
        enum wfs__ResolveValueType resolve;	///< initialized with default value = (enum wfs__ResolveValueType)3
        /// Optional attribute 'resolveDepth' of XML schema type 'wfs:positiveIntegerWithStar'
        std::string resolveDepth;	///< initialized with default value = "*"
        /// Optional attribute 'resolveTimeout' of XML schema type 'xsd:positiveInteger'
        ULONG64 resolveTimeout;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wfs__PropertyName
        virtual long soap_type(void) const { return SOAP_TYPE__wfs__PropertyName; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wfs__PropertyName, default initialized and not managed by a soap context
        virtual _wfs__PropertyName *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wfs__PropertyName); }
      public:
        /// Constructor with default initializations
        _wfs__PropertyName() : __item(), resolvePath(), resolve((enum wfs__ResolveValueType)3), resolveDepth("*"), resolveTimeout(), soap() { }
        virtual ~_wfs__PropertyName() { }
        /// Friend allocator used by soap_new__wfs__PropertyName(struct soap*, int)
        friend SOAP_FMAC1 _wfs__PropertyName * SOAP_FMAC2 soap_instantiate__wfs__PropertyName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:403 */
#ifndef SOAP_TYPE__wfs__DropStoredQuery
#define SOAP_TYPE__wfs__DropStoredQuery (111)
/* Type _wfs__DropStoredQuery is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'wfs:DropStoredQuery': */
class SOAP_CMAC _wfs__DropStoredQuery : public wfs__BaseRequestType {
      public:
        /// Required attribute 'id' of XML schema type 'xsd:anyURI'
        char *id;
      public:
        /// Return unique type id SOAP_TYPE__wfs__DropStoredQuery
        virtual long soap_type(void) const { return SOAP_TYPE__wfs__DropStoredQuery; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wfs__DropStoredQuery, default initialized and not managed by a soap context
        virtual _wfs__DropStoredQuery *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wfs__DropStoredQuery); }
      public:
        /// Constructor with default initializations
        _wfs__DropStoredQuery() : id() { }
        virtual ~_wfs__DropStoredQuery() { }
        /// Friend allocator used by soap_new__wfs__DropStoredQuery(struct soap*, int)
        friend SOAP_FMAC1 _wfs__DropStoredQuery * SOAP_FMAC2 soap_instantiate__wfs__DropStoredQuery(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:413 */
#ifndef SOAP_TYPE_ows__BasicIdentificationType
#define SOAP_TYPE_ows__BasicIdentificationType (116)
/* complex XML schema type 'ows:BasicIdentificationType': */
class SOAP_CMAC ows__BasicIdentificationType : public ows__DescriptionType {
      public:
        /// Optional element 'ows:Identifier' of XML schema type 'ows:CodeType'
        ows__CodeType *Identifier;
        /// Optional element 'ows:Metadata' of XML schema type 'ows:MetadataType'
        std::vector<ows__MetadataType *> Metadata;
      public:
        /// Return unique type id SOAP_TYPE_ows__BasicIdentificationType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__BasicIdentificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__BasicIdentificationType, default initialized and not managed by a soap context
        virtual ows__BasicIdentificationType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__BasicIdentificationType); }
      public:
        /// Constructor with default initializations
        ows__BasicIdentificationType() : Identifier(), Metadata() { }
        virtual ~ows__BasicIdentificationType() { }
        /// Friend allocator used by soap_new_ows__BasicIdentificationType(struct soap*, int)
        friend SOAP_FMAC1 ows__BasicIdentificationType * SOAP_FMAC2 soap_instantiate_ows__BasicIdentificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:421 */
#ifndef SOAP_TYPE_ows__WGS84BoundingBoxType
#define SOAP_TYPE_ows__WGS84BoundingBoxType (120)
/* Type ows__WGS84BoundingBoxType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:WGS84BoundingBoxType': */
class SOAP_CMAC ows__WGS84BoundingBoxType : public xsd__anyType {
      public:
        /// Required element 'ows:LowerCorner' of XML schema type 'ows:PositionType2D'
        std::string LowerCorner;
        /// Required element 'ows:UpperCorner' of XML schema type 'ows:PositionType2D'
        std::string UpperCorner;
        /// Optional attribute 'crs' of XML schema type 'xsd:anyURI'
        char *crs;
        /// Optional attribute 'dimensions' of XML schema type 'xsd:positiveInteger'
        ULONG64 dimensions;
      public:
        /// Return unique type id SOAP_TYPE_ows__WGS84BoundingBoxType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__WGS84BoundingBoxType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__WGS84BoundingBoxType, default initialized and not managed by a soap context
        virtual ows__WGS84BoundingBoxType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__WGS84BoundingBoxType); }
      public:
        /// Constructor with default initializations
        ows__WGS84BoundingBoxType() : LowerCorner(), UpperCorner(), crs(), dimensions() { }
        virtual ~ows__WGS84BoundingBoxType() { }
        /// Friend allocator used by soap_new_ows__WGS84BoundingBoxType(struct soap*, int)
        friend SOAP_FMAC1 ows__WGS84BoundingBoxType * SOAP_FMAC2 soap_instantiate_ows__WGS84BoundingBoxType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:423 */
#ifndef SOAP_TYPE_ows__LanguageStringType
#define SOAP_TYPE_ows__LanguageStringType (121)
/* simple XML schema type 'ows:LanguageStringType': */
class SOAP_CMAC ows__LanguageStringType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'xml:lang' of XML schema type 'xml:lang'
        char **xml__lang;
      public:
        /// Return unique type id SOAP_TYPE_ows__LanguageStringType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__LanguageStringType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__LanguageStringType, default initialized and not managed by a soap context
        virtual ows__LanguageStringType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__LanguageStringType); }
      public:
        /// Constructor with default initializations
        ows__LanguageStringType() : __item(), xml__lang() { }
        virtual ~ows__LanguageStringType() { }
        /// Friend allocator used by soap_new_ows__LanguageStringType(struct soap*, int)
        friend SOAP_FMAC1 ows__LanguageStringType * SOAP_FMAC2 soap_instantiate_ows__LanguageStringType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:427 */
#ifndef SOAP_TYPE_ows__CodeType
#define SOAP_TYPE_ows__CodeType (123)
/* simple XML schema type 'ows:CodeType': */
class SOAP_CMAC ows__CodeType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'codeSpace' of XML schema type 'xsd:anyURI'
        char **codeSpace;
      public:
        /// Return unique type id SOAP_TYPE_ows__CodeType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__CodeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__CodeType, default initialized and not managed by a soap context
        virtual ows__CodeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__CodeType); }
      public:
        /// Constructor with default initializations
        ows__CodeType() : __item(), codeSpace() { }
        virtual ~ows__CodeType() { }
        /// Friend allocator used by soap_new_ows__CodeType(struct soap*, int)
        friend SOAP_FMAC1 ows__CodeType * SOAP_FMAC2 soap_instantiate_ows__CodeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:451 */
#ifndef SOAP_TYPE_ows__RequestMethodType
#define SOAP_TYPE_ows__RequestMethodType (135)
/* Type ows__RequestMethodType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:RequestMethodType': */
class SOAP_CMAC ows__RequestMethodType : public ows__OnlineResourceType {
      public:
        /// Optional element 'ows:Constraint' of XML schema type 'ows:DomainType'
        std::vector<ows__DomainType *> Constraint;
      public:
        /// Return unique type id SOAP_TYPE_ows__RequestMethodType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__RequestMethodType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__RequestMethodType, default initialized and not managed by a soap context
        virtual ows__RequestMethodType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__RequestMethodType); }
      public:
        /// Constructor with default initializations
        ows__RequestMethodType() : Constraint() { }
        virtual ~ows__RequestMethodType() { }
        /// Friend allocator used by soap_new_ows__RequestMethodType(struct soap*, int)
        friend SOAP_FMAC1 ows__RequestMethodType * SOAP_FMAC2 soap_instantiate_ows__RequestMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:453 */
#ifndef SOAP_TYPE_ows__DomainType
#define SOAP_TYPE_ows__DomainType (136)
/* Type ows__DomainType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:DomainType': */
class SOAP_CMAC ows__DomainType : public ows__UnNamedDomainType {
      public:
        /// Required attribute 'name' of XML schema type 'xsd:string'
        std::string name;
      public:
        /// Return unique type id SOAP_TYPE_ows__DomainType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__DomainType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__DomainType, default initialized and not managed by a soap context
        virtual ows__DomainType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__DomainType); }
      public:
        /// Constructor with default initializations
        ows__DomainType() : name() { }
        virtual ~ows__DomainType() { }
        /// Friend allocator used by soap_new_ows__DomainType(struct soap*, int)
        friend SOAP_FMAC1 ows__DomainType * SOAP_FMAC2 soap_instantiate_ows__DomainType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:457 */
#ifndef SOAP_TYPE_ows__ValueType
#define SOAP_TYPE_ows__ValueType (138)
/* Type ows__ValueType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'ows:ValueType': */
class SOAP_CMAC ows__ValueType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_ows__ValueType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__ValueType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__ValueType, default initialized and not managed by a soap context
        virtual ows__ValueType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__ValueType); }
      public:
        /// Constructor with default initializations
        ows__ValueType() : __item() { }
        virtual ~ows__ValueType() { }
        /// Friend allocator used by soap_new_ows__ValueType(struct soap*, int)
        friend SOAP_FMAC1 ows__ValueType * SOAP_FMAC2 soap_instantiate_ows__ValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:461 */
#ifndef SOAP_TYPE_ows__DomainMetadataType
#define SOAP_TYPE_ows__DomainMetadataType (140)
/* Type ows__DomainMetadataType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'ows:DomainMetadataType': */
class SOAP_CMAC ows__DomainMetadataType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'ows:reference' of XML schema type 'xsd:anyURI'
        char **ows__reference;
      public:
        /// Return unique type id SOAP_TYPE_ows__DomainMetadataType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__DomainMetadataType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__DomainMetadataType, default initialized and not managed by a soap context
        virtual ows__DomainMetadataType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__DomainMetadataType); }
      public:
        /// Constructor with default initializations
        ows__DomainMetadataType() : __item(), ows__reference() { }
        virtual ~ows__DomainMetadataType() { }
        /// Friend allocator used by soap_new_ows__DomainMetadataType(struct soap*, int)
        friend SOAP_FMAC1 ows__DomainMetadataType * SOAP_FMAC2 soap_instantiate_ows__DomainMetadataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:8261 */
#ifndef SOAP_TYPE__ows__union_DatasetDescriptionSummaryBaseType
#define SOAP_TYPE__ows__union_DatasetDescriptionSummaryBaseType (722)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ows__union_DatasetDescriptionSummaryBaseType
{
        #define SOAP_UNION__ows__union_DatasetDescriptionSummaryBaseType_BoundingBox	(1)	/**< union variant selector value for member BoundingBox */
        std::vector<ows__BoundingBoxType *> *BoundingBox;
        #define SOAP_UNION__ows__union_DatasetDescriptionSummaryBaseType_WGS84BoundingBox_	(2)	/**< union variant selector value for member WGS84BoundingBox_ */
        ows__WGS84BoundingBoxType *WGS84BoundingBox_;
};
#endif

/* ws-inspire-wfs2.h:8256 */
#ifndef SOAP_TYPE___ows__union_DatasetDescriptionSummaryBaseType
#define SOAP_TYPE___ows__union_DatasetDescriptionSummaryBaseType (721)
/* Wrapper: */
class SOAP_CMAC __ows__union_DatasetDescriptionSummaryBaseType {
      public:
        /// Union with union _ows__union_DatasetDescriptionSummaryBaseType variant selector __unionBoundingBox set to one of: SOAP_UNION__ows__union_DatasetDescriptionSummaryBaseType_BoundingBox SOAP_UNION__ows__union_DatasetDescriptionSummaryBaseType_WGS84BoundingBox_
        int __unionBoundingBox;
        union _ows__union_DatasetDescriptionSummaryBaseType union_DatasetDescriptionSummaryBaseType;
      public:
        /// Return unique type id SOAP_TYPE___ows__union_DatasetDescriptionSummaryBaseType
        virtual long soap_type(void) const { return SOAP_TYPE___ows__union_DatasetDescriptionSummaryBaseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __ows__union_DatasetDescriptionSummaryBaseType, default initialized and not managed by a soap context
        virtual __ows__union_DatasetDescriptionSummaryBaseType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__ows__union_DatasetDescriptionSummaryBaseType); }
      public:
        /// Constructor with default initializations
        __ows__union_DatasetDescriptionSummaryBaseType() : __unionBoundingBox() { }
        virtual ~__ows__union_DatasetDescriptionSummaryBaseType() { }
        /// Friend allocator used by soap_new___ows__union_DatasetDescriptionSummaryBaseType(struct soap*, int)
        friend SOAP_FMAC1 __ows__union_DatasetDescriptionSummaryBaseType * SOAP_FMAC2 soap_instantiate___ows__union_DatasetDescriptionSummaryBaseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:465 */
#ifndef SOAP_TYPE_ows__DatasetDescriptionSummaryBaseType
#define SOAP_TYPE_ows__DatasetDescriptionSummaryBaseType (142)
/* Type ows__DatasetDescriptionSummaryBaseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:DatasetDescriptionSummaryBaseType': */
class SOAP_CMAC ows__DatasetDescriptionSummaryBaseType : public ows__DescriptionType {
      public:
        /// Optional element 'ows:WGS84BoundingBox' of XML schema type 'ows:WGS84BoundingBoxType'
        std::vector<ows__WGS84BoundingBoxType *> WGS84BoundingBox;
        /// Required element 'ows:Identifier' of XML schema type 'ows:CodeType'
        ows__CodeType *Identifier;
        /// Sequence of elements '-union-DatasetDescriptionSummaryBaseType' of XML schema type '-ows:union-DatasetDescriptionSummaryBaseType' stored in dynamic array __union_DatasetDescriptionSummaryBaseType of length __sizeBoundingBox
        int __sizeBoundingBox;
        __ows__union_DatasetDescriptionSummaryBaseType *__union_DatasetDescriptionSummaryBaseType;
        /// Optional element 'ows:Metadata' of XML schema type 'ows:MetadataType'
        std::vector<ows__MetadataType *> Metadata;
        /// Optional element 'ows:DatasetDescriptionSummary' of XML schema type 'ows:DatasetDescriptionSummaryBaseType'
        std::vector<ows__DatasetDescriptionSummaryBaseType *> DatasetDescriptionSummary;
      public:
        /// Return unique type id SOAP_TYPE_ows__DatasetDescriptionSummaryBaseType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__DatasetDescriptionSummaryBaseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__DatasetDescriptionSummaryBaseType, default initialized and not managed by a soap context
        virtual ows__DatasetDescriptionSummaryBaseType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__DatasetDescriptionSummaryBaseType); }
      public:
        /// Constructor with default initializations
        ows__DatasetDescriptionSummaryBaseType() : WGS84BoundingBox(), Identifier(), __sizeBoundingBox(), __union_DatasetDescriptionSummaryBaseType(), Metadata(), DatasetDescriptionSummary() { }
        virtual ~ows__DatasetDescriptionSummaryBaseType() { }
        /// Friend allocator used by soap_new_ows__DatasetDescriptionSummaryBaseType(struct soap*, int)
        friend SOAP_FMAC1 ows__DatasetDescriptionSummaryBaseType * SOAP_FMAC2 soap_instantiate_ows__DatasetDescriptionSummaryBaseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:471 */
#ifndef SOAP_TYPE_ows__ReferenceType
#define SOAP_TYPE_ows__ReferenceType (145)
/* complex XML schema type 'ows:ReferenceType': */
class SOAP_CMAC ows__ReferenceType : public ows__AbstractReferenceBaseType {
      public:
        /// Optional element 'ows:Identifier' of XML schema type 'ows:CodeType'
        ows__CodeType *Identifier;
        /// Optional element 'ows:Abstract' of XML schema type 'ows:LanguageStringType'
        std::vector<ows__LanguageStringType *> Abstract;
        /// Optional element 'ows:Format' of XML schema type 'ows:MimeType'
        std::string *Format;
        /// Optional element 'ows:Metadata' of XML schema type 'ows:MetadataType'
        std::vector<ows__MetadataType *> Metadata;
      public:
        /// Return unique type id SOAP_TYPE_ows__ReferenceType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__ReferenceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__ReferenceType, default initialized and not managed by a soap context
        virtual ows__ReferenceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__ReferenceType); }
      public:
        /// Constructor with default initializations
        ows__ReferenceType() : Identifier(), Abstract(), Format(), Metadata() { }
        virtual ~ows__ReferenceType() { }
        /// Friend allocator used by soap_new_ows__ReferenceType(struct soap*, int)
        friend SOAP_FMAC1 ows__ReferenceType * SOAP_FMAC2 soap_instantiate_ows__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:482 */
#ifndef SOAP_TYPE__ows__ServiceIdentification
#define SOAP_TYPE__ows__ServiceIdentification (150)
/* Type _ows__ServiceIdentification is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:ServiceIdentification': */
class SOAP_CMAC _ows__ServiceIdentification : public ows__DescriptionType {
      public:
        /// Required element 'ows:ServiceType' of XML schema type 'ows:CodeType'
        ows__CodeType *ServiceType;
        /// Required element 'ows:ServiceTypeVersion' of XML schema type 'ows:VersionType'
        std::vector<std::string> ServiceTypeVersion;
        /// Optional element 'ows:Profile' of XML schema type 'xsd:anyURI'
        std::vector<char *> Profile;
        /// Optional element 'ows:Fees' of XML schema type 'xsd:string'
        std::string *Fees;
        /// Optional element 'ows:AccessConstraints' of XML schema type 'xsd:string'
        std::vector<std::string> AccessConstraints;
      public:
        /// Return unique type id SOAP_TYPE__ows__ServiceIdentification
        virtual long soap_type(void) const { return SOAP_TYPE__ows__ServiceIdentification; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ows__ServiceIdentification, default initialized and not managed by a soap context
        virtual _ows__ServiceIdentification *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ows__ServiceIdentification); }
      public:
        /// Constructor with default initializations
        _ows__ServiceIdentification() : ServiceType(), ServiceTypeVersion(), Profile(), Fees(), AccessConstraints() { }
        virtual ~_ows__ServiceIdentification() { }
        /// Friend allocator used by soap_new__ows__ServiceIdentification(struct soap*, int)
        friend SOAP_FMAC1 _ows__ServiceIdentification * SOAP_FMAC2 soap_instantiate__ows__ServiceIdentification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:498 */
#ifndef SOAP_TYPE__ows__ValuesReference
#define SOAP_TYPE__ows__ValuesReference (158)
/* simple XML schema type 'ows:ValuesReference': */
class SOAP_CMAC _ows__ValuesReference {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Required attribute 'ows:reference' of XML schema type 'xsd:anyURI'
        char *ows__reference;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ows__ValuesReference
        virtual long soap_type(void) const { return SOAP_TYPE__ows__ValuesReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ows__ValuesReference, default initialized and not managed by a soap context
        virtual _ows__ValuesReference *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ows__ValuesReference); }
      public:
        /// Constructor with default initializations
        _ows__ValuesReference() : __item(), ows__reference(), soap() { }
        virtual ~_ows__ValuesReference() { }
        /// Friend allocator used by soap_new__ows__ValuesReference(struct soap*, int)
        friend SOAP_FMAC1 _ows__ValuesReference * SOAP_FMAC2 soap_instantiate__ows__ValuesReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:502 */
#ifndef SOAP_TYPE_idls__ExtendedCapabilitiesType
#define SOAP_TYPE_idls__ExtendedCapabilitiesType (160)
/* Type idls__ExtendedCapabilitiesType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'idls:ExtendedCapabilitiesType': */
class SOAP_CMAC idls__ExtendedCapabilitiesType : public icommon__ExtendedCapabilitiesType {
      public:
        /// Required element 'idls:SpatialDataSetIdentifier' of XML schema type 'icommon:uniqueResourceIdentifier'
        std::vector<icommon__uniqueResourceIdentifier *> SpatialDataSetIdentifier;
      public:
        /// Return unique type id SOAP_TYPE_idls__ExtendedCapabilitiesType
        virtual long soap_type(void) const { return SOAP_TYPE_idls__ExtendedCapabilitiesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type idls__ExtendedCapabilitiesType, default initialized and not managed by a soap context
        virtual idls__ExtendedCapabilitiesType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(idls__ExtendedCapabilitiesType); }
      public:
        /// Constructor with default initializations
        idls__ExtendedCapabilitiesType() : SpatialDataSetIdentifier() { }
        virtual ~idls__ExtendedCapabilitiesType() { }
        /// Friend allocator used by soap_new_idls__ExtendedCapabilitiesType(struct soap*, int)
        friend SOAP_FMAC1 idls__ExtendedCapabilitiesType * SOAP_FMAC2 soap_instantiate_idls__ExtendedCapabilitiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:8594 */
#ifndef SOAP_TYPE__fes__union_AbstractAdhocQueryExpressionType
#define SOAP_TYPE__fes__union_AbstractAdhocQueryExpressionType (728)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _fes__union_AbstractAdhocQueryExpressionType
{
        #define SOAP_UNION__fes__union_AbstractAdhocQueryExpressionType_wfs__PropertyName	(1)	/**< union variant selector value for member wfs__PropertyName */
        _wfs__PropertyName *wfs__PropertyName;
        #define SOAP_UNION__fes__union_AbstractAdhocQueryExpressionType_wfs__PropertyName_	(2)	/**< union variant selector value for member wfs__PropertyName_ */
        _wfs__PropertyName *wfs__PropertyName_;
};
#endif

/* ws-inspire-wfs2.h:8589 */
#ifndef SOAP_TYPE___fes__union_AbstractAdhocQueryExpressionType
#define SOAP_TYPE___fes__union_AbstractAdhocQueryExpressionType (727)
/* Wrapper: */
class SOAP_CMAC __fes__union_AbstractAdhocQueryExpressionType {
      public:
        /// Union with union _fes__union_AbstractAdhocQueryExpressionType variant selector __unionAbstractProjectionClause set to one of: SOAP_UNION__fes__union_AbstractAdhocQueryExpressionType_wfs__PropertyName SOAP_UNION__fes__union_AbstractAdhocQueryExpressionType_wfs__PropertyName_
        int __unionAbstractProjectionClause;
        union _fes__union_AbstractAdhocQueryExpressionType union_AbstractAdhocQueryExpressionType;
      public:
        /// Return unique type id SOAP_TYPE___fes__union_AbstractAdhocQueryExpressionType
        virtual long soap_type(void) const { return SOAP_TYPE___fes__union_AbstractAdhocQueryExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __fes__union_AbstractAdhocQueryExpressionType, default initialized and not managed by a soap context
        virtual __fes__union_AbstractAdhocQueryExpressionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__fes__union_AbstractAdhocQueryExpressionType); }
      public:
        /// Constructor with default initializations
        __fes__union_AbstractAdhocQueryExpressionType() : __unionAbstractProjectionClause() { }
        virtual ~__fes__union_AbstractAdhocQueryExpressionType() { }
        /// Friend allocator used by soap_new___fes__union_AbstractAdhocQueryExpressionType(struct soap*, int)
        friend SOAP_FMAC1 __fes__union_AbstractAdhocQueryExpressionType * SOAP_FMAC2 soap_instantiate___fes__union_AbstractAdhocQueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:8608 */
#ifndef SOAP_TYPE__fes__union_AbstractAdhocQueryExpressionType_
#define SOAP_TYPE__fes__union_AbstractAdhocQueryExpressionType_ (731)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _fes__union_AbstractAdhocQueryExpressionType_
{
        #define SOAP_UNION__fes__union_AbstractAdhocQueryExpressionType__Filter	(1)	/**< union variant selector value for member Filter */
        fes__FilterType *Filter;
};
#endif

/* ws-inspire-wfs2.h:8619 */
#ifndef SOAP_TYPE__fes__union_AbstractAdhocQueryExpressionType__
#define SOAP_TYPE__fes__union_AbstractAdhocQueryExpressionType__ (732)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _fes__union_AbstractAdhocQueryExpressionType__
{
        #define SOAP_UNION__fes__union_AbstractAdhocQueryExpressionType___SortBy	(1)	/**< union variant selector value for member SortBy */
        fes__SortByType *SortBy;
};
#endif

/* ws-inspire-wfs2.h:518 */
#ifndef SOAP_TYPE_fes__AbstractAdhocQueryExpressionType
#define SOAP_TYPE_fes__AbstractAdhocQueryExpressionType (168)
/* Type fes__AbstractAdhocQueryExpressionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:AbstractAdhocQueryExpressionType': */
class SOAP_CMAC fes__AbstractAdhocQueryExpressionType : public fes__AbstractQueryExpressionType {
      public:
        /// Sequence of elements '-union-AbstractAdhocQueryExpressionType' of XML schema type '-fes:union-AbstractAdhocQueryExpressionType' stored in dynamic array __union_AbstractAdhocQueryExpressionType of length __sizeAbstractProjectionClause
        int __sizeAbstractProjectionClause;
        __fes__union_AbstractAdhocQueryExpressionType *__union_AbstractAdhocQueryExpressionType;
        /// Union with union _fes__union_AbstractAdhocQueryExpressionType_ variant selector __unionAbstractSelectionClause set to one of: SOAP_UNION__fes__union_AbstractAdhocQueryExpressionType__Filter
        int __unionAbstractSelectionClause;
        union _fes__union_AbstractAdhocQueryExpressionType_ union_AbstractAdhocQueryExpressionType_;
        /// Union with union _fes__union_AbstractAdhocQueryExpressionType__ variant selector __unionAbstractSortingClause set to one of: SOAP_UNION__fes__union_AbstractAdhocQueryExpressionType___SortBy
        int __unionAbstractSortingClause;
        union _fes__union_AbstractAdhocQueryExpressionType__ union_AbstractAdhocQueryExpressionType__;
        /// Required attribute 'typeNames' of XML schema type 'fes:TypeNamesListType'
        std::string typeNames;
        /// Optional attribute 'aliases' of XML schema type 'fes:AliasesType'
        std::string *aliases;
      public:
        /// Return unique type id SOAP_TYPE_fes__AbstractAdhocQueryExpressionType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__AbstractAdhocQueryExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__AbstractAdhocQueryExpressionType, default initialized and not managed by a soap context
        virtual fes__AbstractAdhocQueryExpressionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__AbstractAdhocQueryExpressionType); }
      public:
        /// Constructor with default initializations
        fes__AbstractAdhocQueryExpressionType() : __sizeAbstractProjectionClause(), __union_AbstractAdhocQueryExpressionType(), __unionAbstractSelectionClause(), __unionAbstractSortingClause(), typeNames(), aliases() { }
        virtual ~fes__AbstractAdhocQueryExpressionType() { }
        /// Friend allocator used by soap_new_fes__AbstractAdhocQueryExpressionType(struct soap*, int)
        friend SOAP_FMAC1 fes__AbstractAdhocQueryExpressionType * SOAP_FMAC2 soap_instantiate_fes__AbstractAdhocQueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:8763 */
#ifndef SOAP_TYPE__fes__union_FilterType______
#define SOAP_TYPE__fes__union_FilterType______ (749)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _fes__union_FilterType______
{
        #define SOAP_UNION__fes__union_FilterType_______ResourceId	(1)	/**< union variant selector value for member ResourceId */
        fes__ResourceIdType *ResourceId;
};
#endif

/* ws-inspire-wfs2.h:8758 */
#ifndef SOAP_TYPE___fes__union_FilterType______
#define SOAP_TYPE___fes__union_FilterType______ (748)
/* Wrapper: */
class SOAP_CMAC __fes__union_FilterType______ {
      public:
        /// Union with union _fes__union_FilterType______ variant selector __union_x005fId set to one of: SOAP_UNION__fes__union_FilterType_______ResourceId
        int __union_x005fId;
        union _fes__union_FilterType______ union_FilterType______;
      public:
        /// Return unique type id SOAP_TYPE___fes__union_FilterType______
        virtual long soap_type(void) const { return SOAP_TYPE___fes__union_FilterType______; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __fes__union_FilterType______, default initialized and not managed by a soap context
        virtual __fes__union_FilterType______ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__fes__union_FilterType______); }
      public:
        /// Constructor with default initializations
        __fes__union_FilterType______() : __union_x005fId() { }
        virtual ~__fes__union_FilterType______() { }
        /// Friend allocator used by soap_new___fes__union_FilterType______(struct soap*, int)
        friend SOAP_FMAC1 __fes__union_FilterType______ * SOAP_FMAC2 soap_instantiate___fes__union_FilterType______(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:8756 */
#ifndef SOAP_TYPE____fes__union_FilterType______
#define SOAP_TYPE____fes__union_FilterType______ (747)
/* Wrapper: */
struct SOAP_CMAC ___fes__union_FilterType______ {
      public:
        /** Sequence of elements '-union-FilterType' of XML schema type '-fes:union-FilterType' stored in dynamic array __union_FilterType______ of length __size_x005fId */
        int __size_x005fId;
        __fes__union_FilterType______ *__union_FilterType______;
      public:
        /** Return unique type id SOAP_TYPE____fes__union_FilterType______ */
        long soap_type() const { return SOAP_TYPE____fes__union_FilterType______; }
        /** Friend allocator */
        friend SOAP_FMAC1 ___fes__union_FilterType______ * SOAP_FMAC2 soap_instantiate____fes__union_FilterType______(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:8651 */
#ifndef SOAP_TYPE__fes__union_FilterType
#define SOAP_TYPE__fes__union_FilterType (735)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _fes__union_FilterType
{
        #define SOAP_UNION__fes__union_FilterType_PropertyIsEqualTo	(1)	/**< union variant selector value for member PropertyIsEqualTo */
        fes__BinaryComparisonOpType *PropertyIsEqualTo;
        #define SOAP_UNION__fes__union_FilterType_PropertyIsNotEqualTo	(2)	/**< union variant selector value for member PropertyIsNotEqualTo */
        fes__BinaryComparisonOpType *PropertyIsNotEqualTo;
        #define SOAP_UNION__fes__union_FilterType_PropertyIsLessThan	(3)	/**< union variant selector value for member PropertyIsLessThan */
        fes__BinaryComparisonOpType *PropertyIsLessThan;
        #define SOAP_UNION__fes__union_FilterType_PropertyIsGreaterThan	(4)	/**< union variant selector value for member PropertyIsGreaterThan */
        fes__BinaryComparisonOpType *PropertyIsGreaterThan;
        #define SOAP_UNION__fes__union_FilterType_PropertyIsLessThanOrEqualTo	(5)	/**< union variant selector value for member PropertyIsLessThanOrEqualTo */
        fes__BinaryComparisonOpType *PropertyIsLessThanOrEqualTo;
        #define SOAP_UNION__fes__union_FilterType_PropertyIsGreaterThanOrEqualTo	(6)	/**< union variant selector value for member PropertyIsGreaterThanOrEqualTo */
        fes__BinaryComparisonOpType *PropertyIsGreaterThanOrEqualTo;
        #define SOAP_UNION__fes__union_FilterType_PropertyIsLike	(7)	/**< union variant selector value for member PropertyIsLike */
        fes__PropertyIsLikeType *PropertyIsLike;
        #define SOAP_UNION__fes__union_FilterType_PropertyIsNull	(8)	/**< union variant selector value for member PropertyIsNull */
        fes__PropertyIsNullType *PropertyIsNull;
        #define SOAP_UNION__fes__union_FilterType_PropertyIsNil	(9)	/**< union variant selector value for member PropertyIsNil */
        fes__PropertyIsNilType *PropertyIsNil;
        #define SOAP_UNION__fes__union_FilterType_PropertyIsBetween	(10)	/**< union variant selector value for member PropertyIsBetween */
        fes__PropertyIsBetweenType *PropertyIsBetween;
        #define SOAP_UNION__fes__union_FilterType_Equals	(11)	/**< union variant selector value for member Equals */
        fes__BinarySpatialOpType *Equals;
        #define SOAP_UNION__fes__union_FilterType_Disjoint	(12)	/**< union variant selector value for member Disjoint */
        fes__BinarySpatialOpType *Disjoint;
        #define SOAP_UNION__fes__union_FilterType_Touches	(13)	/**< union variant selector value for member Touches */
        fes__BinarySpatialOpType *Touches;
        #define SOAP_UNION__fes__union_FilterType_Within	(14)	/**< union variant selector value for member Within */
        fes__BinarySpatialOpType *Within;
        #define SOAP_UNION__fes__union_FilterType_Overlaps	(15)	/**< union variant selector value for member Overlaps */
        fes__BinarySpatialOpType *Overlaps;
        #define SOAP_UNION__fes__union_FilterType_Crosses	(16)	/**< union variant selector value for member Crosses */
        fes__BinarySpatialOpType *Crosses;
        #define SOAP_UNION__fes__union_FilterType_Intersects	(17)	/**< union variant selector value for member Intersects */
        fes__BinarySpatialOpType *Intersects;
        #define SOAP_UNION__fes__union_FilterType_Contains	(18)	/**< union variant selector value for member Contains */
        fes__BinarySpatialOpType *Contains;
        #define SOAP_UNION__fes__union_FilterType_DWithin	(19)	/**< union variant selector value for member DWithin */
        fes__DistanceBufferType *DWithin;
        #define SOAP_UNION__fes__union_FilterType_Beyond	(20)	/**< union variant selector value for member Beyond */
        fes__DistanceBufferType *Beyond;
        #define SOAP_UNION__fes__union_FilterType_BBOX	(21)	/**< union variant selector value for member BBOX */
        fes__BBOXType *BBOX;
        #define SOAP_UNION__fes__union_FilterType_After	(22)	/**< union variant selector value for member After */
        fes__BinaryTemporalOpType *After;
        #define SOAP_UNION__fes__union_FilterType_Before	(23)	/**< union variant selector value for member Before */
        fes__BinaryTemporalOpType *Before;
        #define SOAP_UNION__fes__union_FilterType_Begins	(24)	/**< union variant selector value for member Begins */
        fes__BinaryTemporalOpType *Begins;
        #define SOAP_UNION__fes__union_FilterType_BegunBy	(25)	/**< union variant selector value for member BegunBy */
        fes__BinaryTemporalOpType *BegunBy;
        #define SOAP_UNION__fes__union_FilterType_TContains	(26)	/**< union variant selector value for member TContains */
        fes__BinaryTemporalOpType *TContains;
        #define SOAP_UNION__fes__union_FilterType_During	(27)	/**< union variant selector value for member During */
        fes__BinaryTemporalOpType *During;
        #define SOAP_UNION__fes__union_FilterType_EndedBy	(28)	/**< union variant selector value for member EndedBy */
        fes__BinaryTemporalOpType *EndedBy;
        #define SOAP_UNION__fes__union_FilterType_Ends	(29)	/**< union variant selector value for member Ends */
        fes__BinaryTemporalOpType *Ends;
        #define SOAP_UNION__fes__union_FilterType_TEquals	(30)	/**< union variant selector value for member TEquals */
        fes__BinaryTemporalOpType *TEquals;
        #define SOAP_UNION__fes__union_FilterType_Meets	(31)	/**< union variant selector value for member Meets */
        fes__BinaryTemporalOpType *Meets;
        #define SOAP_UNION__fes__union_FilterType_MetBy	(32)	/**< union variant selector value for member MetBy */
        fes__BinaryTemporalOpType *MetBy;
        #define SOAP_UNION__fes__union_FilterType_TOverlaps	(33)	/**< union variant selector value for member TOverlaps */
        fes__BinaryTemporalOpType *TOverlaps;
        #define SOAP_UNION__fes__union_FilterType_OverlappedBy	(34)	/**< union variant selector value for member OverlappedBy */
        fes__BinaryTemporalOpType *OverlappedBy;
        #define SOAP_UNION__fes__union_FilterType_AnyInteracts	(35)	/**< union variant selector value for member AnyInteracts */
        fes__BinaryTemporalOpType *AnyInteracts;
        #define SOAP_UNION__fes__union_FilterType_And	(36)	/**< union variant selector value for member And */
        fes__BinaryLogicOpType *And;
        #define SOAP_UNION__fes__union_FilterType_Or	(37)	/**< union variant selector value for member Or */
        fes__BinaryLogicOpType *Or;
        #define SOAP_UNION__fes__union_FilterType_Not	(38)	/**< union variant selector value for member Not */
        fes__UnaryLogicOpType *Not;
        #define SOAP_UNION__fes__union_FilterType_Function	(39)	/**< union variant selector value for member Function */
        fes__FunctionType *Function;
        #define SOAP_UNION__fes__union_FilterType___union_FilterType______	(40)	/**< union variant selector value for member __union_FilterType______ */
        struct ___fes__union_FilterType______ __union_FilterType______;
};
#endif

/* ws-inspire-wfs2.h:526 */
#ifndef SOAP_TYPE_fes__FilterType
#define SOAP_TYPE_fes__FilterType (172)
/* Type fes__FilterType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:FilterType': */
class SOAP_CMAC fes__FilterType : public fes__AbstractSelectionClauseType {
      public:
        /// Union with union _fes__union_FilterType variant selector __union_FilterType set to one of: SOAP_UNION__fes__union_FilterType_PropertyIsEqualTo SOAP_UNION__fes__union_FilterType_PropertyIsNotEqualTo SOAP_UNION__fes__union_FilterType_PropertyIsLessThan SOAP_UNION__fes__union_FilterType_PropertyIsGreaterThan SOAP_UNION__fes__union_FilterType_PropertyIsLessThanOrEqualTo SOAP_UNION__fes__union_FilterType_PropertyIsGreaterThanOrEqualTo SOAP_UNION__fes__union_FilterType_PropertyIsLike SOAP_UNION__fes__union_FilterType_PropertyIsNull SOAP_UNION__fes__union_FilterType_PropertyIsNil SOAP_UNION__fes__union_FilterType_PropertyIsBetween SOAP_UNION__fes__union_FilterType_Equals SOAP_UNION__fes__union_FilterType_Disjoint SOAP_UNION__fes__union_FilterType_Touches SOAP_UNION__fes__union_FilterType_Within SOAP_UNION__fes__union_FilterType_Overlaps SOAP_UNION__fes__union_FilterType_Crosses SOAP_UNION__fes__union_FilterType_Intersects SOAP_UNION__fes__union_FilterType_Contains SOAP_UNION__fes__union_FilterType_DWithin SOAP_UNION__fes__union_FilterType_Beyond SOAP_UNION__fes__union_FilterType_BBOX SOAP_UNION__fes__union_FilterType_After SOAP_UNION__fes__union_FilterType_Before SOAP_UNION__fes__union_FilterType_Begins SOAP_UNION__fes__union_FilterType_BegunBy SOAP_UNION__fes__union_FilterType_TContains SOAP_UNION__fes__union_FilterType_During SOAP_UNION__fes__union_FilterType_EndedBy SOAP_UNION__fes__union_FilterType_Ends SOAP_UNION__fes__union_FilterType_TEquals SOAP_UNION__fes__union_FilterType_Meets SOAP_UNION__fes__union_FilterType_MetBy SOAP_UNION__fes__union_FilterType_TOverlaps SOAP_UNION__fes__union_FilterType_OverlappedBy SOAP_UNION__fes__union_FilterType_AnyInteracts SOAP_UNION__fes__union_FilterType_And SOAP_UNION__fes__union_FilterType_Or SOAP_UNION__fes__union_FilterType_Not SOAP_UNION__fes__union_FilterType_Function SOAP_UNION__fes__union_FilterType___union_FilterType______
        int __union_FilterType;
        union _fes__union_FilterType union_FilterType;
      public:
        /// Return unique type id SOAP_TYPE_fes__FilterType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__FilterType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__FilterType, default initialized and not managed by a soap context
        virtual fes__FilterType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__FilterType); }
      public:
        /// Constructor with default initializations
        fes__FilterType() : __union_FilterType() { }
        virtual ~fes__FilterType() { }
        /// Friend allocator used by soap_new_fes__FilterType(struct soap*, int)
        friend SOAP_FMAC1 fes__FilterType * SOAP_FMAC2 soap_instantiate_fes__FilterType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:540 */
#ifndef SOAP_TYPE_fes__ResourceIdType
#define SOAP_TYPE_fes__ResourceIdType (179)
/* simple XML schema type 'fes:ResourceIdType': */
class SOAP_CMAC fes__ResourceIdType : public fes__AbstractIdType {
      public:
        /// Required attribute 'rid' of XML schema type 'xsd:string'
        std::string rid;
        /// Optional attribute 'previousRid' of XML schema type 'xsd:string'
        std::string *previousRid;
        /// Optional attribute 'version' of XML schema type 'fes:VersionType'
        std::string *version;
        /// Optional attribute 'startDate' of XML schema type 'xsd:dateTime'
        time_t *startDate;
        /// Optional attribute 'endDate' of XML schema type 'xsd:dateTime'
        time_t *endDate;
      public:
        /// Return unique type id SOAP_TYPE_fes__ResourceIdType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__ResourceIdType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__ResourceIdType, default initialized and not managed by a soap context
        virtual fes__ResourceIdType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__ResourceIdType); }
      public:
        /// Constructor with default initializations
        fes__ResourceIdType() : rid(), previousRid(), version(), startDate(), endDate() { }
        virtual ~fes__ResourceIdType() { }
        /// Friend allocator used by soap_new_fes__ResourceIdType(struct soap*, int)
        friend SOAP_FMAC1 fes__ResourceIdType * SOAP_FMAC2 soap_instantiate_fes__ResourceIdType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:8830 */
#ifndef SOAP_TYPE__fes__union_BinaryComparisonOpType
#define SOAP_TYPE__fes__union_BinaryComparisonOpType (754)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _fes__union_BinaryComparisonOpType
{
        #define SOAP_UNION__fes__union_BinaryComparisonOpType_ValueReference	(1)	/**< union variant selector value for member ValueReference */
        std::string *ValueReference;
        #define SOAP_UNION__fes__union_BinaryComparisonOpType_Function	(2)	/**< union variant selector value for member Function */
        fes__FunctionType *Function;
        #define SOAP_UNION__fes__union_BinaryComparisonOpType_Literal	(3)	/**< union variant selector value for member Literal */
        fes__LiteralType *Literal;
};
#endif

/* ws-inspire-wfs2.h:8825 */
#ifndef SOAP_TYPE___fes__union_BinaryComparisonOpType
#define SOAP_TYPE___fes__union_BinaryComparisonOpType (753)
/* Wrapper: */
class SOAP_CMAC __fes__union_BinaryComparisonOpType {
      public:
        /// Union with union _fes__union_BinaryComparisonOpType variant selector __unionexpression set to one of: SOAP_UNION__fes__union_BinaryComparisonOpType_ValueReference SOAP_UNION__fes__union_BinaryComparisonOpType_Function SOAP_UNION__fes__union_BinaryComparisonOpType_Literal
        int __unionexpression;
        union _fes__union_BinaryComparisonOpType union_BinaryComparisonOpType;
      public:
        /// Return unique type id SOAP_TYPE___fes__union_BinaryComparisonOpType
        virtual long soap_type(void) const { return SOAP_TYPE___fes__union_BinaryComparisonOpType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __fes__union_BinaryComparisonOpType, default initialized and not managed by a soap context
        virtual __fes__union_BinaryComparisonOpType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__fes__union_BinaryComparisonOpType); }
      public:
        /// Constructor with default initializations
        __fes__union_BinaryComparisonOpType() : __unionexpression() { }
        virtual ~__fes__union_BinaryComparisonOpType() { }
        /// Friend allocator used by soap_new___fes__union_BinaryComparisonOpType(struct soap*, int)
        friend SOAP_FMAC1 __fes__union_BinaryComparisonOpType * SOAP_FMAC2 soap_instantiate___fes__union_BinaryComparisonOpType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:542 */
#ifndef SOAP_TYPE_fes__BinaryComparisonOpType
#define SOAP_TYPE_fes__BinaryComparisonOpType (180)
/* complex XML schema type 'fes:BinaryComparisonOpType': */
class SOAP_CMAC fes__BinaryComparisonOpType : public fes__ComparisonOpsType {
      public:
        /// Sequence of 2 to 2 elements '-union-BinaryComparisonOpType' of XML schema type '-fes:union-BinaryComparisonOpType' stored in dynamic array __union_BinaryComparisonOpType of length __sizeexpression
        int __sizeexpression;
        __fes__union_BinaryComparisonOpType *__union_BinaryComparisonOpType;
        /// Optional attribute 'matchCase' of XML schema type 'xsd:boolean'
        bool matchCase;	///< initialized with default value = (bool)1
        /// Optional attribute 'matchAction' of XML schema type 'fes:MatchActionType'
        enum fes__MatchActionType matchAction;	///< initialized with default value = (enum fes__MatchActionType)1
      public:
        /// Return unique type id SOAP_TYPE_fes__BinaryComparisonOpType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__BinaryComparisonOpType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__BinaryComparisonOpType, default initialized and not managed by a soap context
        virtual fes__BinaryComparisonOpType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__BinaryComparisonOpType); }
      public:
        /// Constructor with default initializations
        fes__BinaryComparisonOpType() : __sizeexpression(), __union_BinaryComparisonOpType(), matchCase((bool)1), matchAction((enum fes__MatchActionType)1) { }
        virtual ~fes__BinaryComparisonOpType() { }
        /// Friend allocator used by soap_new_fes__BinaryComparisonOpType(struct soap*, int)
        friend SOAP_FMAC1 fes__BinaryComparisonOpType * SOAP_FMAC2 soap_instantiate_fes__BinaryComparisonOpType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:8872 */
#ifndef SOAP_TYPE__fes__union_PropertyIsLikeType
#define SOAP_TYPE__fes__union_PropertyIsLikeType (757)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _fes__union_PropertyIsLikeType
{
        #define SOAP_UNION__fes__union_PropertyIsLikeType_ValueReference	(1)	/**< union variant selector value for member ValueReference */
        std::string *ValueReference;
        #define SOAP_UNION__fes__union_PropertyIsLikeType_Function	(2)	/**< union variant selector value for member Function */
        fes__FunctionType *Function;
        #define SOAP_UNION__fes__union_PropertyIsLikeType_Literal	(3)	/**< union variant selector value for member Literal */
        fes__LiteralType *Literal;
};
#endif

/* ws-inspire-wfs2.h:8867 */
#ifndef SOAP_TYPE___fes__union_PropertyIsLikeType
#define SOAP_TYPE___fes__union_PropertyIsLikeType (756)
/* Wrapper: */
class SOAP_CMAC __fes__union_PropertyIsLikeType {
      public:
        /// Union with union _fes__union_PropertyIsLikeType variant selector __unionexpression set to one of: SOAP_UNION__fes__union_PropertyIsLikeType_ValueReference SOAP_UNION__fes__union_PropertyIsLikeType_Function SOAP_UNION__fes__union_PropertyIsLikeType_Literal
        int __unionexpression;
        union _fes__union_PropertyIsLikeType union_PropertyIsLikeType;
      public:
        /// Return unique type id SOAP_TYPE___fes__union_PropertyIsLikeType
        virtual long soap_type(void) const { return SOAP_TYPE___fes__union_PropertyIsLikeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __fes__union_PropertyIsLikeType, default initialized and not managed by a soap context
        virtual __fes__union_PropertyIsLikeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__fes__union_PropertyIsLikeType); }
      public:
        /// Constructor with default initializations
        __fes__union_PropertyIsLikeType() : __unionexpression() { }
        virtual ~__fes__union_PropertyIsLikeType() { }
        /// Friend allocator used by soap_new___fes__union_PropertyIsLikeType(struct soap*, int)
        friend SOAP_FMAC1 __fes__union_PropertyIsLikeType * SOAP_FMAC2 soap_instantiate___fes__union_PropertyIsLikeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:544 */
#ifndef SOAP_TYPE_fes__PropertyIsLikeType
#define SOAP_TYPE_fes__PropertyIsLikeType (181)
/* complex XML schema type 'fes:PropertyIsLikeType': */
class SOAP_CMAC fes__PropertyIsLikeType : public fes__ComparisonOpsType {
      public:
        /// Sequence of 2 to 2 elements '-union-PropertyIsLikeType' of XML schema type '-fes:union-PropertyIsLikeType' stored in dynamic array __union_PropertyIsLikeType of length __sizeexpression
        int __sizeexpression;
        __fes__union_PropertyIsLikeType *__union_PropertyIsLikeType;
        /// Required attribute 'wildCard' of XML schema type 'xsd:string'
        std::string wildCard;
        /// Required attribute 'singleChar' of XML schema type 'xsd:string'
        std::string singleChar;
        /// Required attribute 'escapeChar' of XML schema type 'xsd:string'
        std::string escapeChar;
        /// Optional attribute 'matchCase' of XML schema type 'xsd:boolean'
        bool matchCase;	///< initialized with default value = (bool)1
      public:
        /// Return unique type id SOAP_TYPE_fes__PropertyIsLikeType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__PropertyIsLikeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__PropertyIsLikeType, default initialized and not managed by a soap context
        virtual fes__PropertyIsLikeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__PropertyIsLikeType); }
      public:
        /// Constructor with default initializations
        fes__PropertyIsLikeType() : __sizeexpression(), __union_PropertyIsLikeType(), wildCard(), singleChar(), escapeChar(), matchCase((bool)1) { }
        virtual ~fes__PropertyIsLikeType() { }
        /// Friend allocator used by soap_new_fes__PropertyIsLikeType(struct soap*, int)
        friend SOAP_FMAC1 fes__PropertyIsLikeType * SOAP_FMAC2 soap_instantiate_fes__PropertyIsLikeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:8915 */
#ifndef SOAP_TYPE__fes__union_PropertyIsNullType
#define SOAP_TYPE__fes__union_PropertyIsNullType (759)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _fes__union_PropertyIsNullType
{
        #define SOAP_UNION__fes__union_PropertyIsNullType_ValueReference	(1)	/**< union variant selector value for member ValueReference */
        std::string *ValueReference;
        #define SOAP_UNION__fes__union_PropertyIsNullType_Function	(2)	/**< union variant selector value for member Function */
        fes__FunctionType *Function;
        #define SOAP_UNION__fes__union_PropertyIsNullType_Literal	(3)	/**< union variant selector value for member Literal */
        fes__LiteralType *Literal;
};
#endif

/* ws-inspire-wfs2.h:546 */
#ifndef SOAP_TYPE_fes__PropertyIsNullType
#define SOAP_TYPE_fes__PropertyIsNullType (182)
/* complex XML schema type 'fes:PropertyIsNullType': */
class SOAP_CMAC fes__PropertyIsNullType : public fes__ComparisonOpsType {
      public:
        /// Union with union _fes__union_PropertyIsNullType variant selector __unionexpression set to one of: SOAP_UNION__fes__union_PropertyIsNullType_ValueReference SOAP_UNION__fes__union_PropertyIsNullType_Function SOAP_UNION__fes__union_PropertyIsNullType_Literal
        int __unionexpression;
        union _fes__union_PropertyIsNullType union_PropertyIsNullType;
      public:
        /// Return unique type id SOAP_TYPE_fes__PropertyIsNullType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__PropertyIsNullType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__PropertyIsNullType, default initialized and not managed by a soap context
        virtual fes__PropertyIsNullType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__PropertyIsNullType); }
      public:
        /// Constructor with default initializations
        fes__PropertyIsNullType() : __unionexpression() { }
        virtual ~fes__PropertyIsNullType() { }
        /// Friend allocator used by soap_new_fes__PropertyIsNullType(struct soap*, int)
        friend SOAP_FMAC1 fes__PropertyIsNullType * SOAP_FMAC2 soap_instantiate_fes__PropertyIsNullType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:8949 */
#ifndef SOAP_TYPE__fes__union_PropertyIsNilType
#define SOAP_TYPE__fes__union_PropertyIsNilType (760)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _fes__union_PropertyIsNilType
{
        #define SOAP_UNION__fes__union_PropertyIsNilType_ValueReference	(1)	/**< union variant selector value for member ValueReference */
        std::string *ValueReference;
        #define SOAP_UNION__fes__union_PropertyIsNilType_Function	(2)	/**< union variant selector value for member Function */
        fes__FunctionType *Function;
        #define SOAP_UNION__fes__union_PropertyIsNilType_Literal	(3)	/**< union variant selector value for member Literal */
        fes__LiteralType *Literal;
};
#endif

/* ws-inspire-wfs2.h:548 */
#ifndef SOAP_TYPE_fes__PropertyIsNilType
#define SOAP_TYPE_fes__PropertyIsNilType (183)
/* complex XML schema type 'fes:PropertyIsNilType': */
class SOAP_CMAC fes__PropertyIsNilType : public fes__ComparisonOpsType {
      public:
        /// Union with union _fes__union_PropertyIsNilType variant selector __unionexpression set to one of: SOAP_UNION__fes__union_PropertyIsNilType_ValueReference SOAP_UNION__fes__union_PropertyIsNilType_Function SOAP_UNION__fes__union_PropertyIsNilType_Literal
        int __unionexpression;
        union _fes__union_PropertyIsNilType union_PropertyIsNilType;
        /// Optional attribute 'nilReason' of XML schema type 'xsd:string'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_fes__PropertyIsNilType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__PropertyIsNilType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__PropertyIsNilType, default initialized and not managed by a soap context
        virtual fes__PropertyIsNilType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__PropertyIsNilType); }
      public:
        /// Constructor with default initializations
        fes__PropertyIsNilType() : __unionexpression(), nilReason() { }
        virtual ~fes__PropertyIsNilType() { }
        /// Friend allocator used by soap_new_fes__PropertyIsNilType(struct soap*, int)
        friend SOAP_FMAC1 fes__PropertyIsNilType * SOAP_FMAC2 soap_instantiate_fes__PropertyIsNilType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:8985 */
#ifndef SOAP_TYPE__fes__union_PropertyIsBetweenType
#define SOAP_TYPE__fes__union_PropertyIsBetweenType (761)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _fes__union_PropertyIsBetweenType
{
        #define SOAP_UNION__fes__union_PropertyIsBetweenType_ValueReference	(1)	/**< union variant selector value for member ValueReference */
        std::string *ValueReference;
        #define SOAP_UNION__fes__union_PropertyIsBetweenType_Function	(2)	/**< union variant selector value for member Function */
        fes__FunctionType *Function;
        #define SOAP_UNION__fes__union_PropertyIsBetweenType_Literal	(3)	/**< union variant selector value for member Literal */
        fes__LiteralType *Literal;
};
#endif

/* ws-inspire-wfs2.h:550 */
#ifndef SOAP_TYPE_fes__PropertyIsBetweenType
#define SOAP_TYPE_fes__PropertyIsBetweenType (184)
/* complex XML schema type 'fes:PropertyIsBetweenType': */
class SOAP_CMAC fes__PropertyIsBetweenType : public fes__ComparisonOpsType {
      public:
        /// Union with union _fes__union_PropertyIsBetweenType variant selector __unionexpression set to one of: SOAP_UNION__fes__union_PropertyIsBetweenType_ValueReference SOAP_UNION__fes__union_PropertyIsBetweenType_Function SOAP_UNION__fes__union_PropertyIsBetweenType_Literal
        int __unionexpression;
        union _fes__union_PropertyIsBetweenType union_PropertyIsBetweenType;
        /// Required element 'fes:LowerBoundary' of XML schema type 'fes:LowerBoundaryType'
        fes__LowerBoundaryType *LowerBoundary;
        /// Required element 'fes:UpperBoundary' of XML schema type 'fes:UpperBoundaryType'
        fes__UpperBoundaryType *UpperBoundary;
      public:
        /// Return unique type id SOAP_TYPE_fes__PropertyIsBetweenType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__PropertyIsBetweenType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__PropertyIsBetweenType, default initialized and not managed by a soap context
        virtual fes__PropertyIsBetweenType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__PropertyIsBetweenType); }
      public:
        /// Constructor with default initializations
        fes__PropertyIsBetweenType() : __unionexpression(), LowerBoundary(), UpperBoundary() { }
        virtual ~fes__PropertyIsBetweenType() { }
        /// Friend allocator used by soap_new_fes__PropertyIsBetweenType(struct soap*, int)
        friend SOAP_FMAC1 fes__PropertyIsBetweenType * SOAP_FMAC2 soap_instantiate_fes__PropertyIsBetweenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:9024 */
#ifndef SOAP_TYPE__fes__union_BinarySpatialOpType
#define SOAP_TYPE__fes__union_BinarySpatialOpType (765)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _fes__union_BinarySpatialOpType
{
        #define SOAP_UNION__fes__union_BinarySpatialOpType_ValueReference	(1)	/**< union variant selector value for member ValueReference */
        std::string *ValueReference;
        #define SOAP_UNION__fes__union_BinarySpatialOpType_Function	(2)	/**< union variant selector value for member Function */
        fes__FunctionType *Function;
        #define SOAP_UNION__fes__union_BinarySpatialOpType_Literal	(3)	/**< union variant selector value for member Literal */
        fes__LiteralType *Literal;
        #define SOAP_UNION__fes__union_BinarySpatialOpType___any	(4)	/**< union variant selector value for member __any */
        char *__any;
};
#endif

/* ws-inspire-wfs2.h:9019 */
#ifndef SOAP_TYPE___fes__union_BinarySpatialOpType
#define SOAP_TYPE___fes__union_BinarySpatialOpType (764)
/* Wrapper: */
class SOAP_CMAC __fes__union_BinarySpatialOpType {
      public:
        /// Union with union _fes__union_BinarySpatialOpType variant selector __union_BinarySpatialOpType set to one of: SOAP_UNION__fes__union_BinarySpatialOpType_ValueReference SOAP_UNION__fes__union_BinarySpatialOpType_Function SOAP_UNION__fes__union_BinarySpatialOpType_Literal SOAP_UNION__fes__union_BinarySpatialOpType___any
        int __union_BinarySpatialOpType;
        union _fes__union_BinarySpatialOpType union_BinarySpatialOpType;
      public:
        /// Return unique type id SOAP_TYPE___fes__union_BinarySpatialOpType
        virtual long soap_type(void) const { return SOAP_TYPE___fes__union_BinarySpatialOpType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __fes__union_BinarySpatialOpType, default initialized and not managed by a soap context
        virtual __fes__union_BinarySpatialOpType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__fes__union_BinarySpatialOpType); }
      public:
        /// Constructor with default initializations
        __fes__union_BinarySpatialOpType() : __union_BinarySpatialOpType() { }
        virtual ~__fes__union_BinarySpatialOpType() { }
        /// Friend allocator used by soap_new___fes__union_BinarySpatialOpType(struct soap*, int)
        friend SOAP_FMAC1 __fes__union_BinarySpatialOpType * SOAP_FMAC2 soap_instantiate___fes__union_BinarySpatialOpType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:556 */
#ifndef SOAP_TYPE_fes__BinarySpatialOpType
#define SOAP_TYPE_fes__BinarySpatialOpType (187)
/* complex XML schema type 'fes:BinarySpatialOpType': */
class SOAP_CMAC fes__BinarySpatialOpType : public fes__SpatialOpsType {
      public:
        std::vector<__fes__union_BinarySpatialOpType> __union_BinarySpatialOpType;
      public:
        /// Return unique type id SOAP_TYPE_fes__BinarySpatialOpType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__BinarySpatialOpType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__BinarySpatialOpType, default initialized and not managed by a soap context
        virtual fes__BinarySpatialOpType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__BinarySpatialOpType); }
      public:
        /// Constructor with default initializations
        fes__BinarySpatialOpType() : __union_BinarySpatialOpType() { }
        virtual ~fes__BinarySpatialOpType() { }
        /// Friend allocator used by soap_new_fes__BinarySpatialOpType(struct soap*, int)
        friend SOAP_FMAC1 fes__BinarySpatialOpType * SOAP_FMAC2 soap_instantiate_fes__BinarySpatialOpType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:9071 */
#ifndef SOAP_TYPE__fes__union_BinaryTemporalOpType
#define SOAP_TYPE__fes__union_BinaryTemporalOpType (768)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _fes__union_BinaryTemporalOpType
{
        #define SOAP_UNION__fes__union_BinaryTemporalOpType_ValueReference	(1)	/**< union variant selector value for member ValueReference */
        std::string *ValueReference;
        #define SOAP_UNION__fes__union_BinaryTemporalOpType_Function	(2)	/**< union variant selector value for member Function */
        fes__FunctionType *Function;
        #define SOAP_UNION__fes__union_BinaryTemporalOpType_Literal	(3)	/**< union variant selector value for member Literal */
        fes__LiteralType *Literal;
        #define SOAP_UNION__fes__union_BinaryTemporalOpType___any	(4)	/**< union variant selector value for member __any */
        char *__any;
};
#endif

/* ws-inspire-wfs2.h:9066 */
#ifndef SOAP_TYPE___fes__union_BinaryTemporalOpType
#define SOAP_TYPE___fes__union_BinaryTemporalOpType (767)
/* Wrapper: */
class SOAP_CMAC __fes__union_BinaryTemporalOpType {
      public:
        /// Union with union _fes__union_BinaryTemporalOpType variant selector __union_BinaryTemporalOpType set to one of: SOAP_UNION__fes__union_BinaryTemporalOpType_ValueReference SOAP_UNION__fes__union_BinaryTemporalOpType_Function SOAP_UNION__fes__union_BinaryTemporalOpType_Literal SOAP_UNION__fes__union_BinaryTemporalOpType___any
        int __union_BinaryTemporalOpType;
        union _fes__union_BinaryTemporalOpType union_BinaryTemporalOpType;
      public:
        /// Return unique type id SOAP_TYPE___fes__union_BinaryTemporalOpType
        virtual long soap_type(void) const { return SOAP_TYPE___fes__union_BinaryTemporalOpType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __fes__union_BinaryTemporalOpType, default initialized and not managed by a soap context
        virtual __fes__union_BinaryTemporalOpType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__fes__union_BinaryTemporalOpType); }
      public:
        /// Constructor with default initializations
        __fes__union_BinaryTemporalOpType() : __union_BinaryTemporalOpType() { }
        virtual ~__fes__union_BinaryTemporalOpType() { }
        /// Friend allocator used by soap_new___fes__union_BinaryTemporalOpType(struct soap*, int)
        friend SOAP_FMAC1 __fes__union_BinaryTemporalOpType * SOAP_FMAC2 soap_instantiate___fes__union_BinaryTemporalOpType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:558 */
#ifndef SOAP_TYPE_fes__BinaryTemporalOpType
#define SOAP_TYPE_fes__BinaryTemporalOpType (188)
/* complex XML schema type 'fes:BinaryTemporalOpType': */
class SOAP_CMAC fes__BinaryTemporalOpType : public fes__TemporalOpsType {
      public:
        std::vector<__fes__union_BinaryTemporalOpType> __union_BinaryTemporalOpType;
      public:
        /// Return unique type id SOAP_TYPE_fes__BinaryTemporalOpType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__BinaryTemporalOpType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__BinaryTemporalOpType, default initialized and not managed by a soap context
        virtual fes__BinaryTemporalOpType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__BinaryTemporalOpType); }
      public:
        /// Constructor with default initializations
        fes__BinaryTemporalOpType() : __union_BinaryTemporalOpType() { }
        virtual ~fes__BinaryTemporalOpType() { }
        /// Friend allocator used by soap_new_fes__BinaryTemporalOpType(struct soap*, int)
        friend SOAP_FMAC1 fes__BinaryTemporalOpType * SOAP_FMAC2 soap_instantiate_fes__BinaryTemporalOpType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:9118 */
#ifndef SOAP_TYPE__fes__union_BBOXType
#define SOAP_TYPE__fes__union_BBOXType (771)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _fes__union_BBOXType
{
        #define SOAP_UNION__fes__union_BBOXType_ValueReference	(1)	/**< union variant selector value for member ValueReference */
        std::string *ValueReference;
        #define SOAP_UNION__fes__union_BBOXType_Function	(2)	/**< union variant selector value for member Function */
        fes__FunctionType *Function;
        #define SOAP_UNION__fes__union_BBOXType_Literal	(3)	/**< union variant selector value for member Literal */
        fes__LiteralType *Literal;
        #define SOAP_UNION__fes__union_BBOXType___any	(4)	/**< union variant selector value for member __any */
        char *__any;
};
#endif

/* ws-inspire-wfs2.h:9113 */
#ifndef SOAP_TYPE___fes__union_BBOXType
#define SOAP_TYPE___fes__union_BBOXType (770)
/* Wrapper: */
class SOAP_CMAC __fes__union_BBOXType {
      public:
        /// Union with union _fes__union_BBOXType variant selector __union_BBOXType set to one of: SOAP_UNION__fes__union_BBOXType_ValueReference SOAP_UNION__fes__union_BBOXType_Function SOAP_UNION__fes__union_BBOXType_Literal SOAP_UNION__fes__union_BBOXType___any
        int __union_BBOXType;
        union _fes__union_BBOXType union_BBOXType;
      public:
        /// Return unique type id SOAP_TYPE___fes__union_BBOXType
        virtual long soap_type(void) const { return SOAP_TYPE___fes__union_BBOXType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __fes__union_BBOXType, default initialized and not managed by a soap context
        virtual __fes__union_BBOXType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__fes__union_BBOXType); }
      public:
        /// Constructor with default initializations
        __fes__union_BBOXType() : __union_BBOXType() { }
        virtual ~__fes__union_BBOXType() { }
        /// Friend allocator used by soap_new___fes__union_BBOXType(struct soap*, int)
        friend SOAP_FMAC1 __fes__union_BBOXType * SOAP_FMAC2 soap_instantiate___fes__union_BBOXType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:560 */
#ifndef SOAP_TYPE_fes__BBOXType
#define SOAP_TYPE_fes__BBOXType (189)
/* complex XML schema type 'fes:BBOXType': */
class SOAP_CMAC fes__BBOXType : public fes__SpatialOpsType {
      public:
        std::vector<__fes__union_BBOXType> __union_BBOXType;
      public:
        /// Return unique type id SOAP_TYPE_fes__BBOXType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__BBOXType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__BBOXType, default initialized and not managed by a soap context
        virtual fes__BBOXType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__BBOXType); }
      public:
        /// Constructor with default initializations
        fes__BBOXType() : __union_BBOXType() { }
        virtual ~fes__BBOXType() { }
        /// Friend allocator used by soap_new_fes__BBOXType(struct soap*, int)
        friend SOAP_FMAC1 fes__BBOXType * SOAP_FMAC2 soap_instantiate_fes__BBOXType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:9164 */
#ifndef SOAP_TYPE__fes__union_DistanceBufferType
#define SOAP_TYPE__fes__union_DistanceBufferType (774)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _fes__union_DistanceBufferType
{
        #define SOAP_UNION__fes__union_DistanceBufferType_ValueReference	(1)	/**< union variant selector value for member ValueReference */
        std::string *ValueReference;
        #define SOAP_UNION__fes__union_DistanceBufferType_Function	(2)	/**< union variant selector value for member Function */
        fes__FunctionType *Function;
        #define SOAP_UNION__fes__union_DistanceBufferType_Literal	(3)	/**< union variant selector value for member Literal */
        fes__LiteralType *Literal;
        #define SOAP_UNION__fes__union_DistanceBufferType___any	(4)	/**< union variant selector value for member __any */
        char *__any;
};
#endif

/* ws-inspire-wfs2.h:9160 */
#ifndef SOAP_TYPE___fes__union_DistanceBufferType
#define SOAP_TYPE___fes__union_DistanceBufferType (773)
/* Wrapper: */
class SOAP_CMAC __fes__union_DistanceBufferType {
      public:
        /// Union with union _fes__union_DistanceBufferType variant selector __union_DistanceBufferType set to one of: SOAP_UNION__fes__union_DistanceBufferType_ValueReference SOAP_UNION__fes__union_DistanceBufferType_Function SOAP_UNION__fes__union_DistanceBufferType_Literal SOAP_UNION__fes__union_DistanceBufferType___any
        int __union_DistanceBufferType;
        union _fes__union_DistanceBufferType union_DistanceBufferType;
      public:
        /// Return unique type id SOAP_TYPE___fes__union_DistanceBufferType
        virtual long soap_type(void) const { return SOAP_TYPE___fes__union_DistanceBufferType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __fes__union_DistanceBufferType, default initialized and not managed by a soap context
        virtual __fes__union_DistanceBufferType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__fes__union_DistanceBufferType); }
      public:
        /// Constructor with default initializations
        __fes__union_DistanceBufferType() : __union_DistanceBufferType() { }
        virtual ~__fes__union_DistanceBufferType() { }
        /// Friend allocator used by soap_new___fes__union_DistanceBufferType(struct soap*, int)
        friend SOAP_FMAC1 __fes__union_DistanceBufferType * SOAP_FMAC2 soap_instantiate___fes__union_DistanceBufferType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:562 */
#ifndef SOAP_TYPE_fes__DistanceBufferType
#define SOAP_TYPE_fes__DistanceBufferType (190)
/* complex XML schema type 'fes:DistanceBufferType': */
class SOAP_CMAC fes__DistanceBufferType : public fes__SpatialOpsType {
      public:
        std::vector<__fes__union_DistanceBufferType> __union_DistanceBufferType;
        /// Required element 'fes:Distance' of XML schema type 'fes:MeasureType'
        fes__MeasureType *Distance;
      public:
        /// Return unique type id SOAP_TYPE_fes__DistanceBufferType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__DistanceBufferType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__DistanceBufferType, default initialized and not managed by a soap context
        virtual fes__DistanceBufferType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__DistanceBufferType); }
      public:
        /// Constructor with default initializations
        fes__DistanceBufferType() : __union_DistanceBufferType(), Distance() { }
        virtual ~fes__DistanceBufferType() { }
        /// Friend allocator used by soap_new_fes__DistanceBufferType(struct soap*, int)
        friend SOAP_FMAC1 fes__DistanceBufferType * SOAP_FMAC2 soap_instantiate_fes__DistanceBufferType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:9327 */
#ifndef SOAP_TYPE__fes__union_BinaryLogicOpType_______
#define SOAP_TYPE__fes__union_BinaryLogicOpType_______ (781)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _fes__union_BinaryLogicOpType_______
{
        #define SOAP_UNION__fes__union_BinaryLogicOpType________ResourceId	(1)	/**< union variant selector value for member ResourceId */
        fes__ResourceIdType *ResourceId;
};
#endif

/* ws-inspire-wfs2.h:9322 */
#ifndef SOAP_TYPE___fes__union_BinaryLogicOpType_______
#define SOAP_TYPE___fes__union_BinaryLogicOpType_______ (780)
/* Wrapper: */
class SOAP_CMAC __fes__union_BinaryLogicOpType_______ {
      public:
        /// Union with union _fes__union_BinaryLogicOpType_______ variant selector __union_x005fId set to one of: SOAP_UNION__fes__union_BinaryLogicOpType________ResourceId
        int __union_x005fId;
        union _fes__union_BinaryLogicOpType_______ union_BinaryLogicOpType_______;
      public:
        /// Return unique type id SOAP_TYPE___fes__union_BinaryLogicOpType_______
        virtual long soap_type(void) const { return SOAP_TYPE___fes__union_BinaryLogicOpType_______; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __fes__union_BinaryLogicOpType_______, default initialized and not managed by a soap context
        virtual __fes__union_BinaryLogicOpType_______ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__fes__union_BinaryLogicOpType_______); }
      public:
        /// Constructor with default initializations
        __fes__union_BinaryLogicOpType_______() : __union_x005fId() { }
        virtual ~__fes__union_BinaryLogicOpType_______() { }
        /// Friend allocator used by soap_new___fes__union_BinaryLogicOpType_______(struct soap*, int)
        friend SOAP_FMAC1 __fes__union_BinaryLogicOpType_______ * SOAP_FMAC2 soap_instantiate___fes__union_BinaryLogicOpType_______(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:9320 */
#ifndef SOAP_TYPE____fes__union_BinaryLogicOpType_______
#define SOAP_TYPE____fes__union_BinaryLogicOpType_______ (779)
/* Wrapper: */
struct SOAP_CMAC ___fes__union_BinaryLogicOpType_______ {
      public:
        /** Sequence of elements '-union-BinaryLogicOpType' of XML schema type '-fes:union-BinaryLogicOpType' stored in dynamic array __union_BinaryLogicOpType_______ of length __size_x005fId */
        int __size_x005fId;
        __fes__union_BinaryLogicOpType_______ *__union_BinaryLogicOpType_______;
      public:
        /** Return unique type id SOAP_TYPE____fes__union_BinaryLogicOpType_______ */
        long soap_type() const { return SOAP_TYPE____fes__union_BinaryLogicOpType_______; }
        /** Friend allocator */
        friend SOAP_FMAC1 ___fes__union_BinaryLogicOpType_______ * SOAP_FMAC2 soap_instantiate____fes__union_BinaryLogicOpType_______(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:9215 */
#ifndef SOAP_TYPE__fes__union_BinaryLogicOpType_
#define SOAP_TYPE__fes__union_BinaryLogicOpType_ (778)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _fes__union_BinaryLogicOpType_
{
        #define SOAP_UNION__fes__union_BinaryLogicOpType__PropertyIsEqualTo	(1)	/**< union variant selector value for member PropertyIsEqualTo */
        fes__BinaryComparisonOpType *PropertyIsEqualTo;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__PropertyIsNotEqualTo	(2)	/**< union variant selector value for member PropertyIsNotEqualTo */
        fes__BinaryComparisonOpType *PropertyIsNotEqualTo;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__PropertyIsLessThan	(3)	/**< union variant selector value for member PropertyIsLessThan */
        fes__BinaryComparisonOpType *PropertyIsLessThan;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__PropertyIsGreaterThan	(4)	/**< union variant selector value for member PropertyIsGreaterThan */
        fes__BinaryComparisonOpType *PropertyIsGreaterThan;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__PropertyIsLessThanOrEqualTo	(5)	/**< union variant selector value for member PropertyIsLessThanOrEqualTo */
        fes__BinaryComparisonOpType *PropertyIsLessThanOrEqualTo;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__PropertyIsGreaterThanOrEqualTo	(6)	/**< union variant selector value for member PropertyIsGreaterThanOrEqualTo */
        fes__BinaryComparisonOpType *PropertyIsGreaterThanOrEqualTo;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__PropertyIsLike	(7)	/**< union variant selector value for member PropertyIsLike */
        fes__PropertyIsLikeType *PropertyIsLike;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__PropertyIsNull	(8)	/**< union variant selector value for member PropertyIsNull */
        fes__PropertyIsNullType *PropertyIsNull;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__PropertyIsNil	(9)	/**< union variant selector value for member PropertyIsNil */
        fes__PropertyIsNilType *PropertyIsNil;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__PropertyIsBetween	(10)	/**< union variant selector value for member PropertyIsBetween */
        fes__PropertyIsBetweenType *PropertyIsBetween;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__Equals	(11)	/**< union variant selector value for member Equals */
        fes__BinarySpatialOpType *Equals;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__Disjoint	(12)	/**< union variant selector value for member Disjoint */
        fes__BinarySpatialOpType *Disjoint;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__Touches	(13)	/**< union variant selector value for member Touches */
        fes__BinarySpatialOpType *Touches;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__Within	(14)	/**< union variant selector value for member Within */
        fes__BinarySpatialOpType *Within;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__Overlaps	(15)	/**< union variant selector value for member Overlaps */
        fes__BinarySpatialOpType *Overlaps;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__Crosses	(16)	/**< union variant selector value for member Crosses */
        fes__BinarySpatialOpType *Crosses;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__Intersects	(17)	/**< union variant selector value for member Intersects */
        fes__BinarySpatialOpType *Intersects;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__Contains	(18)	/**< union variant selector value for member Contains */
        fes__BinarySpatialOpType *Contains;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__DWithin	(19)	/**< union variant selector value for member DWithin */
        fes__DistanceBufferType *DWithin;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__Beyond	(20)	/**< union variant selector value for member Beyond */
        fes__DistanceBufferType *Beyond;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__BBOX	(21)	/**< union variant selector value for member BBOX */
        fes__BBOXType *BBOX;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__After	(22)	/**< union variant selector value for member After */
        fes__BinaryTemporalOpType *After;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__Before	(23)	/**< union variant selector value for member Before */
        fes__BinaryTemporalOpType *Before;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__Begins	(24)	/**< union variant selector value for member Begins */
        fes__BinaryTemporalOpType *Begins;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__BegunBy	(25)	/**< union variant selector value for member BegunBy */
        fes__BinaryTemporalOpType *BegunBy;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__TContains	(26)	/**< union variant selector value for member TContains */
        fes__BinaryTemporalOpType *TContains;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__During	(27)	/**< union variant selector value for member During */
        fes__BinaryTemporalOpType *During;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__EndedBy	(28)	/**< union variant selector value for member EndedBy */
        fes__BinaryTemporalOpType *EndedBy;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__Ends	(29)	/**< union variant selector value for member Ends */
        fes__BinaryTemporalOpType *Ends;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__TEquals	(30)	/**< union variant selector value for member TEquals */
        fes__BinaryTemporalOpType *TEquals;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__Meets	(31)	/**< union variant selector value for member Meets */
        fes__BinaryTemporalOpType *Meets;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__MetBy	(32)	/**< union variant selector value for member MetBy */
        fes__BinaryTemporalOpType *MetBy;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__TOverlaps	(33)	/**< union variant selector value for member TOverlaps */
        fes__BinaryTemporalOpType *TOverlaps;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__OverlappedBy	(34)	/**< union variant selector value for member OverlappedBy */
        fes__BinaryTemporalOpType *OverlappedBy;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__AnyInteracts	(35)	/**< union variant selector value for member AnyInteracts */
        fes__BinaryTemporalOpType *AnyInteracts;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__And	(36)	/**< union variant selector value for member And */
        fes__BinaryLogicOpType *And;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__Or	(37)	/**< union variant selector value for member Or */
        fes__BinaryLogicOpType *Or;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__Not	(38)	/**< union variant selector value for member Not */
        fes__UnaryLogicOpType *Not;
        #define SOAP_UNION__fes__union_BinaryLogicOpType__Function	(39)	/**< union variant selector value for member Function */
        fes__FunctionType *Function;
        #define SOAP_UNION__fes__union_BinaryLogicOpType____union_BinaryLogicOpType_______	(40)	/**< union variant selector value for member __union_BinaryLogicOpType_______ */
        struct ___fes__union_BinaryLogicOpType_______ __union_BinaryLogicOpType_______;
};
#endif

/* ws-inspire-wfs2.h:9209 */
#ifndef SOAP_TYPE___fes__union_BinaryLogicOpType
#define SOAP_TYPE___fes__union_BinaryLogicOpType (777)
/* Wrapper: */
class SOAP_CMAC __fes__union_BinaryLogicOpType {
      public:
        /// Union with union _fes__union_BinaryLogicOpType_ variant selector __union_BinaryLogicOpType_ set to one of: SOAP_UNION__fes__union_BinaryLogicOpType__PropertyIsEqualTo SOAP_UNION__fes__union_BinaryLogicOpType__PropertyIsNotEqualTo SOAP_UNION__fes__union_BinaryLogicOpType__PropertyIsLessThan SOAP_UNION__fes__union_BinaryLogicOpType__PropertyIsGreaterThan SOAP_UNION__fes__union_BinaryLogicOpType__PropertyIsLessThanOrEqualTo SOAP_UNION__fes__union_BinaryLogicOpType__PropertyIsGreaterThanOrEqualTo SOAP_UNION__fes__union_BinaryLogicOpType__PropertyIsLike SOAP_UNION__fes__union_BinaryLogicOpType__PropertyIsNull SOAP_UNION__fes__union_BinaryLogicOpType__PropertyIsNil SOAP_UNION__fes__union_BinaryLogicOpType__PropertyIsBetween SOAP_UNION__fes__union_BinaryLogicOpType__Equals SOAP_UNION__fes__union_BinaryLogicOpType__Disjoint SOAP_UNION__fes__union_BinaryLogicOpType__Touches SOAP_UNION__fes__union_BinaryLogicOpType__Within SOAP_UNION__fes__union_BinaryLogicOpType__Overlaps SOAP_UNION__fes__union_BinaryLogicOpType__Crosses SOAP_UNION__fes__union_BinaryLogicOpType__Intersects SOAP_UNION__fes__union_BinaryLogicOpType__Contains SOAP_UNION__fes__union_BinaryLogicOpType__DWithin SOAP_UNION__fes__union_BinaryLogicOpType__Beyond SOAP_UNION__fes__union_BinaryLogicOpType__BBOX SOAP_UNION__fes__union_BinaryLogicOpType__After SOAP_UNION__fes__union_BinaryLogicOpType__Before SOAP_UNION__fes__union_BinaryLogicOpType__Begins SOAP_UNION__fes__union_BinaryLogicOpType__BegunBy SOAP_UNION__fes__union_BinaryLogicOpType__TContains SOAP_UNION__fes__union_BinaryLogicOpType__During SOAP_UNION__fes__union_BinaryLogicOpType__EndedBy SOAP_UNION__fes__union_BinaryLogicOpType__Ends SOAP_UNION__fes__union_BinaryLogicOpType__TEquals SOAP_UNION__fes__union_BinaryLogicOpType__Meets SOAP_UNION__fes__union_BinaryLogicOpType__MetBy SOAP_UNION__fes__union_BinaryLogicOpType__TOverlaps SOAP_UNION__fes__union_BinaryLogicOpType__OverlappedBy SOAP_UNION__fes__union_BinaryLogicOpType__AnyInteracts SOAP_UNION__fes__union_BinaryLogicOpType__And SOAP_UNION__fes__union_BinaryLogicOpType__Or SOAP_UNION__fes__union_BinaryLogicOpType__Not SOAP_UNION__fes__union_BinaryLogicOpType__Function SOAP_UNION__fes__union_BinaryLogicOpType____union_BinaryLogicOpType_______
        int __union_BinaryLogicOpType_;
        union _fes__union_BinaryLogicOpType_ union_BinaryLogicOpType_;
      public:
        /// Return unique type id SOAP_TYPE___fes__union_BinaryLogicOpType
        virtual long soap_type(void) const { return SOAP_TYPE___fes__union_BinaryLogicOpType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __fes__union_BinaryLogicOpType, default initialized and not managed by a soap context
        virtual __fes__union_BinaryLogicOpType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__fes__union_BinaryLogicOpType); }
      public:
        /// Constructor with default initializations
        __fes__union_BinaryLogicOpType() : __union_BinaryLogicOpType_() { }
        virtual ~__fes__union_BinaryLogicOpType() { }
        /// Friend allocator used by soap_new___fes__union_BinaryLogicOpType(struct soap*, int)
        friend SOAP_FMAC1 __fes__union_BinaryLogicOpType * SOAP_FMAC2 soap_instantiate___fes__union_BinaryLogicOpType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:564 */
#ifndef SOAP_TYPE_fes__BinaryLogicOpType
#define SOAP_TYPE_fes__BinaryLogicOpType (191)
/* Type fes__BinaryLogicOpType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'fes:BinaryLogicOpType': */
class SOAP_CMAC fes__BinaryLogicOpType : public fes__LogicOpsType {
      public:
        std::vector<__fes__union_BinaryLogicOpType> __union_BinaryLogicOpType;
      public:
        /// Return unique type id SOAP_TYPE_fes__BinaryLogicOpType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__BinaryLogicOpType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__BinaryLogicOpType, default initialized and not managed by a soap context
        virtual fes__BinaryLogicOpType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__BinaryLogicOpType); }
      public:
        /// Constructor with default initializations
        fes__BinaryLogicOpType() : __union_BinaryLogicOpType() { }
        virtual ~fes__BinaryLogicOpType() { }
        /// Friend allocator used by soap_new_fes__BinaryLogicOpType(struct soap*, int)
        friend SOAP_FMAC1 fes__BinaryLogicOpType * SOAP_FMAC2 soap_instantiate_fes__BinaryLogicOpType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:9476 */
#ifndef SOAP_TYPE__fes__union_UnaryLogicOpType_______
#define SOAP_TYPE__fes__union_UnaryLogicOpType_______ (787)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _fes__union_UnaryLogicOpType_______
{
        #define SOAP_UNION__fes__union_UnaryLogicOpType________ResourceId	(1)	/**< union variant selector value for member ResourceId */
        fes__ResourceIdType *ResourceId;
};
#endif

/* ws-inspire-wfs2.h:9471 */
#ifndef SOAP_TYPE___fes__union_UnaryLogicOpType_______
#define SOAP_TYPE___fes__union_UnaryLogicOpType_______ (786)
/* Wrapper: */
class SOAP_CMAC __fes__union_UnaryLogicOpType_______ {
      public:
        /// Union with union _fes__union_UnaryLogicOpType_______ variant selector __union_x005fId set to one of: SOAP_UNION__fes__union_UnaryLogicOpType________ResourceId
        int __union_x005fId;
        union _fes__union_UnaryLogicOpType_______ union_UnaryLogicOpType_______;
      public:
        /// Return unique type id SOAP_TYPE___fes__union_UnaryLogicOpType_______
        virtual long soap_type(void) const { return SOAP_TYPE___fes__union_UnaryLogicOpType_______; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __fes__union_UnaryLogicOpType_______, default initialized and not managed by a soap context
        virtual __fes__union_UnaryLogicOpType_______ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__fes__union_UnaryLogicOpType_______); }
      public:
        /// Constructor with default initializations
        __fes__union_UnaryLogicOpType_______() : __union_x005fId() { }
        virtual ~__fes__union_UnaryLogicOpType_______() { }
        /// Friend allocator used by soap_new___fes__union_UnaryLogicOpType_______(struct soap*, int)
        friend SOAP_FMAC1 __fes__union_UnaryLogicOpType_______ * SOAP_FMAC2 soap_instantiate___fes__union_UnaryLogicOpType_______(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:9469 */
#ifndef SOAP_TYPE____fes__union_UnaryLogicOpType_______
#define SOAP_TYPE____fes__union_UnaryLogicOpType_______ (785)
/* Wrapper: */
struct SOAP_CMAC ___fes__union_UnaryLogicOpType_______ {
      public:
        /** Sequence of elements '-union-UnaryLogicOpType' of XML schema type '-fes:union-UnaryLogicOpType' stored in dynamic array __union_UnaryLogicOpType_______ of length __size_x005fId */
        int __size_x005fId;
        __fes__union_UnaryLogicOpType_______ *__union_UnaryLogicOpType_______;
      public:
        /** Return unique type id SOAP_TYPE____fes__union_UnaryLogicOpType_______ */
        long soap_type() const { return SOAP_TYPE____fes__union_UnaryLogicOpType_______; }
        /** Friend allocator */
        friend SOAP_FMAC1 ___fes__union_UnaryLogicOpType_______ * SOAP_FMAC2 soap_instantiate____fes__union_UnaryLogicOpType_______(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:9364 */
#ifndef SOAP_TYPE__fes__union_UnaryLogicOpType_
#define SOAP_TYPE__fes__union_UnaryLogicOpType_ (784)
/* Type _fes__union_UnaryLogicOpType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _fes__union_UnaryLogicOpType_
{
        #define SOAP_UNION__fes__union_UnaryLogicOpType__PropertyIsEqualTo	(1)	/**< union variant selector value for member PropertyIsEqualTo */
        fes__BinaryComparisonOpType *PropertyIsEqualTo;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__PropertyIsNotEqualTo	(2)	/**< union variant selector value for member PropertyIsNotEqualTo */
        fes__BinaryComparisonOpType *PropertyIsNotEqualTo;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__PropertyIsLessThan	(3)	/**< union variant selector value for member PropertyIsLessThan */
        fes__BinaryComparisonOpType *PropertyIsLessThan;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__PropertyIsGreaterThan	(4)	/**< union variant selector value for member PropertyIsGreaterThan */
        fes__BinaryComparisonOpType *PropertyIsGreaterThan;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__PropertyIsLessThanOrEqualTo	(5)	/**< union variant selector value for member PropertyIsLessThanOrEqualTo */
        fes__BinaryComparisonOpType *PropertyIsLessThanOrEqualTo;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__PropertyIsGreaterThanOrEqualTo	(6)	/**< union variant selector value for member PropertyIsGreaterThanOrEqualTo */
        fes__BinaryComparisonOpType *PropertyIsGreaterThanOrEqualTo;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__PropertyIsLike	(7)	/**< union variant selector value for member PropertyIsLike */
        fes__PropertyIsLikeType *PropertyIsLike;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__PropertyIsNull	(8)	/**< union variant selector value for member PropertyIsNull */
        fes__PropertyIsNullType *PropertyIsNull;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__PropertyIsNil	(9)	/**< union variant selector value for member PropertyIsNil */
        fes__PropertyIsNilType *PropertyIsNil;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__PropertyIsBetween	(10)	/**< union variant selector value for member PropertyIsBetween */
        fes__PropertyIsBetweenType *PropertyIsBetween;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__Equals	(11)	/**< union variant selector value for member Equals */
        fes__BinarySpatialOpType *Equals;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__Disjoint	(12)	/**< union variant selector value for member Disjoint */
        fes__BinarySpatialOpType *Disjoint;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__Touches	(13)	/**< union variant selector value for member Touches */
        fes__BinarySpatialOpType *Touches;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__Within	(14)	/**< union variant selector value for member Within */
        fes__BinarySpatialOpType *Within;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__Overlaps	(15)	/**< union variant selector value for member Overlaps */
        fes__BinarySpatialOpType *Overlaps;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__Crosses	(16)	/**< union variant selector value for member Crosses */
        fes__BinarySpatialOpType *Crosses;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__Intersects	(17)	/**< union variant selector value for member Intersects */
        fes__BinarySpatialOpType *Intersects;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__Contains	(18)	/**< union variant selector value for member Contains */
        fes__BinarySpatialOpType *Contains;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__DWithin	(19)	/**< union variant selector value for member DWithin */
        fes__DistanceBufferType *DWithin;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__Beyond	(20)	/**< union variant selector value for member Beyond */
        fes__DistanceBufferType *Beyond;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__BBOX	(21)	/**< union variant selector value for member BBOX */
        fes__BBOXType *BBOX;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__After	(22)	/**< union variant selector value for member After */
        fes__BinaryTemporalOpType *After;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__Before	(23)	/**< union variant selector value for member Before */
        fes__BinaryTemporalOpType *Before;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__Begins	(24)	/**< union variant selector value for member Begins */
        fes__BinaryTemporalOpType *Begins;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__BegunBy	(25)	/**< union variant selector value for member BegunBy */
        fes__BinaryTemporalOpType *BegunBy;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__TContains	(26)	/**< union variant selector value for member TContains */
        fes__BinaryTemporalOpType *TContains;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__During	(27)	/**< union variant selector value for member During */
        fes__BinaryTemporalOpType *During;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__EndedBy	(28)	/**< union variant selector value for member EndedBy */
        fes__BinaryTemporalOpType *EndedBy;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__Ends	(29)	/**< union variant selector value for member Ends */
        fes__BinaryTemporalOpType *Ends;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__TEquals	(30)	/**< union variant selector value for member TEquals */
        fes__BinaryTemporalOpType *TEquals;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__Meets	(31)	/**< union variant selector value for member Meets */
        fes__BinaryTemporalOpType *Meets;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__MetBy	(32)	/**< union variant selector value for member MetBy */
        fes__BinaryTemporalOpType *MetBy;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__TOverlaps	(33)	/**< union variant selector value for member TOverlaps */
        fes__BinaryTemporalOpType *TOverlaps;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__OverlappedBy	(34)	/**< union variant selector value for member OverlappedBy */
        fes__BinaryTemporalOpType *OverlappedBy;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__AnyInteracts	(35)	/**< union variant selector value for member AnyInteracts */
        fes__BinaryTemporalOpType *AnyInteracts;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__And	(36)	/**< union variant selector value for member And */
        fes__BinaryLogicOpType *And;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__Or	(37)	/**< union variant selector value for member Or */
        fes__BinaryLogicOpType *Or;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__Not	(38)	/**< union variant selector value for member Not */
        fes__UnaryLogicOpType *Not;
        #define SOAP_UNION__fes__union_UnaryLogicOpType__Function	(39)	/**< union variant selector value for member Function */
        fes__FunctionType *Function;
        #define SOAP_UNION__fes__union_UnaryLogicOpType____union_UnaryLogicOpType_______	(40)	/**< union variant selector value for member __union_UnaryLogicOpType_______ */
        struct ___fes__union_UnaryLogicOpType_______ __union_UnaryLogicOpType_______;
};
#endif

/* ws-inspire-wfs2.h:566 */
#ifndef SOAP_TYPE_fes__UnaryLogicOpType
#define SOAP_TYPE_fes__UnaryLogicOpType (192)
/* complex XML schema type 'fes:UnaryLogicOpType': */
class SOAP_CMAC fes__UnaryLogicOpType : public fes__LogicOpsType {
      public:
        /// Union with union _fes__union_UnaryLogicOpType_ variant selector __union_UnaryLogicOpType_ set to one of: SOAP_UNION__fes__union_UnaryLogicOpType__PropertyIsEqualTo SOAP_UNION__fes__union_UnaryLogicOpType__PropertyIsNotEqualTo SOAP_UNION__fes__union_UnaryLogicOpType__PropertyIsLessThan SOAP_UNION__fes__union_UnaryLogicOpType__PropertyIsGreaterThan SOAP_UNION__fes__union_UnaryLogicOpType__PropertyIsLessThanOrEqualTo SOAP_UNION__fes__union_UnaryLogicOpType__PropertyIsGreaterThanOrEqualTo SOAP_UNION__fes__union_UnaryLogicOpType__PropertyIsLike SOAP_UNION__fes__union_UnaryLogicOpType__PropertyIsNull SOAP_UNION__fes__union_UnaryLogicOpType__PropertyIsNil SOAP_UNION__fes__union_UnaryLogicOpType__PropertyIsBetween SOAP_UNION__fes__union_UnaryLogicOpType__Equals SOAP_UNION__fes__union_UnaryLogicOpType__Disjoint SOAP_UNION__fes__union_UnaryLogicOpType__Touches SOAP_UNION__fes__union_UnaryLogicOpType__Within SOAP_UNION__fes__union_UnaryLogicOpType__Overlaps SOAP_UNION__fes__union_UnaryLogicOpType__Crosses SOAP_UNION__fes__union_UnaryLogicOpType__Intersects SOAP_UNION__fes__union_UnaryLogicOpType__Contains SOAP_UNION__fes__union_UnaryLogicOpType__DWithin SOAP_UNION__fes__union_UnaryLogicOpType__Beyond SOAP_UNION__fes__union_UnaryLogicOpType__BBOX SOAP_UNION__fes__union_UnaryLogicOpType__After SOAP_UNION__fes__union_UnaryLogicOpType__Before SOAP_UNION__fes__union_UnaryLogicOpType__Begins SOAP_UNION__fes__union_UnaryLogicOpType__BegunBy SOAP_UNION__fes__union_UnaryLogicOpType__TContains SOAP_UNION__fes__union_UnaryLogicOpType__During SOAP_UNION__fes__union_UnaryLogicOpType__EndedBy SOAP_UNION__fes__union_UnaryLogicOpType__Ends SOAP_UNION__fes__union_UnaryLogicOpType__TEquals SOAP_UNION__fes__union_UnaryLogicOpType__Meets SOAP_UNION__fes__union_UnaryLogicOpType__MetBy SOAP_UNION__fes__union_UnaryLogicOpType__TOverlaps SOAP_UNION__fes__union_UnaryLogicOpType__OverlappedBy SOAP_UNION__fes__union_UnaryLogicOpType__AnyInteracts SOAP_UNION__fes__union_UnaryLogicOpType__And SOAP_UNION__fes__union_UnaryLogicOpType__Or SOAP_UNION__fes__union_UnaryLogicOpType__Not SOAP_UNION__fes__union_UnaryLogicOpType__Function SOAP_UNION__fes__union_UnaryLogicOpType____union_UnaryLogicOpType_______
        int __union_UnaryLogicOpType_;
        union _fes__union_UnaryLogicOpType_ union_UnaryLogicOpType_;
      public:
        /// Return unique type id SOAP_TYPE_fes__UnaryLogicOpType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__UnaryLogicOpType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__UnaryLogicOpType, default initialized and not managed by a soap context
        virtual fes__UnaryLogicOpType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__UnaryLogicOpType); }
      public:
        /// Constructor with default initializations
        fes__UnaryLogicOpType() : __union_UnaryLogicOpType_() { }
        virtual ~fes__UnaryLogicOpType() { }
        /// Friend allocator used by soap_new_fes__UnaryLogicOpType(struct soap*, int)
        friend SOAP_FMAC1 fes__UnaryLogicOpType * SOAP_FMAC2 soap_instantiate_fes__UnaryLogicOpType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:568 */
#ifndef SOAP_TYPE_fes__MeasureType
#define SOAP_TYPE_fes__MeasureType (193)
/* simple XML schema type 'fes:MeasureType': */
class SOAP_CMAC fes__MeasureType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:double' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'fes:UomIdentifier'
        std::string uom;
      public:
        /// Return unique type id SOAP_TYPE_fes__MeasureType
        virtual long soap_type(void) const { return SOAP_TYPE_fes__MeasureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fes__MeasureType, default initialized and not managed by a soap context
        virtual fes__MeasureType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fes__MeasureType); }
      public:
        /// Constructor with default initializations
        fes__MeasureType() : __item(), uom() { }
        virtual ~fes__MeasureType() { }
        /// Friend allocator used by soap_new_fes__MeasureType(struct soap*, int)
        friend SOAP_FMAC1 fes__MeasureType * SOAP_FMAC2 soap_instantiate_fes__MeasureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:626 */
#ifndef SOAP_TYPE_icommon__data
#define SOAP_TYPE_icommon__data (222)
/* Type icommon__data is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:data': */
class SOAP_CMAC icommon__data : public icommon__resource {
      public:
        /// Required element 'icommon:UniqueResourceIdentifier' of XML schema type 'icommon:uniqueResourceIdentifier'
        std::vector<icommon__uniqueResourceIdentifier *> UniqueResourceIdentifier;
        /// Optional element 'icommon:ResourceLanguage' of XML schema type 'icommon:languageISO6392B'
        std::vector<enum icommon__languageISO6392B> ResourceLanguage;
        /// Required element 'icommon:TopicCategory' of XML schema type 'icommon:topicCategory'
        std::vector<enum icommon__topicCategory> TopicCategory;
        /// Required element 'icommon:Lineage' of XML schema type 'icommon:notEmptyString'
        std::string Lineage;
      public:
        /// Return unique type id SOAP_TYPE_icommon__data
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__data; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__data, default initialized and not managed by a soap context
        virtual icommon__data *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__data); }
      public:
        /// Constructor with default initializations
        icommon__data() : UniqueResourceIdentifier(), ResourceLanguage(), TopicCategory(), Lineage() { }
        virtual ~icommon__data() { }
        /// Friend allocator used by soap_new_icommon__data(struct soap*, int)
        friend SOAP_FMAC1 icommon__data * SOAP_FMAC2 soap_instantiate_icommon__data(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:632 */
#ifndef SOAP_TYPE_icommon__service_x005fext
#define SOAP_TYPE_icommon__service_x005fext (225)
/* Type icommon__service_x005fext is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:service_ext': */
class SOAP_CMAC icommon__service_x005fext : public icommon__resource {
      public:
        /// Optional element 'icommon:CoupledResource' of XML schema type 'icommon:uniqueResourceIdentifier'
        std::vector<icommon__uniqueResourceIdentifier *> CoupledResource;
        /// Required element 'icommon:SpatialDataServiceType' of XML schema type 'icommon:spatialDataServiceType'
        enum icommon__spatialDataServiceType SpatialDataServiceType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__service_x005fext
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__service_x005fext; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__service_x005fext, default initialized and not managed by a soap context
        virtual icommon__service_x005fext *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__service_x005fext); }
      public:
        /// Constructor with default initializations
        icommon__service_x005fext() : CoupledResource(), SpatialDataServiceType() { }
        virtual ~icommon__service_x005fext() { }
        /// Friend allocator used by soap_new_icommon__service_x005fext(struct soap*, int)
        friend SOAP_FMAC1 icommon__service_x005fext * SOAP_FMAC2 soap_instantiate_icommon__service_x005fext(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:9707 */
#ifndef SOAP_TYPE__icommon__union_citationConformity
#define SOAP_TYPE__icommon__union_citationConformity (791)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationConformity
{
        #define SOAP_UNION__icommon__union_citationConformity_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        std::string *DateOfPublication;
        #define SOAP_UNION__icommon__union_citationConformity_DateOfCreation	(2)	/**< union variant selector value for member DateOfCreation */
        std::string *DateOfCreation;
        #define SOAP_UNION__icommon__union_citationConformity_DateOfLastRevision	(3)	/**< union variant selector value for member DateOfLastRevision */
        std::string *DateOfLastRevision;
};
#endif

/* ws-inspire-wfs2.h:642 */
#ifndef SOAP_TYPE_icommon__citationConformity
#define SOAP_TYPE_icommon__citationConformity (230)
/* complex XML schema type 'icommon:citationConformity': */
class SOAP_CMAC icommon__citationConformity : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:notEmptyString'
        std::string Title;
        /// Union with union _icommon__union_citationConformity variant selector __union_citationConformity set to one of: SOAP_UNION__icommon__union_citationConformity_DateOfPublication SOAP_UNION__icommon__union_citationConformity_DateOfCreation SOAP_UNION__icommon__union_citationConformity_DateOfLastRevision
        int __union_citationConformity;
        union _icommon__union_citationConformity union_citationConformity;
        /// Optional element 'icommon:URI' of XML schema type 'xsd:anyURI'
        std::vector<char *> URI;
        /// Optional element 'icommon:ResourceLocator' of XML schema type 'icommon:resourceLocatorType'
        std::vector<icommon__resourceLocatorType *> ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationConformity
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationConformity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationConformity, default initialized and not managed by a soap context
        virtual icommon__citationConformity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationConformity); }
      public:
        /// Constructor with default initializations
        icommon__citationConformity() : Title(), __union_citationConformity(), URI(), ResourceLocator() { }
        virtual ~icommon__citationConformity() { }
        /// Friend allocator used by soap_new_icommon__citationConformity(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationConformity * SOAP_FMAC2 soap_instantiate_icommon__citationConformity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:9756 */
#ifndef SOAP_TYPE__icommon__union_originatingControlledVocabulary
#define SOAP_TYPE__icommon__union_originatingControlledVocabulary (792)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_originatingControlledVocabulary
{
        #define SOAP_UNION__icommon__union_originatingControlledVocabulary_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        std::string *DateOfPublication;
        #define SOAP_UNION__icommon__union_originatingControlledVocabulary_DateOfCreation	(2)	/**< union variant selector value for member DateOfCreation */
        std::string *DateOfCreation;
        #define SOAP_UNION__icommon__union_originatingControlledVocabulary_DateOfLastRevision	(3)	/**< union variant selector value for member DateOfLastRevision */
        std::string *DateOfLastRevision;
};
#endif

/* ws-inspire-wfs2.h:646 */
#ifndef SOAP_TYPE_icommon__originatingControlledVocabulary
#define SOAP_TYPE_icommon__originatingControlledVocabulary (232)
/* complex XML schema type 'icommon:originatingControlledVocabulary': */
class SOAP_CMAC icommon__originatingControlledVocabulary : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:notEmptyString'
        std::string Title;
        /// Union with union _icommon__union_originatingControlledVocabulary variant selector __union_originatingControlledVocabulary set to one of: SOAP_UNION__icommon__union_originatingControlledVocabulary_DateOfPublication SOAP_UNION__icommon__union_originatingControlledVocabulary_DateOfCreation SOAP_UNION__icommon__union_originatingControlledVocabulary_DateOfLastRevision
        int __union_originatingControlledVocabulary;
        union _icommon__union_originatingControlledVocabulary union_originatingControlledVocabulary;
        /// Optional element 'icommon:URI' of XML schema type 'xsd:anyURI'
        std::vector<char *> URI;
        /// Optional element 'icommon:ResourceLocator' of XML schema type 'icommon:resourceLocatorType'
        std::vector<icommon__resourceLocatorType *> ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__originatingControlledVocabulary
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__originatingControlledVocabulary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__originatingControlledVocabulary, default initialized and not managed by a soap context
        virtual icommon__originatingControlledVocabulary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__originatingControlledVocabulary); }
      public:
        /// Constructor with default initializations
        icommon__originatingControlledVocabulary() : Title(), __union_originatingControlledVocabulary(), URI(), ResourceLocator() { }
        virtual ~icommon__originatingControlledVocabulary() { }
        /// Friend allocator used by soap_new_icommon__originatingControlledVocabulary(struct soap*, int)
        friend SOAP_FMAC1 icommon__originatingControlledVocabulary * SOAP_FMAC2 soap_instantiate_icommon__originatingControlledVocabulary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:658 */
#ifndef SOAP_TYPE_icommon__classificationOfSpatialDataService
#define SOAP_TYPE_icommon__classificationOfSpatialDataService (238)
/* complex XML schema type 'icommon:classificationOfSpatialDataService': */
class SOAP_CMAC icommon__classificationOfSpatialDataService : public xsd__anyType {
      public:
        /// Optional element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabulary'
        std::vector<icommon__originatingControlledVocabulary *> OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:classificationOfSpatialDataService-KeywordValue'
        enum _icommon__classificationOfSpatialDataService_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__classificationOfSpatialDataService
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__classificationOfSpatialDataService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__classificationOfSpatialDataService, default initialized and not managed by a soap context
        virtual icommon__classificationOfSpatialDataService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__classificationOfSpatialDataService); }
      public:
        /// Constructor with default initializations
        icommon__classificationOfSpatialDataService() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__classificationOfSpatialDataService() { }
        /// Friend allocator used by soap_new_icommon__classificationOfSpatialDataService(struct soap*, int)
        friend SOAP_FMAC1 icommon__classificationOfSpatialDataService * SOAP_FMAC2 soap_instantiate_icommon__classificationOfSpatialDataService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:664 */
#ifndef SOAP_TYPE_icommon__languageElementISO6392B
#define SOAP_TYPE_icommon__languageElementISO6392B (241)
/* complex XML schema type 'icommon:languageElementISO6392B': */
class SOAP_CMAC icommon__languageElementISO6392B : public xsd__anyType {
      public:
        /// Required element 'icommon:Language' of XML schema type 'icommon:euLanguageISO6392B'
        enum icommon__euLanguageISO6392B Language;
      public:
        /// Return unique type id SOAP_TYPE_icommon__languageElementISO6392B
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__languageElementISO6392B; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__languageElementISO6392B, default initialized and not managed by a soap context
        virtual icommon__languageElementISO6392B *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__languageElementISO6392B); }
      public:
        /// Constructor with default initializations
        icommon__languageElementISO6392B() : Language() { }
        virtual ~icommon__languageElementISO6392B() { }
        /// Friend allocator used by soap_new_icommon__languageElementISO6392B(struct soap*, int)
        friend SOAP_FMAC1 icommon__languageElementISO6392B * SOAP_FMAC2 soap_instantiate_icommon__languageElementISO6392B(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:666 */
#ifndef SOAP_TYPE_icommon__languageElementIETF
#define SOAP_TYPE_icommon__languageElementIETF (242)
/* Type icommon__languageElementIETF is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:languageElementIETF': */
class SOAP_CMAC icommon__languageElementIETF : public xsd__anyType {
      public:
        /// Required element 'icommon:Language' of XML schema type 'icommon:euLanguageIETF'
        enum icommon__euLanguageIETF Language;
      public:
        /// Return unique type id SOAP_TYPE_icommon__languageElementIETF
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__languageElementIETF; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__languageElementIETF, default initialized and not managed by a soap context
        virtual icommon__languageElementIETF *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__languageElementIETF); }
      public:
        /// Constructor with default initializations
        icommon__languageElementIETF() : Language() { }
        virtual ~icommon__languageElementIETF() { }
        /// Friend allocator used by soap_new_icommon__languageElementIETF(struct soap*, int)
        friend SOAP_FMAC1 icommon__languageElementIETF * SOAP_FMAC2 soap_instantiate_icommon__languageElementIETF(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:674 */
#ifndef SOAP_TYPE_icommon__inspireTheme
#define SOAP_TYPE_icommon__inspireTheme (246)
/* complex XML schema type 'icommon:inspireTheme': */
class SOAP_CMAC icommon__inspireTheme : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:keywordValue'
        std::string KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme, default initialized and not managed by a soap context
        virtual icommon__inspireTheme *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:708 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fbul
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fbul (263)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005fbul is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_bul': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005fbul : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_bul-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fbul_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_bul-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fbul_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fbul
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fbul; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005fbul, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005fbul *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005fbul); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005fbul() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005fbul() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005fbul(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005fbul * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005fbul(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:714 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fcze
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fcze (266)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005fcze is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_cze': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005fcze : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_cze-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fcze_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_cze-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fcze_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fcze
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fcze; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005fcze, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005fcze *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005fcze); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005fcze() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005fcze() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005fcze(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005fcze * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005fcze(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:720 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fdan
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fdan (269)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005fdan is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_dan': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005fdan : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_dan-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fdan_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_dan-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fdan_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fdan
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fdan; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005fdan, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005fdan *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005fdan); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005fdan() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005fdan() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005fdan(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005fdan * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005fdan(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:726 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fdut
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fdut (272)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005fdut is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_dut': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005fdut : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_dut-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fdut_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_dut-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fdut_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fdut
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fdut; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005fdut, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005fdut *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005fdut); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005fdut() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005fdut() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005fdut(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005fdut * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005fdut(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:732 */
#ifndef SOAP_TYPE_icommon__resLocGEMETInspireThemes_x005feng
#define SOAP_TYPE_icommon__resLocGEMETInspireThemes_x005feng (275)
/* Type icommon__resLocGEMETInspireThemes_x005feng is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocGEMETInspireThemes_eng': */
class SOAP_CMAC icommon__resLocGEMETInspireThemes_x005feng : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocGEMETInspireThemes_eng-URL'
        enum _icommon__resLocGEMETInspireThemes_x005feng_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocGEMETInspireThemes_eng-MediaType'
        enum _icommon__resLocGEMETInspireThemes_x005feng_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocGEMETInspireThemes_x005feng
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocGEMETInspireThemes_x005feng; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocGEMETInspireThemes_x005feng, default initialized and not managed by a soap context
        virtual icommon__resLocGEMETInspireThemes_x005feng *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocGEMETInspireThemes_x005feng); }
      public:
        /// Constructor with default initializations
        icommon__resLocGEMETInspireThemes_x005feng() : URL(), MediaType() { }
        virtual ~icommon__resLocGEMETInspireThemes_x005feng() { }
        /// Friend allocator used by soap_new_icommon__resLocGEMETInspireThemes_x005feng(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocGEMETInspireThemes_x005feng * SOAP_FMAC2 soap_instantiate_icommon__resLocGEMETInspireThemes_x005feng(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:10146 */
#ifndef SOAP_TYPE__icommon__union_citationGEMETInspireThemes_x005feng
#define SOAP_TYPE__icommon__union_citationGEMETInspireThemes_x005feng (807)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationGEMETInspireThemes_x005feng
{
        #define SOAP_UNION__icommon__union_citationGEMETInspireThemes_x005feng_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationGEMETInspireThemes_x005feng_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:734 */
#ifndef SOAP_TYPE_icommon__citationGEMETInspireThemes_x005feng
#define SOAP_TYPE_icommon__citationGEMETInspireThemes_x005feng (276)
/* Type icommon__citationGEMETInspireThemes_x005feng is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationGEMETInspireThemes_eng': */
class SOAP_CMAC icommon__citationGEMETInspireThemes_x005feng : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationGEMETInspireThemes_eng-Title'
        enum _icommon__citationGEMETInspireThemes_x005feng_Title Title;
        /// Union with union _icommon__union_citationGEMETInspireThemes_x005feng variant selector __union_citationGEMETInspireThemes_x005feng set to one of: SOAP_UNION__icommon__union_citationGEMETInspireThemes_x005feng_DateOfPublication
        int __union_citationGEMETInspireThemes_x005feng;
        union _icommon__union_citationGEMETInspireThemes_x005feng union_citationGEMETInspireThemes_x005feng;
        /// Optional element 'icommon:URI' of XML schema type 'xsd:anyType'
        std::vector<char *> URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocGEMETInspireThemes_eng'
        icommon__resLocGEMETInspireThemes_x005feng *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationGEMETInspireThemes_x005feng
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationGEMETInspireThemes_x005feng; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationGEMETInspireThemes_x005feng, default initialized and not managed by a soap context
        virtual icommon__citationGEMETInspireThemes_x005feng *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationGEMETInspireThemes_x005feng); }
      public:
        /// Constructor with default initializations
        icommon__citationGEMETInspireThemes_x005feng() : Title(), __union_citationGEMETInspireThemes_x005feng(), URI(), ResourceLocator() { }
        virtual ~icommon__citationGEMETInspireThemes_x005feng() { }
        /// Friend allocator used by soap_new_icommon__citationGEMETInspireThemes_x005feng(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationGEMETInspireThemes_x005feng * SOAP_FMAC2 soap_instantiate_icommon__citationGEMETInspireThemes_x005feng(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:736 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005feng
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005feng (277)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005feng is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_eng': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005feng : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_eng-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005feng_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_eng-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005feng_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005feng
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005feng; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005feng, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005feng *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005feng); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005feng() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005feng() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005feng(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005feng * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005feng(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:742 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fest
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fest (280)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005fest is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_est': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005fest : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_est-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fest_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_est-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fest_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fest
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005fest, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005fest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005fest); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005fest() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005fest() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005fest(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005fest * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005fest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:748 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005ffin
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005ffin (283)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005ffin is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_fin': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005ffin : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_fin-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005ffin_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_fin-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005ffin_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005ffin
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005ffin; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005ffin, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005ffin *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005ffin); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005ffin() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005ffin() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005ffin(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005ffin * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005ffin(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:754 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005ffre
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005ffre (286)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005ffre is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_fre': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005ffre : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_fre-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005ffre_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_fre-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005ffre_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005ffre
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005ffre; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005ffre, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005ffre *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005ffre); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005ffre() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005ffre() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005ffre(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005ffre * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005ffre(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:760 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fger
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fger (289)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005fger is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_ger': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005fger : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_ger-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fger_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_ger-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fger_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fger
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fger; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005fger, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005fger *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005fger); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005fger() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005fger() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005fger(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005fger * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005fger(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:766 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fgle
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fgle (292)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005fgle is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_gle': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005fgle : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_gle-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fgle_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_gle-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fgle_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fgle
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fgle; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005fgle, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005fgle *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005fgle); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005fgle() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005fgle() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005fgle(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005fgle * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005fgle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:772 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fgre
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fgre (295)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005fgre is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_gre': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005fgre : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_gre-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fgre_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_gre-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fgre_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fgre
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fgre; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005fgre, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005fgre *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005fgre); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005fgre() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005fgre() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005fgre(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005fgre * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005fgre(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:778 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fhun
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fhun (298)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005fhun is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_hun': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005fhun : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_hun-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fhun_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_hun-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fhun_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fhun
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fhun; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005fhun, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005fhun *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005fhun); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005fhun() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005fhun() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005fhun(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005fhun * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005fhun(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:784 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fita
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fita (301)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005fita is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_ita': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005fita : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_ita-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fita_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_ita-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fita_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fita
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fita; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005fita, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005fita *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005fita); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005fita() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005fita() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005fita(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005fita * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005fita(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:790 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005flav
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005flav (304)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005flav is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_lav': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005flav : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_lav-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005flav_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_lav-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005flav_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005flav
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005flav; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005flav, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005flav *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005flav); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005flav() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005flav() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005flav(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005flav * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005flav(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:796 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005flit
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005flit (307)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005flit is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_lit': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005flit : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_lit-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005flit_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_lit-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005flit_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005flit
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005flit; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005flit, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005flit *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005flit); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005flit() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005flit() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005flit(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005flit * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005flit(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:802 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fmlt
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fmlt (310)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005fmlt is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_mlt': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005fmlt : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_mlt-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fmlt_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_mlt-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fmlt_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fmlt
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fmlt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005fmlt, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005fmlt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005fmlt); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005fmlt() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005fmlt() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005fmlt(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005fmlt * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005fmlt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:808 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fpol
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fpol (313)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005fpol is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_pol': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005fpol : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_pol-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fpol_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_pol-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fpol_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fpol
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fpol; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005fpol, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005fpol *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005fpol); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005fpol() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005fpol() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005fpol(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005fpol * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005fpol(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:814 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fpor
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fpor (316)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005fpor is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_por': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005fpor : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_por-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fpor_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_por-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fpor_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fpor
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fpor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005fpor, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005fpor *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005fpor); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005fpor() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005fpor() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005fpor(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005fpor * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005fpor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:820 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005frum
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005frum (319)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005frum is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_rum': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005frum : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_rum-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005frum_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_rum-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005frum_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005frum
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005frum; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005frum, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005frum *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005frum); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005frum() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005frum() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005frum(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005frum * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005frum(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:826 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fslo
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fslo (322)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005fslo is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_slo': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005fslo : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_slo-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fslo_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_slo-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fslo_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fslo
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fslo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005fslo, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005fslo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005fslo); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005fslo() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005fslo() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005fslo(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005fslo * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005fslo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:832 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fslv
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fslv (325)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005fslv is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_slv': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005fslv : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_slv-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fslv_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_slv-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fslv_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fslv
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fslv; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005fslv, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005fslv *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005fslv); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005fslv() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005fslv() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005fslv(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005fslv * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005fslv(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:840 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fspa
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fspa (329)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005fspa is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_spa': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005fspa : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_spa-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fspa_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_spa-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fspa_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fspa
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fspa; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005fspa, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005fspa *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005fspa); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005fspa() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005fspa() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005fspa(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005fspa * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005fspa(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:844 */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fswe
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fswe (331)
/* Type icommon__resLocInspireInteroperabilityRegulation_x005fswe is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:resLocInspireInteroperabilityRegulation_swe': */
class SOAP_CMAC icommon__resLocInspireInteroperabilityRegulation_x005fswe : public xsd__anyType {
      public:
        /// Required element 'icommon:URL' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_swe-URL'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fswe_URL URL;
        /// Required element 'icommon:MediaType' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_swe-MediaType'
        enum _icommon__resLocInspireInteroperabilityRegulation_x005fswe_MediaType MediaType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fswe
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fswe; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__resLocInspireInteroperabilityRegulation_x005fswe, default initialized and not managed by a soap context
        virtual icommon__resLocInspireInteroperabilityRegulation_x005fswe *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__resLocInspireInteroperabilityRegulation_x005fswe); }
      public:
        /// Constructor with default initializations
        icommon__resLocInspireInteroperabilityRegulation_x005fswe() : URL(), MediaType() { }
        virtual ~icommon__resLocInspireInteroperabilityRegulation_x005fswe() { }
        /// Friend allocator used by soap_new_icommon__resLocInspireInteroperabilityRegulation_x005fswe(struct soap*, int)
        friend SOAP_FMAC1 icommon__resLocInspireInteroperabilityRegulation_x005fswe * SOAP_FMAC2 soap_instantiate_icommon__resLocInspireInteroperabilityRegulation_x005fswe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:289 */
#ifndef SOAP_TYPE_wfs__QueryType
#define SOAP_TYPE_wfs__QueryType (54)
/* Type wfs__QueryType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:QueryType': */
class SOAP_CMAC wfs__QueryType : public fes__AbstractAdhocQueryExpressionType {
      public:
        /// Optional attribute 'srsName' of XML schema type 'xsd:anyURI'
        char **srsName;
        /// Optional attribute 'featureVersion' of XML schema type 'xsd:string'
        std::string *featureVersion;
      public:
        /// Return unique type id SOAP_TYPE_wfs__QueryType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__QueryType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__QueryType, default initialized and not managed by a soap context
        virtual wfs__QueryType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__QueryType); }
      public:
        /// Constructor with default initializations
        wfs__QueryType() : srsName(), featureVersion() { }
        virtual ~wfs__QueryType() { }
        /// Friend allocator used by soap_new_wfs__QueryType(struct soap*, int)
        friend SOAP_FMAC1 wfs__QueryType * SOAP_FMAC2 soap_instantiate_wfs__QueryType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:327 */
#ifndef SOAP_TYPE_wfs__GetFeatureWithLockType
#define SOAP_TYPE_wfs__GetFeatureWithLockType (73)
/* Type wfs__GetFeatureWithLockType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wfs:GetFeatureWithLockType': */
class SOAP_CMAC wfs__GetFeatureWithLockType : public wfs__GetFeatureType {
      public:
        /// Optional attribute 'expiry' of XML schema type 'xsd:positiveInteger'
        ULONG64 expiry;
        /// Optional attribute 'lockAction' of XML schema type 'wfs:AllSomeType'
        enum wfs__AllSomeType lockAction;	///< initialized with default value = (enum wfs__AllSomeType)0
      public:
        /// Return unique type id SOAP_TYPE_wfs__GetFeatureWithLockType
        virtual long soap_type(void) const { return SOAP_TYPE_wfs__GetFeatureWithLockType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wfs__GetFeatureWithLockType, default initialized and not managed by a soap context
        virtual wfs__GetFeatureWithLockType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wfs__GetFeatureWithLockType); }
      public:
        /// Constructor with default initializations
        wfs__GetFeatureWithLockType() : expiry(), lockAction((enum wfs__AllSomeType)0) { }
        virtual ~wfs__GetFeatureWithLockType() { }
        /// Friend allocator used by soap_new_wfs__GetFeatureWithLockType(struct soap*, int)
        friend SOAP_FMAC1 wfs__GetFeatureWithLockType * SOAP_FMAC2 soap_instantiate_wfs__GetFeatureWithLockType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:10915 */
#ifndef SOAP_TYPE__ows__union_IdentificationType
#define SOAP_TYPE__ows__union_IdentificationType (850)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ows__union_IdentificationType
{
        #define SOAP_UNION__ows__union_IdentificationType_BoundingBox	(1)	/**< union variant selector value for member BoundingBox */
        std::vector<ows__BoundingBoxType *> *BoundingBox;
        #define SOAP_UNION__ows__union_IdentificationType_WGS84BoundingBox	(2)	/**< union variant selector value for member WGS84BoundingBox */
        ows__WGS84BoundingBoxType *WGS84BoundingBox;
};
#endif

/* ws-inspire-wfs2.h:10910 */
#ifndef SOAP_TYPE___ows__union_IdentificationType
#define SOAP_TYPE___ows__union_IdentificationType (849)
/* Wrapper: */
class SOAP_CMAC __ows__union_IdentificationType {
      public:
        /// Union with union _ows__union_IdentificationType variant selector __unionBoundingBox set to one of: SOAP_UNION__ows__union_IdentificationType_BoundingBox SOAP_UNION__ows__union_IdentificationType_WGS84BoundingBox
        int __unionBoundingBox;
        union _ows__union_IdentificationType union_IdentificationType;
      public:
        /// Return unique type id SOAP_TYPE___ows__union_IdentificationType
        virtual long soap_type(void) const { return SOAP_TYPE___ows__union_IdentificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __ows__union_IdentificationType, default initialized and not managed by a soap context
        virtual __ows__union_IdentificationType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__ows__union_IdentificationType); }
      public:
        /// Constructor with default initializations
        __ows__union_IdentificationType() : __unionBoundingBox() { }
        virtual ~__ows__union_IdentificationType() { }
        /// Friend allocator used by soap_new___ows__union_IdentificationType(struct soap*, int)
        friend SOAP_FMAC1 __ows__union_IdentificationType * SOAP_FMAC2 soap_instantiate___ows__union_IdentificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:10949 */
#ifndef SOAP_TYPE__ows__union_IdentificationType_
#define SOAP_TYPE__ows__union_IdentificationType_ (853)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ows__union_IdentificationType_
{
        #define SOAP_UNION__ows__union_IdentificationType__AvailableCRS	(1)	/**< union variant selector value for member AvailableCRS */
        std::vector<char *> *AvailableCRS;
        #define SOAP_UNION__ows__union_IdentificationType__SupportedCRS	(2)	/**< union variant selector value for member SupportedCRS */
        char **SupportedCRS;
};
#endif

/* ws-inspire-wfs2.h:10944 */
#ifndef SOAP_TYPE___ows__union_IdentificationType_
#define SOAP_TYPE___ows__union_IdentificationType_ (852)
/* Wrapper: */
class SOAP_CMAC __ows__union_IdentificationType_ {
      public:
        /// Union with union _ows__union_IdentificationType_ variant selector __unionAvailableCRS set to one of: SOAP_UNION__ows__union_IdentificationType__AvailableCRS SOAP_UNION__ows__union_IdentificationType__SupportedCRS
        int __unionAvailableCRS;
        union _ows__union_IdentificationType_ union_IdentificationType_;
      public:
        /// Return unique type id SOAP_TYPE___ows__union_IdentificationType_
        virtual long soap_type(void) const { return SOAP_TYPE___ows__union_IdentificationType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __ows__union_IdentificationType_, default initialized and not managed by a soap context
        virtual __ows__union_IdentificationType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__ows__union_IdentificationType_); }
      public:
        /// Constructor with default initializations
        __ows__union_IdentificationType_() : __unionAvailableCRS() { }
        virtual ~__ows__union_IdentificationType_() { }
        /// Friend allocator used by soap_new___ows__union_IdentificationType_(struct soap*, int)
        friend SOAP_FMAC1 __ows__union_IdentificationType_ * SOAP_FMAC2 soap_instantiate___ows__union_IdentificationType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:415 */
#ifndef SOAP_TYPE_ows__IdentificationType
#define SOAP_TYPE_ows__IdentificationType (117)
/* Type ows__IdentificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:IdentificationType': */
class SOAP_CMAC ows__IdentificationType : public ows__BasicIdentificationType {
      public:
        /// Sequence of elements '-union-IdentificationType' of XML schema type '-ows:union-IdentificationType' stored in dynamic array __union_IdentificationType of length __sizeBoundingBox
        int __sizeBoundingBox;
        __ows__union_IdentificationType *__union_IdentificationType;
        /// Optional element 'ows:OutputFormat' of XML schema type 'ows:MimeType'
        std::vector<std::string> OutputFormat;
        /// Sequence of elements '-union-IdentificationType' of XML schema type '-ows:union-IdentificationType' stored in dynamic array __union_IdentificationType_ of length __sizeAvailableCRS
        int __sizeAvailableCRS;
        __ows__union_IdentificationType_ *__union_IdentificationType_;
      public:
        /// Return unique type id SOAP_TYPE_ows__IdentificationType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__IdentificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__IdentificationType, default initialized and not managed by a soap context
        virtual ows__IdentificationType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__IdentificationType); }
      public:
        /// Constructor with default initializations
        ows__IdentificationType() : __sizeBoundingBox(), __union_IdentificationType(), OutputFormat(), __sizeAvailableCRS(), __union_IdentificationType_() { }
        virtual ~ows__IdentificationType() { }
        /// Friend allocator used by soap_new_ows__IdentificationType(struct soap*, int)
        friend SOAP_FMAC1 ows__IdentificationType * SOAP_FMAC2 soap_instantiate_ows__IdentificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:11060 */
#ifndef SOAP_TYPE__ows__union_ServiceReferenceType
#define SOAP_TYPE__ows__union_ServiceReferenceType (856)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ows__union_ServiceReferenceType
{
        #define SOAP_UNION__ows__union_ServiceReferenceType_RequestMessage	(1)	/**< union variant selector value for member RequestMessage */
        xsd__anyType *RequestMessage;
        #define SOAP_UNION__ows__union_ServiceReferenceType_RequestMessageReference	(2)	/**< union variant selector value for member RequestMessageReference */
        char **RequestMessageReference;
};
#endif

/* ws-inspire-wfs2.h:467 */
#ifndef SOAP_TYPE_ows__ServiceReferenceType
#define SOAP_TYPE_ows__ServiceReferenceType (143)
/* Type ows__ServiceReferenceType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:ServiceReferenceType': */
class SOAP_CMAC ows__ServiceReferenceType : public ows__ReferenceType {
      public:
        /// Union with union _ows__union_ServiceReferenceType variant selector __union_ServiceReferenceType set to one of: SOAP_UNION__ows__union_ServiceReferenceType_RequestMessage SOAP_UNION__ows__union_ServiceReferenceType_RequestMessageReference
        int __union_ServiceReferenceType;
        union _ows__union_ServiceReferenceType union_ServiceReferenceType;
      public:
        /// Return unique type id SOAP_TYPE_ows__ServiceReferenceType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__ServiceReferenceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__ServiceReferenceType, default initialized and not managed by a soap context
        virtual ows__ServiceReferenceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__ServiceReferenceType); }
      public:
        /// Constructor with default initializations
        ows__ServiceReferenceType() : __union_ServiceReferenceType() { }
        virtual ~ows__ServiceReferenceType() { }
        /// Friend allocator used by soap_new_ows__ServiceReferenceType(struct soap*, int)
        friend SOAP_FMAC1 ows__ServiceReferenceType * SOAP_FMAC2 soap_instantiate_ows__ServiceReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:11139 */
#ifndef SOAP_TYPE__ows__union_ReferenceGroupType
#define SOAP_TYPE__ows__union_ReferenceGroupType (858)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ows__union_ReferenceGroupType
{
        #define SOAP_UNION__ows__union_ReferenceGroupType_Reference	(1)	/**< union variant selector value for member Reference */
        ows__ReferenceType *Reference;
        #define SOAP_UNION__ows__union_ReferenceGroupType_ServiceReference	(2)	/**< union variant selector value for member ServiceReference */
        ows__ServiceReferenceType *ServiceReference;
};
#endif

/* ws-inspire-wfs2.h:11134 */
#ifndef SOAP_TYPE___ows__union_ReferenceGroupType
#define SOAP_TYPE___ows__union_ReferenceGroupType (857)
/* Wrapper: */
class SOAP_CMAC __ows__union_ReferenceGroupType {
      public:
        /// Union with union _ows__union_ReferenceGroupType variant selector __unionAbstractReferenceBase set to one of: SOAP_UNION__ows__union_ReferenceGroupType_Reference SOAP_UNION__ows__union_ReferenceGroupType_ServiceReference
        int __unionAbstractReferenceBase;
        union _ows__union_ReferenceGroupType union_ReferenceGroupType;
      public:
        /// Return unique type id SOAP_TYPE___ows__union_ReferenceGroupType
        virtual long soap_type(void) const { return SOAP_TYPE___ows__union_ReferenceGroupType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __ows__union_ReferenceGroupType, default initialized and not managed by a soap context
        virtual __ows__union_ReferenceGroupType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__ows__union_ReferenceGroupType); }
      public:
        /// Constructor with default initializations
        __ows__union_ReferenceGroupType() : __unionAbstractReferenceBase() { }
        virtual ~__ows__union_ReferenceGroupType() { }
        /// Friend allocator used by soap_new___ows__union_ReferenceGroupType(struct soap*, int)
        friend SOAP_FMAC1 __ows__union_ReferenceGroupType * SOAP_FMAC2 soap_instantiate___ows__union_ReferenceGroupType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:473 */
#ifndef SOAP_TYPE_ows__ReferenceGroupType
#define SOAP_TYPE_ows__ReferenceGroupType (146)
/* Type ows__ReferenceGroupType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:ReferenceGroupType': */
class SOAP_CMAC ows__ReferenceGroupType : public ows__BasicIdentificationType {
      public:
        /// Sequence of elements '-union-ReferenceGroupType' of XML schema type '-ows:union-ReferenceGroupType' stored in dynamic array __union_ReferenceGroupType of length __sizeAbstractReferenceBase
        int __sizeAbstractReferenceBase;
        __ows__union_ReferenceGroupType *__union_ReferenceGroupType;
      public:
        /// Return unique type id SOAP_TYPE_ows__ReferenceGroupType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__ReferenceGroupType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__ReferenceGroupType, default initialized and not managed by a soap context
        virtual ows__ReferenceGroupType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__ReferenceGroupType); }
      public:
        /// Constructor with default initializations
        ows__ReferenceGroupType() : __sizeAbstractReferenceBase(), __union_ReferenceGroupType() { }
        virtual ~ows__ReferenceGroupType() { }
        /// Friend allocator used by soap_new_ows__ReferenceGroupType(struct soap*, int)
        friend SOAP_FMAC1 ows__ReferenceGroupType * SOAP_FMAC2 soap_instantiate_ows__ReferenceGroupType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:475 */
#ifndef SOAP_TYPE_ows__ManifestType
#define SOAP_TYPE_ows__ManifestType (147)
/* Type ows__ManifestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ows:ManifestType': */
class SOAP_CMAC ows__ManifestType : public ows__BasicIdentificationType {
      public:
        /// Required element 'ows:ReferenceGroup' of XML schema type 'ows:ReferenceGroupType'
        std::vector<ows__ReferenceGroupType *> ReferenceGroup;
      public:
        /// Return unique type id SOAP_TYPE_ows__ManifestType
        virtual long soap_type(void) const { return SOAP_TYPE_ows__ManifestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ows__ManifestType, default initialized and not managed by a soap context
        virtual ows__ManifestType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ows__ManifestType); }
      public:
        /// Constructor with default initializations
        ows__ManifestType() : ReferenceGroup() { }
        virtual ~ows__ManifestType() { }
        /// Friend allocator used by soap_new_ows__ManifestType(struct soap*, int)
        friend SOAP_FMAC1 ows__ManifestType * SOAP_FMAC2 soap_instantiate_ows__ManifestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:628 */
#ifndef SOAP_TYPE_icommon__dataset
#define SOAP_TYPE_icommon__dataset (223)
/* Type icommon__dataset is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:dataset': */
class SOAP_CMAC icommon__dataset : public xsd__anyType {
      public:
        /// Required element 'icommon:ResourceTitle' of XML schema type 'icommon:notEmptyString'
        std::string ResourceTitle;
        /// Required element 'icommon:ResourceAbstract' of XML schema type 'icommon:notEmptyString'
        std::string ResourceAbstract;
        /// Required element 'icommon:ResourceType' of XML schema type 'icommon:dataset-ResourceType'
        enum _icommon__dataset_ResourceType ResourceType;
        /// Optional element 'icommon:ResourceLocator' of XML schema type 'icommon:resourceLocatorType'
        std::vector<icommon__resourceLocatorType *> ResourceLocator;
        /// Required element 'icommon:MandatoryKeyword' of XML schema type 'icommon:inspireTheme'
        std::vector<icommon__inspireTheme *> MandatoryKeyword;
        /// Optional element 'icommon:Keyword' of XML schema type 'icommon:keyword'
        std::vector<icommon__keyword *> Keyword;
        /// Required element 'icommon:GeographicBoundingBox' of XML schema type 'icommon:geographicBoundingBox'
        std::vector<icommon__geographicBoundingBox *> GeographicBoundingBox;
        /// Required element 'icommon:TemporalReference' of XML schema type 'icommon:temporalReference'
        std::vector<icommon__temporalReference *> TemporalReference;
        /// Optional element 'icommon:SpatialResolution' of XML schema type 'icommon:spatialResolution'
        std::vector<icommon__spatialResolution *> SpatialResolution;
        /// Required element 'icommon:Conformity' of XML schema type 'icommon:conformity'
        std::vector<icommon__conformity *> Conformity;
        /// Required element 'icommon:ConditionsForAccessAndUse' of XML schema type 'icommon:notEmptyString'
        std::vector<std::string> ConditionsForAccessAndUse;
        /// Required element 'icommon:LimitationsOnPublicAccess' of XML schema type 'icommon:notEmptyString'
        std::vector<std::string> LimitationsOnPublicAccess;
        /// Required element 'icommon:ResponsibleOrganisation' of XML schema type 'icommon:responsibleOrganisation'
        std::vector<icommon__responsibleOrganisation *> ResponsibleOrganisation;
        /// Required element 'icommon:MetadataPointOfContact' of XML schema type 'icommon:metadataPointOfContact'
        std::vector<icommon__metadataPointOfContact *> MetadataPointOfContact;
        /// Required element 'icommon:MetadataDate' of XML schema type 'icommon:iso8601Date'
        std::string MetadataDate;
        /// Required element 'icommon:MetadataLanguage' of XML schema type 'icommon:euLanguageISO6392B'
        enum icommon__euLanguageISO6392B MetadataLanguage;
        /// Required element 'icommon:UniqueResourceIdentifier' of XML schema type 'icommon:uniqueResourceIdentifier'
        std::vector<icommon__uniqueResourceIdentifier *> UniqueResourceIdentifier;
        /// Optional element 'icommon:ResourceLanguage' of XML schema type 'icommon:languageISO6392B'
        std::vector<enum icommon__languageISO6392B> ResourceLanguage;
        /// Required element 'icommon:TopicCategory' of XML schema type 'icommon:topicCategory'
        std::vector<enum icommon__topicCategory> TopicCategory;
        /// Required element 'icommon:Lineage' of XML schema type 'icommon:notEmptyString'
        std::string Lineage;
      public:
        /// Return unique type id SOAP_TYPE_icommon__dataset
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__dataset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__dataset, default initialized and not managed by a soap context
        virtual icommon__dataset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__dataset); }
      public:
        /// Constructor with default initializations
        icommon__dataset() : ResourceTitle(), ResourceAbstract(), ResourceType(), ResourceLocator(), MandatoryKeyword(), Keyword(), GeographicBoundingBox(), TemporalReference(), SpatialResolution(), Conformity(), ConditionsForAccessAndUse(), LimitationsOnPublicAccess(), ResponsibleOrganisation(), MetadataPointOfContact(), MetadataDate(), MetadataLanguage(), UniqueResourceIdentifier(), ResourceLanguage(), TopicCategory(), Lineage() { }
        virtual ~icommon__dataset() { }
        /// Friend allocator used by soap_new_icommon__dataset(struct soap*, int)
        friend SOAP_FMAC1 icommon__dataset * SOAP_FMAC2 soap_instantiate_icommon__dataset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:630 */
#ifndef SOAP_TYPE_icommon__series
#define SOAP_TYPE_icommon__series (224)
/* Type icommon__series is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:series': */
class SOAP_CMAC icommon__series : public xsd__anyType {
      public:
        /// Required element 'icommon:ResourceTitle' of XML schema type 'icommon:notEmptyString'
        std::string ResourceTitle;
        /// Required element 'icommon:ResourceAbstract' of XML schema type 'icommon:notEmptyString'
        std::string ResourceAbstract;
        /// Required element 'icommon:ResourceType' of XML schema type 'icommon:series-ResourceType'
        enum _icommon__series_ResourceType ResourceType;
        /// Optional element 'icommon:ResourceLocator' of XML schema type 'icommon:resourceLocatorType'
        std::vector<icommon__resourceLocatorType *> ResourceLocator;
        /// Required element 'icommon:MandatoryKeyword' of XML schema type 'icommon:inspireTheme'
        std::vector<icommon__inspireTheme *> MandatoryKeyword;
        /// Optional element 'icommon:Keyword' of XML schema type 'icommon:keyword'
        std::vector<icommon__keyword *> Keyword;
        /// Required element 'icommon:GeographicBoundingBox' of XML schema type 'icommon:geographicBoundingBox'
        std::vector<icommon__geographicBoundingBox *> GeographicBoundingBox;
        /// Required element 'icommon:TemporalReference' of XML schema type 'icommon:temporalReference'
        std::vector<icommon__temporalReference *> TemporalReference;
        /// Optional element 'icommon:SpatialResolution' of XML schema type 'icommon:spatialResolution'
        std::vector<icommon__spatialResolution *> SpatialResolution;
        /// Required element 'icommon:Conformity' of XML schema type 'icommon:conformity'
        std::vector<icommon__conformity *> Conformity;
        /// Required element 'icommon:ConditionsForAccessAndUse' of XML schema type 'icommon:notEmptyString'
        std::vector<std::string> ConditionsForAccessAndUse;
        /// Required element 'icommon:LimitationsOnPublicAccess' of XML schema type 'icommon:notEmptyString'
        std::vector<std::string> LimitationsOnPublicAccess;
        /// Required element 'icommon:ResponsibleOrganisation' of XML schema type 'icommon:responsibleOrganisation'
        std::vector<icommon__responsibleOrganisation *> ResponsibleOrganisation;
        /// Required element 'icommon:MetadataPointOfContact' of XML schema type 'icommon:metadataPointOfContact'
        std::vector<icommon__metadataPointOfContact *> MetadataPointOfContact;
        /// Required element 'icommon:MetadataDate' of XML schema type 'icommon:iso8601Date'
        std::string MetadataDate;
        /// Required element 'icommon:MetadataLanguage' of XML schema type 'icommon:euLanguageISO6392B'
        enum icommon__euLanguageISO6392B MetadataLanguage;
        /// Required element 'icommon:UniqueResourceIdentifier' of XML schema type 'icommon:uniqueResourceIdentifier'
        std::vector<icommon__uniqueResourceIdentifier *> UniqueResourceIdentifier;
        /// Optional element 'icommon:ResourceLanguage' of XML schema type 'icommon:languageISO6392B'
        std::vector<enum icommon__languageISO6392B> ResourceLanguage;
        /// Required element 'icommon:TopicCategory' of XML schema type 'icommon:topicCategory'
        std::vector<enum icommon__topicCategory> TopicCategory;
        /// Required element 'icommon:Lineage' of XML schema type 'icommon:notEmptyString'
        std::string Lineage;
      public:
        /// Return unique type id SOAP_TYPE_icommon__series
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__series; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__series, default initialized and not managed by a soap context
        virtual icommon__series *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__series); }
      public:
        /// Constructor with default initializations
        icommon__series() : ResourceTitle(), ResourceAbstract(), ResourceType(), ResourceLocator(), MandatoryKeyword(), Keyword(), GeographicBoundingBox(), TemporalReference(), SpatialResolution(), Conformity(), ConditionsForAccessAndUse(), LimitationsOnPublicAccess(), ResponsibleOrganisation(), MetadataPointOfContact(), MetadataDate(), MetadataLanguage(), UniqueResourceIdentifier(), ResourceLanguage(), TopicCategory(), Lineage() { }
        virtual ~icommon__series() { }
        /// Friend allocator used by soap_new_icommon__series(struct soap*, int)
        friend SOAP_FMAC1 icommon__series * SOAP_FMAC2 soap_instantiate_icommon__series(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:634 */
#ifndef SOAP_TYPE_icommon__service
#define SOAP_TYPE_icommon__service (226)
/* Type icommon__service is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:service': */
class SOAP_CMAC icommon__service : public xsd__anyType {
      public:
        /// Required element 'icommon:ResourceTitle' of XML schema type 'icommon:notEmptyString'
        std::string ResourceTitle;
        /// Required element 'icommon:ResourceAbstract' of XML schema type 'icommon:notEmptyString'
        std::string ResourceAbstract;
        /// Required element 'icommon:ResourceType' of XML schema type 'icommon:serviceSpatialDataResourceType'
        enum icommon__serviceSpatialDataResourceType ResourceType;
        /// Optional element 'icommon:ResourceLocator' of XML schema type 'icommon:resourceLocatorType'
        std::vector<icommon__resourceLocatorType *> ResourceLocator;
        /// Required element 'icommon:MandatoryKeyword' of XML schema type 'icommon:classificationOfSpatialDataService'
        std::vector<icommon__classificationOfSpatialDataService *> MandatoryKeyword;
        /// Optional element 'icommon:Keyword' of XML schema type 'icommon:keyword'
        std::vector<icommon__keyword *> Keyword;
        /// Optional element 'icommon:GeographicBoundingBox' of XML schema type 'icommon:geographicBoundingBox'
        std::vector<icommon__geographicBoundingBox *> GeographicBoundingBox;
        /// Required element 'icommon:TemporalReference' of XML schema type 'icommon:temporalReference'
        std::vector<icommon__temporalReference *> TemporalReference;
        /// Optional element 'icommon:SpatialResolution' of XML schema type 'icommon:spatialResolution'
        std::vector<icommon__spatialResolution *> SpatialResolution;
        /// Required element 'icommon:Conformity' of XML schema type 'icommon:conformity'
        std::vector<icommon__conformity *> Conformity;
        /// Required element 'icommon:ConditionsForAccessAndUse' of XML schema type 'icommon:notEmptyString'
        std::vector<std::string> ConditionsForAccessAndUse;
        /// Required element 'icommon:LimitationsOnPublicAccess' of XML schema type 'icommon:notEmptyString'
        std::vector<std::string> LimitationsOnPublicAccess;
        /// Required element 'icommon:ResponsibleOrganisation' of XML schema type 'icommon:responsibleOrganisation'
        std::vector<icommon__responsibleOrganisation *> ResponsibleOrganisation;
        /// Required element 'icommon:MetadataPointOfContact' of XML schema type 'icommon:metadataPointOfContact'
        std::vector<icommon__metadataPointOfContact *> MetadataPointOfContact;
        /// Required element 'icommon:MetadataDate' of XML schema type 'icommon:iso8601Date'
        std::string MetadataDate;
        /// Required element 'icommon:MetadataLanguage' of XML schema type 'icommon:euLanguageISO6392B'
        enum icommon__euLanguageISO6392B MetadataLanguage;
        /// Optional element 'icommon:CoupledResource' of XML schema type 'icommon:uniqueResourceIdentifier'
        std::vector<icommon__uniqueResourceIdentifier *> CoupledResource;
        /// Required element 'icommon:SpatialDataServiceType' of XML schema type 'icommon:spatialDataServiceType'
        enum icommon__spatialDataServiceType SpatialDataServiceType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__service
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__service; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__service, default initialized and not managed by a soap context
        virtual icommon__service *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__service); }
      public:
        /// Constructor with default initializations
        icommon__service() : ResourceTitle(), ResourceAbstract(), ResourceType(), ResourceLocator(), MandatoryKeyword(), Keyword(), GeographicBoundingBox(), TemporalReference(), SpatialResolution(), Conformity(), ConditionsForAccessAndUse(), LimitationsOnPublicAccess(), ResponsibleOrganisation(), MetadataPointOfContact(), MetadataDate(), MetadataLanguage(), CoupledResource(), SpatialDataServiceType() { }
        virtual ~icommon__service() { }
        /// Friend allocator used by soap_new_icommon__service(struct soap*, int)
        friend SOAP_FMAC1 icommon__service * SOAP_FMAC2 soap_instantiate_icommon__service(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:11490 */
#ifndef SOAP_TYPE__icommon__union_originatingControlledVocabularyGemetInspireThemes
#define SOAP_TYPE__icommon__union_originatingControlledVocabularyGemetInspireThemes (869)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_originatingControlledVocabularyGemetInspireThemes
{
        #define SOAP_UNION__icommon__union_originatingControlledVocabularyGemetInspireThemes_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__originatingControlledVocabularyGemetInspireThemes_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:648 */
#ifndef SOAP_TYPE_icommon__originatingControlledVocabularyGemetInspireThemes
#define SOAP_TYPE_icommon__originatingControlledVocabularyGemetInspireThemes (233)
/* complex XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes': */
class SOAP_CMAC icommon__originatingControlledVocabularyGemetInspireThemes : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes-Title'
        enum _icommon__originatingControlledVocabularyGemetInspireThemes_Title Title;
        /// Union with union _icommon__union_originatingControlledVocabularyGemetInspireThemes variant selector __union_originatingControlledVocabularyGemetInspireThemes set to one of: SOAP_UNION__icommon__union_originatingControlledVocabularyGemetInspireThemes_DateOfPublication
        int __union_originatingControlledVocabularyGemetInspireThemes;
        union _icommon__union_originatingControlledVocabularyGemetInspireThemes union_originatingControlledVocabularyGemetInspireThemes;
      public:
        /// Return unique type id SOAP_TYPE_icommon__originatingControlledVocabularyGemetInspireThemes
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__originatingControlledVocabularyGemetInspireThemes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__originatingControlledVocabularyGemetInspireThemes, default initialized and not managed by a soap context
        virtual icommon__originatingControlledVocabularyGemetInspireThemes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__originatingControlledVocabularyGemetInspireThemes); }
      public:
        /// Constructor with default initializations
        icommon__originatingControlledVocabularyGemetInspireThemes() : Title(), __union_originatingControlledVocabularyGemetInspireThemes() { }
        virtual ~icommon__originatingControlledVocabularyGemetInspireThemes() { }
        /// Friend allocator used by soap_new_icommon__originatingControlledVocabularyGemetInspireThemes(struct soap*, int)
        friend SOAP_FMAC1 icommon__originatingControlledVocabularyGemetInspireThemes * SOAP_FMAC2 soap_instantiate_icommon__originatingControlledVocabularyGemetInspireThemes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:11527 */
#ifndef SOAP_TYPE__icommon__union_originatingControlledVocabularyMD
#define SOAP_TYPE__icommon__union_originatingControlledVocabularyMD (873)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_originatingControlledVocabularyMD
{
        #define SOAP_UNION__icommon__union_originatingControlledVocabularyMD_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__originatingControlledVocabularyMD_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:650 */
#ifndef SOAP_TYPE_icommon__originatingControlledVocabularyMD
#define SOAP_TYPE_icommon__originatingControlledVocabularyMD (234)
/* Type icommon__originatingControlledVocabularyMD is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:originatingControlledVocabularyMD': */
class SOAP_CMAC icommon__originatingControlledVocabularyMD : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:originatingControlledVocabularyMD-Title'
        enum _icommon__originatingControlledVocabularyMD_Title Title;
        /// Union with union _icommon__union_originatingControlledVocabularyMD variant selector __union_originatingControlledVocabularyMD set to one of: SOAP_UNION__icommon__union_originatingControlledVocabularyMD_DateOfPublication
        int __union_originatingControlledVocabularyMD;
        union _icommon__union_originatingControlledVocabularyMD union_originatingControlledVocabularyMD;
      public:
        /// Return unique type id SOAP_TYPE_icommon__originatingControlledVocabularyMD
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__originatingControlledVocabularyMD; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__originatingControlledVocabularyMD, default initialized and not managed by a soap context
        virtual icommon__originatingControlledVocabularyMD *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__originatingControlledVocabularyMD); }
      public:
        /// Constructor with default initializations
        icommon__originatingControlledVocabularyMD() : Title(), __union_originatingControlledVocabularyMD() { }
        virtual ~icommon__originatingControlledVocabularyMD() { }
        /// Friend allocator used by soap_new_icommon__originatingControlledVocabularyMD(struct soap*, int)
        friend SOAP_FMAC1 icommon__originatingControlledVocabularyMD * SOAP_FMAC2 soap_instantiate_icommon__originatingControlledVocabularyMD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:706 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fbul
#define SOAP_TYPE_icommon__inspireTheme_x005fbul (262)
/* Type icommon__inspireTheme_x005fbul is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_bul': */
class SOAP_CMAC icommon__inspireTheme_x005fbul : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_bul-KeywordValue'
        enum _icommon__inspireTheme_x005fbul_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005fbul
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005fbul; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005fbul, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005fbul *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005fbul); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005fbul() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005fbul() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005fbul(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005fbul * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005fbul(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:11625 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fbul
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fbul (878)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fbul
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fbul_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005fbul_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:710 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fbul
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fbul (264)
/* Type icommon__citationInspireInteroperabilityRegulation_x005fbul is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_bul': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005fbul : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_bul-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fbul_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005fbul variant selector __union_citationInspireInteroperabilityRegulation_x005fbul set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fbul_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005fbul;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005fbul union_citationInspireInteroperabilityRegulation_x005fbul;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_bul-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fbul_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_bul'
        icommon__resLocInspireInteroperabilityRegulation_x005fbul *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fbul
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fbul; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005fbul, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005fbul *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005fbul); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005fbul() : Title(), __union_citationInspireInteroperabilityRegulation_x005fbul(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005fbul() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005fbul(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005fbul * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005fbul(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:712 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fcze
#define SOAP_TYPE_icommon__inspireTheme_x005fcze (265)
/* Type icommon__inspireTheme_x005fcze is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_cze': */
class SOAP_CMAC icommon__inspireTheme_x005fcze : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_cze-KeywordValue'
        enum _icommon__inspireTheme_x005fcze_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005fcze
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005fcze; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005fcze, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005fcze *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005fcze); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005fcze() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005fcze() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005fcze(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005fcze * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005fcze(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:11730 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fcze
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fcze (885)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fcze
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fcze_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005fcze_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:716 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fcze
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fcze (267)
/* Type icommon__citationInspireInteroperabilityRegulation_x005fcze is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_cze': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005fcze : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_cze-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fcze_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005fcze variant selector __union_citationInspireInteroperabilityRegulation_x005fcze set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fcze_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005fcze;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005fcze union_citationInspireInteroperabilityRegulation_x005fcze;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_cze-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fcze_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_cze'
        icommon__resLocInspireInteroperabilityRegulation_x005fcze *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fcze
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fcze; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005fcze, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005fcze *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005fcze); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005fcze() : Title(), __union_citationInspireInteroperabilityRegulation_x005fcze(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005fcze() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005fcze(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005fcze * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005fcze(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:718 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fdan
#define SOAP_TYPE_icommon__inspireTheme_x005fdan (268)
/* Type icommon__inspireTheme_x005fdan is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_dan': */
class SOAP_CMAC icommon__inspireTheme_x005fdan : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_dan-KeywordValue'
        enum _icommon__inspireTheme_x005fdan_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005fdan
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005fdan; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005fdan, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005fdan *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005fdan); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005fdan() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005fdan() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005fdan(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005fdan * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005fdan(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:11835 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fdan
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fdan (892)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fdan
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fdan_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005fdan_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:722 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fdan
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fdan (270)
/* Type icommon__citationInspireInteroperabilityRegulation_x005fdan is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_dan': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005fdan : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_dan-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fdan_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005fdan variant selector __union_citationInspireInteroperabilityRegulation_x005fdan set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fdan_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005fdan;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005fdan union_citationInspireInteroperabilityRegulation_x005fdan;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_dan-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fdan_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_dan'
        icommon__resLocInspireInteroperabilityRegulation_x005fdan *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fdan
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fdan; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005fdan, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005fdan *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005fdan); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005fdan() : Title(), __union_citationInspireInteroperabilityRegulation_x005fdan(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005fdan() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005fdan(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005fdan * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005fdan(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:724 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fdut
#define SOAP_TYPE_icommon__inspireTheme_x005fdut (271)
/* Type icommon__inspireTheme_x005fdut is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_dut': */
class SOAP_CMAC icommon__inspireTheme_x005fdut : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_dut-KeywordValue'
        enum _icommon__inspireTheme_x005fdut_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005fdut
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005fdut; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005fdut, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005fdut *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005fdut); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005fdut() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005fdut() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005fdut(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005fdut * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005fdut(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:11940 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fdut
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fdut (899)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fdut
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fdut_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005fdut_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:728 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fdut
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fdut (273)
/* Type icommon__citationInspireInteroperabilityRegulation_x005fdut is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_dut': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005fdut : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_dut-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fdut_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005fdut variant selector __union_citationInspireInteroperabilityRegulation_x005fdut set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fdut_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005fdut;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005fdut union_citationInspireInteroperabilityRegulation_x005fdut;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_dut-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fdut_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_dut'
        icommon__resLocInspireInteroperabilityRegulation_x005fdut *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fdut
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fdut; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005fdut, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005fdut *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005fdut); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005fdut() : Title(), __union_citationInspireInteroperabilityRegulation_x005fdut(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005fdut() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005fdut(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005fdut * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005fdut(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:730 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005feng
#define SOAP_TYPE_icommon__inspireTheme_x005feng (274)
/* Type icommon__inspireTheme_x005feng is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_eng': */
class SOAP_CMAC icommon__inspireTheme_x005feng : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_eng-KeywordValue'
        enum _icommon__inspireTheme_x005feng_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005feng
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005feng; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005feng, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005feng *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005feng); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005feng() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005feng() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005feng(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005feng * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005feng(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:12045 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005feng
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005feng (906)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005feng
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005feng_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005feng_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:738 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005feng
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005feng (278)
/* Type icommon__citationInspireInteroperabilityRegulation_x005feng is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_eng': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005feng : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_eng-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005feng_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005feng variant selector __union_citationInspireInteroperabilityRegulation_x005feng set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005feng_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005feng;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005feng union_citationInspireInteroperabilityRegulation_x005feng;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_eng-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005feng_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_eng'
        icommon__resLocInspireInteroperabilityRegulation_x005feng *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005feng
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005feng; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005feng, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005feng *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005feng); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005feng() : Title(), __union_citationInspireInteroperabilityRegulation_x005feng(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005feng() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005feng(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005feng * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005feng(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:740 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fest
#define SOAP_TYPE_icommon__inspireTheme_x005fest (279)
/* Type icommon__inspireTheme_x005fest is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_est': */
class SOAP_CMAC icommon__inspireTheme_x005fest : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_est-KeywordValue'
        enum _icommon__inspireTheme_x005fest_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005fest
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005fest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005fest, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005fest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005fest); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005fest() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005fest() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005fest(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005fest * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005fest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:12150 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fest
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fest (913)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fest
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fest_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005fest_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:744 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fest
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fest (281)
/* Type icommon__citationInspireInteroperabilityRegulation_x005fest is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_est': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005fest : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_est-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fest_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005fest variant selector __union_citationInspireInteroperabilityRegulation_x005fest set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fest_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005fest;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005fest union_citationInspireInteroperabilityRegulation_x005fest;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_est-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fest_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_est'
        icommon__resLocInspireInteroperabilityRegulation_x005fest *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fest
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005fest, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005fest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005fest); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005fest() : Title(), __union_citationInspireInteroperabilityRegulation_x005fest(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005fest() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005fest(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005fest * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005fest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:746 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005ffin
#define SOAP_TYPE_icommon__inspireTheme_x005ffin (282)
/* Type icommon__inspireTheme_x005ffin is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_fin': */
class SOAP_CMAC icommon__inspireTheme_x005ffin : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_fin-KeywordValue'
        enum _icommon__inspireTheme_x005ffin_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005ffin
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005ffin; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005ffin, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005ffin *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005ffin); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005ffin() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005ffin() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005ffin(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005ffin * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005ffin(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:12255 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005ffin
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005ffin (920)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005ffin
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005ffin_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005ffin_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:750 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005ffin
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005ffin (284)
/* Type icommon__citationInspireInteroperabilityRegulation_x005ffin is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_fin': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005ffin : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_fin-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005ffin_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005ffin variant selector __union_citationInspireInteroperabilityRegulation_x005ffin set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005ffin_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005ffin;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005ffin union_citationInspireInteroperabilityRegulation_x005ffin;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_fin-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005ffin_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_fin'
        icommon__resLocInspireInteroperabilityRegulation_x005ffin *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005ffin
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005ffin; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005ffin, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005ffin *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005ffin); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005ffin() : Title(), __union_citationInspireInteroperabilityRegulation_x005ffin(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005ffin() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005ffin(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005ffin * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005ffin(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:752 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005ffre
#define SOAP_TYPE_icommon__inspireTheme_x005ffre (285)
/* Type icommon__inspireTheme_x005ffre is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_fre': */
class SOAP_CMAC icommon__inspireTheme_x005ffre : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_fre-KeywordValue'
        enum _icommon__inspireTheme_x005ffre_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005ffre
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005ffre; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005ffre, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005ffre *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005ffre); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005ffre() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005ffre() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005ffre(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005ffre * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005ffre(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:12360 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005ffre
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005ffre (927)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005ffre
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005ffre_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005ffre_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:756 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005ffre
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005ffre (287)
/* Type icommon__citationInspireInteroperabilityRegulation_x005ffre is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_fre': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005ffre : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_fre-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005ffre_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005ffre variant selector __union_citationInspireInteroperabilityRegulation_x005ffre set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005ffre_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005ffre;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005ffre union_citationInspireInteroperabilityRegulation_x005ffre;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_fre-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005ffre_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_fre'
        icommon__resLocInspireInteroperabilityRegulation_x005ffre *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005ffre
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005ffre; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005ffre, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005ffre *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005ffre); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005ffre() : Title(), __union_citationInspireInteroperabilityRegulation_x005ffre(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005ffre() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005ffre(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005ffre * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005ffre(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:758 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fger
#define SOAP_TYPE_icommon__inspireTheme_x005fger (288)
/* Type icommon__inspireTheme_x005fger is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_ger': */
class SOAP_CMAC icommon__inspireTheme_x005fger : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_ger-KeywordValue'
        enum _icommon__inspireTheme_x005fger_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005fger
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005fger; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005fger, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005fger *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005fger); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005fger() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005fger() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005fger(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005fger * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005fger(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:12465 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fger
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fger (934)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fger
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fger_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005fger_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:762 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fger
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fger (290)
/* Type icommon__citationInspireInteroperabilityRegulation_x005fger is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_ger': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005fger : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_ger-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fger_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005fger variant selector __union_citationInspireInteroperabilityRegulation_x005fger set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fger_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005fger;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005fger union_citationInspireInteroperabilityRegulation_x005fger;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_ger-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fger_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_ger'
        icommon__resLocInspireInteroperabilityRegulation_x005fger *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fger
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fger; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005fger, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005fger *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005fger); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005fger() : Title(), __union_citationInspireInteroperabilityRegulation_x005fger(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005fger() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005fger(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005fger * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005fger(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:764 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fgle
#define SOAP_TYPE_icommon__inspireTheme_x005fgle (291)
/* Type icommon__inspireTheme_x005fgle is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_gle': */
class SOAP_CMAC icommon__inspireTheme_x005fgle : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_gle-KeywordValue'
        enum _icommon__inspireTheme_x005fgle_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005fgle
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005fgle; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005fgle, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005fgle *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005fgle); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005fgle() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005fgle() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005fgle(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005fgle * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005fgle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:12570 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fgle
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fgle (941)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fgle
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fgle_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005fgle_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:768 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fgle
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fgle (293)
/* Type icommon__citationInspireInteroperabilityRegulation_x005fgle is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_gle': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005fgle : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_gle-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fgle_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005fgle variant selector __union_citationInspireInteroperabilityRegulation_x005fgle set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fgle_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005fgle;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005fgle union_citationInspireInteroperabilityRegulation_x005fgle;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_gle-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fgle_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_gle'
        icommon__resLocInspireInteroperabilityRegulation_x005fgle *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fgle
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fgle; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005fgle, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005fgle *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005fgle); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005fgle() : Title(), __union_citationInspireInteroperabilityRegulation_x005fgle(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005fgle() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005fgle(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005fgle * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005fgle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:770 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fgre
#define SOAP_TYPE_icommon__inspireTheme_x005fgre (294)
/* Type icommon__inspireTheme_x005fgre is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_gre': */
class SOAP_CMAC icommon__inspireTheme_x005fgre : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_gre-KeywordValue'
        enum _icommon__inspireTheme_x005fgre_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005fgre
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005fgre; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005fgre, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005fgre *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005fgre); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005fgre() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005fgre() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005fgre(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005fgre * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005fgre(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:12675 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fgre
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fgre (948)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fgre
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fgre_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005fgre_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:774 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fgre
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fgre (296)
/* Type icommon__citationInspireInteroperabilityRegulation_x005fgre is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_gre': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005fgre : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_gre-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fgre_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005fgre variant selector __union_citationInspireInteroperabilityRegulation_x005fgre set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fgre_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005fgre;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005fgre union_citationInspireInteroperabilityRegulation_x005fgre;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_gre-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fgre_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_gre'
        icommon__resLocInspireInteroperabilityRegulation_x005fgre *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fgre
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fgre; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005fgre, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005fgre *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005fgre); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005fgre() : Title(), __union_citationInspireInteroperabilityRegulation_x005fgre(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005fgre() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005fgre(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005fgre * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005fgre(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:776 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fhun
#define SOAP_TYPE_icommon__inspireTheme_x005fhun (297)
/* Type icommon__inspireTheme_x005fhun is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_hun': */
class SOAP_CMAC icommon__inspireTheme_x005fhun : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_hun-KeywordValue'
        enum _icommon__inspireTheme_x005fhun_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005fhun
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005fhun; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005fhun, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005fhun *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005fhun); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005fhun() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005fhun() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005fhun(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005fhun * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005fhun(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:12780 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fhun
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fhun (955)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fhun
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fhun_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005fhun_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:780 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fhun
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fhun (299)
/* Type icommon__citationInspireInteroperabilityRegulation_x005fhun is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_hun': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005fhun : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_hun-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fhun_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005fhun variant selector __union_citationInspireInteroperabilityRegulation_x005fhun set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fhun_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005fhun;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005fhun union_citationInspireInteroperabilityRegulation_x005fhun;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_hun-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fhun_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_hun'
        icommon__resLocInspireInteroperabilityRegulation_x005fhun *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fhun
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fhun; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005fhun, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005fhun *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005fhun); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005fhun() : Title(), __union_citationInspireInteroperabilityRegulation_x005fhun(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005fhun() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005fhun(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005fhun * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005fhun(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:782 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fita
#define SOAP_TYPE_icommon__inspireTheme_x005fita (300)
/* Type icommon__inspireTheme_x005fita is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_ita': */
class SOAP_CMAC icommon__inspireTheme_x005fita : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_ita-KeywordValue'
        enum _icommon__inspireTheme_x005fita_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005fita
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005fita; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005fita, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005fita *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005fita); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005fita() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005fita() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005fita(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005fita * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005fita(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:12885 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fita
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fita (962)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fita
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fita_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005fita_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:786 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fita
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fita (302)
/* Type icommon__citationInspireInteroperabilityRegulation_x005fita is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_ita': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005fita : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_ita-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fita_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005fita variant selector __union_citationInspireInteroperabilityRegulation_x005fita set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fita_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005fita;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005fita union_citationInspireInteroperabilityRegulation_x005fita;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_ita-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fita_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_ita'
        icommon__resLocInspireInteroperabilityRegulation_x005fita *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fita
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fita; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005fita, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005fita *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005fita); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005fita() : Title(), __union_citationInspireInteroperabilityRegulation_x005fita(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005fita() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005fita(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005fita * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005fita(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:788 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005flav
#define SOAP_TYPE_icommon__inspireTheme_x005flav (303)
/* Type icommon__inspireTheme_x005flav is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_lav': */
class SOAP_CMAC icommon__inspireTheme_x005flav : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_lav-KeywordValue'
        enum _icommon__inspireTheme_x005flav_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005flav
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005flav; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005flav, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005flav *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005flav); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005flav() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005flav() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005flav(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005flav * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005flav(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:12990 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005flav
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005flav (969)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005flav
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005flav_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005flav_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:792 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005flav
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005flav (305)
/* Type icommon__citationInspireInteroperabilityRegulation_x005flav is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_lav': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005flav : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_lav-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005flav_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005flav variant selector __union_citationInspireInteroperabilityRegulation_x005flav set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005flav_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005flav;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005flav union_citationInspireInteroperabilityRegulation_x005flav;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_lav-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005flav_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_lav'
        icommon__resLocInspireInteroperabilityRegulation_x005flav *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005flav
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005flav; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005flav, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005flav *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005flav); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005flav() : Title(), __union_citationInspireInteroperabilityRegulation_x005flav(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005flav() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005flav(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005flav * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005flav(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:794 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005flit
#define SOAP_TYPE_icommon__inspireTheme_x005flit (306)
/* Type icommon__inspireTheme_x005flit is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_lit': */
class SOAP_CMAC icommon__inspireTheme_x005flit : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_lit-KeywordValue'
        enum _icommon__inspireTheme_x005flit_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005flit
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005flit; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005flit, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005flit *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005flit); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005flit() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005flit() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005flit(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005flit * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005flit(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:13095 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005flit
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005flit (976)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005flit
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005flit_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005flit_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:798 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005flit
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005flit (308)
/* Type icommon__citationInspireInteroperabilityRegulation_x005flit is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_lit': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005flit : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_lit-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005flit_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005flit variant selector __union_citationInspireInteroperabilityRegulation_x005flit set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005flit_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005flit;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005flit union_citationInspireInteroperabilityRegulation_x005flit;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_lit-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005flit_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_lit'
        icommon__resLocInspireInteroperabilityRegulation_x005flit *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005flit
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005flit; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005flit, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005flit *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005flit); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005flit() : Title(), __union_citationInspireInteroperabilityRegulation_x005flit(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005flit() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005flit(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005flit * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005flit(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:800 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fmlt
#define SOAP_TYPE_icommon__inspireTheme_x005fmlt (309)
/* Type icommon__inspireTheme_x005fmlt is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_mlt': */
class SOAP_CMAC icommon__inspireTheme_x005fmlt : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_mlt-KeywordValue'
        enum _icommon__inspireTheme_x005fmlt_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005fmlt
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005fmlt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005fmlt, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005fmlt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005fmlt); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005fmlt() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005fmlt() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005fmlt(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005fmlt * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005fmlt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:13200 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fmlt
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fmlt (983)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fmlt
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fmlt_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005fmlt_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:804 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fmlt
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fmlt (311)
/* Type icommon__citationInspireInteroperabilityRegulation_x005fmlt is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_mlt': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005fmlt : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_mlt-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fmlt_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005fmlt variant selector __union_citationInspireInteroperabilityRegulation_x005fmlt set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fmlt_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005fmlt;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005fmlt union_citationInspireInteroperabilityRegulation_x005fmlt;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_mlt-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fmlt_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_mlt'
        icommon__resLocInspireInteroperabilityRegulation_x005fmlt *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fmlt
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fmlt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005fmlt, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005fmlt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005fmlt); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005fmlt() : Title(), __union_citationInspireInteroperabilityRegulation_x005fmlt(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005fmlt() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005fmlt(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005fmlt * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005fmlt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:806 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fpol
#define SOAP_TYPE_icommon__inspireTheme_x005fpol (312)
/* Type icommon__inspireTheme_x005fpol is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_pol': */
class SOAP_CMAC icommon__inspireTheme_x005fpol : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_pol-KeywordValue'
        enum _icommon__inspireTheme_x005fpol_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005fpol
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005fpol; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005fpol, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005fpol *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005fpol); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005fpol() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005fpol() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005fpol(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005fpol * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005fpol(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:13305 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fpol
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fpol (990)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fpol
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fpol_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005fpol_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:810 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fpol
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fpol (314)
/* Type icommon__citationInspireInteroperabilityRegulation_x005fpol is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_pol': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005fpol : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_pol-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fpol_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005fpol variant selector __union_citationInspireInteroperabilityRegulation_x005fpol set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fpol_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005fpol;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005fpol union_citationInspireInteroperabilityRegulation_x005fpol;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_pol-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fpol_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_pol'
        icommon__resLocInspireInteroperabilityRegulation_x005fpol *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fpol
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fpol; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005fpol, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005fpol *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005fpol); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005fpol() : Title(), __union_citationInspireInteroperabilityRegulation_x005fpol(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005fpol() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005fpol(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005fpol * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005fpol(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:812 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fpor
#define SOAP_TYPE_icommon__inspireTheme_x005fpor (315)
/* Type icommon__inspireTheme_x005fpor is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_por': */
class SOAP_CMAC icommon__inspireTheme_x005fpor : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_por-KeywordValue'
        enum _icommon__inspireTheme_x005fpor_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005fpor
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005fpor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005fpor, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005fpor *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005fpor); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005fpor() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005fpor() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005fpor(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005fpor * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005fpor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:13410 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fpor
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fpor (997)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fpor
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fpor_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005fpor_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:816 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fpor
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fpor (317)
/* Type icommon__citationInspireInteroperabilityRegulation_x005fpor is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_por': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005fpor : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_por-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fpor_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005fpor variant selector __union_citationInspireInteroperabilityRegulation_x005fpor set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fpor_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005fpor;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005fpor union_citationInspireInteroperabilityRegulation_x005fpor;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_por-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fpor_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_por'
        icommon__resLocInspireInteroperabilityRegulation_x005fpor *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fpor
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fpor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005fpor, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005fpor *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005fpor); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005fpor() : Title(), __union_citationInspireInteroperabilityRegulation_x005fpor(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005fpor() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005fpor(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005fpor * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005fpor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:818 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005frum
#define SOAP_TYPE_icommon__inspireTheme_x005frum (318)
/* Type icommon__inspireTheme_x005frum is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_rum': */
class SOAP_CMAC icommon__inspireTheme_x005frum : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_rum-KeywordValue'
        enum _icommon__inspireTheme_x005frum_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005frum
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005frum; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005frum, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005frum *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005frum); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005frum() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005frum() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005frum(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005frum * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005frum(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:13515 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005frum
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005frum (1004)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005frum
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005frum_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005frum_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:822 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005frum
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005frum (320)
/* Type icommon__citationInspireInteroperabilityRegulation_x005frum is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_rum': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005frum : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_rum-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005frum_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005frum variant selector __union_citationInspireInteroperabilityRegulation_x005frum set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005frum_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005frum;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005frum union_citationInspireInteroperabilityRegulation_x005frum;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_rum-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005frum_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_rum'
        icommon__resLocInspireInteroperabilityRegulation_x005frum *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005frum
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005frum; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005frum, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005frum *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005frum); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005frum() : Title(), __union_citationInspireInteroperabilityRegulation_x005frum(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005frum() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005frum(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005frum * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005frum(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:824 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fslo
#define SOAP_TYPE_icommon__inspireTheme_x005fslo (321)
/* Type icommon__inspireTheme_x005fslo is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_slo': */
class SOAP_CMAC icommon__inspireTheme_x005fslo : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_slo-KeywordValue'
        enum _icommon__inspireTheme_x005fslo_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005fslo
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005fslo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005fslo, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005fslo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005fslo); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005fslo() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005fslo() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005fslo(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005fslo * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005fslo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:13620 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fslo
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fslo (1011)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fslo
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fslo_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005fslo_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:828 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fslo
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fslo (323)
/* Type icommon__citationInspireInteroperabilityRegulation_x005fslo is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_slo': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005fslo : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_slo-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fslo_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005fslo variant selector __union_citationInspireInteroperabilityRegulation_x005fslo set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fslo_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005fslo;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005fslo union_citationInspireInteroperabilityRegulation_x005fslo;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_slo-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fslo_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_slo'
        icommon__resLocInspireInteroperabilityRegulation_x005fslo *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fslo
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fslo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005fslo, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005fslo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005fslo); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005fslo() : Title(), __union_citationInspireInteroperabilityRegulation_x005fslo(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005fslo() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005fslo(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005fslo * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005fslo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:830 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fslv
#define SOAP_TYPE_icommon__inspireTheme_x005fslv (324)
/* Type icommon__inspireTheme_x005fslv is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_slv': */
class SOAP_CMAC icommon__inspireTheme_x005fslv : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_slv-KeywordValue'
        enum _icommon__inspireTheme_x005fslv_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005fslv
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005fslv; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005fslv, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005fslv *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005fslv); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005fslv() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005fslv() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005fslv(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005fslv * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005fslv(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:13725 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fslv
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fslv (1018)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fslv
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fslv_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005fslv_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:834 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fslv
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fslv (326)
/* Type icommon__citationInspireInteroperabilityRegulation_x005fslv is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_slv': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005fslv : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_slv-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fslv_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005fslv variant selector __union_citationInspireInteroperabilityRegulation_x005fslv set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fslv_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005fslv;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005fslv union_citationInspireInteroperabilityRegulation_x005fslv;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_slv-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fslv_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_slv'
        icommon__resLocInspireInteroperabilityRegulation_x005fslv *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fslv
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fslv; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005fslv, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005fslv *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005fslv); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005fslv() : Title(), __union_citationInspireInteroperabilityRegulation_x005fslv(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005fslv() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005fslv(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005fslv * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005fslv(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:836 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fspa
#define SOAP_TYPE_icommon__inspireTheme_x005fspa (327)
/* Type icommon__inspireTheme_x005fspa is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_spa': */
class SOAP_CMAC icommon__inspireTheme_x005fspa : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_spa-KeywordValue'
        enum _icommon__inspireTheme_x005fspa_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005fspa
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005fspa; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005fspa, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005fspa *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005fspa); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005fspa() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005fspa() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005fspa(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005fspa * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005fspa(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:13830 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fspa
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fspa (1025)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fspa
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fspa_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005fspa_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:838 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fspa
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fspa (328)
/* Type icommon__citationInspireInteroperabilityRegulation_x005fspa is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_spa': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005fspa : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_spa-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fspa_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005fspa variant selector __union_citationInspireInteroperabilityRegulation_x005fspa set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fspa_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005fspa;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005fspa union_citationInspireInteroperabilityRegulation_x005fspa;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_spa-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fspa_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_spa'
        icommon__resLocInspireInteroperabilityRegulation_x005fspa *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fspa
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fspa; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005fspa, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005fspa *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005fspa); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005fspa() : Title(), __union_citationInspireInteroperabilityRegulation_x005fspa(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005fspa() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005fspa(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005fspa * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005fspa(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:842 */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fswe
#define SOAP_TYPE_icommon__inspireTheme_x005fswe (330)
/* Type icommon__inspireTheme_x005fswe is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:inspireTheme_swe': */
class SOAP_CMAC icommon__inspireTheme_x005fswe : public xsd__anyType {
      public:
        /// Required element 'icommon:OriginatingControlledVocabulary' of XML schema type 'icommon:originatingControlledVocabularyGemetInspireThemes'
        icommon__originatingControlledVocabularyGemetInspireThemes *OriginatingControlledVocabulary;
        /// Required element 'icommon:KeywordValue' of XML schema type 'icommon:inspireTheme_swe-KeywordValue'
        enum _icommon__inspireTheme_x005fswe_KeywordValue KeywordValue;
      public:
        /// Return unique type id SOAP_TYPE_icommon__inspireTheme_x005fswe
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__inspireTheme_x005fswe; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__inspireTheme_x005fswe, default initialized and not managed by a soap context
        virtual icommon__inspireTheme_x005fswe *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__inspireTheme_x005fswe); }
      public:
        /// Constructor with default initializations
        icommon__inspireTheme_x005fswe() : OriginatingControlledVocabulary(), KeywordValue() { }
        virtual ~icommon__inspireTheme_x005fswe() { }
        /// Friend allocator used by soap_new_icommon__inspireTheme_x005fswe(struct soap*, int)
        friend SOAP_FMAC1 icommon__inspireTheme_x005fswe * SOAP_FMAC2 soap_instantiate_icommon__inspireTheme_x005fswe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:13935 */
#ifndef SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fswe
#define SOAP_TYPE__icommon__union_citationInspireInteroperabilityRegulation_x005fswe (1032)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _icommon__union_citationInspireInteroperabilityRegulation_x005fswe
{
        #define SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fswe_DateOfPublication	(1)	/**< union variant selector value for member DateOfPublication */
        enum _icommon__citationInspireInteroperabilityRegulation_x005fswe_DateOfPublication *DateOfPublication;
};
#endif

/* ws-inspire-wfs2.h:846 */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fswe
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fswe (332)
/* Type icommon__citationInspireInteroperabilityRegulation_x005fswe is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:citationInspireInteroperabilityRegulation_swe': */
class SOAP_CMAC icommon__citationInspireInteroperabilityRegulation_x005fswe : public xsd__anyType {
      public:
        /// Required element 'icommon:Title' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_swe-Title'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fswe_Title Title;
        /// Union with union _icommon__union_citationInspireInteroperabilityRegulation_x005fswe variant selector __union_citationInspireInteroperabilityRegulation_x005fswe set to one of: SOAP_UNION__icommon__union_citationInspireInteroperabilityRegulation_x005fswe_DateOfPublication
        int __union_citationInspireInteroperabilityRegulation_x005fswe;
        union _icommon__union_citationInspireInteroperabilityRegulation_x005fswe union_citationInspireInteroperabilityRegulation_x005fswe;
        /// Required element 'icommon:URI' of XML schema type 'icommon:citationInspireInteroperabilityRegulation_swe-URI'
        enum _icommon__citationInspireInteroperabilityRegulation_x005fswe_URI URI;
        /// Required element 'icommon:ResourceLocator' of XML schema type 'icommon:resLocInspireInteroperabilityRegulation_swe'
        icommon__resLocInspireInteroperabilityRegulation_x005fswe *ResourceLocator;
      public:
        /// Return unique type id SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fswe
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fswe; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__citationInspireInteroperabilityRegulation_x005fswe, default initialized and not managed by a soap context
        virtual icommon__citationInspireInteroperabilityRegulation_x005fswe *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__citationInspireInteroperabilityRegulation_x005fswe); }
      public:
        /// Constructor with default initializations
        icommon__citationInspireInteroperabilityRegulation_x005fswe() : Title(), __union_citationInspireInteroperabilityRegulation_x005fswe(), URI(), ResourceLocator() { }
        virtual ~icommon__citationInspireInteroperabilityRegulation_x005fswe() { }
        /// Friend allocator used by soap_new_icommon__citationInspireInteroperabilityRegulation_x005fswe(struct soap*, int)
        friend SOAP_FMAC1 icommon__citationInspireInteroperabilityRegulation_x005fswe * SOAP_FMAC2 soap_instantiate_icommon__citationInspireInteroperabilityRegulation_x005fswe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:680 */
#ifndef SOAP_TYPE_icommon__discoveryService_x005fext
#define SOAP_TYPE_icommon__discoveryService_x005fext (249)
/* Type icommon__discoveryService_x005fext is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:discoveryService_ext': */
class SOAP_CMAC icommon__discoveryService_x005fext : public icommon__service {
      public:
        /// Return unique type id SOAP_TYPE_icommon__discoveryService_x005fext
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__discoveryService_x005fext; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__discoveryService_x005fext, default initialized and not managed by a soap context
        virtual icommon__discoveryService_x005fext *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__discoveryService_x005fext); }
      public:
        /// Constructor with default initializations
        icommon__discoveryService_x005fext() { }
        virtual ~icommon__discoveryService_x005fext() { }
        /// Friend allocator used by soap_new_icommon__discoveryService_x005fext(struct soap*, int)
        friend SOAP_FMAC1 icommon__discoveryService_x005fext * SOAP_FMAC2 soap_instantiate_icommon__discoveryService_x005fext(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:686 */
#ifndef SOAP_TYPE_icommon__viewService_x005fext
#define SOAP_TYPE_icommon__viewService_x005fext (252)
/* Type icommon__viewService_x005fext is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:viewService_ext': */
class SOAP_CMAC icommon__viewService_x005fext : public icommon__service {
      public:
        /// Required element 'icommon:Layers' of XML schema type 'icommon:layers'
        icommon__layers *Layers;
      public:
        /// Return unique type id SOAP_TYPE_icommon__viewService_x005fext
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__viewService_x005fext; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__viewService_x005fext, default initialized and not managed by a soap context
        virtual icommon__viewService_x005fext *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__viewService_x005fext); }
      public:
        /// Constructor with default initializations
        icommon__viewService_x005fext() : Layers() { }
        virtual ~icommon__viewService_x005fext() { }
        /// Friend allocator used by soap_new_icommon__viewService_x005fext(struct soap*, int)
        friend SOAP_FMAC1 icommon__viewService_x005fext * SOAP_FMAC2 soap_instantiate_icommon__viewService_x005fext(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:690 */
#ifndef SOAP_TYPE_icommon__downloadService_x005fext
#define SOAP_TYPE_icommon__downloadService_x005fext (254)
/* Type icommon__downloadService_x005fext is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:downloadService_ext': */
class SOAP_CMAC icommon__downloadService_x005fext : public icommon__service {
      public:
        /// Return unique type id SOAP_TYPE_icommon__downloadService_x005fext
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__downloadService_x005fext; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__downloadService_x005fext, default initialized and not managed by a soap context
        virtual icommon__downloadService_x005fext *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__downloadService_x005fext); }
      public:
        /// Constructor with default initializations
        icommon__downloadService_x005fext() { }
        virtual ~icommon__downloadService_x005fext() { }
        /// Friend allocator used by soap_new_icommon__downloadService_x005fext(struct soap*, int)
        friend SOAP_FMAC1 icommon__downloadService_x005fext * SOAP_FMAC2 soap_instantiate_icommon__downloadService_x005fext(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:694 */
#ifndef SOAP_TYPE_icommon__transformationService_x005fext
#define SOAP_TYPE_icommon__transformationService_x005fext (256)
/* Type icommon__transformationService_x005fext is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:transformationService_ext': */
class SOAP_CMAC icommon__transformationService_x005fext : public icommon__service {
      public:
        /// Return unique type id SOAP_TYPE_icommon__transformationService_x005fext
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__transformationService_x005fext; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__transformationService_x005fext, default initialized and not managed by a soap context
        virtual icommon__transformationService_x005fext *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__transformationService_x005fext); }
      public:
        /// Constructor with default initializations
        icommon__transformationService_x005fext() { }
        virtual ~icommon__transformationService_x005fext() { }
        /// Friend allocator used by soap_new_icommon__transformationService_x005fext(struct soap*, int)
        friend SOAP_FMAC1 icommon__transformationService_x005fext * SOAP_FMAC2 soap_instantiate_icommon__transformationService_x005fext(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:698 */
#ifndef SOAP_TYPE_icommon__invokeService_x005fext
#define SOAP_TYPE_icommon__invokeService_x005fext (258)
/* Type icommon__invokeService_x005fext is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:invokeService_ext': */
class SOAP_CMAC icommon__invokeService_x005fext : public icommon__service {
      public:
        /// Return unique type id SOAP_TYPE_icommon__invokeService_x005fext
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__invokeService_x005fext; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__invokeService_x005fext, default initialized and not managed by a soap context
        virtual icommon__invokeService_x005fext *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__invokeService_x005fext); }
      public:
        /// Constructor with default initializations
        icommon__invokeService_x005fext() { }
        virtual ~icommon__invokeService_x005fext() { }
        /// Friend allocator used by soap_new_icommon__invokeService_x005fext(struct soap*, int)
        friend SOAP_FMAC1 icommon__invokeService_x005fext * SOAP_FMAC2 soap_instantiate_icommon__invokeService_x005fext(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:702 */
#ifndef SOAP_TYPE_icommon__otherService_x005fext
#define SOAP_TYPE_icommon__otherService_x005fext (260)
/* Type icommon__otherService_x005fext is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:otherService_ext': */
class SOAP_CMAC icommon__otherService_x005fext : public icommon__service {
      public:
        /// Return unique type id SOAP_TYPE_icommon__otherService_x005fext
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__otherService_x005fext; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__otherService_x005fext, default initialized and not managed by a soap context
        virtual icommon__otherService_x005fext *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__otherService_x005fext); }
      public:
        /// Constructor with default initializations
        icommon__otherService_x005fext() { }
        virtual ~icommon__otherService_x005fext() { }
        /// Friend allocator used by soap_new_icommon__otherService_x005fext(struct soap*, int)
        friend SOAP_FMAC1 icommon__otherService_x005fext * SOAP_FMAC2 soap_instantiate_icommon__otherService_x005fext(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:682 */
#ifndef SOAP_TYPE_icommon__discoveryService
#define SOAP_TYPE_icommon__discoveryService (250)
/* Type icommon__discoveryService is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:discoveryService': */
class SOAP_CMAC icommon__discoveryService : public xsd__anyType {
      public:
        /// Required element 'icommon:ResourceTitle' of XML schema type 'icommon:notEmptyString'
        std::string ResourceTitle;
        /// Required element 'icommon:ResourceAbstract' of XML schema type 'icommon:notEmptyString'
        std::string ResourceAbstract;
        /// Required element 'icommon:ResourceType' of XML schema type 'icommon:serviceSpatialDataResourceType'
        enum icommon__serviceSpatialDataResourceType ResourceType;
        /// Optional element 'icommon:ResourceLocator' of XML schema type 'icommon:resourceLocatorType'
        std::vector<icommon__resourceLocatorType *> ResourceLocator;
        /// Required element 'icommon:MandatoryKeyword' of XML schema type 'icommon:classificationOfSpatialDataService'
        std::vector<icommon__classificationOfSpatialDataService *> MandatoryKeyword;
        /// Optional element 'icommon:Keyword' of XML schema type 'icommon:keyword'
        std::vector<icommon__keyword *> Keyword;
        /// Optional element 'icommon:GeographicBoundingBox' of XML schema type 'icommon:geographicBoundingBox'
        std::vector<icommon__geographicBoundingBox *> GeographicBoundingBox;
        /// Required element 'icommon:TemporalReference' of XML schema type 'icommon:temporalReference'
        std::vector<icommon__temporalReference *> TemporalReference;
        /// Optional element 'icommon:SpatialResolution' of XML schema type 'icommon:spatialResolution'
        std::vector<icommon__spatialResolution *> SpatialResolution;
        /// Required element 'icommon:Conformity' of XML schema type 'icommon:conformity'
        std::vector<icommon__conformity *> Conformity;
        /// Required element 'icommon:ConditionsForAccessAndUse' of XML schema type 'icommon:notEmptyString'
        std::vector<std::string> ConditionsForAccessAndUse;
        /// Required element 'icommon:LimitationsOnPublicAccess' of XML schema type 'icommon:notEmptyString'
        std::vector<std::string> LimitationsOnPublicAccess;
        /// Required element 'icommon:ResponsibleOrganisation' of XML schema type 'icommon:responsibleOrganisation'
        std::vector<icommon__responsibleOrganisation *> ResponsibleOrganisation;
        /// Required element 'icommon:MetadataPointOfContact' of XML schema type 'icommon:metadataPointOfContact'
        std::vector<icommon__metadataPointOfContact *> MetadataPointOfContact;
        /// Required element 'icommon:MetadataDate' of XML schema type 'icommon:iso8601Date'
        std::string MetadataDate;
        /// Required element 'icommon:MetadataLanguage' of XML schema type 'icommon:euLanguageISO6392B'
        enum icommon__euLanguageISO6392B MetadataLanguage;
        /// Optional element 'icommon:CoupledResource' of XML schema type 'icommon:uniqueResourceIdentifier'
        std::vector<icommon__uniqueResourceIdentifier *> CoupledResource;
        /// Required element 'icommon:SpatialDataServiceType' of XML schema type 'icommon:discoverySpatialDataServiceType'
        enum icommon__discoverySpatialDataServiceType SpatialDataServiceType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__discoveryService
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__discoveryService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__discoveryService, default initialized and not managed by a soap context
        virtual icommon__discoveryService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__discoveryService); }
      public:
        /// Constructor with default initializations
        icommon__discoveryService() : ResourceTitle(), ResourceAbstract(), ResourceType(), ResourceLocator(), MandatoryKeyword(), Keyword(), GeographicBoundingBox(), TemporalReference(), SpatialResolution(), Conformity(), ConditionsForAccessAndUse(), LimitationsOnPublicAccess(), ResponsibleOrganisation(), MetadataPointOfContact(), MetadataDate(), MetadataLanguage(), CoupledResource(), SpatialDataServiceType() { }
        virtual ~icommon__discoveryService() { }
        /// Friend allocator used by soap_new_icommon__discoveryService(struct soap*, int)
        friend SOAP_FMAC1 icommon__discoveryService * SOAP_FMAC2 soap_instantiate_icommon__discoveryService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:688 */
#ifndef SOAP_TYPE_icommon__viewService
#define SOAP_TYPE_icommon__viewService (253)
/* Type icommon__viewService is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:viewService': */
class SOAP_CMAC icommon__viewService : public xsd__anyType {
      public:
        /// Required element 'icommon:ResourceTitle' of XML schema type 'icommon:notEmptyString'
        std::string ResourceTitle;
        /// Required element 'icommon:ResourceAbstract' of XML schema type 'icommon:notEmptyString'
        std::string ResourceAbstract;
        /// Required element 'icommon:ResourceType' of XML schema type 'icommon:serviceSpatialDataResourceType'
        enum icommon__serviceSpatialDataResourceType ResourceType;
        /// Optional element 'icommon:ResourceLocator' of XML schema type 'icommon:resourceLocatorType'
        std::vector<icommon__resourceLocatorType *> ResourceLocator;
        /// Required element 'icommon:MandatoryKeyword' of XML schema type 'icommon:classificationOfSpatialDataService'
        std::vector<icommon__classificationOfSpatialDataService *> MandatoryKeyword;
        /// Optional element 'icommon:Keyword' of XML schema type 'icommon:keyword'
        std::vector<icommon__keyword *> Keyword;
        /// Optional element 'icommon:GeographicBoundingBox' of XML schema type 'icommon:geographicBoundingBox'
        std::vector<icommon__geographicBoundingBox *> GeographicBoundingBox;
        /// Required element 'icommon:TemporalReference' of XML schema type 'icommon:temporalReference'
        std::vector<icommon__temporalReference *> TemporalReference;
        /// Optional element 'icommon:SpatialResolution' of XML schema type 'icommon:spatialResolution'
        std::vector<icommon__spatialResolution *> SpatialResolution;
        /// Required element 'icommon:Conformity' of XML schema type 'icommon:conformity'
        std::vector<icommon__conformity *> Conformity;
        /// Required element 'icommon:ConditionsForAccessAndUse' of XML schema type 'icommon:notEmptyString'
        std::vector<std::string> ConditionsForAccessAndUse;
        /// Required element 'icommon:LimitationsOnPublicAccess' of XML schema type 'icommon:notEmptyString'
        std::vector<std::string> LimitationsOnPublicAccess;
        /// Required element 'icommon:ResponsibleOrganisation' of XML schema type 'icommon:responsibleOrganisation'
        std::vector<icommon__responsibleOrganisation *> ResponsibleOrganisation;
        /// Required element 'icommon:MetadataPointOfContact' of XML schema type 'icommon:metadataPointOfContact'
        std::vector<icommon__metadataPointOfContact *> MetadataPointOfContact;
        /// Required element 'icommon:MetadataDate' of XML schema type 'icommon:iso8601Date'
        std::string MetadataDate;
        /// Required element 'icommon:MetadataLanguage' of XML schema type 'icommon:euLanguageISO6392B'
        enum icommon__euLanguageISO6392B MetadataLanguage;
        /// Optional element 'icommon:CoupledResource' of XML schema type 'icommon:uniqueResourceIdentifier'
        std::vector<icommon__uniqueResourceIdentifier *> CoupledResource;
        /// Required element 'icommon:SpatialDataServiceType' of XML schema type 'icommon:viewSpatialDataServiceType'
        enum icommon__viewSpatialDataServiceType SpatialDataServiceType;
        /// Required element 'icommon:Layers' of XML schema type 'icommon:layers'
        icommon__layers *Layers;
      public:
        /// Return unique type id SOAP_TYPE_icommon__viewService
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__viewService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__viewService, default initialized and not managed by a soap context
        virtual icommon__viewService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__viewService); }
      public:
        /// Constructor with default initializations
        icommon__viewService() : ResourceTitle(), ResourceAbstract(), ResourceType(), ResourceLocator(), MandatoryKeyword(), Keyword(), GeographicBoundingBox(), TemporalReference(), SpatialResolution(), Conformity(), ConditionsForAccessAndUse(), LimitationsOnPublicAccess(), ResponsibleOrganisation(), MetadataPointOfContact(), MetadataDate(), MetadataLanguage(), CoupledResource(), SpatialDataServiceType(), Layers() { }
        virtual ~icommon__viewService() { }
        /// Friend allocator used by soap_new_icommon__viewService(struct soap*, int)
        friend SOAP_FMAC1 icommon__viewService * SOAP_FMAC2 soap_instantiate_icommon__viewService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:692 */
#ifndef SOAP_TYPE_icommon__downloadService
#define SOAP_TYPE_icommon__downloadService (255)
/* Type icommon__downloadService is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:downloadService': */
class SOAP_CMAC icommon__downloadService : public xsd__anyType {
      public:
        /// Required element 'icommon:ResourceTitle' of XML schema type 'icommon:notEmptyString'
        std::string ResourceTitle;
        /// Required element 'icommon:ResourceAbstract' of XML schema type 'icommon:notEmptyString'
        std::string ResourceAbstract;
        /// Required element 'icommon:ResourceType' of XML schema type 'icommon:serviceSpatialDataResourceType'
        enum icommon__serviceSpatialDataResourceType ResourceType;
        /// Optional element 'icommon:ResourceLocator' of XML schema type 'icommon:resourceLocatorType'
        std::vector<icommon__resourceLocatorType *> ResourceLocator;
        /// Required element 'icommon:MandatoryKeyword' of XML schema type 'icommon:classificationOfSpatialDataService'
        std::vector<icommon__classificationOfSpatialDataService *> MandatoryKeyword;
        /// Optional element 'icommon:Keyword' of XML schema type 'icommon:keyword'
        std::vector<icommon__keyword *> Keyword;
        /// Optional element 'icommon:GeographicBoundingBox' of XML schema type 'icommon:geographicBoundingBox'
        std::vector<icommon__geographicBoundingBox *> GeographicBoundingBox;
        /// Required element 'icommon:TemporalReference' of XML schema type 'icommon:temporalReference'
        std::vector<icommon__temporalReference *> TemporalReference;
        /// Optional element 'icommon:SpatialResolution' of XML schema type 'icommon:spatialResolution'
        std::vector<icommon__spatialResolution *> SpatialResolution;
        /// Required element 'icommon:Conformity' of XML schema type 'icommon:conformity'
        std::vector<icommon__conformity *> Conformity;
        /// Required element 'icommon:ConditionsForAccessAndUse' of XML schema type 'icommon:notEmptyString'
        std::vector<std::string> ConditionsForAccessAndUse;
        /// Required element 'icommon:LimitationsOnPublicAccess' of XML schema type 'icommon:notEmptyString'
        std::vector<std::string> LimitationsOnPublicAccess;
        /// Required element 'icommon:ResponsibleOrganisation' of XML schema type 'icommon:responsibleOrganisation'
        std::vector<icommon__responsibleOrganisation *> ResponsibleOrganisation;
        /// Required element 'icommon:MetadataPointOfContact' of XML schema type 'icommon:metadataPointOfContact'
        std::vector<icommon__metadataPointOfContact *> MetadataPointOfContact;
        /// Required element 'icommon:MetadataDate' of XML schema type 'icommon:iso8601Date'
        std::string MetadataDate;
        /// Required element 'icommon:MetadataLanguage' of XML schema type 'icommon:euLanguageISO6392B'
        enum icommon__euLanguageISO6392B MetadataLanguage;
        /// Optional element 'icommon:CoupledResource' of XML schema type 'icommon:uniqueResourceIdentifier'
        std::vector<icommon__uniqueResourceIdentifier *> CoupledResource;
        /// Required element 'icommon:SpatialDataServiceType' of XML schema type 'icommon:transformationSpatialDataServiceType'
        enum icommon__transformationSpatialDataServiceType SpatialDataServiceType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__downloadService
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__downloadService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__downloadService, default initialized and not managed by a soap context
        virtual icommon__downloadService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__downloadService); }
      public:
        /// Constructor with default initializations
        icommon__downloadService() : ResourceTitle(), ResourceAbstract(), ResourceType(), ResourceLocator(), MandatoryKeyword(), Keyword(), GeographicBoundingBox(), TemporalReference(), SpatialResolution(), Conformity(), ConditionsForAccessAndUse(), LimitationsOnPublicAccess(), ResponsibleOrganisation(), MetadataPointOfContact(), MetadataDate(), MetadataLanguage(), CoupledResource(), SpatialDataServiceType() { }
        virtual ~icommon__downloadService() { }
        /// Friend allocator used by soap_new_icommon__downloadService(struct soap*, int)
        friend SOAP_FMAC1 icommon__downloadService * SOAP_FMAC2 soap_instantiate_icommon__downloadService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:696 */
#ifndef SOAP_TYPE_icommon__transformationService
#define SOAP_TYPE_icommon__transformationService (257)
/* Type icommon__transformationService is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:transformationService': */
class SOAP_CMAC icommon__transformationService : public xsd__anyType {
      public:
        /// Required element 'icommon:ResourceTitle' of XML schema type 'icommon:notEmptyString'
        std::string ResourceTitle;
        /// Required element 'icommon:ResourceAbstract' of XML schema type 'icommon:notEmptyString'
        std::string ResourceAbstract;
        /// Required element 'icommon:ResourceType' of XML schema type 'icommon:serviceSpatialDataResourceType'
        enum icommon__serviceSpatialDataResourceType ResourceType;
        /// Optional element 'icommon:ResourceLocator' of XML schema type 'icommon:resourceLocatorType'
        std::vector<icommon__resourceLocatorType *> ResourceLocator;
        /// Required element 'icommon:MandatoryKeyword' of XML schema type 'icommon:classificationOfSpatialDataService'
        std::vector<icommon__classificationOfSpatialDataService *> MandatoryKeyword;
        /// Optional element 'icommon:Keyword' of XML schema type 'icommon:keyword'
        std::vector<icommon__keyword *> Keyword;
        /// Optional element 'icommon:GeographicBoundingBox' of XML schema type 'icommon:geographicBoundingBox'
        std::vector<icommon__geographicBoundingBox *> GeographicBoundingBox;
        /// Required element 'icommon:TemporalReference' of XML schema type 'icommon:temporalReference'
        std::vector<icommon__temporalReference *> TemporalReference;
        /// Optional element 'icommon:SpatialResolution' of XML schema type 'icommon:spatialResolution'
        std::vector<icommon__spatialResolution *> SpatialResolution;
        /// Required element 'icommon:Conformity' of XML schema type 'icommon:conformity'
        std::vector<icommon__conformity *> Conformity;
        /// Required element 'icommon:ConditionsForAccessAndUse' of XML schema type 'icommon:notEmptyString'
        std::vector<std::string> ConditionsForAccessAndUse;
        /// Required element 'icommon:LimitationsOnPublicAccess' of XML schema type 'icommon:notEmptyString'
        std::vector<std::string> LimitationsOnPublicAccess;
        /// Required element 'icommon:ResponsibleOrganisation' of XML schema type 'icommon:responsibleOrganisation'
        std::vector<icommon__responsibleOrganisation *> ResponsibleOrganisation;
        /// Required element 'icommon:MetadataPointOfContact' of XML schema type 'icommon:metadataPointOfContact'
        std::vector<icommon__metadataPointOfContact *> MetadataPointOfContact;
        /// Required element 'icommon:MetadataDate' of XML schema type 'icommon:iso8601Date'
        std::string MetadataDate;
        /// Required element 'icommon:MetadataLanguage' of XML schema type 'icommon:euLanguageISO6392B'
        enum icommon__euLanguageISO6392B MetadataLanguage;
        /// Optional element 'icommon:CoupledResource' of XML schema type 'icommon:uniqueResourceIdentifier'
        std::vector<icommon__uniqueResourceIdentifier *> CoupledResource;
        /// Required element 'icommon:SpatialDataServiceType' of XML schema type 'icommon:transformationSpatialDataServiceType'
        enum icommon__transformationSpatialDataServiceType SpatialDataServiceType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__transformationService
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__transformationService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__transformationService, default initialized and not managed by a soap context
        virtual icommon__transformationService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__transformationService); }
      public:
        /// Constructor with default initializations
        icommon__transformationService() : ResourceTitle(), ResourceAbstract(), ResourceType(), ResourceLocator(), MandatoryKeyword(), Keyword(), GeographicBoundingBox(), TemporalReference(), SpatialResolution(), Conformity(), ConditionsForAccessAndUse(), LimitationsOnPublicAccess(), ResponsibleOrganisation(), MetadataPointOfContact(), MetadataDate(), MetadataLanguage(), CoupledResource(), SpatialDataServiceType() { }
        virtual ~icommon__transformationService() { }
        /// Friend allocator used by soap_new_icommon__transformationService(struct soap*, int)
        friend SOAP_FMAC1 icommon__transformationService * SOAP_FMAC2 soap_instantiate_icommon__transformationService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:700 */
#ifndef SOAP_TYPE_icommon__invokeService
#define SOAP_TYPE_icommon__invokeService (259)
/* Type icommon__invokeService is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:invokeService': */
class SOAP_CMAC icommon__invokeService : public xsd__anyType {
      public:
        /// Required element 'icommon:ResourceTitle' of XML schema type 'icommon:notEmptyString'
        std::string ResourceTitle;
        /// Required element 'icommon:ResourceAbstract' of XML schema type 'icommon:notEmptyString'
        std::string ResourceAbstract;
        /// Required element 'icommon:ResourceType' of XML schema type 'icommon:serviceSpatialDataResourceType'
        enum icommon__serviceSpatialDataResourceType ResourceType;
        /// Optional element 'icommon:ResourceLocator' of XML schema type 'icommon:resourceLocatorType'
        std::vector<icommon__resourceLocatorType *> ResourceLocator;
        /// Required element 'icommon:MandatoryKeyword' of XML schema type 'icommon:classificationOfSpatialDataService'
        std::vector<icommon__classificationOfSpatialDataService *> MandatoryKeyword;
        /// Optional element 'icommon:Keyword' of XML schema type 'icommon:keyword'
        std::vector<icommon__keyword *> Keyword;
        /// Optional element 'icommon:GeographicBoundingBox' of XML schema type 'icommon:geographicBoundingBox'
        std::vector<icommon__geographicBoundingBox *> GeographicBoundingBox;
        /// Required element 'icommon:TemporalReference' of XML schema type 'icommon:temporalReference'
        std::vector<icommon__temporalReference *> TemporalReference;
        /// Optional element 'icommon:SpatialResolution' of XML schema type 'icommon:spatialResolution'
        std::vector<icommon__spatialResolution *> SpatialResolution;
        /// Required element 'icommon:Conformity' of XML schema type 'icommon:conformity'
        std::vector<icommon__conformity *> Conformity;
        /// Required element 'icommon:ConditionsForAccessAndUse' of XML schema type 'icommon:notEmptyString'
        std::vector<std::string> ConditionsForAccessAndUse;
        /// Required element 'icommon:LimitationsOnPublicAccess' of XML schema type 'icommon:notEmptyString'
        std::vector<std::string> LimitationsOnPublicAccess;
        /// Required element 'icommon:ResponsibleOrganisation' of XML schema type 'icommon:responsibleOrganisation'
        std::vector<icommon__responsibleOrganisation *> ResponsibleOrganisation;
        /// Required element 'icommon:MetadataPointOfContact' of XML schema type 'icommon:metadataPointOfContact'
        std::vector<icommon__metadataPointOfContact *> MetadataPointOfContact;
        /// Required element 'icommon:MetadataDate' of XML schema type 'icommon:iso8601Date'
        std::string MetadataDate;
        /// Required element 'icommon:MetadataLanguage' of XML schema type 'icommon:euLanguageISO6392B'
        enum icommon__euLanguageISO6392B MetadataLanguage;
        /// Optional element 'icommon:CoupledResource' of XML schema type 'icommon:uniqueResourceIdentifier'
        std::vector<icommon__uniqueResourceIdentifier *> CoupledResource;
        /// Required element 'icommon:SpatialDataServiceType' of XML schema type 'icommon:discoverySpatialDataServiceType'
        enum icommon__discoverySpatialDataServiceType SpatialDataServiceType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__invokeService
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__invokeService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__invokeService, default initialized and not managed by a soap context
        virtual icommon__invokeService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__invokeService); }
      public:
        /// Constructor with default initializations
        icommon__invokeService() : ResourceTitle(), ResourceAbstract(), ResourceType(), ResourceLocator(), MandatoryKeyword(), Keyword(), GeographicBoundingBox(), TemporalReference(), SpatialResolution(), Conformity(), ConditionsForAccessAndUse(), LimitationsOnPublicAccess(), ResponsibleOrganisation(), MetadataPointOfContact(), MetadataDate(), MetadataLanguage(), CoupledResource(), SpatialDataServiceType() { }
        virtual ~icommon__invokeService() { }
        /// Friend allocator used by soap_new_icommon__invokeService(struct soap*, int)
        friend SOAP_FMAC1 icommon__invokeService * SOAP_FMAC2 soap_instantiate_icommon__invokeService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:704 */
#ifndef SOAP_TYPE_icommon__otherService
#define SOAP_TYPE_icommon__otherService (261)
/* Type icommon__otherService is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'icommon:otherService': */
class SOAP_CMAC icommon__otherService : public xsd__anyType {
      public:
        /// Required element 'icommon:ResourceTitle' of XML schema type 'icommon:notEmptyString'
        std::string ResourceTitle;
        /// Required element 'icommon:ResourceAbstract' of XML schema type 'icommon:notEmptyString'
        std::string ResourceAbstract;
        /// Required element 'icommon:ResourceType' of XML schema type 'icommon:serviceSpatialDataResourceType'
        enum icommon__serviceSpatialDataResourceType ResourceType;
        /// Optional element 'icommon:ResourceLocator' of XML schema type 'icommon:resourceLocatorType'
        std::vector<icommon__resourceLocatorType *> ResourceLocator;
        /// Required element 'icommon:MandatoryKeyword' of XML schema type 'icommon:classificationOfSpatialDataService'
        std::vector<icommon__classificationOfSpatialDataService *> MandatoryKeyword;
        /// Optional element 'icommon:Keyword' of XML schema type 'icommon:keyword'
        std::vector<icommon__keyword *> Keyword;
        /// Optional element 'icommon:GeographicBoundingBox' of XML schema type 'icommon:geographicBoundingBox'
        std::vector<icommon__geographicBoundingBox *> GeographicBoundingBox;
        /// Required element 'icommon:TemporalReference' of XML schema type 'icommon:temporalReference'
        std::vector<icommon__temporalReference *> TemporalReference;
        /// Optional element 'icommon:SpatialResolution' of XML schema type 'icommon:spatialResolution'
        std::vector<icommon__spatialResolution *> SpatialResolution;
        /// Required element 'icommon:Conformity' of XML schema type 'icommon:conformity'
        std::vector<icommon__conformity *> Conformity;
        /// Required element 'icommon:ConditionsForAccessAndUse' of XML schema type 'icommon:notEmptyString'
        std::vector<std::string> ConditionsForAccessAndUse;
        /// Required element 'icommon:LimitationsOnPublicAccess' of XML schema type 'icommon:notEmptyString'
        std::vector<std::string> LimitationsOnPublicAccess;
        /// Required element 'icommon:ResponsibleOrganisation' of XML schema type 'icommon:responsibleOrganisation'
        std::vector<icommon__responsibleOrganisation *> ResponsibleOrganisation;
        /// Required element 'icommon:MetadataPointOfContact' of XML schema type 'icommon:metadataPointOfContact'
        std::vector<icommon__metadataPointOfContact *> MetadataPointOfContact;
        /// Required element 'icommon:MetadataDate' of XML schema type 'icommon:iso8601Date'
        std::string MetadataDate;
        /// Required element 'icommon:MetadataLanguage' of XML schema type 'icommon:euLanguageISO6392B'
        enum icommon__euLanguageISO6392B MetadataLanguage;
        /// Optional element 'icommon:CoupledResource' of XML schema type 'icommon:uniqueResourceIdentifier'
        std::vector<icommon__uniqueResourceIdentifier *> CoupledResource;
        /// Required element 'icommon:SpatialDataServiceType' of XML schema type 'icommon:discoverySpatialDataServiceType'
        enum icommon__discoverySpatialDataServiceType SpatialDataServiceType;
      public:
        /// Return unique type id SOAP_TYPE_icommon__otherService
        virtual long soap_type(void) const { return SOAP_TYPE_icommon__otherService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type icommon__otherService, default initialized and not managed by a soap context
        virtual icommon__otherService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(icommon__otherService); }
      public:
        /// Constructor with default initializations
        icommon__otherService() : ResourceTitle(), ResourceAbstract(), ResourceType(), ResourceLocator(), MandatoryKeyword(), Keyword(), GeographicBoundingBox(), TemporalReference(), SpatialResolution(), Conformity(), ConditionsForAccessAndUse(), LimitationsOnPublicAccess(), ResponsibleOrganisation(), MetadataPointOfContact(), MetadataDate(), MetadataLanguage(), CoupledResource(), SpatialDataServiceType() { }
        virtual ~icommon__otherService() { }
        /// Friend allocator used by soap_new_icommon__otherService(struct soap*, int)
        friend SOAP_FMAC1 icommon__otherService * SOAP_FMAC2 soap_instantiate_icommon__otherService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:15353 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (1175)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        /** Optional element 'ows:ExceptionReport' of XML schema type 'ows:ExceptionReport' */
        _ows__ExceptionReport *ows__ExceptionReport;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
        char *__any;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : ows__ExceptionReport(), __type(), fault(), __any() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ws-inspire-wfs2.h:15436 */
#ifndef SOAP_TYPE___f2i_plu__wfs_x002ecreateStoredQueryResponse
#define SOAP_TYPE___f2i_plu__wfs_x002ecreateStoredQueryResponse (1181)
/* Wrapper: */
struct SOAP_CMAC __f2i_plu__wfs_x002ecreateStoredQueryResponse {
      public:
        /** Required element 'wfs:CreateStoredQueryResponse' of XML schema type 'wfs:CreateStoredQueryResponseType' */
        wfs__CreateStoredQueryResponseType wfs__CreateStoredQueryResponse;
      public:
        /** Return unique type id SOAP_TYPE___f2i_plu__wfs_x002ecreateStoredQueryResponse */
        long soap_type() const { return SOAP_TYPE___f2i_plu__wfs_x002ecreateStoredQueryResponse; }
        /** Constructor with member initializations */
        __f2i_plu__wfs_x002ecreateStoredQueryResponse() : wfs__CreateStoredQueryResponse() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __f2i_plu__wfs_x002ecreateStoredQueryResponse * SOAP_FMAC2 soap_instantiate___f2i_plu__wfs_x002ecreateStoredQueryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:15436 */
#ifndef SOAP_TYPE___f2i_plu__wfs_x002ecreateStoredQuery
#define SOAP_TYPE___f2i_plu__wfs_x002ecreateStoredQuery (1182)
/* Wrapper: */
struct SOAP_CMAC __f2i_plu__wfs_x002ecreateStoredQuery {
      public:
        /** Optional element 'wfs:CreateStoredQuery' of XML schema type 'wfs:CreateStoredQueryType' */
        wfs__CreateStoredQueryType *wfs__CreateStoredQuery;
      public:
        /** Return unique type id SOAP_TYPE___f2i_plu__wfs_x002ecreateStoredQuery */
        long soap_type() const { return SOAP_TYPE___f2i_plu__wfs_x002ecreateStoredQuery; }
        /** Constructor with member initializations */
        __f2i_plu__wfs_x002ecreateStoredQuery() : wfs__CreateStoredQuery() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __f2i_plu__wfs_x002ecreateStoredQuery * SOAP_FMAC2 soap_instantiate___f2i_plu__wfs_x002ecreateStoredQuery(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:15503 */
#ifndef SOAP_TYPE___f2i_plu__wfs_x002edescribeFeatureType
#define SOAP_TYPE___f2i_plu__wfs_x002edescribeFeatureType (1186)
/* Wrapper: */
struct SOAP_CMAC __f2i_plu__wfs_x002edescribeFeatureType {
      public:
        /** Optional element 'wfs:DescribeFeatureType' of XML schema type 'wfs:DescribeFeatureTypeType' */
        wfs__DescribeFeatureTypeType *wfs__DescribeFeatureType;
      public:
        /** Return unique type id SOAP_TYPE___f2i_plu__wfs_x002edescribeFeatureType */
        long soap_type() const { return SOAP_TYPE___f2i_plu__wfs_x002edescribeFeatureType; }
        /** Constructor with member initializations */
        __f2i_plu__wfs_x002edescribeFeatureType() : wfs__DescribeFeatureType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __f2i_plu__wfs_x002edescribeFeatureType * SOAP_FMAC2 soap_instantiate___f2i_plu__wfs_x002edescribeFeatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:15570 */
#ifndef SOAP_TYPE___f2i_plu__wfs_x002egetFeature
#define SOAP_TYPE___f2i_plu__wfs_x002egetFeature (1190)
/* Wrapper: */
struct SOAP_CMAC __f2i_plu__wfs_x002egetFeature {
      public:
        /** Optional element 'wfs:GetFeature' of XML schema type 'wfs:GetFeatureType' */
        wfs__GetFeatureType *wfs__GetFeature;
      public:
        /** Return unique type id SOAP_TYPE___f2i_plu__wfs_x002egetFeature */
        long soap_type() const { return SOAP_TYPE___f2i_plu__wfs_x002egetFeature; }
        /** Constructor with member initializations */
        __f2i_plu__wfs_x002egetFeature() : wfs__GetFeature() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __f2i_plu__wfs_x002egetFeature * SOAP_FMAC2 soap_instantiate___f2i_plu__wfs_x002egetFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:15637 */
#ifndef SOAP_TYPE___f2i_plu__wfs_x002edescribeStoredQueries
#define SOAP_TYPE___f2i_plu__wfs_x002edescribeStoredQueries (1194)
/* Wrapper: */
struct SOAP_CMAC __f2i_plu__wfs_x002edescribeStoredQueries {
      public:
        /** Optional element 'wfs:DescribeStoredQueries' of XML schema type 'wfs:DescribeStoredQueriesType' */
        wfs__DescribeStoredQueriesType *wfs__DescribeStoredQueries;
      public:
        /** Return unique type id SOAP_TYPE___f2i_plu__wfs_x002edescribeStoredQueries */
        long soap_type() const { return SOAP_TYPE___f2i_plu__wfs_x002edescribeStoredQueries; }
        /** Constructor with member initializations */
        __f2i_plu__wfs_x002edescribeStoredQueries() : wfs__DescribeStoredQueries() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __f2i_plu__wfs_x002edescribeStoredQueries * SOAP_FMAC2 soap_instantiate___f2i_plu__wfs_x002edescribeStoredQueries(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:15704 */
#ifndef SOAP_TYPE___f2i_plu__wfs_x002elistStoredQueries
#define SOAP_TYPE___f2i_plu__wfs_x002elistStoredQueries (1198)
/* Wrapper: */
struct SOAP_CMAC __f2i_plu__wfs_x002elistStoredQueries {
      public:
        /** Optional element 'wfs:ListStoredQueries' of XML schema type 'wfs:ListStoredQueriesType' */
        wfs__ListStoredQueriesType *wfs__ListStoredQueries;
      public:
        /** Return unique type id SOAP_TYPE___f2i_plu__wfs_x002elistStoredQueries */
        long soap_type() const { return SOAP_TYPE___f2i_plu__wfs_x002elistStoredQueries; }
        /** Constructor with member initializations */
        __f2i_plu__wfs_x002elistStoredQueries() : wfs__ListStoredQueries() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __f2i_plu__wfs_x002elistStoredQueries * SOAP_FMAC2 soap_instantiate___f2i_plu__wfs_x002elistStoredQueries(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:15771 */
#ifndef SOAP_TYPE___f2i_plu__wfs_x002edropStoredQueryResponse
#define SOAP_TYPE___f2i_plu__wfs_x002edropStoredQueryResponse (1202)
/* Wrapper: */
struct SOAP_CMAC __f2i_plu__wfs_x002edropStoredQueryResponse {
      public:
        /** Required element 'wfs:DropStoredQueryResponse' of XML schema type 'wfs:ExecutionStatusType' */
        wfs__ExecutionStatusType wfs__DropStoredQueryResponse;
      public:
        /** Return unique type id SOAP_TYPE___f2i_plu__wfs_x002edropStoredQueryResponse */
        long soap_type() const { return SOAP_TYPE___f2i_plu__wfs_x002edropStoredQueryResponse; }
        /** Constructor with member initializations */
        __f2i_plu__wfs_x002edropStoredQueryResponse() : wfs__DropStoredQueryResponse() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __f2i_plu__wfs_x002edropStoredQueryResponse * SOAP_FMAC2 soap_instantiate___f2i_plu__wfs_x002edropStoredQueryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:15771 */
#ifndef SOAP_TYPE___f2i_plu__wfs_x002edropStoredQuery
#define SOAP_TYPE___f2i_plu__wfs_x002edropStoredQuery (1203)
/* Wrapper: */
struct SOAP_CMAC __f2i_plu__wfs_x002edropStoredQuery {
      public:
        /** Optional element 'wfs:DropStoredQuery' of XML schema type 'wfs:DropStoredQuery' */
        _wfs__DropStoredQuery *wfs__DropStoredQuery;
      public:
        /** Return unique type id SOAP_TYPE___f2i_plu__wfs_x002edropStoredQuery */
        long soap_type() const { return SOAP_TYPE___f2i_plu__wfs_x002edropStoredQuery; }
        /** Constructor with member initializations */
        __f2i_plu__wfs_x002edropStoredQuery() : wfs__DropStoredQuery() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __f2i_plu__wfs_x002edropStoredQuery * SOAP_FMAC2 soap_instantiate___f2i_plu__wfs_x002edropStoredQuery(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:15838 */
#ifndef SOAP_TYPE___f2i_plu__wfs_x002egetCapabilities
#define SOAP_TYPE___f2i_plu__wfs_x002egetCapabilities (1207)
/* Wrapper: */
struct SOAP_CMAC __f2i_plu__wfs_x002egetCapabilities {
      public:
        /** Optional element 'ows:GetCapabilities' of XML schema type 'ows:GetCapabilitiesType' */
        ows__GetCapabilitiesType *ows__GetCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___f2i_plu__wfs_x002egetCapabilities */
        long soap_type() const { return SOAP_TYPE___f2i_plu__wfs_x002egetCapabilities; }
        /** Constructor with member initializations */
        __f2i_plu__wfs_x002egetCapabilities() : ows__GetCapabilities() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __f2i_plu__wfs_x002egetCapabilities * SOAP_FMAC2 soap_instantiate___f2i_plu__wfs_x002egetCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:15905 */
#ifndef SOAP_TYPE___f2i_plu__wfs_x002egetFeatureWithLock
#define SOAP_TYPE___f2i_plu__wfs_x002egetFeatureWithLock (1210)
/* Wrapper: */
struct SOAP_CMAC __f2i_plu__wfs_x002egetFeatureWithLock {
      public:
        /** Optional element 'wfs:GetFeatureWithLock' of XML schema type 'wfs:GetFeatureWithLockType' */
        wfs__GetFeatureWithLockType *wfs__GetFeatureWithLock;
      public:
        /** Return unique type id SOAP_TYPE___f2i_plu__wfs_x002egetFeatureWithLock */
        long soap_type() const { return SOAP_TYPE___f2i_plu__wfs_x002egetFeatureWithLock; }
        /** Constructor with member initializations */
        __f2i_plu__wfs_x002egetFeatureWithLock() : wfs__GetFeatureWithLock() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __f2i_plu__wfs_x002egetFeatureWithLock * SOAP_FMAC2 soap_instantiate___f2i_plu__wfs_x002egetFeatureWithLock(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:15972 */
#ifndef SOAP_TYPE___f2i_plu__wfs_x002egetPropertyValue
#define SOAP_TYPE___f2i_plu__wfs_x002egetPropertyValue (1214)
/* Wrapper: */
struct SOAP_CMAC __f2i_plu__wfs_x002egetPropertyValue {
      public:
        /** Optional element 'wfs:GetPropertyValue' of XML schema type 'wfs:GetPropertyValueType' */
        wfs__GetPropertyValueType *wfs__GetPropertyValue;
      public:
        /** Return unique type id SOAP_TYPE___f2i_plu__wfs_x002egetPropertyValue */
        long soap_type() const { return SOAP_TYPE___f2i_plu__wfs_x002egetPropertyValue; }
        /** Constructor with member initializations */
        __f2i_plu__wfs_x002egetPropertyValue() : wfs__GetPropertyValue() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __f2i_plu__wfs_x002egetPropertyValue * SOAP_FMAC2 soap_instantiate___f2i_plu__wfs_x002egetPropertyValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:16039 */
#ifndef SOAP_TYPE___f2i_plu__wfs_x002elockFeature
#define SOAP_TYPE___f2i_plu__wfs_x002elockFeature (1218)
/* Wrapper: */
struct SOAP_CMAC __f2i_plu__wfs_x002elockFeature {
      public:
        /** Optional element 'wfs:LockFeature' of XML schema type 'wfs:LockFeatureType' */
        wfs__LockFeatureType *wfs__LockFeature;
      public:
        /** Return unique type id SOAP_TYPE___f2i_plu__wfs_x002elockFeature */
        long soap_type() const { return SOAP_TYPE___f2i_plu__wfs_x002elockFeature; }
        /** Constructor with member initializations */
        __f2i_plu__wfs_x002elockFeature() : wfs__LockFeature() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __f2i_plu__wfs_x002elockFeature * SOAP_FMAC2 soap_instantiate___f2i_plu__wfs_x002elockFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:16106 */
#ifndef SOAP_TYPE___f2i_plu__wfs_x002etransaction
#define SOAP_TYPE___f2i_plu__wfs_x002etransaction (1222)
/* Wrapper: */
struct SOAP_CMAC __f2i_plu__wfs_x002etransaction {
      public:
        /** Optional element 'wfs:Transaction' of XML schema type 'wfs:TransactionType' */
        wfs__TransactionType *wfs__Transaction;
      public:
        /** Return unique type id SOAP_TYPE___f2i_plu__wfs_x002etransaction */
        long soap_type() const { return SOAP_TYPE___f2i_plu__wfs_x002etransaction; }
        /** Constructor with member initializations */
        __f2i_plu__wfs_x002etransaction() : wfs__Transaction() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __f2i_plu__wfs_x002etransaction * SOAP_FMAC2 soap_instantiate___f2i_plu__wfs_x002etransaction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ws-inspire-wfs2.h:18611 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (1223)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ws-inspire-wfs2.h:18611 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (1224)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ws-inspire-wfs2.h:18611 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (1226)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ws-inspire-wfs2.h:18611 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (1227)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* xsd.h:53 */
#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (8)
typedef char *_xml__lang;
#endif

/* xsd.h:55 */
#ifndef SOAP_TYPE__xsd__schema
#define SOAP_TYPE__xsd__schema (9)
typedef char *_xsd__schema;
#endif

/* xsd.h:62 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (12)
typedef char *xsd__anyURI;
#endif

/* xsd.h:77 */
#ifndef SOAP_TYPE_xsd__byte
#define SOAP_TYPE_xsd__byte (18)
typedef char xsd__byte;
#endif

/* xsd.h:78 */
#ifndef SOAP_TYPE_xsd__date
#define SOAP_TYPE_xsd__date (19)
typedef char *xsd__date;
#endif

/* xsd.h:79 */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (21)
typedef double xsd__decimal;
#endif

/* xsd.h:80 */
#ifndef SOAP_TYPE_xsd__double
#define SOAP_TYPE_xsd__double (22)
typedef double xsd__double;
#endif

/* xsd.h:81 */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (23)
typedef char *xsd__duration;
#endif

/* xsd.h:82 */
#ifndef SOAP_TYPE_xsd__float
#define SOAP_TYPE_xsd__float (25)
typedef float xsd__float;
#endif

/* xsd.h:83 */
#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (26)
typedef char *xsd__ID;
#endif

/* xsd.h:84 */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (28)
typedef LONG64 xsd__integer;
#endif

/* xsd.h:85 */
#ifndef SOAP_TYPE_xsd__language
#define SOAP_TYPE_xsd__language (29)
typedef char *xsd__language;
#endif

/* xsd.h:86 */
#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (30)
typedef LONG64 xsd__long;
#endif

/* xsd.h:87 */
#ifndef SOAP_TYPE_xsd__Name
#define SOAP_TYPE_xsd__Name (31)
typedef char *xsd__Name;
#endif

/* xsd.h:88 */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (32)
typedef char *xsd__NCName;
#endif

/* xsd.h:89 */
#ifndef SOAP_TYPE_xsd__NMTOKEN
#define SOAP_TYPE_xsd__NMTOKEN (33)
typedef char *xsd__NMTOKEN;
#endif

/* xsd.h:90 */
#ifndef SOAP_TYPE_xsd__negativeInteger
#define SOAP_TYPE_xsd__negativeInteger (34)
typedef LONG64 xsd__negativeInteger;
#endif

/* xsd.h:91 */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (36)
typedef ULONG64 xsd__nonNegativeInteger;
#endif

/* xsd.h:92 */
#ifndef SOAP_TYPE_xsd__nonPositiveInteger
#define SOAP_TYPE_xsd__nonPositiveInteger (37)
typedef LONG64 xsd__nonPositiveInteger;
#endif

/* xsd.h:93 */
#ifndef SOAP_TYPE_xsd__normalizedString
#define SOAP_TYPE_xsd__normalizedString (38)
typedef char *xsd__normalizedString;
#endif

/* xsd.h:94 */
#ifndef SOAP_TYPE_xsd__positiveInteger
#define SOAP_TYPE_xsd__positiveInteger (39)
typedef ULONG64 xsd__positiveInteger;
#endif

/* xsd.h:95 */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (40)
typedef char *xsd__QName;
#endif

/* xsd.h:96 */
#ifndef SOAP_TYPE_xsd__time
#define SOAP_TYPE_xsd__time (41)
typedef char *xsd__time;
#endif

/* xsd.h:97 */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (42)
typedef char *xsd__token;
#endif

/* xsd.h:98 */
#ifndef SOAP_TYPE_xsd__short
#define SOAP_TYPE_xsd__short (44)
typedef short xsd__short;
#endif

/* xsd.h:99 */
#ifndef SOAP_TYPE_xsd__unsignedByte
#define SOAP_TYPE_xsd__unsignedByte (45)
typedef unsigned char xsd__unsignedByte;
#endif

/* xsd.h:100 */
#ifndef SOAP_TYPE_xsd__unsignedInt
#define SOAP_TYPE_xsd__unsignedInt (46)
typedef unsigned int xsd__unsignedInt;
#endif

/* xsd.h:101 */
#ifndef SOAP_TYPE_xsd__unsignedLong
#define SOAP_TYPE_xsd__unsignedLong (47)
typedef ULONG64 xsd__unsignedLong;
#endif

/* xsd.h:102 */
#ifndef SOAP_TYPE_xsd__unsignedShort
#define SOAP_TYPE_xsd__unsignedShort (49)
typedef unsigned short xsd__unsignedShort;
#endif

/* xsd.h:104 */
#ifndef SOAP_TYPE__SOAP_ENC__actor
#define SOAP_TYPE__SOAP_ENC__actor (50)
typedef char *_SOAP_ENC__actor;
#endif

/* xsd.h:105 */
#ifndef SOAP_TYPE__SOAP_ENC__mustUnderstand
#define SOAP_TYPE__SOAP_ENC__mustUnderstand (51)
typedef int _SOAP_ENC__mustUnderstand;
#endif

/* ws-inspire-wfs2.h:480 */
#ifndef SOAP_TYPE__ows__Resource
#define SOAP_TYPE__ows__Resource (149)
typedef _XML _ows__Resource;
#endif

/* ws-inspire-wfs2.h:859 */
#ifndef SOAP_TYPE_wfs__positiveIntegerWithStar
#define SOAP_TYPE_wfs__positiveIntegerWithStar (335)
typedef std::string wfs__positiveIntegerWithStar;
#endif

/* ws-inspire-wfs2.h:863 */
#ifndef SOAP_TYPE_wfs__nonNegativeIntegerOrUnknown
#define SOAP_TYPE_wfs__nonNegativeIntegerOrUnknown (336)
typedef std::string wfs__nonNegativeIntegerOrUnknown;
#endif

/* ws-inspire-wfs2.h:867 */
#ifndef SOAP_TYPE_wfs__StateValueType
#define SOAP_TYPE_wfs__StateValueType (337)
typedef std::string wfs__StateValueType;
#endif

/* ws-inspire-wfs2.h:871 */
#ifndef SOAP_TYPE_wfs__ReturnFeatureTypesListType
#define SOAP_TYPE_wfs__ReturnFeatureTypesListType (338)
typedef xsd__QName wfs__ReturnFeatureTypesListType;
#endif

/* ws-inspire-wfs2.h:901 */
#ifndef SOAP_TYPE_ows__PositionType
#define SOAP_TYPE_ows__PositionType (339)
typedef std::string ows__PositionType;
#endif

/* ws-inspire-wfs2.h:929 */
#ifndef SOAP_TYPE_fes__TypeNamesListType
#define SOAP_TYPE_fes__TypeNamesListType (340)
typedef std::string fes__TypeNamesListType;
#endif

/* ws-inspire-wfs2.h:932 */
#ifndef SOAP_TYPE_fes__TypeNamesType
#define SOAP_TYPE_fes__TypeNamesType (341)
typedef std::string fes__TypeNamesType;
#endif

/* ws-inspire-wfs2.h:936 */
#ifndef SOAP_TYPE_fes__AliasesType
#define SOAP_TYPE_fes__AliasesType (342)
typedef std::string fes__AliasesType;
#endif

/* ws-inspire-wfs2.h:939 */
#ifndef SOAP_TYPE_fes__VersionType
#define SOAP_TYPE_fes__VersionType (343)
typedef std::string fes__VersionType;
#endif

/* ws-inspire-wfs2.h:942 */
#ifndef SOAP_TYPE_fes__UomIdentifier
#define SOAP_TYPE_fes__UomIdentifier (344)
typedef std::string fes__UomIdentifier;
#endif

/* ws-inspire-wfs2.h:946 */
#ifndef SOAP_TYPE_fes__ComparisonOperatorNameType
#define SOAP_TYPE_fes__ComparisonOperatorNameType (345)
typedef std::string fes__ComparisonOperatorNameType;
#endif

/* ws-inspire-wfs2.h:950 */
#ifndef SOAP_TYPE_fes__SpatialOperatorNameType
#define SOAP_TYPE_fes__SpatialOperatorNameType (346)
typedef std::string fes__SpatialOperatorNameType;
#endif

/* ws-inspire-wfs2.h:954 */
#ifndef SOAP_TYPE_fes__TemporalOperatorNameType
#define SOAP_TYPE_fes__TemporalOperatorNameType (347)
typedef std::string fes__TemporalOperatorNameType;
#endif

/* ws-inspire-wfs2.h:967 */
#ifndef SOAP_TYPE_wfs__VersionStringType
#define SOAP_TYPE_wfs__VersionStringType (348)
typedef std::string wfs__VersionStringType;
#endif

/* ws-inspire-wfs2.h:1088 */
#ifndef SOAP_TYPE_ows__MimeType
#define SOAP_TYPE_ows__MimeType (360)
typedef std::string ows__MimeType;
#endif

/* ws-inspire-wfs2.h:1105 */
#ifndef SOAP_TYPE_ows__VersionType
#define SOAP_TYPE_ows__VersionType (362)
typedef std::string ows__VersionType;
#endif

/* ws-inspire-wfs2.h:1117 */
#ifndef SOAP_TYPE_ows__PositionType2D
#define SOAP_TYPE_ows__PositionType2D (364)
typedef ows__PositionType ows__PositionType2D;
#endif

/* ws-inspire-wfs2.h:1125 */
#ifndef SOAP_TYPE_ows__ServiceType
#define SOAP_TYPE_ows__ServiceType (365)
typedef std::string ows__ServiceType;
#endif

/* ws-inspire-wfs2.h:1141 */
#ifndef SOAP_TYPE_ows__UpdateSequenceType
#define SOAP_TYPE_ows__UpdateSequenceType (367)
typedef std::string ows__UpdateSequenceType;
#endif

/* ws-inspire-wfs2.h:1221 */
#ifndef SOAP_TYPE_xlink__hrefType
#define SOAP_TYPE_xlink__hrefType (372)
typedef xsd__anyURI xlink__hrefType;
#endif

/* ws-inspire-wfs2.h:1234 */
#ifndef SOAP_TYPE_xlink__roleType
#define SOAP_TYPE_xlink__roleType (374)
typedef char *xlink__roleType;
#endif

/* ws-inspire-wfs2.h:1247 */
#ifndef SOAP_TYPE_xlink__arcroleType
#define SOAP_TYPE_xlink__arcroleType (376)
typedef char *xlink__arcroleType;
#endif

/* ws-inspire-wfs2.h:1259 */
#ifndef SOAP_TYPE_xlink__titleAttrType
#define SOAP_TYPE_xlink__titleAttrType (378)
typedef std::string xlink__titleAttrType;
#endif

/* ws-inspire-wfs2.h:1310 */
#ifndef SOAP_TYPE_xlink__labelType
#define SOAP_TYPE_xlink__labelType (384)
typedef xsd__NCName xlink__labelType;
#endif

/* ws-inspire-wfs2.h:1322 */
#ifndef SOAP_TYPE_xlink__fromType
#define SOAP_TYPE_xlink__fromType (386)
typedef xsd__NCName xlink__fromType;
#endif

/* ws-inspire-wfs2.h:1334 */
#ifndef SOAP_TYPE_xlink__toType
#define SOAP_TYPE_xlink__toType (388)
typedef xsd__NCName xlink__toType;
#endif

/* ws-inspire-wfs2.h:1355 */
#ifndef SOAP_TYPE_fes__SchemaElement
#define SOAP_TYPE_fes__SchemaElement (390)
typedef std::string fes__SchemaElement;
#endif

/* ws-inspire-wfs2.h:1406 */
#ifndef SOAP_TYPE_fes__UomSymbol
#define SOAP_TYPE_fes__UomSymbol (396)
typedef std::string fes__UomSymbol;
#endif

/* ws-inspire-wfs2.h:1419 */
#ifndef SOAP_TYPE_fes__UomURI
#define SOAP_TYPE_fes__UomURI (398)
typedef char *fes__UomURI;
#endif

/* ws-inspire-wfs2.h:1491 */
#ifndef SOAP_TYPE_icommon__notEmptyString
#define SOAP_TYPE_icommon__notEmptyString (404)
typedef std::string icommon__notEmptyString;
#endif

/* ws-inspire-wfs2.h:1591 */
#ifndef SOAP_TYPE_icommon__emailType
#define SOAP_TYPE_icommon__emailType (408)
typedef std::string icommon__emailType;
#endif

/* ws-inspire-wfs2.h:1608 */
#ifndef SOAP_TYPE_icommon__iso8601Date
#define SOAP_TYPE_icommon__iso8601Date (410)
typedef std::string icommon__iso8601Date;
#endif

/* ws-inspire-wfs2.h:2177 */
#ifndef SOAP_TYPE_icommon__languageIETF
#define SOAP_TYPE_icommon__languageIETF (420)
typedef xsd__language icommon__languageIETF;
#endif

/* ws-inspire-wfs2.h:2264 */
#ifndef SOAP_TYPE_icommon__geoBoxDigits
#define SOAP_TYPE_icommon__geoBoxDigits (424)
typedef std::string icommon__geoBoxDigits;
#endif

/* ws-inspire-wfs2.h:2420 */
#ifndef SOAP_TYPE_icommon__keywordValue
#define SOAP_TYPE_icommon__keywordValue (438)
typedef icommon__notEmptyString icommon__keywordValue;
#endif

/* ws-inspire-wfs2.h:14610 */
#ifndef SOAP_TYPE__wfs__Query
#define SOAP_TYPE__wfs__Query (1038)
typedef wfs__QueryType _wfs__Query;
#endif

/* ws-inspire-wfs2.h:14613 */
#ifndef SOAP_TYPE__wfs__StoredQuery
#define SOAP_TYPE__wfs__StoredQuery (1039)
typedef wfs__StoredQueryType _wfs__StoredQuery;
#endif

/* ws-inspire-wfs2.h:14616 */
#ifndef SOAP_TYPE__wfs__GetCapabilities
#define SOAP_TYPE__wfs__GetCapabilities (1040)
typedef wfs__GetCapabilitiesType _wfs__GetCapabilities;
#endif

/* ws-inspire-wfs2.h:14619 */
#ifndef SOAP_TYPE__wfs__WFS_x005fCapabilities
#define SOAP_TYPE__wfs__WFS_x005fCapabilities (1041)
typedef wfs__WFS_x005fCapabilitiesType _wfs__WFS_x005fCapabilities;
#endif

/* ws-inspire-wfs2.h:14622 */
#ifndef SOAP_TYPE__wfs__FeatureTypeList
#define SOAP_TYPE__wfs__FeatureTypeList (1042)
typedef wfs__FeatureTypeListType _wfs__FeatureTypeList;
#endif

/* ws-inspire-wfs2.h:14625 */
#ifndef SOAP_TYPE__wfs__Element
#define SOAP_TYPE__wfs__Element (1043)
typedef wfs__ElementType _wfs__Element;
#endif

/* ws-inspire-wfs2.h:14628 */
#ifndef SOAP_TYPE__wfs__ValueList
#define SOAP_TYPE__wfs__ValueList (1044)
typedef wfs__ValueListType _wfs__ValueList;
#endif

/* ws-inspire-wfs2.h:14631 */
#ifndef SOAP_TYPE__wfs__Value
#define SOAP_TYPE__wfs__Value (1045)
typedef xsd__anyType _wfs__Value;
#endif

/* ws-inspire-wfs2.h:14634 */
#ifndef SOAP_TYPE__wfs__DescribeFeatureType
#define SOAP_TYPE__wfs__DescribeFeatureType (1046)
typedef wfs__DescribeFeatureTypeType _wfs__DescribeFeatureType;
#endif

/* ws-inspire-wfs2.h:14637 */
#ifndef SOAP_TYPE__wfs__GetPropertyValue
#define SOAP_TYPE__wfs__GetPropertyValue (1047)
typedef wfs__GetPropertyValueType _wfs__GetPropertyValue;
#endif

/* ws-inspire-wfs2.h:14640 */
#ifndef SOAP_TYPE__wfs__ValueCollection
#define SOAP_TYPE__wfs__ValueCollection (1048)
typedef wfs__ValueCollectionType _wfs__ValueCollection;
#endif

/* ws-inspire-wfs2.h:14643 */
#ifndef SOAP_TYPE__wfs__member
#define SOAP_TYPE__wfs__member (1049)
typedef wfs__MemberPropertyType _wfs__member;
#endif

/* ws-inspire-wfs2.h:14646 */
#ifndef SOAP_TYPE__wfs__Tuple
#define SOAP_TYPE__wfs__Tuple (1050)
typedef wfs__TupleType _wfs__Tuple;
#endif

/* ws-inspire-wfs2.h:14649 */
#ifndef SOAP_TYPE__wfs__GetFeature
#define SOAP_TYPE__wfs__GetFeature (1051)
typedef wfs__GetFeatureType _wfs__GetFeature;
#endif

/* ws-inspire-wfs2.h:14652 */
#ifndef SOAP_TYPE__wfs__GetFeatureWithLock
#define SOAP_TYPE__wfs__GetFeatureWithLock (1052)
typedef wfs__GetFeatureWithLockType _wfs__GetFeatureWithLock;
#endif

/* ws-inspire-wfs2.h:14655 */
#ifndef SOAP_TYPE__wfs__FeatureCollection
#define SOAP_TYPE__wfs__FeatureCollection (1053)
typedef wfs__FeatureCollectionType _wfs__FeatureCollection;
#endif

/* ws-inspire-wfs2.h:14658 */
#ifndef SOAP_TYPE__wfs__SimpleFeatureCollection
#define SOAP_TYPE__wfs__SimpleFeatureCollection (1054)
typedef wfs__SimpleFeatureCollectionType _wfs__SimpleFeatureCollection;
#endif

/* ws-inspire-wfs2.h:14661 */
#ifndef SOAP_TYPE__wfs__boundedBy
#define SOAP_TYPE__wfs__boundedBy (1055)
typedef wfs__EnvelopePropertyType _wfs__boundedBy;
#endif

/* ws-inspire-wfs2.h:14664 */
#ifndef SOAP_TYPE__wfs__ListStoredQueries
#define SOAP_TYPE__wfs__ListStoredQueries (1056)
typedef wfs__ListStoredQueriesType _wfs__ListStoredQueries;
#endif

/* ws-inspire-wfs2.h:14667 */
#ifndef SOAP_TYPE__wfs__ListStoredQueriesResponse
#define SOAP_TYPE__wfs__ListStoredQueriesResponse (1057)
typedef wfs__ListStoredQueriesResponseType _wfs__ListStoredQueriesResponse;
#endif

/* ws-inspire-wfs2.h:14670 */
#ifndef SOAP_TYPE__wfs__DescribeStoredQueries
#define SOAP_TYPE__wfs__DescribeStoredQueries (1058)
typedef wfs__DescribeStoredQueriesType _wfs__DescribeStoredQueries;
#endif

/* ws-inspire-wfs2.h:14673 */
#ifndef SOAP_TYPE__wfs__DescribeStoredQueriesResponse
#define SOAP_TYPE__wfs__DescribeStoredQueriesResponse (1059)
typedef wfs__DescribeStoredQueriesResponseType _wfs__DescribeStoredQueriesResponse;
#endif

/* ws-inspire-wfs2.h:14676 */
#ifndef SOAP_TYPE__wfs__CreateStoredQuery
#define SOAP_TYPE__wfs__CreateStoredQuery (1060)
typedef wfs__CreateStoredQueryType _wfs__CreateStoredQuery;
#endif

/* ws-inspire-wfs2.h:14679 */
#ifndef SOAP_TYPE__wfs__CreateStoredQueryResponse
#define SOAP_TYPE__wfs__CreateStoredQueryResponse (1061)
typedef wfs__CreateStoredQueryResponseType _wfs__CreateStoredQueryResponse;
#endif

/* ws-inspire-wfs2.h:14682 */
#ifndef SOAP_TYPE__wfs__DropStoredQueryResponse
#define SOAP_TYPE__wfs__DropStoredQueryResponse (1062)
typedef wfs__ExecutionStatusType _wfs__DropStoredQueryResponse;
#endif

/* ws-inspire-wfs2.h:14685 */
#ifndef SOAP_TYPE__wfs__LockFeature
#define SOAP_TYPE__wfs__LockFeature (1063)
typedef wfs__LockFeatureType _wfs__LockFeature;
#endif

/* ws-inspire-wfs2.h:14688 */
#ifndef SOAP_TYPE__wfs__LockFeatureResponse
#define SOAP_TYPE__wfs__LockFeatureResponse (1064)
typedef wfs__LockFeatureResponseType _wfs__LockFeatureResponse;
#endif

/* ws-inspire-wfs2.h:14691 */
#ifndef SOAP_TYPE__wfs__Transaction
#define SOAP_TYPE__wfs__Transaction (1065)
typedef wfs__TransactionType _wfs__Transaction;
#endif

/* ws-inspire-wfs2.h:14694 */
#ifndef SOAP_TYPE__wfs__Insert
#define SOAP_TYPE__wfs__Insert (1066)
typedef wfs__InsertType _wfs__Insert;
#endif

/* ws-inspire-wfs2.h:14697 */
#ifndef SOAP_TYPE__wfs__Update
#define SOAP_TYPE__wfs__Update (1067)
typedef wfs__UpdateType _wfs__Update;
#endif

/* ws-inspire-wfs2.h:14700 */
#ifndef SOAP_TYPE__wfs__Property
#define SOAP_TYPE__wfs__Property (1068)
typedef wfs__PropertyType _wfs__Property;
#endif

/* ws-inspire-wfs2.h:14703 */
#ifndef SOAP_TYPE__wfs__Replace
#define SOAP_TYPE__wfs__Replace (1069)
typedef wfs__ReplaceType _wfs__Replace;
#endif

/* ws-inspire-wfs2.h:14706 */
#ifndef SOAP_TYPE__wfs__Delete
#define SOAP_TYPE__wfs__Delete (1070)
typedef wfs__DeleteType _wfs__Delete;
#endif

/* ws-inspire-wfs2.h:14709 */
#ifndef SOAP_TYPE__wfs__Native
#define SOAP_TYPE__wfs__Native (1071)
typedef wfs__NativeType _wfs__Native;
#endif

/* ws-inspire-wfs2.h:14712 */
#ifndef SOAP_TYPE__wfs__TransactionResponse
#define SOAP_TYPE__wfs__TransactionResponse (1072)
typedef wfs__TransactionResponseType _wfs__TransactionResponse;
#endif

/* ws-inspire-wfs2.h:14731 */
#ifndef SOAP_TYPE__util__DescribeFeatureTypeResponse
#define SOAP_TYPE__util__DescribeFeatureTypeResponse (1073)
typedef util__DescribeFeatureTypeResponseType _util__DescribeFeatureTypeResponse;
#endif

/* ws-inspire-wfs2.h:14750 */
#ifndef SOAP_TYPE__ows__Exception
#define SOAP_TYPE__ows__Exception (1074)
typedef ows__ExceptionType _ows__Exception;
#endif

/* ws-inspire-wfs2.h:14753 */
#ifndef SOAP_TYPE__ows__GetResourceByID
#define SOAP_TYPE__ows__GetResourceByID (1075)
typedef ows__GetResourceByIdType _ows__GetResourceByID;
#endif

/* ws-inspire-wfs2.h:14760 */
#ifndef SOAP_TYPE__ows__Identifier
#define SOAP_TYPE__ows__Identifier (1076)
typedef ows__CodeType _ows__Identifier;
#endif

/* ws-inspire-wfs2.h:14767 */
#ifndef SOAP_TYPE__ows__OutputFormat
#define SOAP_TYPE__ows__OutputFormat (1077)
typedef ows__MimeType _ows__OutputFormat;
#endif

/* ws-inspire-wfs2.h:14770 */
#ifndef SOAP_TYPE__ows__AvailableCRS
#define SOAP_TYPE__ows__AvailableCRS (1078)
typedef xsd__anyURI _ows__AvailableCRS;
#endif

/* ws-inspire-wfs2.h:14777 */
#ifndef SOAP_TYPE__ows__SupportedCRS
#define SOAP_TYPE__ows__SupportedCRS (1079)
typedef xsd__anyURI _ows__SupportedCRS;
#endif

/* ws-inspire-wfs2.h:14784 */
#ifndef SOAP_TYPE__ows__AccessConstraints
#define SOAP_TYPE__ows__AccessConstraints (1080)
typedef std::string _ows__AccessConstraints;
#endif

/* ws-inspire-wfs2.h:14791 */
#ifndef SOAP_TYPE__ows__Fees
#define SOAP_TYPE__ows__Fees (1081)
typedef std::string _ows__Fees;
#endif

/* ws-inspire-wfs2.h:14798 */
#ifndef SOAP_TYPE__ows__Language
#define SOAP_TYPE__ows__Language (1082)
typedef xsd__language _ows__Language;
#endif

/* ws-inspire-wfs2.h:14801 */
#ifndef SOAP_TYPE__ows__Metadata
#define SOAP_TYPE__ows__Metadata (1083)
typedef ows__MetadataType _ows__Metadata;
#endif

/* ws-inspire-wfs2.h:14804 */
#ifndef SOAP_TYPE__ows__BoundingBox
#define SOAP_TYPE__ows__BoundingBox (1084)
typedef ows__BoundingBoxType _ows__BoundingBox;
#endif

/* ws-inspire-wfs2.h:14807 */
#ifndef SOAP_TYPE__ows__WGS84BoundingBox
#define SOAP_TYPE__ows__WGS84BoundingBox (1085)
typedef ows__WGS84BoundingBoxType _ows__WGS84BoundingBox;
#endif

/* ws-inspire-wfs2.h:14814 */
#ifndef SOAP_TYPE__ows__Title
#define SOAP_TYPE__ows__Title (1086)
typedef ows__LanguageStringType _ows__Title;
#endif

/* ws-inspire-wfs2.h:14821 */
#ifndef SOAP_TYPE__ows__Abstract
#define SOAP_TYPE__ows__Abstract (1087)
typedef ows__LanguageStringType _ows__Abstract;
#endif

/* ws-inspire-wfs2.h:14824 */
#ifndef SOAP_TYPE__ows__Keywords
#define SOAP_TYPE__ows__Keywords (1088)
typedef ows__KeywordsType _ows__Keywords;
#endif

/* ws-inspire-wfs2.h:14835 */
#ifndef SOAP_TYPE__ows__PointOfContact
#define SOAP_TYPE__ows__PointOfContact (1089)
typedef ows__ResponsiblePartyType _ows__PointOfContact;
#endif

/* ws-inspire-wfs2.h:14842 */
#ifndef SOAP_TYPE__ows__IndividualName
#define SOAP_TYPE__ows__IndividualName (1090)
typedef std::string _ows__IndividualName;
#endif

/* ws-inspire-wfs2.h:14849 */
#ifndef SOAP_TYPE__ows__OrganisationName
#define SOAP_TYPE__ows__OrganisationName (1091)
typedef std::string _ows__OrganisationName;
#endif

/* ws-inspire-wfs2.h:14856 */
#ifndef SOAP_TYPE__ows__PositionName
#define SOAP_TYPE__ows__PositionName (1092)
typedef std::string _ows__PositionName;
#endif

/* ws-inspire-wfs2.h:14863 */
#ifndef SOAP_TYPE__ows__Role
#define SOAP_TYPE__ows__Role (1093)
typedef ows__CodeType _ows__Role;
#endif

/* ws-inspire-wfs2.h:14870 */
#ifndef SOAP_TYPE__ows__ContactInfo
#define SOAP_TYPE__ows__ContactInfo (1094)
typedef ows__ContactType _ows__ContactInfo;
#endif

/* ws-inspire-wfs2.h:14873 */
#ifndef SOAP_TYPE__ows__GetCapabilities
#define SOAP_TYPE__ows__GetCapabilities (1095)
typedef ows__GetCapabilitiesType _ows__GetCapabilities;
#endif

/* ws-inspire-wfs2.h:14880 */
#ifndef SOAP_TYPE__ows__ExtendedCapabilities
#define SOAP_TYPE__ows__ExtendedCapabilities (1096)
typedef xsd__anyType _ows__ExtendedCapabilities;
#endif

/* ws-inspire-wfs2.h:14883 */
#ifndef SOAP_TYPE__ows__Value
#define SOAP_TYPE__ows__Value (1097)
typedef ows__ValueType _ows__Value;
#endif

/* ws-inspire-wfs2.h:14890 */
#ifndef SOAP_TYPE__ows__DefaultValue
#define SOAP_TYPE__ows__DefaultValue (1098)
typedef ows__ValueType _ows__DefaultValue;
#endif

/* ws-inspire-wfs2.h:14893 */
#ifndef SOAP_TYPE__ows__Range
#define SOAP_TYPE__ows__Range (1099)
typedef ows__RangeType _ows__Range;
#endif

/* ws-inspire-wfs2.h:14900 */
#ifndef SOAP_TYPE__ows__MinimumValue
#define SOAP_TYPE__ows__MinimumValue (1100)
typedef ows__ValueType _ows__MinimumValue;
#endif

/* ws-inspire-wfs2.h:14907 */
#ifndef SOAP_TYPE__ows__MaximumValue
#define SOAP_TYPE__ows__MaximumValue (1101)
typedef ows__ValueType _ows__MaximumValue;
#endif

/* ws-inspire-wfs2.h:14914 */
#ifndef SOAP_TYPE__ows__Spacing
#define SOAP_TYPE__ows__Spacing (1102)
typedef ows__ValueType _ows__Spacing;
#endif

/* ws-inspire-wfs2.h:14921 */
#ifndef SOAP_TYPE__ows__Meaning
#define SOAP_TYPE__ows__Meaning (1103)
typedef ows__DomainMetadataType _ows__Meaning;
#endif

/* ws-inspire-wfs2.h:14928 */
#ifndef SOAP_TYPE__ows__DataType
#define SOAP_TYPE__ows__DataType (1104)
typedef ows__DomainMetadataType _ows__DataType;
#endif

/* ws-inspire-wfs2.h:14935 */
#ifndef SOAP_TYPE__ows__ReferenceSystem
#define SOAP_TYPE__ows__ReferenceSystem (1105)
typedef ows__DomainMetadataType _ows__ReferenceSystem;
#endif

/* ws-inspire-wfs2.h:14942 */
#ifndef SOAP_TYPE__ows__UOM
#define SOAP_TYPE__ows__UOM (1106)
typedef ows__DomainMetadataType _ows__UOM;
#endif

/* ws-inspire-wfs2.h:14949 */
#ifndef SOAP_TYPE__ows__OtherSource
#define SOAP_TYPE__ows__OtherSource (1107)
typedef ows__MetadataType _ows__OtherSource;
#endif

/* ws-inspire-wfs2.h:14952 */
#ifndef SOAP_TYPE__ows__DatasetDescriptionSummary
#define SOAP_TYPE__ows__DatasetDescriptionSummary (1108)
typedef ows__DatasetDescriptionSummaryBaseType _ows__DatasetDescriptionSummary;
#endif

/* ws-inspire-wfs2.h:14963 */
#ifndef SOAP_TYPE__ows__OperationResponse
#define SOAP_TYPE__ows__OperationResponse (1109)
typedef ows__ManifestType _ows__OperationResponse;
#endif

/* ws-inspire-wfs2.h:14970 */
#ifndef SOAP_TYPE__ows__InputData
#define SOAP_TYPE__ows__InputData (1110)
typedef ows__ManifestType _ows__InputData;
#endif

/* ws-inspire-wfs2.h:14973 */
#ifndef SOAP_TYPE__ows__ServiceReference
#define SOAP_TYPE__ows__ServiceReference (1111)
typedef ows__ServiceReferenceType _ows__ServiceReference;
#endif

/* ws-inspire-wfs2.h:14976 */
#ifndef SOAP_TYPE__ows__Reference
#define SOAP_TYPE__ows__Reference (1112)
typedef ows__ReferenceType _ows__Reference;
#endif

/* ws-inspire-wfs2.h:14979 */
#ifndef SOAP_TYPE__ows__ReferenceGroup
#define SOAP_TYPE__ows__ReferenceGroup (1113)
typedef ows__ReferenceGroupType _ows__ReferenceGroup;
#endif

/* ws-inspire-wfs2.h:14982 */
#ifndef SOAP_TYPE__ows__Manifest
#define SOAP_TYPE__ows__Manifest (1114)
typedef ows__ManifestType _ows__Manifest;
#endif

/* ws-inspire-wfs2.h:14997 */
#ifndef SOAP_TYPE__ows__reference
#define SOAP_TYPE__ows__reference (1115)
typedef xsd__anyURI _ows__reference;
#endif

/* ws-inspire-wfs2.h:15008 */
#ifndef SOAP_TYPE__idls__ExtendedCapabilities
#define SOAP_TYPE__idls__ExtendedCapabilities (1116)
typedef idls__ExtendedCapabilitiesType _idls__ExtendedCapabilities;
#endif

/* ws-inspire-wfs2.h:15011 */
#ifndef SOAP_TYPE__idls__spatial_x005fdataset_x005fidentifier_x005fcode
#define SOAP_TYPE__idls__spatial_x005fdataset_x005fidentifier_x005fcode (1117)
typedef icommon__notEmptyString _idls__spatial_x005fdataset_x005fidentifier_x005fcode;
#endif

/* ws-inspire-wfs2.h:15014 */
#ifndef SOAP_TYPE__idls__spatial_x005fdataset_x005fidentifier_x005fnamespace
#define SOAP_TYPE__idls__spatial_x005fdataset_x005fidentifier_x005fnamespace (1118)
typedef xsd__anyURI _idls__spatial_x005fdataset_x005fidentifier_x005fnamespace;
#endif

/* ws-inspire-wfs2.h:15029 */
#ifndef SOAP_TYPE__idls__crs
#define SOAP_TYPE__idls__crs (1119)
typedef xsd__anyURI _idls__crs;
#endif

/* ws-inspire-wfs2.h:15076 */
#ifndef SOAP_TYPE__fes__Filter
#define SOAP_TYPE__fes__Filter (1120)
typedef fes__FilterType _fes__Filter;
#endif

/* ws-inspire-wfs2.h:15079 */
#ifndef SOAP_TYPE__fes__PropertyIsEqualTo
#define SOAP_TYPE__fes__PropertyIsEqualTo (1121)
typedef fes__BinaryComparisonOpType _fes__PropertyIsEqualTo;
#endif

/* ws-inspire-wfs2.h:15082 */
#ifndef SOAP_TYPE__fes__PropertyIsNotEqualTo
#define SOAP_TYPE__fes__PropertyIsNotEqualTo (1122)
typedef fes__BinaryComparisonOpType _fes__PropertyIsNotEqualTo;
#endif

/* ws-inspire-wfs2.h:15085 */
#ifndef SOAP_TYPE__fes__PropertyIsLessThan
#define SOAP_TYPE__fes__PropertyIsLessThan (1123)
typedef fes__BinaryComparisonOpType _fes__PropertyIsLessThan;
#endif

/* ws-inspire-wfs2.h:15088 */
#ifndef SOAP_TYPE__fes__PropertyIsGreaterThan
#define SOAP_TYPE__fes__PropertyIsGreaterThan (1124)
typedef fes__BinaryComparisonOpType _fes__PropertyIsGreaterThan;
#endif

/* ws-inspire-wfs2.h:15091 */
#ifndef SOAP_TYPE__fes__PropertyIsLessThanOrEqualTo
#define SOAP_TYPE__fes__PropertyIsLessThanOrEqualTo (1125)
typedef fes__BinaryComparisonOpType _fes__PropertyIsLessThanOrEqualTo;
#endif

/* ws-inspire-wfs2.h:15094 */
#ifndef SOAP_TYPE__fes__PropertyIsGreaterThanOrEqualTo
#define SOAP_TYPE__fes__PropertyIsGreaterThanOrEqualTo (1126)
typedef fes__BinaryComparisonOpType _fes__PropertyIsGreaterThanOrEqualTo;
#endif

/* ws-inspire-wfs2.h:15097 */
#ifndef SOAP_TYPE__fes__PropertyIsLike
#define SOAP_TYPE__fes__PropertyIsLike (1127)
typedef fes__PropertyIsLikeType _fes__PropertyIsLike;
#endif

/* ws-inspire-wfs2.h:15100 */
#ifndef SOAP_TYPE__fes__PropertyIsNull
#define SOAP_TYPE__fes__PropertyIsNull (1128)
typedef fes__PropertyIsNullType _fes__PropertyIsNull;
#endif

/* ws-inspire-wfs2.h:15103 */
#ifndef SOAP_TYPE__fes__PropertyIsNil
#define SOAP_TYPE__fes__PropertyIsNil (1129)
typedef fes__PropertyIsNilType _fes__PropertyIsNil;
#endif

/* ws-inspire-wfs2.h:15106 */
#ifndef SOAP_TYPE__fes__PropertyIsBetween
#define SOAP_TYPE__fes__PropertyIsBetween (1130)
typedef fes__PropertyIsBetweenType _fes__PropertyIsBetween;
#endif

/* ws-inspire-wfs2.h:15109 */
#ifndef SOAP_TYPE__fes__Equals
#define SOAP_TYPE__fes__Equals (1131)
typedef fes__BinarySpatialOpType _fes__Equals;
#endif

/* ws-inspire-wfs2.h:15112 */
#ifndef SOAP_TYPE__fes__Disjoint
#define SOAP_TYPE__fes__Disjoint (1132)
typedef fes__BinarySpatialOpType _fes__Disjoint;
#endif

/* ws-inspire-wfs2.h:15115 */
#ifndef SOAP_TYPE__fes__Touches
#define SOAP_TYPE__fes__Touches (1133)
typedef fes__BinarySpatialOpType _fes__Touches;
#endif

/* ws-inspire-wfs2.h:15118 */
#ifndef SOAP_TYPE__fes__Within
#define SOAP_TYPE__fes__Within (1134)
typedef fes__BinarySpatialOpType _fes__Within;
#endif

/* ws-inspire-wfs2.h:15121 */
#ifndef SOAP_TYPE__fes__Overlaps
#define SOAP_TYPE__fes__Overlaps (1135)
typedef fes__BinarySpatialOpType _fes__Overlaps;
#endif

/* ws-inspire-wfs2.h:15124 */
#ifndef SOAP_TYPE__fes__Crosses
#define SOAP_TYPE__fes__Crosses (1136)
typedef fes__BinarySpatialOpType _fes__Crosses;
#endif

/* ws-inspire-wfs2.h:15127 */
#ifndef SOAP_TYPE__fes__Intersects
#define SOAP_TYPE__fes__Intersects (1137)
typedef fes__BinarySpatialOpType _fes__Intersects;
#endif

/* ws-inspire-wfs2.h:15130 */
#ifndef SOAP_TYPE__fes__Contains
#define SOAP_TYPE__fes__Contains (1138)
typedef fes__BinarySpatialOpType _fes__Contains;
#endif

/* ws-inspire-wfs2.h:15133 */
#ifndef SOAP_TYPE__fes__DWithin
#define SOAP_TYPE__fes__DWithin (1139)
typedef fes__DistanceBufferType _fes__DWithin;
#endif

/* ws-inspire-wfs2.h:15136 */
#ifndef SOAP_TYPE__fes__Beyond
#define SOAP_TYPE__fes__Beyond (1140)
typedef fes__DistanceBufferType _fes__Beyond;
#endif

/* ws-inspire-wfs2.h:15139 */
#ifndef SOAP_TYPE__fes__BBOX
#define SOAP_TYPE__fes__BBOX (1141)
typedef fes__BBOXType _fes__BBOX;
#endif

/* ws-inspire-wfs2.h:15142 */
#ifndef SOAP_TYPE__fes__After
#define SOAP_TYPE__fes__After (1142)
typedef fes__BinaryTemporalOpType _fes__After;
#endif

/* ws-inspire-wfs2.h:15145 */
#ifndef SOAP_TYPE__fes__Before
#define SOAP_TYPE__fes__Before (1143)
typedef fes__BinaryTemporalOpType _fes__Before;
#endif

/* ws-inspire-wfs2.h:15148 */
#ifndef SOAP_TYPE__fes__Begins
#define SOAP_TYPE__fes__Begins (1144)
typedef fes__BinaryTemporalOpType _fes__Begins;
#endif

/* ws-inspire-wfs2.h:15151 */
#ifndef SOAP_TYPE__fes__BegunBy
#define SOAP_TYPE__fes__BegunBy (1145)
typedef fes__BinaryTemporalOpType _fes__BegunBy;
#endif

/* ws-inspire-wfs2.h:15154 */
#ifndef SOAP_TYPE__fes__TContains
#define SOAP_TYPE__fes__TContains (1146)
typedef fes__BinaryTemporalOpType _fes__TContains;
#endif

/* ws-inspire-wfs2.h:15157 */
#ifndef SOAP_TYPE__fes__During
#define SOAP_TYPE__fes__During (1147)
typedef fes__BinaryTemporalOpType _fes__During;
#endif

/* ws-inspire-wfs2.h:15160 */
#ifndef SOAP_TYPE__fes__EndedBy
#define SOAP_TYPE__fes__EndedBy (1148)
typedef fes__BinaryTemporalOpType _fes__EndedBy;
#endif

/* ws-inspire-wfs2.h:15163 */
#ifndef SOAP_TYPE__fes__Ends
#define SOAP_TYPE__fes__Ends (1149)
typedef fes__BinaryTemporalOpType _fes__Ends;
#endif

/* ws-inspire-wfs2.h:15166 */
#ifndef SOAP_TYPE__fes__TEquals
#define SOAP_TYPE__fes__TEquals (1150)
typedef fes__BinaryTemporalOpType _fes__TEquals;
#endif

/* ws-inspire-wfs2.h:15169 */
#ifndef SOAP_TYPE__fes__Meets
#define SOAP_TYPE__fes__Meets (1151)
typedef fes__BinaryTemporalOpType _fes__Meets;
#endif

/* ws-inspire-wfs2.h:15172 */
#ifndef SOAP_TYPE__fes__MetBy
#define SOAP_TYPE__fes__MetBy (1152)
typedef fes__BinaryTemporalOpType _fes__MetBy;
#endif

/* ws-inspire-wfs2.h:15175 */
#ifndef SOAP_TYPE__fes__TOverlaps
#define SOAP_TYPE__fes__TOverlaps (1153)
typedef fes__BinaryTemporalOpType _fes__TOverlaps;
#endif

/* ws-inspire-wfs2.h:15178 */
#ifndef SOAP_TYPE__fes__OverlappedBy
#define SOAP_TYPE__fes__OverlappedBy (1154)
typedef fes__BinaryTemporalOpType _fes__OverlappedBy;
#endif

/* ws-inspire-wfs2.h:15181 */
#ifndef SOAP_TYPE__fes__AnyInteracts
#define SOAP_TYPE__fes__AnyInteracts (1155)
typedef fes__BinaryTemporalOpType _fes__AnyInteracts;
#endif

/* ws-inspire-wfs2.h:15184 */
#ifndef SOAP_TYPE__fes__And
#define SOAP_TYPE__fes__And (1156)
typedef fes__BinaryLogicOpType _fes__And;
#endif

/* ws-inspire-wfs2.h:15187 */
#ifndef SOAP_TYPE__fes__Or
#define SOAP_TYPE__fes__Or (1157)
typedef fes__BinaryLogicOpType _fes__Or;
#endif

/* ws-inspire-wfs2.h:15190 */
#ifndef SOAP_TYPE__fes__Not
#define SOAP_TYPE__fes__Not (1158)
typedef fes__UnaryLogicOpType _fes__Not;
#endif

/* ws-inspire-wfs2.h:15193 */
#ifndef SOAP_TYPE__fes__ResourceId
#define SOAP_TYPE__fes__ResourceId (1159)
typedef fes__ResourceIdType _fes__ResourceId;
#endif

/* ws-inspire-wfs2.h:15196 */
#ifndef SOAP_TYPE__fes__ValueReference
#define SOAP_TYPE__fes__ValueReference (1160)
typedef std::string _fes__ValueReference;
#endif

/* ws-inspire-wfs2.h:15199 */
#ifndef SOAP_TYPE__fes__Function
#define SOAP_TYPE__fes__Function (1161)
typedef fes__FunctionType _fes__Function;
#endif

/* ws-inspire-wfs2.h:15202 */
#ifndef SOAP_TYPE__fes__Literal
#define SOAP_TYPE__fes__Literal (1162)
typedef fes__LiteralType _fes__Literal;
#endif

/* ws-inspire-wfs2.h:15205 */
#ifndef SOAP_TYPE__fes__SortBy
#define SOAP_TYPE__fes__SortBy (1163)
typedef fes__SortByType _fes__SortBy;
#endif

/* ws-inspire-wfs2.h:15224 */
#ifndef SOAP_TYPE__icommon__SpatialDataService
#define SOAP_TYPE__icommon__SpatialDataService (1164)
typedef icommon__service _icommon__SpatialDataService;
#endif

/* ws-inspire-wfs2.h:15227 */
#ifndef SOAP_TYPE__icommon__SpatialDataSet
#define SOAP_TYPE__icommon__SpatialDataSet (1165)
typedef icommon__dataset _icommon__SpatialDataSet;
#endif

/* ws-inspire-wfs2.h:15230 */
#ifndef SOAP_TYPE__icommon__SpatialDataSetSeries
#define SOAP_TYPE__icommon__SpatialDataSetSeries (1166)
typedef icommon__series _icommon__SpatialDataSetSeries;
#endif

/* ws-inspire-wfs2.h:15233 */
#ifndef SOAP_TYPE__icommon__SpatialDataServiceType
#define SOAP_TYPE__icommon__SpatialDataServiceType (1167)
typedef enum icommon__spatialDataServiceType _icommon__SpatialDataServiceType;
#endif

/* ws-inspire-wfs2.h:15236 */
#ifndef SOAP_TYPE__icommon__IndividualDate
#define SOAP_TYPE__icommon__IndividualDate (1168)
typedef icommon__iso8601Date _icommon__IndividualDate;
#endif

/* ws-inspire-wfs2.h:15239 */
#ifndef SOAP_TYPE__icommon__DiscoveryService
#define SOAP_TYPE__icommon__DiscoveryService (1169)
typedef icommon__discoveryService _icommon__DiscoveryService;
#endif

/* ws-inspire-wfs2.h:15242 */
#ifndef SOAP_TYPE__icommon__ViewService
#define SOAP_TYPE__icommon__ViewService (1170)
typedef icommon__viewService _icommon__ViewService;
#endif

/* ws-inspire-wfs2.h:15245 */
#ifndef SOAP_TYPE__icommon__DownloadService
#define SOAP_TYPE__icommon__DownloadService (1171)
typedef icommon__downloadService _icommon__DownloadService;
#endif

/* ws-inspire-wfs2.h:15248 */
#ifndef SOAP_TYPE__icommon__TransformationService
#define SOAP_TYPE__icommon__TransformationService (1172)
typedef icommon__transformationService _icommon__TransformationService;
#endif

/* ws-inspire-wfs2.h:15251 */
#ifndef SOAP_TYPE__icommon__InvokeService
#define SOAP_TYPE__icommon__InvokeService (1173)
typedef icommon__invokeService _icommon__InvokeService;
#endif

/* ws-inspire-wfs2.h:15254 */
#ifndef SOAP_TYPE__icommon__OtherService
#define SOAP_TYPE__icommon__OtherService (1174)
typedef icommon__otherService _icommon__OtherService;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* xsd__byte has binding name 'xsd__byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_xsd__byte
#define SOAP_TYPE_xsd__byte (18)
#endif

/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* xsd__short has binding name 'xsd__short' for type 'xsd:short' */
#ifndef SOAP_TYPE_xsd__short
#define SOAP_TYPE_xsd__short (44)
#endif

/* short has binding name 'short' for type 'xsd:short' */
#ifndef SOAP_TYPE_short
#define SOAP_TYPE_short (43)
#endif

/* _SOAP_ENC__mustUnderstand has binding name '_SOAP_ENC__mustUnderstand' for type '' */
#ifndef SOAP_TYPE__SOAP_ENC__mustUnderstand
#define SOAP_TYPE__SOAP_ENC__mustUnderstand (51)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* long has binding name 'long' for type 'xsd:long' */
#ifndef SOAP_TYPE_long
#define SOAP_TYPE_long (671)
#endif

/* xsd__nonPositiveInteger has binding name 'xsd__nonPositiveInteger' for type 'xsd:nonPositiveInteger' */
#ifndef SOAP_TYPE_xsd__nonPositiveInteger
#define SOAP_TYPE_xsd__nonPositiveInteger (37)
#endif

/* xsd__negativeInteger has binding name 'xsd__negativeInteger' for type 'xsd:negativeInteger' */
#ifndef SOAP_TYPE_xsd__negativeInteger
#define SOAP_TYPE_xsd__negativeInteger (34)
#endif

/* xsd__long has binding name 'xsd__long' for type 'xsd:long' */
#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (30)
#endif

/* xsd__integer has binding name 'xsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (28)
#endif

/* LONG64 has binding name 'LONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_LONG64
#define SOAP_TYPE_LONG64 (27)
#endif

/* xsd__float has binding name 'xsd__float' for type 'xsd:float' */
#ifndef SOAP_TYPE_xsd__float
#define SOAP_TYPE_xsd__float (25)
#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_float
#define SOAP_TYPE_float (24)
#endif

/* xsd__double has binding name 'xsd__double' for type 'xsd:double' */
#ifndef SOAP_TYPE_xsd__double
#define SOAP_TYPE_xsd__double (22)
#endif

/* xsd__decimal has binding name 'xsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (21)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (20)
#endif

/* xsd__unsignedByte has binding name 'xsd__unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_xsd__unsignedByte
#define SOAP_TYPE_xsd__unsignedByte (45)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (15)
#endif

/* xsd__unsignedShort has binding name 'xsd__unsignedShort' for type 'xsd:unsignedShort' */
#ifndef SOAP_TYPE_xsd__unsignedShort
#define SOAP_TYPE_xsd__unsignedShort (49)
#endif

/* unsigned short has binding name 'unsignedShort' for type 'xsd:unsignedShort' */
#ifndef SOAP_TYPE_unsignedShort
#define SOAP_TYPE_unsignedShort (48)
#endif

/* xsd__unsignedInt has binding name 'xsd__unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_xsd__unsignedInt
#define SOAP_TYPE_xsd__unsignedInt (46)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (14)
#endif

/* xsd__unsignedLong has binding name 'xsd__unsignedLong' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_xsd__unsignedLong
#define SOAP_TYPE_xsd__unsignedLong (47)
#endif

/* xsd__positiveInteger has binding name 'xsd__positiveInteger' for type 'xsd:positiveInteger' */
#ifndef SOAP_TYPE_xsd__positiveInteger
#define SOAP_TYPE_xsd__positiveInteger (39)
#endif

/* xsd__nonNegativeInteger has binding name 'xsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (36)
#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_ULONG64
#define SOAP_TYPE_ULONG64 (35)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (488)
#endif

/* _icommon__SpatialDataServiceType has binding name '_icommon__SpatialDataServiceType' for type '' */
#ifndef SOAP_TYPE__icommon__SpatialDataServiceType
#define SOAP_TYPE__icommon__SpatialDataServiceType (1167)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fswe_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fswe_URI' for type 'icommon:citationInspireInteroperabilityRegulation_swe-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fswe_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fswe_URI (1035)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fswe_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fswe_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_swe-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fswe_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fswe_DateOfPublication (1033)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fswe_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fswe_Title' for type 'icommon:citationInspireInteroperabilityRegulation_swe-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fswe_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fswe_Title (1031)
#endif

/* enum _icommon__inspireTheme_x005fswe_KeywordValue has binding name '_icommon__inspireTheme_x005fswe_KeywordValue' for type 'icommon:inspireTheme_swe-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fswe_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fswe_KeywordValue (1030)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fspa_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fspa_URI' for type 'icommon:citationInspireInteroperabilityRegulation_spa-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fspa_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fspa_URI (1028)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fspa_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fspa_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_spa-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fspa_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fspa_DateOfPublication (1026)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fspa_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fspa_Title' for type 'icommon:citationInspireInteroperabilityRegulation_spa-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fspa_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fspa_Title (1024)
#endif

/* enum _icommon__inspireTheme_x005fspa_KeywordValue has binding name '_icommon__inspireTheme_x005fspa_KeywordValue' for type 'icommon:inspireTheme_spa-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fspa_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fspa_KeywordValue (1023)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fslv_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fslv_URI' for type 'icommon:citationInspireInteroperabilityRegulation_slv-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslv_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslv_URI (1021)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fslv_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fslv_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_slv-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslv_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslv_DateOfPublication (1019)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fslv_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fslv_Title' for type 'icommon:citationInspireInteroperabilityRegulation_slv-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslv_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslv_Title (1017)
#endif

/* enum _icommon__inspireTheme_x005fslv_KeywordValue has binding name '_icommon__inspireTheme_x005fslv_KeywordValue' for type 'icommon:inspireTheme_slv-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fslv_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fslv_KeywordValue (1016)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fslo_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fslo_URI' for type 'icommon:citationInspireInteroperabilityRegulation_slo-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslo_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslo_URI (1014)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fslo_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fslo_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_slo-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslo_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslo_DateOfPublication (1012)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fslo_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fslo_Title' for type 'icommon:citationInspireInteroperabilityRegulation_slo-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslo_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fslo_Title (1010)
#endif

/* enum _icommon__inspireTheme_x005fslo_KeywordValue has binding name '_icommon__inspireTheme_x005fslo_KeywordValue' for type 'icommon:inspireTheme_slo-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fslo_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fslo_KeywordValue (1009)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005frum_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005frum_URI' for type 'icommon:citationInspireInteroperabilityRegulation_rum-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005frum_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005frum_URI (1007)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005frum_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005frum_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_rum-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005frum_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005frum_DateOfPublication (1005)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005frum_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005frum_Title' for type 'icommon:citationInspireInteroperabilityRegulation_rum-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005frum_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005frum_Title (1003)
#endif

/* enum _icommon__inspireTheme_x005frum_KeywordValue has binding name '_icommon__inspireTheme_x005frum_KeywordValue' for type 'icommon:inspireTheme_rum-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005frum_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005frum_KeywordValue (1002)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fpor_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fpor_URI' for type 'icommon:citationInspireInteroperabilityRegulation_por-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpor_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpor_URI (1000)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fpor_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fpor_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_por-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpor_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpor_DateOfPublication (998)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fpor_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fpor_Title' for type 'icommon:citationInspireInteroperabilityRegulation_por-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpor_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpor_Title (996)
#endif

/* enum _icommon__inspireTheme_x005fpor_KeywordValue has binding name '_icommon__inspireTheme_x005fpor_KeywordValue' for type 'icommon:inspireTheme_por-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fpor_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fpor_KeywordValue (995)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fpol_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fpol_URI' for type 'icommon:citationInspireInteroperabilityRegulation_pol-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpol_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpol_URI (993)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fpol_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fpol_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_pol-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpol_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpol_DateOfPublication (991)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fpol_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fpol_Title' for type 'icommon:citationInspireInteroperabilityRegulation_pol-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpol_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fpol_Title (989)
#endif

/* enum _icommon__inspireTheme_x005fpol_KeywordValue has binding name '_icommon__inspireTheme_x005fpol_KeywordValue' for type 'icommon:inspireTheme_pol-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fpol_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fpol_KeywordValue (988)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fmlt_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fmlt_URI' for type 'icommon:citationInspireInteroperabilityRegulation_mlt-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fmlt_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fmlt_URI (986)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fmlt_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fmlt_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_mlt-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fmlt_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fmlt_DateOfPublication (984)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fmlt_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fmlt_Title' for type 'icommon:citationInspireInteroperabilityRegulation_mlt-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fmlt_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fmlt_Title (982)
#endif

/* enum _icommon__inspireTheme_x005fmlt_KeywordValue has binding name '_icommon__inspireTheme_x005fmlt_KeywordValue' for type 'icommon:inspireTheme_mlt-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fmlt_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fmlt_KeywordValue (981)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005flit_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005flit_URI' for type 'icommon:citationInspireInteroperabilityRegulation_lit-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flit_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flit_URI (979)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005flit_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005flit_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_lit-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flit_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flit_DateOfPublication (977)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005flit_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005flit_Title' for type 'icommon:citationInspireInteroperabilityRegulation_lit-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flit_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flit_Title (975)
#endif

/* enum _icommon__inspireTheme_x005flit_KeywordValue has binding name '_icommon__inspireTheme_x005flit_KeywordValue' for type 'icommon:inspireTheme_lit-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005flit_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005flit_KeywordValue (974)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005flav_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005flav_URI' for type 'icommon:citationInspireInteroperabilityRegulation_lav-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flav_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flav_URI (972)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005flav_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005flav_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_lav-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flav_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flav_DateOfPublication (970)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005flav_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005flav_Title' for type 'icommon:citationInspireInteroperabilityRegulation_lav-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flav_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005flav_Title (968)
#endif

/* enum _icommon__inspireTheme_x005flav_KeywordValue has binding name '_icommon__inspireTheme_x005flav_KeywordValue' for type 'icommon:inspireTheme_lav-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005flav_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005flav_KeywordValue (967)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fita_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fita_URI' for type 'icommon:citationInspireInteroperabilityRegulation_ita-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fita_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fita_URI (965)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fita_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fita_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_ita-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fita_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fita_DateOfPublication (963)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fita_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fita_Title' for type 'icommon:citationInspireInteroperabilityRegulation_ita-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fita_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fita_Title (961)
#endif

/* enum _icommon__inspireTheme_x005fita_KeywordValue has binding name '_icommon__inspireTheme_x005fita_KeywordValue' for type 'icommon:inspireTheme_ita-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fita_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fita_KeywordValue (960)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fhun_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fhun_URI' for type 'icommon:citationInspireInteroperabilityRegulation_hun-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fhun_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fhun_URI (958)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fhun_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fhun_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_hun-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fhun_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fhun_DateOfPublication (956)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fhun_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fhun_Title' for type 'icommon:citationInspireInteroperabilityRegulation_hun-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fhun_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fhun_Title (954)
#endif

/* enum _icommon__inspireTheme_x005fhun_KeywordValue has binding name '_icommon__inspireTheme_x005fhun_KeywordValue' for type 'icommon:inspireTheme_hun-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fhun_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fhun_KeywordValue (953)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fgre_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fgre_URI' for type 'icommon:citationInspireInteroperabilityRegulation_gre-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgre_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgre_URI (951)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fgre_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fgre_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_gre-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgre_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgre_DateOfPublication (949)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fgre_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fgre_Title' for type 'icommon:citationInspireInteroperabilityRegulation_gre-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgre_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgre_Title (947)
#endif

/* enum _icommon__inspireTheme_x005fgre_KeywordValue has binding name '_icommon__inspireTheme_x005fgre_KeywordValue' for type 'icommon:inspireTheme_gre-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fgre_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fgre_KeywordValue (946)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fgle_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fgle_URI' for type 'icommon:citationInspireInteroperabilityRegulation_gle-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgle_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgle_URI (944)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fgle_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fgle_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_gle-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgle_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgle_DateOfPublication (942)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fgle_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fgle_Title' for type 'icommon:citationInspireInteroperabilityRegulation_gle-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgle_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fgle_Title (940)
#endif

/* enum _icommon__inspireTheme_x005fgle_KeywordValue has binding name '_icommon__inspireTheme_x005fgle_KeywordValue' for type 'icommon:inspireTheme_gle-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fgle_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fgle_KeywordValue (939)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fger_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fger_URI' for type 'icommon:citationInspireInteroperabilityRegulation_ger-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fger_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fger_URI (937)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fger_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fger_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_ger-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fger_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fger_DateOfPublication (935)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fger_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fger_Title' for type 'icommon:citationInspireInteroperabilityRegulation_ger-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fger_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fger_Title (933)
#endif

/* enum _icommon__inspireTheme_x005fger_KeywordValue has binding name '_icommon__inspireTheme_x005fger_KeywordValue' for type 'icommon:inspireTheme_ger-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fger_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fger_KeywordValue (932)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005ffre_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005ffre_URI' for type 'icommon:citationInspireInteroperabilityRegulation_fre-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffre_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffre_URI (930)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005ffre_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005ffre_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_fre-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffre_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffre_DateOfPublication (928)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005ffre_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005ffre_Title' for type 'icommon:citationInspireInteroperabilityRegulation_fre-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffre_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffre_Title (926)
#endif

/* enum _icommon__inspireTheme_x005ffre_KeywordValue has binding name '_icommon__inspireTheme_x005ffre_KeywordValue' for type 'icommon:inspireTheme_fre-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005ffre_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005ffre_KeywordValue (925)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005ffin_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005ffin_URI' for type 'icommon:citationInspireInteroperabilityRegulation_fin-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffin_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffin_URI (923)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005ffin_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005ffin_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_fin-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffin_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffin_DateOfPublication (921)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005ffin_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005ffin_Title' for type 'icommon:citationInspireInteroperabilityRegulation_fin-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffin_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005ffin_Title (919)
#endif

/* enum _icommon__inspireTheme_x005ffin_KeywordValue has binding name '_icommon__inspireTheme_x005ffin_KeywordValue' for type 'icommon:inspireTheme_fin-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005ffin_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005ffin_KeywordValue (918)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fest_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fest_URI' for type 'icommon:citationInspireInteroperabilityRegulation_est-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fest_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fest_URI (916)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fest_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fest_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_est-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fest_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fest_DateOfPublication (914)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fest_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fest_Title' for type 'icommon:citationInspireInteroperabilityRegulation_est-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fest_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fest_Title (912)
#endif

/* enum _icommon__inspireTheme_x005fest_KeywordValue has binding name '_icommon__inspireTheme_x005fest_KeywordValue' for type 'icommon:inspireTheme_est-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fest_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fest_KeywordValue (911)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005feng_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005feng_URI' for type 'icommon:citationInspireInteroperabilityRegulation_eng-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005feng_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005feng_URI (909)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005feng_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005feng_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_eng-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005feng_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005feng_DateOfPublication (907)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005feng_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005feng_Title' for type 'icommon:citationInspireInteroperabilityRegulation_eng-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005feng_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005feng_Title (905)
#endif

/* enum _icommon__inspireTheme_x005feng_KeywordValue has binding name '_icommon__inspireTheme_x005feng_KeywordValue' for type 'icommon:inspireTheme_eng-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005feng_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005feng_KeywordValue (904)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fdut_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fdut_URI' for type 'icommon:citationInspireInteroperabilityRegulation_dut-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdut_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdut_URI (902)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fdut_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fdut_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_dut-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdut_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdut_DateOfPublication (900)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fdut_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fdut_Title' for type 'icommon:citationInspireInteroperabilityRegulation_dut-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdut_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdut_Title (898)
#endif

/* enum _icommon__inspireTheme_x005fdut_KeywordValue has binding name '_icommon__inspireTheme_x005fdut_KeywordValue' for type 'icommon:inspireTheme_dut-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fdut_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fdut_KeywordValue (897)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fdan_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fdan_URI' for type 'icommon:citationInspireInteroperabilityRegulation_dan-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdan_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdan_URI (895)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fdan_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fdan_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_dan-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdan_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdan_DateOfPublication (893)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fdan_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fdan_Title' for type 'icommon:citationInspireInteroperabilityRegulation_dan-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdan_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fdan_Title (891)
#endif

/* enum _icommon__inspireTheme_x005fdan_KeywordValue has binding name '_icommon__inspireTheme_x005fdan_KeywordValue' for type 'icommon:inspireTheme_dan-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fdan_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fdan_KeywordValue (890)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fcze_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fcze_URI' for type 'icommon:citationInspireInteroperabilityRegulation_cze-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fcze_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fcze_URI (888)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fcze_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fcze_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_cze-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fcze_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fcze_DateOfPublication (886)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fcze_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fcze_Title' for type 'icommon:citationInspireInteroperabilityRegulation_cze-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fcze_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fcze_Title (884)
#endif

/* enum _icommon__inspireTheme_x005fcze_KeywordValue has binding name '_icommon__inspireTheme_x005fcze_KeywordValue' for type 'icommon:inspireTheme_cze-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fcze_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fcze_KeywordValue (883)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fbul_URI has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fbul_URI' for type 'icommon:citationInspireInteroperabilityRegulation_bul-URI' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fbul_URI
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fbul_URI (881)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fbul_DateOfPublication has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fbul_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_bul-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fbul_DateOfPublication
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fbul_DateOfPublication (879)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fbul_Title has binding name '_icommon__citationInspireInteroperabilityRegulation_x005fbul_Title' for type 'icommon:citationInspireInteroperabilityRegulation_bul-Title' */
#ifndef SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fbul_Title
#define SOAP_TYPE__icommon__citationInspireInteroperabilityRegulation_x005fbul_Title (877)
#endif

/* enum _icommon__inspireTheme_x005fbul_KeywordValue has binding name '_icommon__inspireTheme_x005fbul_KeywordValue' for type 'icommon:inspireTheme_bul-KeywordValue' */
#ifndef SOAP_TYPE__icommon__inspireTheme_x005fbul_KeywordValue
#define SOAP_TYPE__icommon__inspireTheme_x005fbul_KeywordValue (876)
#endif

/* enum _icommon__originatingControlledVocabularyMD_DateOfPublication has binding name '_icommon__originatingControlledVocabularyMD_DateOfPublication' for type 'icommon:originatingControlledVocabularyMD-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__originatingControlledVocabularyMD_DateOfPublication
#define SOAP_TYPE__icommon__originatingControlledVocabularyMD_DateOfPublication (874)
#endif

/* enum _icommon__originatingControlledVocabularyMD_Title has binding name '_icommon__originatingControlledVocabularyMD_Title' for type 'icommon:originatingControlledVocabularyMD-Title' */
#ifndef SOAP_TYPE__icommon__originatingControlledVocabularyMD_Title
#define SOAP_TYPE__icommon__originatingControlledVocabularyMD_Title (872)
#endif

/* enum _icommon__originatingControlledVocabularyGemetInspireThemes_DateOfPublication has binding name '_icommon__originatingControlledVocabularyGemetInspireThemes_DateOfPublication' for type 'icommon:originatingControlledVocabularyGemetInspireThemes-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__originatingControlledVocabularyGemetInspireThemes_DateOfPublication
#define SOAP_TYPE__icommon__originatingControlledVocabularyGemetInspireThemes_DateOfPublication (870)
#endif

/* enum _icommon__originatingControlledVocabularyGemetInspireThemes_Title has binding name '_icommon__originatingControlledVocabularyGemetInspireThemes_Title' for type 'icommon:originatingControlledVocabularyGemetInspireThemes-Title' */
#ifndef SOAP_TYPE__icommon__originatingControlledVocabularyGemetInspireThemes_Title
#define SOAP_TYPE__icommon__originatingControlledVocabularyGemetInspireThemes_Title (868)
#endif

/* enum _icommon__series_ResourceType has binding name '_icommon__series_ResourceType' for type 'icommon:series-ResourceType' */
#ifndef SOAP_TYPE__icommon__series_ResourceType
#define SOAP_TYPE__icommon__series_ResourceType (867)
#endif

/* enum _icommon__dataset_ResourceType has binding name '_icommon__dataset_ResourceType' for type 'icommon:dataset-ResourceType' */
#ifndef SOAP_TYPE__icommon__dataset_ResourceType
#define SOAP_TYPE__icommon__dataset_ResourceType (864)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fswe_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fswe_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_swe-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fswe_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fswe_MediaType (848)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fswe_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fswe_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_swe-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fswe_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fswe_URL (847)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fspa_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fspa_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_spa-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fspa_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fspa_MediaType (846)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fspa_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fspa_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_spa-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fspa_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fspa_URL (845)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fslv_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fslv_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_slv-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fslv_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fslv_MediaType (844)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fslv_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fslv_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_slv-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fslv_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fslv_URL (843)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fslo_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fslo_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_slo-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fslo_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fslo_MediaType (842)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fslo_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fslo_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_slo-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fslo_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fslo_URL (841)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005frum_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005frum_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_rum-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005frum_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005frum_MediaType (840)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005frum_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005frum_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_rum-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005frum_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005frum_URL (839)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fpor_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fpor_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_por-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fpor_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fpor_MediaType (838)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fpor_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fpor_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_por-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fpor_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fpor_URL (837)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fpol_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fpol_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_pol-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fpol_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fpol_MediaType (836)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fpol_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fpol_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_pol-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fpol_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fpol_URL (835)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fmlt_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fmlt_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_mlt-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fmlt_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fmlt_MediaType (834)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fmlt_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fmlt_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_mlt-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fmlt_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fmlt_URL (833)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005flit_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005flit_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_lit-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005flit_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005flit_MediaType (832)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005flit_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005flit_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_lit-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005flit_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005flit_URL (831)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005flav_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005flav_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_lav-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005flav_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005flav_MediaType (830)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005flav_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005flav_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_lav-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005flav_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005flav_URL (829)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fita_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fita_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_ita-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fita_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fita_MediaType (828)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fita_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fita_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_ita-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fita_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fita_URL (827)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fhun_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fhun_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_hun-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fhun_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fhun_MediaType (826)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fhun_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fhun_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_hun-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fhun_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fhun_URL (825)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fgre_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fgre_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_gre-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fgre_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fgre_MediaType (824)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fgre_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fgre_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_gre-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fgre_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fgre_URL (823)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fgle_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fgle_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_gle-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fgle_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fgle_MediaType (822)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fgle_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fgle_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_gle-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fgle_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fgle_URL (821)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fger_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fger_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_ger-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fger_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fger_MediaType (820)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fger_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fger_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_ger-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fger_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fger_URL (819)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005ffre_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005ffre_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_fre-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005ffre_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005ffre_MediaType (818)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005ffre_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005ffre_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_fre-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005ffre_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005ffre_URL (817)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005ffin_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005ffin_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_fin-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005ffin_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005ffin_MediaType (816)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005ffin_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005ffin_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_fin-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005ffin_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005ffin_URL (815)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fest_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fest_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_est-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fest_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fest_MediaType (814)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fest_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fest_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_est-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fest_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fest_URL (813)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005feng_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005feng_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_eng-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005feng_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005feng_MediaType (812)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005feng_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005feng_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_eng-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005feng_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005feng_URL (811)
#endif

/* enum _icommon__citationGEMETInspireThemes_x005feng_DateOfPublication has binding name '_icommon__citationGEMETInspireThemes_x005feng_DateOfPublication' for type 'icommon:citationGEMETInspireThemes_eng-DateOfPublication' */
#ifndef SOAP_TYPE__icommon__citationGEMETInspireThemes_x005feng_DateOfPublication
#define SOAP_TYPE__icommon__citationGEMETInspireThemes_x005feng_DateOfPublication (808)
#endif

/* enum _icommon__citationGEMETInspireThemes_x005feng_Title has binding name '_icommon__citationGEMETInspireThemes_x005feng_Title' for type 'icommon:citationGEMETInspireThemes_eng-Title' */
#ifndef SOAP_TYPE__icommon__citationGEMETInspireThemes_x005feng_Title
#define SOAP_TYPE__icommon__citationGEMETInspireThemes_x005feng_Title (806)
#endif

/* enum _icommon__resLocGEMETInspireThemes_x005feng_MediaType has binding name '_icommon__resLocGEMETInspireThemes_x005feng_MediaType' for type 'icommon:resLocGEMETInspireThemes_eng-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocGEMETInspireThemes_x005feng_MediaType
#define SOAP_TYPE__icommon__resLocGEMETInspireThemes_x005feng_MediaType (805)
#endif

/* enum _icommon__resLocGEMETInspireThemes_x005feng_URL has binding name '_icommon__resLocGEMETInspireThemes_x005feng_URL' for type 'icommon:resLocGEMETInspireThemes_eng-URL' */
#ifndef SOAP_TYPE__icommon__resLocGEMETInspireThemes_x005feng_URL
#define SOAP_TYPE__icommon__resLocGEMETInspireThemes_x005feng_URL (804)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fdut_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fdut_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_dut-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fdut_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fdut_MediaType (803)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fdut_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fdut_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_dut-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fdut_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fdut_URL (802)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fdan_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fdan_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_dan-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fdan_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fdan_MediaType (801)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fdan_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fdan_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_dan-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fdan_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fdan_URL (800)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fcze_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fcze_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_cze-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fcze_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fcze_MediaType (799)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fcze_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fcze_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_cze-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fcze_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fcze_URL (798)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fbul_MediaType has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fbul_MediaType' for type 'icommon:resLocInspireInteroperabilityRegulation_bul-MediaType' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fbul_MediaType
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fbul_MediaType (797)
#endif

/* enum _icommon__resLocInspireInteroperabilityRegulation_x005fbul_URL has binding name '_icommon__resLocInspireInteroperabilityRegulation_x005fbul_URL' for type 'icommon:resLocInspireInteroperabilityRegulation_bul-URL' */
#ifndef SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fbul_URL
#define SOAP_TYPE__icommon__resLocInspireInteroperabilityRegulation_x005fbul_URL (796)
#endif

/* enum _icommon__classificationOfSpatialDataService_KeywordValue has binding name '_icommon__classificationOfSpatialDataService_KeywordValue' for type 'icommon:classificationOfSpatialDataService-KeywordValue' */
#ifndef SOAP_TYPE__icommon__classificationOfSpatialDataService_KeywordValue
#define SOAP_TYPE__icommon__classificationOfSpatialDataService_KeywordValue (794)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (512)
#endif

/* enum icommon__euLanguageIETF has binding name 'icommon__euLanguageIETF' for type 'icommon:euLanguageIETF' */
#ifndef SOAP_TYPE_icommon__euLanguageIETF
#define SOAP_TYPE_icommon__euLanguageIETF (442)
#endif

/* enum icommon__euLanguageISO6392B has binding name 'icommon__euLanguageISO6392B' for type 'icommon:euLanguageISO6392B' */
#ifndef SOAP_TYPE_icommon__euLanguageISO6392B
#define SOAP_TYPE_icommon__euLanguageISO6392B (440)
#endif

/* enum icommon__otherSpatialDataServiceType has binding name 'icommon__otherSpatialDataServiceType' for type 'icommon:otherSpatialDataServiceType' */
#ifndef SOAP_TYPE_icommon__otherSpatialDataServiceType
#define SOAP_TYPE_icommon__otherSpatialDataServiceType (436)
#endif

/* enum icommon__invokeSpatialDataServiceType has binding name 'icommon__invokeSpatialDataServiceType' for type 'icommon:invokeSpatialDataServiceType' */
#ifndef SOAP_TYPE_icommon__invokeSpatialDataServiceType
#define SOAP_TYPE_icommon__invokeSpatialDataServiceType (434)
#endif

/* enum icommon__transformationSpatialDataServiceType has binding name 'icommon__transformationSpatialDataServiceType' for type 'icommon:transformationSpatialDataServiceType' */
#ifndef SOAP_TYPE_icommon__transformationSpatialDataServiceType
#define SOAP_TYPE_icommon__transformationSpatialDataServiceType (432)
#endif

/* enum icommon__discoverySpatialDataServiceType has binding name 'icommon__discoverySpatialDataServiceType' for type 'icommon:discoverySpatialDataServiceType' */
#ifndef SOAP_TYPE_icommon__discoverySpatialDataServiceType
#define SOAP_TYPE_icommon__discoverySpatialDataServiceType (430)
#endif

/* enum icommon__viewSpatialDataServiceType has binding name 'icommon__viewSpatialDataServiceType' for type 'icommon:viewSpatialDataServiceType' */
#ifndef SOAP_TYPE_icommon__viewSpatialDataServiceType
#define SOAP_TYPE_icommon__viewSpatialDataServiceType (428)
#endif

/* enum icommon__serviceSpatialDataResourceType has binding name 'icommon__serviceSpatialDataResourceType' for type 'icommon:serviceSpatialDataResourceType' */
#ifndef SOAP_TYPE_icommon__serviceSpatialDataResourceType
#define SOAP_TYPE_icommon__serviceSpatialDataResourceType (426)
#endif

/* enum icommon__responsiblePartyRole has binding name 'icommon__responsiblePartyRole' for type 'icommon:responsiblePartyRole' */
#ifndef SOAP_TYPE_icommon__responsiblePartyRole
#define SOAP_TYPE_icommon__responsiblePartyRole (422)
#endif

/* enum icommon__languageISO6392B has binding name 'icommon__languageISO6392B' for type 'icommon:languageISO6392B' */
#ifndef SOAP_TYPE_icommon__languageISO6392B
#define SOAP_TYPE_icommon__languageISO6392B (418)
#endif

/* enum icommon__degreeOfConformity has binding name 'icommon__degreeOfConformity' for type 'icommon:degreeOfConformity' */
#ifndef SOAP_TYPE_icommon__degreeOfConformity
#define SOAP_TYPE_icommon__degreeOfConformity (416)
#endif

/* enum icommon__spatialDataServiceType has binding name 'icommon__spatialDataServiceType' for type 'icommon:spatialDataServiceType' */
#ifndef SOAP_TYPE_icommon__spatialDataServiceType
#define SOAP_TYPE_icommon__spatialDataServiceType (414)
#endif

/* enum icommon__resourceType has binding name 'icommon__resourceType' for type 'icommon:resourceType' */
#ifndef SOAP_TYPE_icommon__resourceType
#define SOAP_TYPE_icommon__resourceType (412)
#endif

/* enum icommon__mediaType has binding name 'icommon__mediaType' for type 'icommon:mediaType' */
#ifndef SOAP_TYPE_icommon__mediaType
#define SOAP_TYPE_icommon__mediaType (406)
#endif

/* enum icommon__topicCategory has binding name 'icommon__topicCategory' for type 'icommon:topicCategory' */
#ifndef SOAP_TYPE_icommon__topicCategory
#define SOAP_TYPE_icommon__topicCategory (402)
#endif

/* enum fes__SortOrderType has binding name 'fes__SortOrderType' for type 'fes:SortOrderType' */
#ifndef SOAP_TYPE_fes__SortOrderType
#define SOAP_TYPE_fes__SortOrderType (400)
#endif

/* enum fes__MatchActionType has binding name 'fes__MatchActionType' for type 'fes:MatchActionType' */
#ifndef SOAP_TYPE_fes__MatchActionType
#define SOAP_TYPE_fes__MatchActionType (394)
#endif

/* enum fes__VersionActionTokens has binding name 'fes__VersionActionTokens' for type 'fes:VersionActionTokens' */
#ifndef SOAP_TYPE_fes__VersionActionTokens
#define SOAP_TYPE_fes__VersionActionTokens (392)
#endif

/* enum xlink__actuateType has binding name 'xlink__actuateType' for type 'xlink:actuateType' */
#ifndef SOAP_TYPE_xlink__actuateType
#define SOAP_TYPE_xlink__actuateType (382)
#endif

/* enum xlink__showType has binding name 'xlink__showType' for type 'xlink:showType' */
#ifndef SOAP_TYPE_xlink__showType
#define SOAP_TYPE_xlink__showType (380)
#endif

/* enum xlink__typeType has binding name 'xlink__typeType' for type 'xlink:typeType' */
#ifndef SOAP_TYPE_xlink__typeType
#define SOAP_TYPE_xlink__typeType (370)
#endif

/* enum _ows__rangeClosure has binding name '_ows__rangeClosure' for type 'ows:rangeClosure' */
#ifndef SOAP_TYPE__ows__rangeClosure
#define SOAP_TYPE__ows__rangeClosure (369)
#endif

/* enum wfs__UpdateActionType has binding name 'wfs__UpdateActionType' for type 'wfs:UpdateActionType' */
#ifndef SOAP_TYPE_wfs__UpdateActionType
#define SOAP_TYPE_wfs__UpdateActionType (358)
#endif

/* enum wfs__AllSomeType has binding name 'wfs__AllSomeType' for type 'wfs:AllSomeType' */
#ifndef SOAP_TYPE_wfs__AllSomeType
#define SOAP_TYPE_wfs__AllSomeType (356)
#endif

/* enum wfs__StarStringType has binding name 'wfs__StarStringType' for type 'wfs:StarStringType' */
#ifndef SOAP_TYPE_wfs__StarStringType
#define SOAP_TYPE_wfs__StarStringType (354)
#endif

/* enum wfs__ResolveValueType has binding name 'wfs__ResolveValueType' for type 'wfs:ResolveValueType' */
#ifndef SOAP_TYPE_wfs__ResolveValueType
#define SOAP_TYPE_wfs__ResolveValueType (352)
#endif

/* enum wfs__ResultTypeType has binding name 'wfs__ResultTypeType' for type 'wfs:ResultTypeType' */
#ifndef SOAP_TYPE_wfs__ResultTypeType
#define SOAP_TYPE_wfs__ResultTypeType (350)
#endif

/* _icommon__OtherService has binding name '_icommon__OtherService' for type '' */
#ifndef SOAP_TYPE__icommon__OtherService
#define SOAP_TYPE__icommon__OtherService (1174)
#endif

/* _icommon__InvokeService has binding name '_icommon__InvokeService' for type '' */
#ifndef SOAP_TYPE__icommon__InvokeService
#define SOAP_TYPE__icommon__InvokeService (1173)
#endif

/* _icommon__TransformationService has binding name '_icommon__TransformationService' for type '' */
#ifndef SOAP_TYPE__icommon__TransformationService
#define SOAP_TYPE__icommon__TransformationService (1172)
#endif

/* _icommon__DownloadService has binding name '_icommon__DownloadService' for type '' */
#ifndef SOAP_TYPE__icommon__DownloadService
#define SOAP_TYPE__icommon__DownloadService (1171)
#endif

/* _icommon__ViewService has binding name '_icommon__ViewService' for type '' */
#ifndef SOAP_TYPE__icommon__ViewService
#define SOAP_TYPE__icommon__ViewService (1170)
#endif

/* _icommon__DiscoveryService has binding name '_icommon__DiscoveryService' for type '' */
#ifndef SOAP_TYPE__icommon__DiscoveryService
#define SOAP_TYPE__icommon__DiscoveryService (1169)
#endif

/* _icommon__IndividualDate has binding name '_icommon__IndividualDate' for type '' */
#ifndef SOAP_TYPE__icommon__IndividualDate
#define SOAP_TYPE__icommon__IndividualDate (1168)
#endif

/* _icommon__SpatialDataSetSeries has binding name '_icommon__SpatialDataSetSeries' for type '' */
#ifndef SOAP_TYPE__icommon__SpatialDataSetSeries
#define SOAP_TYPE__icommon__SpatialDataSetSeries (1166)
#endif

/* _icommon__SpatialDataSet has binding name '_icommon__SpatialDataSet' for type '' */
#ifndef SOAP_TYPE__icommon__SpatialDataSet
#define SOAP_TYPE__icommon__SpatialDataSet (1165)
#endif

/* _icommon__SpatialDataService has binding name '_icommon__SpatialDataService' for type '' */
#ifndef SOAP_TYPE__icommon__SpatialDataService
#define SOAP_TYPE__icommon__SpatialDataService (1164)
#endif

/* _fes__SortBy has binding name '_fes__SortBy' for type '' */
#ifndef SOAP_TYPE__fes__SortBy
#define SOAP_TYPE__fes__SortBy (1163)
#endif

/* _fes__Literal has binding name '_fes__Literal' for type '' */
#ifndef SOAP_TYPE__fes__Literal
#define SOAP_TYPE__fes__Literal (1162)
#endif

/* _fes__Function has binding name '_fes__Function' for type '' */
#ifndef SOAP_TYPE__fes__Function
#define SOAP_TYPE__fes__Function (1161)
#endif

/* _fes__ValueReference has binding name '_fes__ValueReference' for type '' */
#ifndef SOAP_TYPE__fes__ValueReference
#define SOAP_TYPE__fes__ValueReference (1160)
#endif

/* _fes__ResourceId has binding name '_fes__ResourceId' for type '' */
#ifndef SOAP_TYPE__fes__ResourceId
#define SOAP_TYPE__fes__ResourceId (1159)
#endif

/* _fes__Not has binding name '_fes__Not' for type '' */
#ifndef SOAP_TYPE__fes__Not
#define SOAP_TYPE__fes__Not (1158)
#endif

/* _fes__Or has binding name '_fes__Or' for type '' */
#ifndef SOAP_TYPE__fes__Or
#define SOAP_TYPE__fes__Or (1157)
#endif

/* _fes__And has binding name '_fes__And' for type '' */
#ifndef SOAP_TYPE__fes__And
#define SOAP_TYPE__fes__And (1156)
#endif

/* _fes__AnyInteracts has binding name '_fes__AnyInteracts' for type '' */
#ifndef SOAP_TYPE__fes__AnyInteracts
#define SOAP_TYPE__fes__AnyInteracts (1155)
#endif

/* _fes__OverlappedBy has binding name '_fes__OverlappedBy' for type '' */
#ifndef SOAP_TYPE__fes__OverlappedBy
#define SOAP_TYPE__fes__OverlappedBy (1154)
#endif

/* _fes__TOverlaps has binding name '_fes__TOverlaps' for type '' */
#ifndef SOAP_TYPE__fes__TOverlaps
#define SOAP_TYPE__fes__TOverlaps (1153)
#endif

/* _fes__MetBy has binding name '_fes__MetBy' for type '' */
#ifndef SOAP_TYPE__fes__MetBy
#define SOAP_TYPE__fes__MetBy (1152)
#endif

/* _fes__Meets has binding name '_fes__Meets' for type '' */
#ifndef SOAP_TYPE__fes__Meets
#define SOAP_TYPE__fes__Meets (1151)
#endif

/* _fes__TEquals has binding name '_fes__TEquals' for type '' */
#ifndef SOAP_TYPE__fes__TEquals
#define SOAP_TYPE__fes__TEquals (1150)
#endif

/* _fes__Ends has binding name '_fes__Ends' for type '' */
#ifndef SOAP_TYPE__fes__Ends
#define SOAP_TYPE__fes__Ends (1149)
#endif

/* _fes__EndedBy has binding name '_fes__EndedBy' for type '' */
#ifndef SOAP_TYPE__fes__EndedBy
#define SOAP_TYPE__fes__EndedBy (1148)
#endif

/* _fes__During has binding name '_fes__During' for type '' */
#ifndef SOAP_TYPE__fes__During
#define SOAP_TYPE__fes__During (1147)
#endif

/* _fes__TContains has binding name '_fes__TContains' for type '' */
#ifndef SOAP_TYPE__fes__TContains
#define SOAP_TYPE__fes__TContains (1146)
#endif

/* _fes__BegunBy has binding name '_fes__BegunBy' for type '' */
#ifndef SOAP_TYPE__fes__BegunBy
#define SOAP_TYPE__fes__BegunBy (1145)
#endif

/* _fes__Begins has binding name '_fes__Begins' for type '' */
#ifndef SOAP_TYPE__fes__Begins
#define SOAP_TYPE__fes__Begins (1144)
#endif

/* _fes__Before has binding name '_fes__Before' for type '' */
#ifndef SOAP_TYPE__fes__Before
#define SOAP_TYPE__fes__Before (1143)
#endif

/* _fes__After has binding name '_fes__After' for type '' */
#ifndef SOAP_TYPE__fes__After
#define SOAP_TYPE__fes__After (1142)
#endif

/* _fes__BBOX has binding name '_fes__BBOX' for type '' */
#ifndef SOAP_TYPE__fes__BBOX
#define SOAP_TYPE__fes__BBOX (1141)
#endif

/* _fes__Beyond has binding name '_fes__Beyond' for type '' */
#ifndef SOAP_TYPE__fes__Beyond
#define SOAP_TYPE__fes__Beyond (1140)
#endif

/* _fes__DWithin has binding name '_fes__DWithin' for type '' */
#ifndef SOAP_TYPE__fes__DWithin
#define SOAP_TYPE__fes__DWithin (1139)
#endif

/* _fes__Contains has binding name '_fes__Contains' for type '' */
#ifndef SOAP_TYPE__fes__Contains
#define SOAP_TYPE__fes__Contains (1138)
#endif

/* _fes__Intersects has binding name '_fes__Intersects' for type '' */
#ifndef SOAP_TYPE__fes__Intersects
#define SOAP_TYPE__fes__Intersects (1137)
#endif

/* _fes__Crosses has binding name '_fes__Crosses' for type '' */
#ifndef SOAP_TYPE__fes__Crosses
#define SOAP_TYPE__fes__Crosses (1136)
#endif

/* _fes__Overlaps has binding name '_fes__Overlaps' for type '' */
#ifndef SOAP_TYPE__fes__Overlaps
#define SOAP_TYPE__fes__Overlaps (1135)
#endif

/* _fes__Within has binding name '_fes__Within' for type '' */
#ifndef SOAP_TYPE__fes__Within
#define SOAP_TYPE__fes__Within (1134)
#endif

/* _fes__Touches has binding name '_fes__Touches' for type '' */
#ifndef SOAP_TYPE__fes__Touches
#define SOAP_TYPE__fes__Touches (1133)
#endif

/* _fes__Disjoint has binding name '_fes__Disjoint' for type '' */
#ifndef SOAP_TYPE__fes__Disjoint
#define SOAP_TYPE__fes__Disjoint (1132)
#endif

/* _fes__Equals has binding name '_fes__Equals' for type '' */
#ifndef SOAP_TYPE__fes__Equals
#define SOAP_TYPE__fes__Equals (1131)
#endif

/* _fes__PropertyIsBetween has binding name '_fes__PropertyIsBetween' for type '' */
#ifndef SOAP_TYPE__fes__PropertyIsBetween
#define SOAP_TYPE__fes__PropertyIsBetween (1130)
#endif

/* _fes__PropertyIsNil has binding name '_fes__PropertyIsNil' for type '' */
#ifndef SOAP_TYPE__fes__PropertyIsNil
#define SOAP_TYPE__fes__PropertyIsNil (1129)
#endif

/* _fes__PropertyIsNull has binding name '_fes__PropertyIsNull' for type '' */
#ifndef SOAP_TYPE__fes__PropertyIsNull
#define SOAP_TYPE__fes__PropertyIsNull (1128)
#endif

/* _fes__PropertyIsLike has binding name '_fes__PropertyIsLike' for type '' */
#ifndef SOAP_TYPE__fes__PropertyIsLike
#define SOAP_TYPE__fes__PropertyIsLike (1127)
#endif

/* _fes__PropertyIsGreaterThanOrEqualTo has binding name '_fes__PropertyIsGreaterThanOrEqualTo' for type '' */
#ifndef SOAP_TYPE__fes__PropertyIsGreaterThanOrEqualTo
#define SOAP_TYPE__fes__PropertyIsGreaterThanOrEqualTo (1126)
#endif

/* _fes__PropertyIsLessThanOrEqualTo has binding name '_fes__PropertyIsLessThanOrEqualTo' for type '' */
#ifndef SOAP_TYPE__fes__PropertyIsLessThanOrEqualTo
#define SOAP_TYPE__fes__PropertyIsLessThanOrEqualTo (1125)
#endif

/* _fes__PropertyIsGreaterThan has binding name '_fes__PropertyIsGreaterThan' for type '' */
#ifndef SOAP_TYPE__fes__PropertyIsGreaterThan
#define SOAP_TYPE__fes__PropertyIsGreaterThan (1124)
#endif

/* _fes__PropertyIsLessThan has binding name '_fes__PropertyIsLessThan' for type '' */
#ifndef SOAP_TYPE__fes__PropertyIsLessThan
#define SOAP_TYPE__fes__PropertyIsLessThan (1123)
#endif

/* _fes__PropertyIsNotEqualTo has binding name '_fes__PropertyIsNotEqualTo' for type '' */
#ifndef SOAP_TYPE__fes__PropertyIsNotEqualTo
#define SOAP_TYPE__fes__PropertyIsNotEqualTo (1122)
#endif

/* _fes__PropertyIsEqualTo has binding name '_fes__PropertyIsEqualTo' for type '' */
#ifndef SOAP_TYPE__fes__PropertyIsEqualTo
#define SOAP_TYPE__fes__PropertyIsEqualTo (1121)
#endif

/* _fes__Filter has binding name '_fes__Filter' for type '' */
#ifndef SOAP_TYPE__fes__Filter
#define SOAP_TYPE__fes__Filter (1120)
#endif

/* _idls__spatial_x005fdataset_x005fidentifier_x005fcode has binding name '_idls__spatial_x005fdataset_x005fidentifier_x005fcode' for type '' */
#ifndef SOAP_TYPE__idls__spatial_x005fdataset_x005fidentifier_x005fcode
#define SOAP_TYPE__idls__spatial_x005fdataset_x005fidentifier_x005fcode (1117)
#endif

/* _idls__ExtendedCapabilities has binding name '_idls__ExtendedCapabilities' for type '' */
#ifndef SOAP_TYPE__idls__ExtendedCapabilities
#define SOAP_TYPE__idls__ExtendedCapabilities (1116)
#endif

/* _ows__Manifest has binding name '_ows__Manifest' for type '' */
#ifndef SOAP_TYPE__ows__Manifest
#define SOAP_TYPE__ows__Manifest (1114)
#endif

/* _ows__ReferenceGroup has binding name '_ows__ReferenceGroup' for type '' */
#ifndef SOAP_TYPE__ows__ReferenceGroup
#define SOAP_TYPE__ows__ReferenceGroup (1113)
#endif

/* _ows__Reference has binding name '_ows__Reference' for type '' */
#ifndef SOAP_TYPE__ows__Reference
#define SOAP_TYPE__ows__Reference (1112)
#endif

/* _ows__ServiceReference has binding name '_ows__ServiceReference' for type '' */
#ifndef SOAP_TYPE__ows__ServiceReference
#define SOAP_TYPE__ows__ServiceReference (1111)
#endif

/* _ows__InputData has binding name '_ows__InputData' for type '' */
#ifndef SOAP_TYPE__ows__InputData
#define SOAP_TYPE__ows__InputData (1110)
#endif

/* _ows__OperationResponse has binding name '_ows__OperationResponse' for type '' */
#ifndef SOAP_TYPE__ows__OperationResponse
#define SOAP_TYPE__ows__OperationResponse (1109)
#endif

/* _ows__DatasetDescriptionSummary has binding name '_ows__DatasetDescriptionSummary' for type '' */
#ifndef SOAP_TYPE__ows__DatasetDescriptionSummary
#define SOAP_TYPE__ows__DatasetDescriptionSummary (1108)
#endif

/* _ows__OtherSource has binding name '_ows__OtherSource' for type '' */
#ifndef SOAP_TYPE__ows__OtherSource
#define SOAP_TYPE__ows__OtherSource (1107)
#endif

/* _ows__UOM has binding name '_ows__UOM' for type '' */
#ifndef SOAP_TYPE__ows__UOM
#define SOAP_TYPE__ows__UOM (1106)
#endif

/* _ows__ReferenceSystem has binding name '_ows__ReferenceSystem' for type '' */
#ifndef SOAP_TYPE__ows__ReferenceSystem
#define SOAP_TYPE__ows__ReferenceSystem (1105)
#endif

/* _ows__DataType has binding name '_ows__DataType' for type '' */
#ifndef SOAP_TYPE__ows__DataType
#define SOAP_TYPE__ows__DataType (1104)
#endif

/* _ows__Meaning has binding name '_ows__Meaning' for type '' */
#ifndef SOAP_TYPE__ows__Meaning
#define SOAP_TYPE__ows__Meaning (1103)
#endif

/* _ows__Spacing has binding name '_ows__Spacing' for type '' */
#ifndef SOAP_TYPE__ows__Spacing
#define SOAP_TYPE__ows__Spacing (1102)
#endif

/* _ows__MaximumValue has binding name '_ows__MaximumValue' for type '' */
#ifndef SOAP_TYPE__ows__MaximumValue
#define SOAP_TYPE__ows__MaximumValue (1101)
#endif

/* _ows__MinimumValue has binding name '_ows__MinimumValue' for type '' */
#ifndef SOAP_TYPE__ows__MinimumValue
#define SOAP_TYPE__ows__MinimumValue (1100)
#endif

/* _ows__Range has binding name '_ows__Range' for type '' */
#ifndef SOAP_TYPE__ows__Range
#define SOAP_TYPE__ows__Range (1099)
#endif

/* _ows__DefaultValue has binding name '_ows__DefaultValue' for type '' */
#ifndef SOAP_TYPE__ows__DefaultValue
#define SOAP_TYPE__ows__DefaultValue (1098)
#endif

/* _ows__Value has binding name '_ows__Value' for type '' */
#ifndef SOAP_TYPE__ows__Value
#define SOAP_TYPE__ows__Value (1097)
#endif

/* _ows__ExtendedCapabilities has binding name '_ows__ExtendedCapabilities' for type '' */
#ifndef SOAP_TYPE__ows__ExtendedCapabilities
#define SOAP_TYPE__ows__ExtendedCapabilities (1096)
#endif

/* _ows__GetCapabilities has binding name '_ows__GetCapabilities' for type '' */
#ifndef SOAP_TYPE__ows__GetCapabilities
#define SOAP_TYPE__ows__GetCapabilities (1095)
#endif

/* _ows__ContactInfo has binding name '_ows__ContactInfo' for type '' */
#ifndef SOAP_TYPE__ows__ContactInfo
#define SOAP_TYPE__ows__ContactInfo (1094)
#endif

/* _ows__Role has binding name '_ows__Role' for type '' */
#ifndef SOAP_TYPE__ows__Role
#define SOAP_TYPE__ows__Role (1093)
#endif

/* _ows__PositionName has binding name '_ows__PositionName' for type '' */
#ifndef SOAP_TYPE__ows__PositionName
#define SOAP_TYPE__ows__PositionName (1092)
#endif

/* _ows__OrganisationName has binding name '_ows__OrganisationName' for type '' */
#ifndef SOAP_TYPE__ows__OrganisationName
#define SOAP_TYPE__ows__OrganisationName (1091)
#endif

/* _ows__IndividualName has binding name '_ows__IndividualName' for type '' */
#ifndef SOAP_TYPE__ows__IndividualName
#define SOAP_TYPE__ows__IndividualName (1090)
#endif

/* _ows__PointOfContact has binding name '_ows__PointOfContact' for type '' */
#ifndef SOAP_TYPE__ows__PointOfContact
#define SOAP_TYPE__ows__PointOfContact (1089)
#endif

/* _ows__Keywords has binding name '_ows__Keywords' for type '' */
#ifndef SOAP_TYPE__ows__Keywords
#define SOAP_TYPE__ows__Keywords (1088)
#endif

/* _ows__Abstract has binding name '_ows__Abstract' for type '' */
#ifndef SOAP_TYPE__ows__Abstract
#define SOAP_TYPE__ows__Abstract (1087)
#endif

/* _ows__Title has binding name '_ows__Title' for type '' */
#ifndef SOAP_TYPE__ows__Title
#define SOAP_TYPE__ows__Title (1086)
#endif

/* _ows__WGS84BoundingBox has binding name '_ows__WGS84BoundingBox' for type '' */
#ifndef SOAP_TYPE__ows__WGS84BoundingBox
#define SOAP_TYPE__ows__WGS84BoundingBox (1085)
#endif

/* _ows__BoundingBox has binding name '_ows__BoundingBox' for type '' */
#ifndef SOAP_TYPE__ows__BoundingBox
#define SOAP_TYPE__ows__BoundingBox (1084)
#endif

/* _ows__Metadata has binding name '_ows__Metadata' for type '' */
#ifndef SOAP_TYPE__ows__Metadata
#define SOAP_TYPE__ows__Metadata (1083)
#endif

/* _ows__Fees has binding name '_ows__Fees' for type '' */
#ifndef SOAP_TYPE__ows__Fees
#define SOAP_TYPE__ows__Fees (1081)
#endif

/* _ows__AccessConstraints has binding name '_ows__AccessConstraints' for type '' */
#ifndef SOAP_TYPE__ows__AccessConstraints
#define SOAP_TYPE__ows__AccessConstraints (1080)
#endif

/* _ows__OutputFormat has binding name '_ows__OutputFormat' for type '' */
#ifndef SOAP_TYPE__ows__OutputFormat
#define SOAP_TYPE__ows__OutputFormat (1077)
#endif

/* _ows__Identifier has binding name '_ows__Identifier' for type '' */
#ifndef SOAP_TYPE__ows__Identifier
#define SOAP_TYPE__ows__Identifier (1076)
#endif

/* _ows__GetResourceByID has binding name '_ows__GetResourceByID' for type '' */
#ifndef SOAP_TYPE__ows__GetResourceByID
#define SOAP_TYPE__ows__GetResourceByID (1075)
#endif

/* _ows__Exception has binding name '_ows__Exception' for type '' */
#ifndef SOAP_TYPE__ows__Exception
#define SOAP_TYPE__ows__Exception (1074)
#endif

/* _util__DescribeFeatureTypeResponse has binding name '_util__DescribeFeatureTypeResponse' for type '' */
#ifndef SOAP_TYPE__util__DescribeFeatureTypeResponse
#define SOAP_TYPE__util__DescribeFeatureTypeResponse (1073)
#endif

/* _wfs__TransactionResponse has binding name '_wfs__TransactionResponse' for type '' */
#ifndef SOAP_TYPE__wfs__TransactionResponse
#define SOAP_TYPE__wfs__TransactionResponse (1072)
#endif

/* _wfs__Native has binding name '_wfs__Native' for type '' */
#ifndef SOAP_TYPE__wfs__Native
#define SOAP_TYPE__wfs__Native (1071)
#endif

/* _wfs__Delete has binding name '_wfs__Delete' for type '' */
#ifndef SOAP_TYPE__wfs__Delete
#define SOAP_TYPE__wfs__Delete (1070)
#endif

/* _wfs__Replace has binding name '_wfs__Replace' for type '' */
#ifndef SOAP_TYPE__wfs__Replace
#define SOAP_TYPE__wfs__Replace (1069)
#endif

/* _wfs__Property has binding name '_wfs__Property' for type '' */
#ifndef SOAP_TYPE__wfs__Property
#define SOAP_TYPE__wfs__Property (1068)
#endif

/* _wfs__Update has binding name '_wfs__Update' for type '' */
#ifndef SOAP_TYPE__wfs__Update
#define SOAP_TYPE__wfs__Update (1067)
#endif

/* _wfs__Insert has binding name '_wfs__Insert' for type '' */
#ifndef SOAP_TYPE__wfs__Insert
#define SOAP_TYPE__wfs__Insert (1066)
#endif

/* _wfs__Transaction has binding name '_wfs__Transaction' for type '' */
#ifndef SOAP_TYPE__wfs__Transaction
#define SOAP_TYPE__wfs__Transaction (1065)
#endif

/* _wfs__LockFeatureResponse has binding name '_wfs__LockFeatureResponse' for type '' */
#ifndef SOAP_TYPE__wfs__LockFeatureResponse
#define SOAP_TYPE__wfs__LockFeatureResponse (1064)
#endif

/* _wfs__LockFeature has binding name '_wfs__LockFeature' for type '' */
#ifndef SOAP_TYPE__wfs__LockFeature
#define SOAP_TYPE__wfs__LockFeature (1063)
#endif

/* _wfs__DropStoredQueryResponse has binding name '_wfs__DropStoredQueryResponse' for type '' */
#ifndef SOAP_TYPE__wfs__DropStoredQueryResponse
#define SOAP_TYPE__wfs__DropStoredQueryResponse (1062)
#endif

/* _wfs__CreateStoredQueryResponse has binding name '_wfs__CreateStoredQueryResponse' for type '' */
#ifndef SOAP_TYPE__wfs__CreateStoredQueryResponse
#define SOAP_TYPE__wfs__CreateStoredQueryResponse (1061)
#endif

/* _wfs__CreateStoredQuery has binding name '_wfs__CreateStoredQuery' for type '' */
#ifndef SOAP_TYPE__wfs__CreateStoredQuery
#define SOAP_TYPE__wfs__CreateStoredQuery (1060)
#endif

/* _wfs__DescribeStoredQueriesResponse has binding name '_wfs__DescribeStoredQueriesResponse' for type '' */
#ifndef SOAP_TYPE__wfs__DescribeStoredQueriesResponse
#define SOAP_TYPE__wfs__DescribeStoredQueriesResponse (1059)
#endif

/* _wfs__DescribeStoredQueries has binding name '_wfs__DescribeStoredQueries' for type '' */
#ifndef SOAP_TYPE__wfs__DescribeStoredQueries
#define SOAP_TYPE__wfs__DescribeStoredQueries (1058)
#endif

/* _wfs__ListStoredQueriesResponse has binding name '_wfs__ListStoredQueriesResponse' for type '' */
#ifndef SOAP_TYPE__wfs__ListStoredQueriesResponse
#define SOAP_TYPE__wfs__ListStoredQueriesResponse (1057)
#endif

/* _wfs__ListStoredQueries has binding name '_wfs__ListStoredQueries' for type '' */
#ifndef SOAP_TYPE__wfs__ListStoredQueries
#define SOAP_TYPE__wfs__ListStoredQueries (1056)
#endif

/* _wfs__boundedBy has binding name '_wfs__boundedBy' for type '' */
#ifndef SOAP_TYPE__wfs__boundedBy
#define SOAP_TYPE__wfs__boundedBy (1055)
#endif

/* _wfs__SimpleFeatureCollection has binding name '_wfs__SimpleFeatureCollection' for type '' */
#ifndef SOAP_TYPE__wfs__SimpleFeatureCollection
#define SOAP_TYPE__wfs__SimpleFeatureCollection (1054)
#endif

/* _wfs__FeatureCollection has binding name '_wfs__FeatureCollection' for type '' */
#ifndef SOAP_TYPE__wfs__FeatureCollection
#define SOAP_TYPE__wfs__FeatureCollection (1053)
#endif

/* _wfs__GetFeatureWithLock has binding name '_wfs__GetFeatureWithLock' for type '' */
#ifndef SOAP_TYPE__wfs__GetFeatureWithLock
#define SOAP_TYPE__wfs__GetFeatureWithLock (1052)
#endif

/* _wfs__GetFeature has binding name '_wfs__GetFeature' for type '' */
#ifndef SOAP_TYPE__wfs__GetFeature
#define SOAP_TYPE__wfs__GetFeature (1051)
#endif

/* _wfs__Tuple has binding name '_wfs__Tuple' for type '' */
#ifndef SOAP_TYPE__wfs__Tuple
#define SOAP_TYPE__wfs__Tuple (1050)
#endif

/* _wfs__member has binding name '_wfs__member' for type '' */
#ifndef SOAP_TYPE__wfs__member
#define SOAP_TYPE__wfs__member (1049)
#endif

/* _wfs__ValueCollection has binding name '_wfs__ValueCollection' for type '' */
#ifndef SOAP_TYPE__wfs__ValueCollection
#define SOAP_TYPE__wfs__ValueCollection (1048)
#endif

/* _wfs__GetPropertyValue has binding name '_wfs__GetPropertyValue' for type '' */
#ifndef SOAP_TYPE__wfs__GetPropertyValue
#define SOAP_TYPE__wfs__GetPropertyValue (1047)
#endif

/* _wfs__DescribeFeatureType has binding name '_wfs__DescribeFeatureType' for type '' */
#ifndef SOAP_TYPE__wfs__DescribeFeatureType
#define SOAP_TYPE__wfs__DescribeFeatureType (1046)
#endif

/* _wfs__Value has binding name '_wfs__Value' for type '' */
#ifndef SOAP_TYPE__wfs__Value
#define SOAP_TYPE__wfs__Value (1045)
#endif

/* _wfs__ValueList has binding name '_wfs__ValueList' for type '' */
#ifndef SOAP_TYPE__wfs__ValueList
#define SOAP_TYPE__wfs__ValueList (1044)
#endif

/* _wfs__Element has binding name '_wfs__Element' for type '' */
#ifndef SOAP_TYPE__wfs__Element
#define SOAP_TYPE__wfs__Element (1043)
#endif

/* _wfs__FeatureTypeList has binding name '_wfs__FeatureTypeList' for type '' */
#ifndef SOAP_TYPE__wfs__FeatureTypeList
#define SOAP_TYPE__wfs__FeatureTypeList (1042)
#endif

/* _wfs__WFS_x005fCapabilities has binding name '_wfs__WFS_x005fCapabilities' for type '' */
#ifndef SOAP_TYPE__wfs__WFS_x005fCapabilities
#define SOAP_TYPE__wfs__WFS_x005fCapabilities (1041)
#endif

/* _wfs__GetCapabilities has binding name '_wfs__GetCapabilities' for type '' */
#ifndef SOAP_TYPE__wfs__GetCapabilities
#define SOAP_TYPE__wfs__GetCapabilities (1040)
#endif

/* _wfs__StoredQuery has binding name '_wfs__StoredQuery' for type '' */
#ifndef SOAP_TYPE__wfs__StoredQuery
#define SOAP_TYPE__wfs__StoredQuery (1039)
#endif

/* _wfs__Query has binding name '_wfs__Query' for type '' */
#ifndef SOAP_TYPE__wfs__Query
#define SOAP_TYPE__wfs__Query (1038)
#endif

/* _wfs__WFS_x005fCapabilitiesType_WSDL has binding name '_wfs__WFS_x005fCapabilitiesType_WSDL' for type '' */
#ifndef SOAP_TYPE__wfs__WFS_x005fCapabilitiesType_WSDL
#define SOAP_TYPE__wfs__WFS_x005fCapabilitiesType_WSDL (698)
#endif

/* _icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendURL has binding name '_icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendURL' for type '' */
#ifndef SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendURL
#define SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendURL (694)
#endif

/* _icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendFormat has binding name '_icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendFormat' for type '' */
#ifndef SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendFormat
#define SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList_Legend_LegendFormat (693)
#endif

/* _icommon__layers_Layer_Styles_Style_LegendList_Legend has binding name '_icommon__layers_Layer_Styles_Style_LegendList_Legend' for type '' */
#ifndef SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList_Legend
#define SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList_Legend (692)
#endif

/* _icommon__layers_Layer_Styles_Style_LegendList has binding name '_icommon__layers_Layer_Styles_Style_LegendList' for type '' */
#ifndef SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList
#define SOAP_TYPE__icommon__layers_Layer_Styles_Style_LegendList (691)
#endif

/* _icommon__layers_Layer_Styles_Style_StyleURL has binding name '_icommon__layers_Layer_Styles_Style_StyleURL' for type '' */
#ifndef SOAP_TYPE__icommon__layers_Layer_Styles_Style_StyleURL
#define SOAP_TYPE__icommon__layers_Layer_Styles_Style_StyleURL (690)
#endif

/* _icommon__layers_Layer_Styles_Style_StyleFormat has binding name '_icommon__layers_Layer_Styles_Style_StyleFormat' for type '' */
#ifndef SOAP_TYPE__icommon__layers_Layer_Styles_Style_StyleFormat
#define SOAP_TYPE__icommon__layers_Layer_Styles_Style_StyleFormat (689)
#endif

/* _icommon__layers_Layer_Styles_Style_StyleAbstract has binding name '_icommon__layers_Layer_Styles_Style_StyleAbstract' for type '' */
#ifndef SOAP_TYPE__icommon__layers_Layer_Styles_Style_StyleAbstract
#define SOAP_TYPE__icommon__layers_Layer_Styles_Style_StyleAbstract (688)
#endif

/* _icommon__layers_Layer_Styles_Style has binding name '_icommon__layers_Layer_Styles_Style' for type '' */
#ifndef SOAP_TYPE__icommon__layers_Layer_Styles_Style
#define SOAP_TYPE__icommon__layers_Layer_Styles_Style (687)
#endif

/* _icommon__layers_Layer_Styles has binding name '_icommon__layers_Layer_Styles' for type '' */
#ifndef SOAP_TYPE__icommon__layers_Layer_Styles
#define SOAP_TYPE__icommon__layers_Layer_Styles (686)
#endif

/* _icommon__layers_Layer_CoordinateReferenceSystems_CRS has binding name '_icommon__layers_Layer_CoordinateReferenceSystems_CRS' for type '' */
#ifndef SOAP_TYPE__icommon__layers_Layer_CoordinateReferenceSystems_CRS
#define SOAP_TYPE__icommon__layers_Layer_CoordinateReferenceSystems_CRS (684)
#endif

/* _icommon__layers_Layer_CoordinateReferenceSystems has binding name '_icommon__layers_Layer_CoordinateReferenceSystems' for type '' */
#ifndef SOAP_TYPE__icommon__layers_Layer_CoordinateReferenceSystems
#define SOAP_TYPE__icommon__layers_Layer_CoordinateReferenceSystems (683)
#endif

/* _icommon__layers_Layer has binding name '_icommon__layers_Layer' for type '' */
#ifndef SOAP_TYPE__icommon__layers_Layer
#define SOAP_TYPE__icommon__layers_Layer (680)
#endif

/* _icommon__responsibleOrganisation_ResponsibleParty has binding name '_icommon__responsibleOrganisation_ResponsibleParty' for type '' */
#ifndef SOAP_TYPE__icommon__responsibleOrganisation_ResponsibleParty
#define SOAP_TYPE__icommon__responsibleOrganisation_ResponsibleParty (658)
#endif

/* _fes__TemporalOperandsType_TemporalOperand has binding name '_fes__TemporalOperandsType_TemporalOperand' for type '' */
#ifndef SOAP_TYPE__fes__TemporalOperandsType_TemporalOperand
#define SOAP_TYPE__fes__TemporalOperandsType_TemporalOperand (624)
#endif

/* _fes__GeometryOperandsType_GeometryOperand has binding name '_fes__GeometryOperandsType_GeometryOperand' for type '' */
#ifndef SOAP_TYPE__fes__GeometryOperandsType_GeometryOperand
#define SOAP_TYPE__fes__GeometryOperandsType_GeometryOperand (617)
#endif

/* _wfs__PropertyType_ValueReference has binding name '_wfs__PropertyType_ValueReference' for type '' */
#ifndef SOAP_TYPE__wfs__PropertyType_ValueReference
#define SOAP_TYPE__wfs__PropertyType_ValueReference (520)
#endif

/* _wfs__FeatureTypeType_NoCRS has binding name '_wfs__FeatureTypeType_NoCRS' for type '' */
#ifndef SOAP_TYPE__wfs__FeatureTypeType_NoCRS
#define SOAP_TYPE__wfs__FeatureTypeType_NoCRS (461)
#endif

/* icommon__euLanguageIETF_ has binding name 'icommon__euLanguageIETF_' for type 'icommon:euLanguageIETF' */
#ifndef SOAP_TYPE_icommon__euLanguageIETF_
#define SOAP_TYPE_icommon__euLanguageIETF_ (443)
#endif

/* icommon__euLanguageISO6392B_ has binding name 'icommon__euLanguageISO6392B_' for type 'icommon:euLanguageISO6392B' */
#ifndef SOAP_TYPE_icommon__euLanguageISO6392B_
#define SOAP_TYPE_icommon__euLanguageISO6392B_ (441)
#endif

/* icommon__keywordValue__ has binding name 'icommon__keywordValue__' for type 'icommon:keywordValue' */
#ifndef SOAP_TYPE_icommon__keywordValue__
#define SOAP_TYPE_icommon__keywordValue__ (439)
#endif

/* icommon__keywordValue has binding name 'icommon__keywordValue' for type 'icommon:keywordValue' */
#ifndef SOAP_TYPE_icommon__keywordValue
#define SOAP_TYPE_icommon__keywordValue (438)
#endif

/* icommon__otherSpatialDataServiceType_ has binding name 'icommon__otherSpatialDataServiceType_' for type 'icommon:otherSpatialDataServiceType' */
#ifndef SOAP_TYPE_icommon__otherSpatialDataServiceType_
#define SOAP_TYPE_icommon__otherSpatialDataServiceType_ (437)
#endif

/* icommon__invokeSpatialDataServiceType_ has binding name 'icommon__invokeSpatialDataServiceType_' for type 'icommon:invokeSpatialDataServiceType' */
#ifndef SOAP_TYPE_icommon__invokeSpatialDataServiceType_
#define SOAP_TYPE_icommon__invokeSpatialDataServiceType_ (435)
#endif

/* icommon__transformationSpatialDataServiceType_ has binding name 'icommon__transformationSpatialDataServiceType_' for type 'icommon:transformationSpatialDataServiceType' */
#ifndef SOAP_TYPE_icommon__transformationSpatialDataServiceType_
#define SOAP_TYPE_icommon__transformationSpatialDataServiceType_ (433)
#endif

/* icommon__discoverySpatialDataServiceType_ has binding name 'icommon__discoverySpatialDataServiceType_' for type 'icommon:discoverySpatialDataServiceType' */
#ifndef SOAP_TYPE_icommon__discoverySpatialDataServiceType_
#define SOAP_TYPE_icommon__discoverySpatialDataServiceType_ (431)
#endif

/* icommon__viewSpatialDataServiceType_ has binding name 'icommon__viewSpatialDataServiceType_' for type 'icommon:viewSpatialDataServiceType' */
#ifndef SOAP_TYPE_icommon__viewSpatialDataServiceType_
#define SOAP_TYPE_icommon__viewSpatialDataServiceType_ (429)
#endif

/* icommon__serviceSpatialDataResourceType_ has binding name 'icommon__serviceSpatialDataResourceType_' for type 'icommon:serviceSpatialDataResourceType' */
#ifndef SOAP_TYPE_icommon__serviceSpatialDataResourceType_
#define SOAP_TYPE_icommon__serviceSpatialDataResourceType_ (427)
#endif

/* icommon__geoBoxDigits__ has binding name 'icommon__geoBoxDigits__' for type 'icommon:geoBoxDigits' */
#ifndef SOAP_TYPE_icommon__geoBoxDigits__
#define SOAP_TYPE_icommon__geoBoxDigits__ (425)
#endif

/* icommon__geoBoxDigits has binding name 'icommon__geoBoxDigits' for type 'icommon:geoBoxDigits' */
#ifndef SOAP_TYPE_icommon__geoBoxDigits
#define SOAP_TYPE_icommon__geoBoxDigits (424)
#endif

/* icommon__responsiblePartyRole_ has binding name 'icommon__responsiblePartyRole_' for type 'icommon:responsiblePartyRole' */
#ifndef SOAP_TYPE_icommon__responsiblePartyRole_
#define SOAP_TYPE_icommon__responsiblePartyRole_ (423)
#endif

/* icommon__languageIETF__ has binding name 'icommon__languageIETF__' for type 'icommon:languageIETF' */
#ifndef SOAP_TYPE_icommon__languageIETF__
#define SOAP_TYPE_icommon__languageIETF__ (421)
#endif

/* icommon__languageISO6392B_ has binding name 'icommon__languageISO6392B_' for type 'icommon:languageISO6392B' */
#ifndef SOAP_TYPE_icommon__languageISO6392B_
#define SOAP_TYPE_icommon__languageISO6392B_ (419)
#endif

/* icommon__degreeOfConformity_ has binding name 'icommon__degreeOfConformity_' for type 'icommon:degreeOfConformity' */
#ifndef SOAP_TYPE_icommon__degreeOfConformity_
#define SOAP_TYPE_icommon__degreeOfConformity_ (417)
#endif

/* icommon__spatialDataServiceType_ has binding name 'icommon__spatialDataServiceType_' for type 'icommon:spatialDataServiceType' */
#ifndef SOAP_TYPE_icommon__spatialDataServiceType_
#define SOAP_TYPE_icommon__spatialDataServiceType_ (415)
#endif

/* icommon__resourceType_ has binding name 'icommon__resourceType_' for type 'icommon:resourceType' */
#ifndef SOAP_TYPE_icommon__resourceType_
#define SOAP_TYPE_icommon__resourceType_ (413)
#endif

/* icommon__iso8601Date__ has binding name 'icommon__iso8601Date__' for type 'icommon:iso8601Date' */
#ifndef SOAP_TYPE_icommon__iso8601Date__
#define SOAP_TYPE_icommon__iso8601Date__ (411)
#endif

/* icommon__iso8601Date has binding name 'icommon__iso8601Date' for type 'icommon:iso8601Date' */
#ifndef SOAP_TYPE_icommon__iso8601Date
#define SOAP_TYPE_icommon__iso8601Date (410)
#endif

/* icommon__emailType__ has binding name 'icommon__emailType__' for type 'icommon:emailType' */
#ifndef SOAP_TYPE_icommon__emailType__
#define SOAP_TYPE_icommon__emailType__ (409)
#endif

/* icommon__emailType has binding name 'icommon__emailType' for type 'icommon:emailType' */
#ifndef SOAP_TYPE_icommon__emailType
#define SOAP_TYPE_icommon__emailType (408)
#endif

/* icommon__mediaType_ has binding name 'icommon__mediaType_' for type 'icommon:mediaType' */
#ifndef SOAP_TYPE_icommon__mediaType_
#define SOAP_TYPE_icommon__mediaType_ (407)
#endif

/* icommon__notEmptyString__ has binding name 'icommon__notEmptyString__' for type 'icommon:notEmptyString' */
#ifndef SOAP_TYPE_icommon__notEmptyString__
#define SOAP_TYPE_icommon__notEmptyString__ (405)
#endif

/* icommon__notEmptyString has binding name 'icommon__notEmptyString' for type 'icommon:notEmptyString' */
#ifndef SOAP_TYPE_icommon__notEmptyString
#define SOAP_TYPE_icommon__notEmptyString (404)
#endif

/* icommon__topicCategory_ has binding name 'icommon__topicCategory_' for type 'icommon:topicCategory' */
#ifndef SOAP_TYPE_icommon__topicCategory_
#define SOAP_TYPE_icommon__topicCategory_ (403)
#endif

/* fes__SortOrderType_ has binding name 'fes__SortOrderType_' for type 'fes:SortOrderType' */
#ifndef SOAP_TYPE_fes__SortOrderType_
#define SOAP_TYPE_fes__SortOrderType_ (401)
#endif

/* fes__UomURI__ has binding name 'fes__UomURI__' for type 'fes:UomURI' */
#ifndef SOAP_TYPE_fes__UomURI__
#define SOAP_TYPE_fes__UomURI__ (399)
#endif

/* fes__UomSymbol__ has binding name 'fes__UomSymbol__' for type 'fes:UomSymbol' */
#ifndef SOAP_TYPE_fes__UomSymbol__
#define SOAP_TYPE_fes__UomSymbol__ (397)
#endif

/* fes__UomSymbol has binding name 'fes__UomSymbol' for type 'fes:UomSymbol' */
#ifndef SOAP_TYPE_fes__UomSymbol
#define SOAP_TYPE_fes__UomSymbol (396)
#endif

/* fes__MatchActionType_ has binding name 'fes__MatchActionType_' for type 'fes:MatchActionType' */
#ifndef SOAP_TYPE_fes__MatchActionType_
#define SOAP_TYPE_fes__MatchActionType_ (395)
#endif

/* fes__VersionActionTokens_ has binding name 'fes__VersionActionTokens_' for type 'fes:VersionActionTokens' */
#ifndef SOAP_TYPE_fes__VersionActionTokens_
#define SOAP_TYPE_fes__VersionActionTokens_ (393)
#endif

/* fes__SchemaElement__ has binding name 'fes__SchemaElement__' for type 'fes:SchemaElement' */
#ifndef SOAP_TYPE_fes__SchemaElement__
#define SOAP_TYPE_fes__SchemaElement__ (391)
#endif

/* fes__SchemaElement has binding name 'fes__SchemaElement' for type 'fes:SchemaElement' */
#ifndef SOAP_TYPE_fes__SchemaElement
#define SOAP_TYPE_fes__SchemaElement (390)
#endif

/* xlink__toType__ has binding name 'xlink__toType__' for type 'xlink:toType' */
#ifndef SOAP_TYPE_xlink__toType__
#define SOAP_TYPE_xlink__toType__ (389)
#endif

/* xlink__fromType__ has binding name 'xlink__fromType__' for type 'xlink:fromType' */
#ifndef SOAP_TYPE_xlink__fromType__
#define SOAP_TYPE_xlink__fromType__ (387)
#endif

/* xlink__labelType__ has binding name 'xlink__labelType__' for type 'xlink:labelType' */
#ifndef SOAP_TYPE_xlink__labelType__
#define SOAP_TYPE_xlink__labelType__ (385)
#endif

/* xlink__actuateType_ has binding name 'xlink__actuateType_' for type 'xlink:actuateType' */
#ifndef SOAP_TYPE_xlink__actuateType_
#define SOAP_TYPE_xlink__actuateType_ (383)
#endif

/* xlink__showType_ has binding name 'xlink__showType_' for type 'xlink:showType' */
#ifndef SOAP_TYPE_xlink__showType_
#define SOAP_TYPE_xlink__showType_ (381)
#endif

/* xlink__titleAttrType__ has binding name 'xlink__titleAttrType__' for type 'xlink:titleAttrType' */
#ifndef SOAP_TYPE_xlink__titleAttrType__
#define SOAP_TYPE_xlink__titleAttrType__ (379)
#endif

/* xlink__titleAttrType has binding name 'xlink__titleAttrType' for type 'xlink:titleAttrType' */
#ifndef SOAP_TYPE_xlink__titleAttrType
#define SOAP_TYPE_xlink__titleAttrType (378)
#endif

/* xlink__arcroleType__ has binding name 'xlink__arcroleType__' for type 'xlink:arcroleType' */
#ifndef SOAP_TYPE_xlink__arcroleType__
#define SOAP_TYPE_xlink__arcroleType__ (377)
#endif

/* xlink__roleType__ has binding name 'xlink__roleType__' for type 'xlink:roleType' */
#ifndef SOAP_TYPE_xlink__roleType__
#define SOAP_TYPE_xlink__roleType__ (375)
#endif

/* xlink__hrefType__ has binding name 'xlink__hrefType__' for type 'xlink:hrefType' */
#ifndef SOAP_TYPE_xlink__hrefType__
#define SOAP_TYPE_xlink__hrefType__ (373)
#endif

/* xlink__typeType_ has binding name 'xlink__typeType_' for type 'xlink:typeType' */
#ifndef SOAP_TYPE_xlink__typeType_
#define SOAP_TYPE_xlink__typeType_ (371)
#endif

/* ows__UpdateSequenceType__ has binding name 'ows__UpdateSequenceType__' for type 'ows:UpdateSequenceType' */
#ifndef SOAP_TYPE_ows__UpdateSequenceType__
#define SOAP_TYPE_ows__UpdateSequenceType__ (368)
#endif

/* ows__UpdateSequenceType has binding name 'ows__UpdateSequenceType' for type 'ows:UpdateSequenceType' */
#ifndef SOAP_TYPE_ows__UpdateSequenceType
#define SOAP_TYPE_ows__UpdateSequenceType (367)
#endif

/* ows__ServiceType__ has binding name 'ows__ServiceType__' for type 'ows:ServiceType' */
#ifndef SOAP_TYPE_ows__ServiceType__
#define SOAP_TYPE_ows__ServiceType__ (366)
#endif

/* ows__ServiceType has binding name 'ows__ServiceType' for type 'ows:ServiceType' */
#ifndef SOAP_TYPE_ows__ServiceType
#define SOAP_TYPE_ows__ServiceType (365)
#endif

/* ows__PositionType2D has binding name 'ows__PositionType2D' for type 'ows:PositionType2D' */
#ifndef SOAP_TYPE_ows__PositionType2D
#define SOAP_TYPE_ows__PositionType2D (364)
#endif

/* ows__VersionType__ has binding name 'ows__VersionType__' for type 'ows:VersionType' */
#ifndef SOAP_TYPE_ows__VersionType__
#define SOAP_TYPE_ows__VersionType__ (363)
#endif

/* ows__VersionType has binding name 'ows__VersionType' for type 'ows:VersionType' */
#ifndef SOAP_TYPE_ows__VersionType
#define SOAP_TYPE_ows__VersionType (362)
#endif

/* ows__MimeType__ has binding name 'ows__MimeType__' for type 'ows:MimeType' */
#ifndef SOAP_TYPE_ows__MimeType__
#define SOAP_TYPE_ows__MimeType__ (361)
#endif

/* ows__MimeType has binding name 'ows__MimeType' for type 'ows:MimeType' */
#ifndef SOAP_TYPE_ows__MimeType
#define SOAP_TYPE_ows__MimeType (360)
#endif

/* wfs__UpdateActionType_ has binding name 'wfs__UpdateActionType_' for type 'wfs:UpdateActionType' */
#ifndef SOAP_TYPE_wfs__UpdateActionType_
#define SOAP_TYPE_wfs__UpdateActionType_ (359)
#endif

/* wfs__AllSomeType_ has binding name 'wfs__AllSomeType_' for type 'wfs:AllSomeType' */
#ifndef SOAP_TYPE_wfs__AllSomeType_
#define SOAP_TYPE_wfs__AllSomeType_ (357)
#endif

/* wfs__StarStringType_ has binding name 'wfs__StarStringType_' for type 'wfs:StarStringType' */
#ifndef SOAP_TYPE_wfs__StarStringType_
#define SOAP_TYPE_wfs__StarStringType_ (355)
#endif

/* wfs__ResolveValueType_ has binding name 'wfs__ResolveValueType_' for type 'wfs:ResolveValueType' */
#ifndef SOAP_TYPE_wfs__ResolveValueType_
#define SOAP_TYPE_wfs__ResolveValueType_ (353)
#endif

/* wfs__ResultTypeType_ has binding name 'wfs__ResultTypeType_' for type 'wfs:ResultTypeType' */
#ifndef SOAP_TYPE_wfs__ResultTypeType_
#define SOAP_TYPE_wfs__ResultTypeType_ (351)
#endif

/* wfs__VersionStringType__ has binding name 'wfs__VersionStringType__' for type 'wfs:VersionStringType' */
#ifndef SOAP_TYPE_wfs__VersionStringType__
#define SOAP_TYPE_wfs__VersionStringType__ (349)
#endif

/* wfs__VersionStringType has binding name 'wfs__VersionStringType' for type 'wfs:VersionStringType' */
#ifndef SOAP_TYPE_wfs__VersionStringType
#define SOAP_TYPE_wfs__VersionStringType (348)
#endif

/* fes__TemporalOperatorNameType has binding name 'fes__TemporalOperatorNameType' for type 'fes:TemporalOperatorNameType' */
#ifndef SOAP_TYPE_fes__TemporalOperatorNameType
#define SOAP_TYPE_fes__TemporalOperatorNameType (347)
#endif

/* fes__SpatialOperatorNameType has binding name 'fes__SpatialOperatorNameType' for type 'fes:SpatialOperatorNameType' */
#ifndef SOAP_TYPE_fes__SpatialOperatorNameType
#define SOAP_TYPE_fes__SpatialOperatorNameType (346)
#endif

/* fes__ComparisonOperatorNameType has binding name 'fes__ComparisonOperatorNameType' for type 'fes:ComparisonOperatorNameType' */
#ifndef SOAP_TYPE_fes__ComparisonOperatorNameType
#define SOAP_TYPE_fes__ComparisonOperatorNameType (345)
#endif

/* fes__UomIdentifier has binding name 'fes__UomIdentifier' for type 'fes:UomIdentifier' */
#ifndef SOAP_TYPE_fes__UomIdentifier
#define SOAP_TYPE_fes__UomIdentifier (344)
#endif

/* fes__VersionType has binding name 'fes__VersionType' for type 'fes:VersionType' */
#ifndef SOAP_TYPE_fes__VersionType
#define SOAP_TYPE_fes__VersionType (343)
#endif

/* fes__AliasesType has binding name 'fes__AliasesType' for type 'fes:AliasesType' */
#ifndef SOAP_TYPE_fes__AliasesType
#define SOAP_TYPE_fes__AliasesType (342)
#endif

/* fes__TypeNamesType has binding name 'fes__TypeNamesType' for type 'fes:TypeNamesType' */
#ifndef SOAP_TYPE_fes__TypeNamesType
#define SOAP_TYPE_fes__TypeNamesType (341)
#endif

/* fes__TypeNamesListType has binding name 'fes__TypeNamesListType' for type 'fes:TypeNamesListType' */
#ifndef SOAP_TYPE_fes__TypeNamesListType
#define SOAP_TYPE_fes__TypeNamesListType (340)
#endif

/* ows__PositionType has binding name 'ows__PositionType' for type 'ows:PositionType' */
#ifndef SOAP_TYPE_ows__PositionType
#define SOAP_TYPE_ows__PositionType (339)
#endif

/* wfs__StateValueType has binding name 'wfs__StateValueType' for type 'wfs:StateValueType' */
#ifndef SOAP_TYPE_wfs__StateValueType
#define SOAP_TYPE_wfs__StateValueType (337)
#endif

/* wfs__nonNegativeIntegerOrUnknown has binding name 'wfs__nonNegativeIntegerOrUnknown' for type 'wfs:nonNegativeIntegerOrUnknown' */
#ifndef SOAP_TYPE_wfs__nonNegativeIntegerOrUnknown
#define SOAP_TYPE_wfs__nonNegativeIntegerOrUnknown (336)
#endif

/* wfs__positiveIntegerWithStar has binding name 'wfs__positiveIntegerWithStar' for type 'wfs:positiveIntegerWithStar' */
#ifndef SOAP_TYPE_wfs__positiveIntegerWithStar
#define SOAP_TYPE_wfs__positiveIntegerWithStar (335)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (334)
#endif

/* _icommon__IntervalOfDates has binding name '_icommon__IntervalOfDates' for type '' */
#ifndef SOAP_TYPE__icommon__IntervalOfDates
#define SOAP_TYPE__icommon__IntervalOfDates (333)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005fswe has binding name 'icommon__citationInspireInteroperabilityRegulation_x005fswe' for type 'icommon:citationInspireInteroperabilityRegulation_swe' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fswe
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fswe (332)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fswe has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005fswe' for type 'icommon:resLocInspireInteroperabilityRegulation_swe' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fswe
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fswe (331)
#endif

/* icommon__inspireTheme_x005fswe has binding name 'icommon__inspireTheme_x005fswe' for type 'icommon:inspireTheme_swe' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fswe
#define SOAP_TYPE_icommon__inspireTheme_x005fswe (330)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fspa has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005fspa' for type 'icommon:resLocInspireInteroperabilityRegulation_spa' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fspa
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fspa (329)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005fspa has binding name 'icommon__citationInspireInteroperabilityRegulation_x005fspa' for type 'icommon:citationInspireInteroperabilityRegulation_spa' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fspa
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fspa (328)
#endif

/* icommon__inspireTheme_x005fspa has binding name 'icommon__inspireTheme_x005fspa' for type 'icommon:inspireTheme_spa' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fspa
#define SOAP_TYPE_icommon__inspireTheme_x005fspa (327)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005fslv has binding name 'icommon__citationInspireInteroperabilityRegulation_x005fslv' for type 'icommon:citationInspireInteroperabilityRegulation_slv' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fslv
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fslv (326)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fslv has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005fslv' for type 'icommon:resLocInspireInteroperabilityRegulation_slv' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fslv
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fslv (325)
#endif

/* icommon__inspireTheme_x005fslv has binding name 'icommon__inspireTheme_x005fslv' for type 'icommon:inspireTheme_slv' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fslv
#define SOAP_TYPE_icommon__inspireTheme_x005fslv (324)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005fslo has binding name 'icommon__citationInspireInteroperabilityRegulation_x005fslo' for type 'icommon:citationInspireInteroperabilityRegulation_slo' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fslo
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fslo (323)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fslo has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005fslo' for type 'icommon:resLocInspireInteroperabilityRegulation_slo' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fslo
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fslo (322)
#endif

/* icommon__inspireTheme_x005fslo has binding name 'icommon__inspireTheme_x005fslo' for type 'icommon:inspireTheme_slo' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fslo
#define SOAP_TYPE_icommon__inspireTheme_x005fslo (321)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005frum has binding name 'icommon__citationInspireInteroperabilityRegulation_x005frum' for type 'icommon:citationInspireInteroperabilityRegulation_rum' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005frum
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005frum (320)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005frum has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005frum' for type 'icommon:resLocInspireInteroperabilityRegulation_rum' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005frum
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005frum (319)
#endif

/* icommon__inspireTheme_x005frum has binding name 'icommon__inspireTheme_x005frum' for type 'icommon:inspireTheme_rum' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005frum
#define SOAP_TYPE_icommon__inspireTheme_x005frum (318)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005fpor has binding name 'icommon__citationInspireInteroperabilityRegulation_x005fpor' for type 'icommon:citationInspireInteroperabilityRegulation_por' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fpor
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fpor (317)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fpor has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005fpor' for type 'icommon:resLocInspireInteroperabilityRegulation_por' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fpor
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fpor (316)
#endif

/* icommon__inspireTheme_x005fpor has binding name 'icommon__inspireTheme_x005fpor' for type 'icommon:inspireTheme_por' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fpor
#define SOAP_TYPE_icommon__inspireTheme_x005fpor (315)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005fpol has binding name 'icommon__citationInspireInteroperabilityRegulation_x005fpol' for type 'icommon:citationInspireInteroperabilityRegulation_pol' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fpol
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fpol (314)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fpol has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005fpol' for type 'icommon:resLocInspireInteroperabilityRegulation_pol' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fpol
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fpol (313)
#endif

/* icommon__inspireTheme_x005fpol has binding name 'icommon__inspireTheme_x005fpol' for type 'icommon:inspireTheme_pol' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fpol
#define SOAP_TYPE_icommon__inspireTheme_x005fpol (312)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005fmlt has binding name 'icommon__citationInspireInteroperabilityRegulation_x005fmlt' for type 'icommon:citationInspireInteroperabilityRegulation_mlt' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fmlt
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fmlt (311)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fmlt has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005fmlt' for type 'icommon:resLocInspireInteroperabilityRegulation_mlt' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fmlt
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fmlt (310)
#endif

/* icommon__inspireTheme_x005fmlt has binding name 'icommon__inspireTheme_x005fmlt' for type 'icommon:inspireTheme_mlt' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fmlt
#define SOAP_TYPE_icommon__inspireTheme_x005fmlt (309)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005flit has binding name 'icommon__citationInspireInteroperabilityRegulation_x005flit' for type 'icommon:citationInspireInteroperabilityRegulation_lit' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005flit
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005flit (308)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005flit has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005flit' for type 'icommon:resLocInspireInteroperabilityRegulation_lit' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005flit
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005flit (307)
#endif

/* icommon__inspireTheme_x005flit has binding name 'icommon__inspireTheme_x005flit' for type 'icommon:inspireTheme_lit' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005flit
#define SOAP_TYPE_icommon__inspireTheme_x005flit (306)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005flav has binding name 'icommon__citationInspireInteroperabilityRegulation_x005flav' for type 'icommon:citationInspireInteroperabilityRegulation_lav' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005flav
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005flav (305)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005flav has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005flav' for type 'icommon:resLocInspireInteroperabilityRegulation_lav' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005flav
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005flav (304)
#endif

/* icommon__inspireTheme_x005flav has binding name 'icommon__inspireTheme_x005flav' for type 'icommon:inspireTheme_lav' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005flav
#define SOAP_TYPE_icommon__inspireTheme_x005flav (303)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005fita has binding name 'icommon__citationInspireInteroperabilityRegulation_x005fita' for type 'icommon:citationInspireInteroperabilityRegulation_ita' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fita
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fita (302)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fita has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005fita' for type 'icommon:resLocInspireInteroperabilityRegulation_ita' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fita
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fita (301)
#endif

/* icommon__inspireTheme_x005fita has binding name 'icommon__inspireTheme_x005fita' for type 'icommon:inspireTheme_ita' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fita
#define SOAP_TYPE_icommon__inspireTheme_x005fita (300)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005fhun has binding name 'icommon__citationInspireInteroperabilityRegulation_x005fhun' for type 'icommon:citationInspireInteroperabilityRegulation_hun' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fhun
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fhun (299)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fhun has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005fhun' for type 'icommon:resLocInspireInteroperabilityRegulation_hun' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fhun
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fhun (298)
#endif

/* icommon__inspireTheme_x005fhun has binding name 'icommon__inspireTheme_x005fhun' for type 'icommon:inspireTheme_hun' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fhun
#define SOAP_TYPE_icommon__inspireTheme_x005fhun (297)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005fgre has binding name 'icommon__citationInspireInteroperabilityRegulation_x005fgre' for type 'icommon:citationInspireInteroperabilityRegulation_gre' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fgre
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fgre (296)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fgre has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005fgre' for type 'icommon:resLocInspireInteroperabilityRegulation_gre' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fgre
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fgre (295)
#endif

/* icommon__inspireTheme_x005fgre has binding name 'icommon__inspireTheme_x005fgre' for type 'icommon:inspireTheme_gre' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fgre
#define SOAP_TYPE_icommon__inspireTheme_x005fgre (294)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005fgle has binding name 'icommon__citationInspireInteroperabilityRegulation_x005fgle' for type 'icommon:citationInspireInteroperabilityRegulation_gle' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fgle
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fgle (293)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fgle has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005fgle' for type 'icommon:resLocInspireInteroperabilityRegulation_gle' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fgle
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fgle (292)
#endif

/* icommon__inspireTheme_x005fgle has binding name 'icommon__inspireTheme_x005fgle' for type 'icommon:inspireTheme_gle' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fgle
#define SOAP_TYPE_icommon__inspireTheme_x005fgle (291)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005fger has binding name 'icommon__citationInspireInteroperabilityRegulation_x005fger' for type 'icommon:citationInspireInteroperabilityRegulation_ger' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fger
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fger (290)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fger has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005fger' for type 'icommon:resLocInspireInteroperabilityRegulation_ger' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fger
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fger (289)
#endif

/* icommon__inspireTheme_x005fger has binding name 'icommon__inspireTheme_x005fger' for type 'icommon:inspireTheme_ger' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fger
#define SOAP_TYPE_icommon__inspireTheme_x005fger (288)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005ffre has binding name 'icommon__citationInspireInteroperabilityRegulation_x005ffre' for type 'icommon:citationInspireInteroperabilityRegulation_fre' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005ffre
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005ffre (287)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005ffre has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005ffre' for type 'icommon:resLocInspireInteroperabilityRegulation_fre' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005ffre
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005ffre (286)
#endif

/* icommon__inspireTheme_x005ffre has binding name 'icommon__inspireTheme_x005ffre' for type 'icommon:inspireTheme_fre' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005ffre
#define SOAP_TYPE_icommon__inspireTheme_x005ffre (285)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005ffin has binding name 'icommon__citationInspireInteroperabilityRegulation_x005ffin' for type 'icommon:citationInspireInteroperabilityRegulation_fin' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005ffin
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005ffin (284)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005ffin has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005ffin' for type 'icommon:resLocInspireInteroperabilityRegulation_fin' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005ffin
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005ffin (283)
#endif

/* icommon__inspireTheme_x005ffin has binding name 'icommon__inspireTheme_x005ffin' for type 'icommon:inspireTheme_fin' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005ffin
#define SOAP_TYPE_icommon__inspireTheme_x005ffin (282)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005fest has binding name 'icommon__citationInspireInteroperabilityRegulation_x005fest' for type 'icommon:citationInspireInteroperabilityRegulation_est' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fest
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fest (281)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fest has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005fest' for type 'icommon:resLocInspireInteroperabilityRegulation_est' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fest
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fest (280)
#endif

/* icommon__inspireTheme_x005fest has binding name 'icommon__inspireTheme_x005fest' for type 'icommon:inspireTheme_est' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fest
#define SOAP_TYPE_icommon__inspireTheme_x005fest (279)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005feng has binding name 'icommon__citationInspireInteroperabilityRegulation_x005feng' for type 'icommon:citationInspireInteroperabilityRegulation_eng' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005feng
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005feng (278)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005feng has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005feng' for type 'icommon:resLocInspireInteroperabilityRegulation_eng' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005feng
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005feng (277)
#endif

/* icommon__citationGEMETInspireThemes_x005feng has binding name 'icommon__citationGEMETInspireThemes_x005feng' for type 'icommon:citationGEMETInspireThemes_eng' */
#ifndef SOAP_TYPE_icommon__citationGEMETInspireThemes_x005feng
#define SOAP_TYPE_icommon__citationGEMETInspireThemes_x005feng (276)
#endif

/* icommon__resLocGEMETInspireThemes_x005feng has binding name 'icommon__resLocGEMETInspireThemes_x005feng' for type 'icommon:resLocGEMETInspireThemes_eng' */
#ifndef SOAP_TYPE_icommon__resLocGEMETInspireThemes_x005feng
#define SOAP_TYPE_icommon__resLocGEMETInspireThemes_x005feng (275)
#endif

/* icommon__inspireTheme_x005feng has binding name 'icommon__inspireTheme_x005feng' for type 'icommon:inspireTheme_eng' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005feng
#define SOAP_TYPE_icommon__inspireTheme_x005feng (274)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005fdut has binding name 'icommon__citationInspireInteroperabilityRegulation_x005fdut' for type 'icommon:citationInspireInteroperabilityRegulation_dut' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fdut
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fdut (273)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fdut has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005fdut' for type 'icommon:resLocInspireInteroperabilityRegulation_dut' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fdut
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fdut (272)
#endif

/* icommon__inspireTheme_x005fdut has binding name 'icommon__inspireTheme_x005fdut' for type 'icommon:inspireTheme_dut' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fdut
#define SOAP_TYPE_icommon__inspireTheme_x005fdut (271)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005fdan has binding name 'icommon__citationInspireInteroperabilityRegulation_x005fdan' for type 'icommon:citationInspireInteroperabilityRegulation_dan' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fdan
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fdan (270)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fdan has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005fdan' for type 'icommon:resLocInspireInteroperabilityRegulation_dan' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fdan
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fdan (269)
#endif

/* icommon__inspireTheme_x005fdan has binding name 'icommon__inspireTheme_x005fdan' for type 'icommon:inspireTheme_dan' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fdan
#define SOAP_TYPE_icommon__inspireTheme_x005fdan (268)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005fcze has binding name 'icommon__citationInspireInteroperabilityRegulation_x005fcze' for type 'icommon:citationInspireInteroperabilityRegulation_cze' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fcze
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fcze (267)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fcze has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005fcze' for type 'icommon:resLocInspireInteroperabilityRegulation_cze' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fcze
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fcze (266)
#endif

/* icommon__inspireTheme_x005fcze has binding name 'icommon__inspireTheme_x005fcze' for type 'icommon:inspireTheme_cze' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fcze
#define SOAP_TYPE_icommon__inspireTheme_x005fcze (265)
#endif

/* icommon__citationInspireInteroperabilityRegulation_x005fbul has binding name 'icommon__citationInspireInteroperabilityRegulation_x005fbul' for type 'icommon:citationInspireInteroperabilityRegulation_bul' */
#ifndef SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fbul
#define SOAP_TYPE_icommon__citationInspireInteroperabilityRegulation_x005fbul (264)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fbul has binding name 'icommon__resLocInspireInteroperabilityRegulation_x005fbul' for type 'icommon:resLocInspireInteroperabilityRegulation_bul' */
#ifndef SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fbul
#define SOAP_TYPE_icommon__resLocInspireInteroperabilityRegulation_x005fbul (263)
#endif

/* icommon__inspireTheme_x005fbul has binding name 'icommon__inspireTheme_x005fbul' for type 'icommon:inspireTheme_bul' */
#ifndef SOAP_TYPE_icommon__inspireTheme_x005fbul
#define SOAP_TYPE_icommon__inspireTheme_x005fbul (262)
#endif

/* icommon__otherService has binding name 'icommon__otherService' for type 'icommon:otherService' */
#ifndef SOAP_TYPE_icommon__otherService
#define SOAP_TYPE_icommon__otherService (261)
#endif

/* icommon__otherService_x005fext has binding name 'icommon__otherService_x005fext' for type 'icommon:otherService_ext' */
#ifndef SOAP_TYPE_icommon__otherService_x005fext
#define SOAP_TYPE_icommon__otherService_x005fext (260)
#endif

/* icommon__invokeService has binding name 'icommon__invokeService' for type 'icommon:invokeService' */
#ifndef SOAP_TYPE_icommon__invokeService
#define SOAP_TYPE_icommon__invokeService (259)
#endif

/* icommon__invokeService_x005fext has binding name 'icommon__invokeService_x005fext' for type 'icommon:invokeService_ext' */
#ifndef SOAP_TYPE_icommon__invokeService_x005fext
#define SOAP_TYPE_icommon__invokeService_x005fext (258)
#endif

/* icommon__transformationService has binding name 'icommon__transformationService' for type 'icommon:transformationService' */
#ifndef SOAP_TYPE_icommon__transformationService
#define SOAP_TYPE_icommon__transformationService (257)
#endif

/* icommon__transformationService_x005fext has binding name 'icommon__transformationService_x005fext' for type 'icommon:transformationService_ext' */
#ifndef SOAP_TYPE_icommon__transformationService_x005fext
#define SOAP_TYPE_icommon__transformationService_x005fext (256)
#endif

/* icommon__downloadService has binding name 'icommon__downloadService' for type 'icommon:downloadService' */
#ifndef SOAP_TYPE_icommon__downloadService
#define SOAP_TYPE_icommon__downloadService (255)
#endif

/* icommon__downloadService_x005fext has binding name 'icommon__downloadService_x005fext' for type 'icommon:downloadService_ext' */
#ifndef SOAP_TYPE_icommon__downloadService_x005fext
#define SOAP_TYPE_icommon__downloadService_x005fext (254)
#endif

/* icommon__viewService has binding name 'icommon__viewService' for type 'icommon:viewService' */
#ifndef SOAP_TYPE_icommon__viewService
#define SOAP_TYPE_icommon__viewService (253)
#endif

/* icommon__viewService_x005fext has binding name 'icommon__viewService_x005fext' for type 'icommon:viewService_ext' */
#ifndef SOAP_TYPE_icommon__viewService_x005fext
#define SOAP_TYPE_icommon__viewService_x005fext (252)
#endif

/* icommon__layers has binding name 'icommon__layers' for type 'icommon:layers' */
#ifndef SOAP_TYPE_icommon__layers
#define SOAP_TYPE_icommon__layers (251)
#endif

/* icommon__discoveryService has binding name 'icommon__discoveryService' for type 'icommon:discoveryService' */
#ifndef SOAP_TYPE_icommon__discoveryService
#define SOAP_TYPE_icommon__discoveryService (250)
#endif

/* icommon__discoveryService_x005fext has binding name 'icommon__discoveryService_x005fext' for type 'icommon:discoveryService_ext' */
#ifndef SOAP_TYPE_icommon__discoveryService_x005fext
#define SOAP_TYPE_icommon__discoveryService_x005fext (249)
#endif

/* icommon__supportedLanguagesType has binding name 'icommon__supportedLanguagesType' for type 'icommon:supportedLanguagesType' */
#ifndef SOAP_TYPE_icommon__supportedLanguagesType
#define SOAP_TYPE_icommon__supportedLanguagesType (248)
#endif

/* icommon__ExtendedCapabilitiesType has binding name 'icommon__ExtendedCapabilitiesType' for type 'icommon:ExtendedCapabilitiesType' */
#ifndef SOAP_TYPE_icommon__ExtendedCapabilitiesType
#define SOAP_TYPE_icommon__ExtendedCapabilitiesType (247)
#endif

/* icommon__inspireTheme has binding name 'icommon__inspireTheme' for type 'icommon:inspireTheme' */
#ifndef SOAP_TYPE_icommon__inspireTheme
#define SOAP_TYPE_icommon__inspireTheme (246)
#endif

/* icommon__uniqueResourceIdentifier has binding name 'icommon__uniqueResourceIdentifier' for type 'icommon:uniqueResourceIdentifier' */
#ifndef SOAP_TYPE_icommon__uniqueResourceIdentifier
#define SOAP_TYPE_icommon__uniqueResourceIdentifier (245)
#endif

/* icommon__spatialResolution has binding name 'icommon__spatialResolution' for type 'icommon:spatialResolution' */
#ifndef SOAP_TYPE_icommon__spatialResolution
#define SOAP_TYPE_icommon__spatialResolution (244)
#endif

/* icommon__geographicBoundingBox has binding name 'icommon__geographicBoundingBox' for type 'icommon:geographicBoundingBox' */
#ifndef SOAP_TYPE_icommon__geographicBoundingBox
#define SOAP_TYPE_icommon__geographicBoundingBox (243)
#endif

/* icommon__languageElementIETF has binding name 'icommon__languageElementIETF' for type 'icommon:languageElementIETF' */
#ifndef SOAP_TYPE_icommon__languageElementIETF
#define SOAP_TYPE_icommon__languageElementIETF (242)
#endif

/* icommon__languageElementISO6392B has binding name 'icommon__languageElementISO6392B' for type 'icommon:languageElementISO6392B' */
#ifndef SOAP_TYPE_icommon__languageElementISO6392B
#define SOAP_TYPE_icommon__languageElementISO6392B (241)
#endif

/* icommon__languageElement has binding name 'icommon__languageElement' for type 'icommon:languageElement' */
#ifndef SOAP_TYPE_icommon__languageElement
#define SOAP_TYPE_icommon__languageElement (240)
#endif

/* icommon__resourceLocatorType has binding name 'icommon__resourceLocatorType' for type 'icommon:resourceLocatorType' */
#ifndef SOAP_TYPE_icommon__resourceLocatorType
#define SOAP_TYPE_icommon__resourceLocatorType (239)
#endif

/* icommon__classificationOfSpatialDataService has binding name 'icommon__classificationOfSpatialDataService' for type 'icommon:classificationOfSpatialDataService' */
#ifndef SOAP_TYPE_icommon__classificationOfSpatialDataService
#define SOAP_TYPE_icommon__classificationOfSpatialDataService (238)
#endif

/* icommon__keyword has binding name 'icommon__keyword' for type 'icommon:keyword' */
#ifndef SOAP_TYPE_icommon__keyword
#define SOAP_TYPE_icommon__keyword (237)
#endif

/* icommon__temporalExtent has binding name 'icommon__temporalExtent' for type 'icommon:temporalExtent' */
#ifndef SOAP_TYPE_icommon__temporalExtent
#define SOAP_TYPE_icommon__temporalExtent (236)
#endif

/* icommon__temporalReference has binding name 'icommon__temporalReference' for type 'icommon:temporalReference' */
#ifndef SOAP_TYPE_icommon__temporalReference
#define SOAP_TYPE_icommon__temporalReference (235)
#endif

/* icommon__originatingControlledVocabularyMD has binding name 'icommon__originatingControlledVocabularyMD' for type 'icommon:originatingControlledVocabularyMD' */
#ifndef SOAP_TYPE_icommon__originatingControlledVocabularyMD
#define SOAP_TYPE_icommon__originatingControlledVocabularyMD (234)
#endif

/* icommon__originatingControlledVocabularyGemetInspireThemes has binding name 'icommon__originatingControlledVocabularyGemetInspireThemes' for type 'icommon:originatingControlledVocabularyGemetInspireThemes' */
#ifndef SOAP_TYPE_icommon__originatingControlledVocabularyGemetInspireThemes
#define SOAP_TYPE_icommon__originatingControlledVocabularyGemetInspireThemes (233)
#endif

/* icommon__originatingControlledVocabulary has binding name 'icommon__originatingControlledVocabulary' for type 'icommon:originatingControlledVocabulary' */
#ifndef SOAP_TYPE_icommon__originatingControlledVocabulary
#define SOAP_TYPE_icommon__originatingControlledVocabulary (232)
#endif

/* icommon__conformity has binding name 'icommon__conformity' for type 'icommon:conformity' */
#ifndef SOAP_TYPE_icommon__conformity
#define SOAP_TYPE_icommon__conformity (231)
#endif

/* icommon__citationConformity has binding name 'icommon__citationConformity' for type 'icommon:citationConformity' */
#ifndef SOAP_TYPE_icommon__citationConformity
#define SOAP_TYPE_icommon__citationConformity (230)
#endif

/* icommon__citation has binding name 'icommon__citation' for type 'icommon:citation' */
#ifndef SOAP_TYPE_icommon__citation
#define SOAP_TYPE_icommon__citation (229)
#endif

/* icommon__responsibleOrganisation has binding name 'icommon__responsibleOrganisation' for type 'icommon:responsibleOrganisation' */
#ifndef SOAP_TYPE_icommon__responsibleOrganisation
#define SOAP_TYPE_icommon__responsibleOrganisation (228)
#endif

/* icommon__metadataPointOfContact has binding name 'icommon__metadataPointOfContact' for type 'icommon:metadataPointOfContact' */
#ifndef SOAP_TYPE_icommon__metadataPointOfContact
#define SOAP_TYPE_icommon__metadataPointOfContact (227)
#endif

/* icommon__service has binding name 'icommon__service' for type 'icommon:service' */
#ifndef SOAP_TYPE_icommon__service
#define SOAP_TYPE_icommon__service (226)
#endif

/* icommon__service_x005fext has binding name 'icommon__service_x005fext' for type 'icommon:service_ext' */
#ifndef SOAP_TYPE_icommon__service_x005fext
#define SOAP_TYPE_icommon__service_x005fext (225)
#endif

/* icommon__series has binding name 'icommon__series' for type 'icommon:series' */
#ifndef SOAP_TYPE_icommon__series
#define SOAP_TYPE_icommon__series (224)
#endif

/* icommon__dataset has binding name 'icommon__dataset' for type 'icommon:dataset' */
#ifndef SOAP_TYPE_icommon__dataset
#define SOAP_TYPE_icommon__dataset (223)
#endif

/* icommon__data has binding name 'icommon__data' for type 'icommon:data' */
#ifndef SOAP_TYPE_icommon__data
#define SOAP_TYPE_icommon__data (222)
#endif

/* icommon__resource has binding name 'icommon__resource' for type 'icommon:resource' */
#ifndef SOAP_TYPE_icommon__resource
#define SOAP_TYPE_icommon__resource (221)
#endif

/* _fes__LogicalOperators has binding name '_fes__LogicalOperators' for type '' */
#ifndef SOAP_TYPE__fes__LogicalOperators
#define SOAP_TYPE__fes__LogicalOperators (220)
#endif

/* _fes__Filter_x005fCapabilities has binding name '_fes__Filter_x005fCapabilities' for type '' */
#ifndef SOAP_TYPE__fes__Filter_x005fCapabilities
#define SOAP_TYPE__fes__Filter_x005fCapabilities (219)
#endif

/* fes__SortPropertyType has binding name 'fes__SortPropertyType' for type 'fes:SortPropertyType' */
#ifndef SOAP_TYPE_fes__SortPropertyType
#define SOAP_TYPE_fes__SortPropertyType (218)
#endif

/* fes__SortByType has binding name 'fes__SortByType' for type 'fes:SortByType' */
#ifndef SOAP_TYPE_fes__SortByType
#define SOAP_TYPE_fes__SortByType (217)
#endif

/* fes__ExtensionOperatorType has binding name 'fes__ExtensionOperatorType' for type 'fes:ExtensionOperatorType' */
#ifndef SOAP_TYPE_fes__ExtensionOperatorType
#define SOAP_TYPE_fes__ExtensionOperatorType (216)
#endif

/* fes__AdditionalOperatorsType has binding name 'fes__AdditionalOperatorsType' for type 'fes:AdditionalOperatorsType' */
#ifndef SOAP_TYPE_fes__AdditionalOperatorsType
#define SOAP_TYPE_fes__AdditionalOperatorsType (215)
#endif

/* fes__Extended_x005fCapabilitiesType has binding name 'fes__Extended_x005fCapabilitiesType' for type 'fes:Extended_CapabilitiesType' */
#ifndef SOAP_TYPE_fes__Extended_x005fCapabilitiesType
#define SOAP_TYPE_fes__Extended_x005fCapabilitiesType (214)
#endif

/* fes__TemporalOperatorType has binding name 'fes__TemporalOperatorType' for type 'fes:TemporalOperatorType' */
#ifndef SOAP_TYPE_fes__TemporalOperatorType
#define SOAP_TYPE_fes__TemporalOperatorType (213)
#endif

/* fes__TemporalOperatorsType has binding name 'fes__TemporalOperatorsType' for type 'fes:TemporalOperatorsType' */
#ifndef SOAP_TYPE_fes__TemporalOperatorsType
#define SOAP_TYPE_fes__TemporalOperatorsType (212)
#endif

/* fes__TemporalOperandsType has binding name 'fes__TemporalOperandsType' for type 'fes:TemporalOperandsType' */
#ifndef SOAP_TYPE_fes__TemporalOperandsType
#define SOAP_TYPE_fes__TemporalOperandsType (211)
#endif

/* fes__Temporal_x005fCapabilitiesType has binding name 'fes__Temporal_x005fCapabilitiesType' for type 'fes:Temporal_CapabilitiesType' */
#ifndef SOAP_TYPE_fes__Temporal_x005fCapabilitiesType
#define SOAP_TYPE_fes__Temporal_x005fCapabilitiesType (210)
#endif

/* fes__SpatialOperatorType has binding name 'fes__SpatialOperatorType' for type 'fes:SpatialOperatorType' */
#ifndef SOAP_TYPE_fes__SpatialOperatorType
#define SOAP_TYPE_fes__SpatialOperatorType (209)
#endif

/* fes__SpatialOperatorsType has binding name 'fes__SpatialOperatorsType' for type 'fes:SpatialOperatorsType' */
#ifndef SOAP_TYPE_fes__SpatialOperatorsType
#define SOAP_TYPE_fes__SpatialOperatorsType (208)
#endif

/* fes__GeometryOperandsType has binding name 'fes__GeometryOperandsType' for type 'fes:GeometryOperandsType' */
#ifndef SOAP_TYPE_fes__GeometryOperandsType
#define SOAP_TYPE_fes__GeometryOperandsType (207)
#endif

/* fes__Spatial_x005fCapabilitiesType has binding name 'fes__Spatial_x005fCapabilitiesType' for type 'fes:Spatial_CapabilitiesType' */
#ifndef SOAP_TYPE_fes__Spatial_x005fCapabilitiesType
#define SOAP_TYPE_fes__Spatial_x005fCapabilitiesType (206)
#endif

/* fes__ArgumentType has binding name 'fes__ArgumentType' for type 'fes:ArgumentType' */
#ifndef SOAP_TYPE_fes__ArgumentType
#define SOAP_TYPE_fes__ArgumentType (205)
#endif

/* fes__ArgumentsType has binding name 'fes__ArgumentsType' for type 'fes:ArgumentsType' */
#ifndef SOAP_TYPE_fes__ArgumentsType
#define SOAP_TYPE_fes__ArgumentsType (204)
#endif

/* fes__AvailableFunctionType has binding name 'fes__AvailableFunctionType' for type 'fes:AvailableFunctionType' */
#ifndef SOAP_TYPE_fes__AvailableFunctionType
#define SOAP_TYPE_fes__AvailableFunctionType (203)
#endif

/* fes__AvailableFunctionsType has binding name 'fes__AvailableFunctionsType' for type 'fes:AvailableFunctionsType' */
#ifndef SOAP_TYPE_fes__AvailableFunctionsType
#define SOAP_TYPE_fes__AvailableFunctionsType (202)
#endif

/* fes__ComparisonOperatorType has binding name 'fes__ComparisonOperatorType' for type 'fes:ComparisonOperatorType' */
#ifndef SOAP_TYPE_fes__ComparisonOperatorType
#define SOAP_TYPE_fes__ComparisonOperatorType (201)
#endif

/* fes__ComparisonOperatorsType has binding name 'fes__ComparisonOperatorsType' for type 'fes:ComparisonOperatorsType' */
#ifndef SOAP_TYPE_fes__ComparisonOperatorsType
#define SOAP_TYPE_fes__ComparisonOperatorsType (200)
#endif

/* fes__Scalar_x005fCapabilitiesType has binding name 'fes__Scalar_x005fCapabilitiesType' for type 'fes:Scalar_CapabilitiesType' */
#ifndef SOAP_TYPE_fes__Scalar_x005fCapabilitiesType
#define SOAP_TYPE_fes__Scalar_x005fCapabilitiesType (199)
#endif

/* fes__ResourceIdentifierType has binding name 'fes__ResourceIdentifierType' for type 'fes:ResourceIdentifierType' */
#ifndef SOAP_TYPE_fes__ResourceIdentifierType
#define SOAP_TYPE_fes__ResourceIdentifierType (198)
#endif

/* fes__Id_x005fCapabilitiesType has binding name 'fes__Id_x005fCapabilitiesType' for type 'fes:Id_CapabilitiesType' */
#ifndef SOAP_TYPE_fes__Id_x005fCapabilitiesType
#define SOAP_TYPE_fes__Id_x005fCapabilitiesType (197)
#endif

/* fes__ConformanceType has binding name 'fes__ConformanceType' for type 'fes:ConformanceType' */
#ifndef SOAP_TYPE_fes__ConformanceType
#define SOAP_TYPE_fes__ConformanceType (196)
#endif

/* fes__LiteralType has binding name 'fes__LiteralType' for type 'fes:LiteralType' */
#ifndef SOAP_TYPE_fes__LiteralType
#define SOAP_TYPE_fes__LiteralType (195)
#endif

/* fes__FunctionType has binding name 'fes__FunctionType' for type 'fes:FunctionType' */
#ifndef SOAP_TYPE_fes__FunctionType
#define SOAP_TYPE_fes__FunctionType (194)
#endif

/* fes__MeasureType has binding name 'fes__MeasureType' for type 'fes:MeasureType' */
#ifndef SOAP_TYPE_fes__MeasureType
#define SOAP_TYPE_fes__MeasureType (193)
#endif

/* fes__UnaryLogicOpType has binding name 'fes__UnaryLogicOpType' for type 'fes:UnaryLogicOpType' */
#ifndef SOAP_TYPE_fes__UnaryLogicOpType
#define SOAP_TYPE_fes__UnaryLogicOpType (192)
#endif

/* fes__BinaryLogicOpType has binding name 'fes__BinaryLogicOpType' for type 'fes:BinaryLogicOpType' */
#ifndef SOAP_TYPE_fes__BinaryLogicOpType
#define SOAP_TYPE_fes__BinaryLogicOpType (191)
#endif

/* fes__DistanceBufferType has binding name 'fes__DistanceBufferType' for type 'fes:DistanceBufferType' */
#ifndef SOAP_TYPE_fes__DistanceBufferType
#define SOAP_TYPE_fes__DistanceBufferType (190)
#endif

/* fes__BBOXType has binding name 'fes__BBOXType' for type 'fes:BBOXType' */
#ifndef SOAP_TYPE_fes__BBOXType
#define SOAP_TYPE_fes__BBOXType (189)
#endif

/* fes__BinaryTemporalOpType has binding name 'fes__BinaryTemporalOpType' for type 'fes:BinaryTemporalOpType' */
#ifndef SOAP_TYPE_fes__BinaryTemporalOpType
#define SOAP_TYPE_fes__BinaryTemporalOpType (188)
#endif

/* fes__BinarySpatialOpType has binding name 'fes__BinarySpatialOpType' for type 'fes:BinarySpatialOpType' */
#ifndef SOAP_TYPE_fes__BinarySpatialOpType
#define SOAP_TYPE_fes__BinarySpatialOpType (187)
#endif

/* fes__UpperBoundaryType has binding name 'fes__UpperBoundaryType' for type 'fes:UpperBoundaryType' */
#ifndef SOAP_TYPE_fes__UpperBoundaryType
#define SOAP_TYPE_fes__UpperBoundaryType (186)
#endif

/* fes__LowerBoundaryType has binding name 'fes__LowerBoundaryType' for type 'fes:LowerBoundaryType' */
#ifndef SOAP_TYPE_fes__LowerBoundaryType
#define SOAP_TYPE_fes__LowerBoundaryType (185)
#endif

/* fes__PropertyIsBetweenType has binding name 'fes__PropertyIsBetweenType' for type 'fes:PropertyIsBetweenType' */
#ifndef SOAP_TYPE_fes__PropertyIsBetweenType
#define SOAP_TYPE_fes__PropertyIsBetweenType (184)
#endif

/* fes__PropertyIsNilType has binding name 'fes__PropertyIsNilType' for type 'fes:PropertyIsNilType' */
#ifndef SOAP_TYPE_fes__PropertyIsNilType
#define SOAP_TYPE_fes__PropertyIsNilType (183)
#endif

/* fes__PropertyIsNullType has binding name 'fes__PropertyIsNullType' for type 'fes:PropertyIsNullType' */
#ifndef SOAP_TYPE_fes__PropertyIsNullType
#define SOAP_TYPE_fes__PropertyIsNullType (182)
#endif

/* fes__PropertyIsLikeType has binding name 'fes__PropertyIsLikeType' for type 'fes:PropertyIsLikeType' */
#ifndef SOAP_TYPE_fes__PropertyIsLikeType
#define SOAP_TYPE_fes__PropertyIsLikeType (181)
#endif

/* fes__BinaryComparisonOpType has binding name 'fes__BinaryComparisonOpType' for type 'fes:BinaryComparisonOpType' */
#ifndef SOAP_TYPE_fes__BinaryComparisonOpType
#define SOAP_TYPE_fes__BinaryComparisonOpType (180)
#endif

/* fes__ResourceIdType has binding name 'fes__ResourceIdType' for type 'fes:ResourceIdType' */
#ifndef SOAP_TYPE_fes__ResourceIdType
#define SOAP_TYPE_fes__ResourceIdType (179)
#endif

/* fes__AbstractIdType has binding name 'fes__AbstractIdType' for type 'fes:AbstractIdType' */
#ifndef SOAP_TYPE_fes__AbstractIdType
#define SOAP_TYPE_fes__AbstractIdType (178)
#endif

/* fes__ExtensionOpsType has binding name 'fes__ExtensionOpsType' for type 'fes:ExtensionOpsType' */
#ifndef SOAP_TYPE_fes__ExtensionOpsType
#define SOAP_TYPE_fes__ExtensionOpsType (177)
#endif

/* fes__LogicOpsType has binding name 'fes__LogicOpsType' for type 'fes:LogicOpsType' */
#ifndef SOAP_TYPE_fes__LogicOpsType
#define SOAP_TYPE_fes__LogicOpsType (176)
#endif

/* fes__TemporalOpsType has binding name 'fes__TemporalOpsType' for type 'fes:TemporalOpsType' */
#ifndef SOAP_TYPE_fes__TemporalOpsType
#define SOAP_TYPE_fes__TemporalOpsType (175)
#endif

/* fes__SpatialOpsType has binding name 'fes__SpatialOpsType' for type 'fes:SpatialOpsType' */
#ifndef SOAP_TYPE_fes__SpatialOpsType
#define SOAP_TYPE_fes__SpatialOpsType (174)
#endif

/* fes__ComparisonOpsType has binding name 'fes__ComparisonOpsType' for type 'fes:ComparisonOpsType' */
#ifndef SOAP_TYPE_fes__ComparisonOpsType
#define SOAP_TYPE_fes__ComparisonOpsType (173)
#endif

/* fes__FilterType has binding name 'fes__FilterType' for type 'fes:FilterType' */
#ifndef SOAP_TYPE_fes__FilterType
#define SOAP_TYPE_fes__FilterType (172)
#endif

/* fes__AbstractSortingClauseType has binding name 'fes__AbstractSortingClauseType' for type 'fes:AbstractSortingClauseType' */
#ifndef SOAP_TYPE_fes__AbstractSortingClauseType
#define SOAP_TYPE_fes__AbstractSortingClauseType (171)
#endif

/* fes__AbstractSelectionClauseType has binding name 'fes__AbstractSelectionClauseType' for type 'fes:AbstractSelectionClauseType' */
#ifndef SOAP_TYPE_fes__AbstractSelectionClauseType
#define SOAP_TYPE_fes__AbstractSelectionClauseType (170)
#endif

/* fes__AbstractProjectionClauseType has binding name 'fes__AbstractProjectionClauseType' for type 'fes:AbstractProjectionClauseType' */
#ifndef SOAP_TYPE_fes__AbstractProjectionClauseType
#define SOAP_TYPE_fes__AbstractProjectionClauseType (169)
#endif

/* fes__AbstractAdhocQueryExpressionType has binding name 'fes__AbstractAdhocQueryExpressionType' for type 'fes:AbstractAdhocQueryExpressionType' */
#ifndef SOAP_TYPE_fes__AbstractAdhocQueryExpressionType
#define SOAP_TYPE_fes__AbstractAdhocQueryExpressionType (168)
#endif

/* fes__AbstractQueryExpressionType has binding name 'fes__AbstractQueryExpressionType' for type 'fes:AbstractQueryExpressionType' */
#ifndef SOAP_TYPE_fes__AbstractQueryExpressionType
#define SOAP_TYPE_fes__AbstractQueryExpressionType (167)
#endif

/* xlink__arcType has binding name 'xlink__arcType' for type 'xlink:arcType' */
#ifndef SOAP_TYPE_xlink__arcType
#define SOAP_TYPE_xlink__arcType (166)
#endif

/* xlink__locatorType has binding name 'xlink__locatorType' for type 'xlink:locatorType' */
#ifndef SOAP_TYPE_xlink__locatorType
#define SOAP_TYPE_xlink__locatorType (165)
#endif

/* xlink__resourceType has binding name 'xlink__resourceType' for type 'xlink:resourceType' */
#ifndef SOAP_TYPE_xlink__resourceType
#define SOAP_TYPE_xlink__resourceType (164)
#endif

/* xlink__titleEltType has binding name 'xlink__titleEltType' for type 'xlink:titleEltType' */
#ifndef SOAP_TYPE_xlink__titleEltType
#define SOAP_TYPE_xlink__titleEltType (163)
#endif

/* xlink__extended has binding name 'xlink__extended' for type 'xlink:extended' */
#ifndef SOAP_TYPE_xlink__extended
#define SOAP_TYPE_xlink__extended (162)
#endif

/* xlink__simple has binding name 'xlink__simple' for type 'xlink:simple' */
#ifndef SOAP_TYPE_xlink__simple
#define SOAP_TYPE_xlink__simple (161)
#endif

/* idls__ExtendedCapabilitiesType has binding name 'idls__ExtendedCapabilitiesType' for type 'idls:ExtendedCapabilitiesType' */
#ifndef SOAP_TYPE_idls__ExtendedCapabilitiesType
#define SOAP_TYPE_idls__ExtendedCapabilitiesType (160)
#endif

/* _ows__AllowedValues has binding name '_ows__AllowedValues' for type '' */
#ifndef SOAP_TYPE__ows__AllowedValues
#define SOAP_TYPE__ows__AllowedValues (159)
#endif

/* _ows__ValuesReference has binding name '_ows__ValuesReference' for type '' */
#ifndef SOAP_TYPE__ows__ValuesReference
#define SOAP_TYPE__ows__ValuesReference (158)
#endif

/* _ows__NoValues has binding name '_ows__NoValues' for type '' */
#ifndef SOAP_TYPE__ows__NoValues
#define SOAP_TYPE__ows__NoValues (157)
#endif

/* _ows__AnyValue has binding name '_ows__AnyValue' for type '' */
#ifndef SOAP_TYPE__ows__AnyValue
#define SOAP_TYPE__ows__AnyValue (156)
#endif

/* _ows__HTTP has binding name '_ows__HTTP' for type '' */
#ifndef SOAP_TYPE__ows__HTTP
#define SOAP_TYPE__ows__HTTP (155)
#endif

/* _ows__DCP has binding name '_ows__DCP' for type '' */
#ifndef SOAP_TYPE__ows__DCP
#define SOAP_TYPE__ows__DCP (154)
#endif

/* _ows__Operation has binding name '_ows__Operation' for type '' */
#ifndef SOAP_TYPE__ows__Operation
#define SOAP_TYPE__ows__Operation (153)
#endif

/* _ows__OperationsMetadata has binding name '_ows__OperationsMetadata' for type '' */
#ifndef SOAP_TYPE__ows__OperationsMetadata
#define SOAP_TYPE__ows__OperationsMetadata (152)
#endif

/* _ows__ServiceProvider has binding name '_ows__ServiceProvider' for type '' */
#ifndef SOAP_TYPE__ows__ServiceProvider
#define SOAP_TYPE__ows__ServiceProvider (151)
#endif

/* _ows__ServiceIdentification has binding name '_ows__ServiceIdentification' for type '' */
#ifndef SOAP_TYPE__ows__ServiceIdentification
#define SOAP_TYPE__ows__ServiceIdentification (150)
#endif

/* _ows__ExceptionReport has binding name '_ows__ExceptionReport' for type '' */
#ifndef SOAP_TYPE__ows__ExceptionReport
#define SOAP_TYPE__ows__ExceptionReport (148)
#endif

/* ows__ManifestType has binding name 'ows__ManifestType' for type 'ows:ManifestType' */
#ifndef SOAP_TYPE_ows__ManifestType
#define SOAP_TYPE_ows__ManifestType (147)
#endif

/* ows__ReferenceGroupType has binding name 'ows__ReferenceGroupType' for type 'ows:ReferenceGroupType' */
#ifndef SOAP_TYPE_ows__ReferenceGroupType
#define SOAP_TYPE_ows__ReferenceGroupType (146)
#endif

/* ows__ReferenceType has binding name 'ows__ReferenceType' for type 'ows:ReferenceType' */
#ifndef SOAP_TYPE_ows__ReferenceType
#define SOAP_TYPE_ows__ReferenceType (145)
#endif

/* ows__AbstractReferenceBaseType has binding name 'ows__AbstractReferenceBaseType' for type 'ows:AbstractReferenceBaseType' */
#ifndef SOAP_TYPE_ows__AbstractReferenceBaseType
#define SOAP_TYPE_ows__AbstractReferenceBaseType (144)
#endif

/* ows__ServiceReferenceType has binding name 'ows__ServiceReferenceType' for type 'ows:ServiceReferenceType' */
#ifndef SOAP_TYPE_ows__ServiceReferenceType
#define SOAP_TYPE_ows__ServiceReferenceType (143)
#endif

/* ows__DatasetDescriptionSummaryBaseType has binding name 'ows__DatasetDescriptionSummaryBaseType' for type 'ows:DatasetDescriptionSummaryBaseType' */
#ifndef SOAP_TYPE_ows__DatasetDescriptionSummaryBaseType
#define SOAP_TYPE_ows__DatasetDescriptionSummaryBaseType (142)
#endif

/* ows__ContentsBaseType has binding name 'ows__ContentsBaseType' for type 'ows:ContentsBaseType' */
#ifndef SOAP_TYPE_ows__ContentsBaseType
#define SOAP_TYPE_ows__ContentsBaseType (141)
#endif

/* ows__DomainMetadataType has binding name 'ows__DomainMetadataType' for type 'ows:DomainMetadataType' */
#ifndef SOAP_TYPE_ows__DomainMetadataType
#define SOAP_TYPE_ows__DomainMetadataType (140)
#endif

/* ows__RangeType has binding name 'ows__RangeType' for type 'ows:RangeType' */
#ifndef SOAP_TYPE_ows__RangeType
#define SOAP_TYPE_ows__RangeType (139)
#endif

/* ows__ValueType has binding name 'ows__ValueType' for type 'ows:ValueType' */
#ifndef SOAP_TYPE_ows__ValueType
#define SOAP_TYPE_ows__ValueType (138)
#endif

/* ows__UnNamedDomainType has binding name 'ows__UnNamedDomainType' for type 'ows:UnNamedDomainType' */
#ifndef SOAP_TYPE_ows__UnNamedDomainType
#define SOAP_TYPE_ows__UnNamedDomainType (137)
#endif

/* ows__DomainType has binding name 'ows__DomainType' for type 'ows:DomainType' */
#ifndef SOAP_TYPE_ows__DomainType
#define SOAP_TYPE_ows__DomainType (136)
#endif

/* ows__RequestMethodType has binding name 'ows__RequestMethodType' for type 'ows:RequestMethodType' */
#ifndef SOAP_TYPE_ows__RequestMethodType
#define SOAP_TYPE_ows__RequestMethodType (135)
#endif

/* ows__AcceptFormatsType has binding name 'ows__AcceptFormatsType' for type 'ows:AcceptFormatsType' */
#ifndef SOAP_TYPE_ows__AcceptFormatsType
#define SOAP_TYPE_ows__AcceptFormatsType (134)
#endif

/* ows__SectionsType has binding name 'ows__SectionsType' for type 'ows:SectionsType' */
#ifndef SOAP_TYPE_ows__SectionsType
#define SOAP_TYPE_ows__SectionsType (133)
#endif

/* ows__AcceptVersionsType has binding name 'ows__AcceptVersionsType' for type 'ows:AcceptVersionsType' */
#ifndef SOAP_TYPE_ows__AcceptVersionsType
#define SOAP_TYPE_ows__AcceptVersionsType (132)
#endif

/* ows__GetCapabilitiesType has binding name 'ows__GetCapabilitiesType' for type 'ows:GetCapabilitiesType' */
#ifndef SOAP_TYPE_ows__GetCapabilitiesType
#define SOAP_TYPE_ows__GetCapabilitiesType (131)
#endif

/* ows__CapabilitiesBaseType has binding name 'ows__CapabilitiesBaseType' for type 'ows:CapabilitiesBaseType' */
#ifndef SOAP_TYPE_ows__CapabilitiesBaseType
#define SOAP_TYPE_ows__CapabilitiesBaseType (130)
#endif

/* ows__AddressType has binding name 'ows__AddressType' for type 'ows:AddressType' */
#ifndef SOAP_TYPE_ows__AddressType
#define SOAP_TYPE_ows__AddressType (129)
#endif

/* ows__TelephoneType has binding name 'ows__TelephoneType' for type 'ows:TelephoneType' */
#ifndef SOAP_TYPE_ows__TelephoneType
#define SOAP_TYPE_ows__TelephoneType (128)
#endif

/* ows__OnlineResourceType has binding name 'ows__OnlineResourceType' for type 'ows:OnlineResourceType' */
#ifndef SOAP_TYPE_ows__OnlineResourceType
#define SOAP_TYPE_ows__OnlineResourceType (127)
#endif

/* ows__ContactType has binding name 'ows__ContactType' for type 'ows:ContactType' */
#ifndef SOAP_TYPE_ows__ContactType
#define SOAP_TYPE_ows__ContactType (126)
#endif

/* ows__ResponsiblePartySubsetType has binding name 'ows__ResponsiblePartySubsetType' for type 'ows:ResponsiblePartySubsetType' */
#ifndef SOAP_TYPE_ows__ResponsiblePartySubsetType
#define SOAP_TYPE_ows__ResponsiblePartySubsetType (125)
#endif

/* ows__ResponsiblePartyType has binding name 'ows__ResponsiblePartyType' for type 'ows:ResponsiblePartyType' */
#ifndef SOAP_TYPE_ows__ResponsiblePartyType
#define SOAP_TYPE_ows__ResponsiblePartyType (124)
#endif

/* ows__CodeType has binding name 'ows__CodeType' for type 'ows:CodeType' */
#ifndef SOAP_TYPE_ows__CodeType
#define SOAP_TYPE_ows__CodeType (123)
#endif

/* ows__KeywordsType has binding name 'ows__KeywordsType' for type 'ows:KeywordsType' */
#ifndef SOAP_TYPE_ows__KeywordsType
#define SOAP_TYPE_ows__KeywordsType (122)
#endif

/* ows__LanguageStringType has binding name 'ows__LanguageStringType' for type 'ows:LanguageStringType' */
#ifndef SOAP_TYPE_ows__LanguageStringType
#define SOAP_TYPE_ows__LanguageStringType (121)
#endif

/* ows__WGS84BoundingBoxType has binding name 'ows__WGS84BoundingBoxType' for type 'ows:WGS84BoundingBoxType' */
#ifndef SOAP_TYPE_ows__WGS84BoundingBoxType
#define SOAP_TYPE_ows__WGS84BoundingBoxType (120)
#endif

/* ows__BoundingBoxType has binding name 'ows__BoundingBoxType' for type 'ows:BoundingBoxType' */
#ifndef SOAP_TYPE_ows__BoundingBoxType
#define SOAP_TYPE_ows__BoundingBoxType (119)
#endif

/* ows__MetadataType has binding name 'ows__MetadataType' for type 'ows:MetadataType' */
#ifndef SOAP_TYPE_ows__MetadataType
#define SOAP_TYPE_ows__MetadataType (118)
#endif

/* ows__IdentificationType has binding name 'ows__IdentificationType' for type 'ows:IdentificationType' */
#ifndef SOAP_TYPE_ows__IdentificationType
#define SOAP_TYPE_ows__IdentificationType (117)
#endif

/* ows__BasicIdentificationType has binding name 'ows__BasicIdentificationType' for type 'ows:BasicIdentificationType' */
#ifndef SOAP_TYPE_ows__BasicIdentificationType
#define SOAP_TYPE_ows__BasicIdentificationType (116)
#endif

/* ows__DescriptionType has binding name 'ows__DescriptionType' for type 'ows:DescriptionType' */
#ifndef SOAP_TYPE_ows__DescriptionType
#define SOAP_TYPE_ows__DescriptionType (115)
#endif

/* ows__GetResourceByIdType has binding name 'ows__GetResourceByIdType' for type 'ows:GetResourceByIdType' */
#ifndef SOAP_TYPE_ows__GetResourceByIdType
#define SOAP_TYPE_ows__GetResourceByIdType (114)
#endif

/* ows__ExceptionType has binding name 'ows__ExceptionType' for type 'ows:ExceptionType' */
#ifndef SOAP_TYPE_ows__ExceptionType
#define SOAP_TYPE_ows__ExceptionType (113)
#endif

/* util__DescribeFeatureTypeResponseType has binding name 'util__DescribeFeatureTypeResponseType' for type 'util:DescribeFeatureTypeResponseType' */
#ifndef SOAP_TYPE_util__DescribeFeatureTypeResponseType
#define SOAP_TYPE_util__DescribeFeatureTypeResponseType (112)
#endif

/* _wfs__DropStoredQuery has binding name '_wfs__DropStoredQuery' for type '' */
#ifndef SOAP_TYPE__wfs__DropStoredQuery
#define SOAP_TYPE__wfs__DropStoredQuery (111)
#endif

/* _wfs__additionalObjects has binding name '_wfs__additionalObjects' for type '' */
#ifndef SOAP_TYPE__wfs__additionalObjects
#define SOAP_TYPE__wfs__additionalObjects (110)
#endif

/* _wfs__PropertyName has binding name '_wfs__PropertyName' for type '' */
#ifndef SOAP_TYPE__wfs__PropertyName
#define SOAP_TYPE__wfs__PropertyName (109)
#endif

/* _wfs__truncatedResponse has binding name '_wfs__truncatedResponse' for type '' */
#ifndef SOAP_TYPE__wfs__truncatedResponse
#define SOAP_TYPE__wfs__truncatedResponse (108)
#endif

/* _wfs__additionalValues has binding name '_wfs__additionalValues' for type '' */
#ifndef SOAP_TYPE__wfs__additionalValues
#define SOAP_TYPE__wfs__additionalValues (107)
#endif

/* _wfs__Abstract has binding name '_wfs__Abstract' for type '' */
#ifndef SOAP_TYPE__wfs__Abstract
#define SOAP_TYPE__wfs__Abstract (106)
#endif

/* _wfs__Title has binding name '_wfs__Title' for type '' */
#ifndef SOAP_TYPE__wfs__Title
#define SOAP_TYPE__wfs__Title (105)
#endif

/* wfs__EmptyType has binding name 'wfs__EmptyType' for type 'wfs:EmptyType' */
#ifndef SOAP_TYPE_wfs__EmptyType
#define SOAP_TYPE_wfs__EmptyType (104)
#endif

/* wfs__CreatedOrModifiedFeatureType has binding name 'wfs__CreatedOrModifiedFeatureType' for type 'wfs:CreatedOrModifiedFeatureType' */
#ifndef SOAP_TYPE_wfs__CreatedOrModifiedFeatureType
#define SOAP_TYPE_wfs__CreatedOrModifiedFeatureType (103)
#endif

/* wfs__ActionResultsType has binding name 'wfs__ActionResultsType' for type 'wfs:ActionResultsType' */
#ifndef SOAP_TYPE_wfs__ActionResultsType
#define SOAP_TYPE_wfs__ActionResultsType (102)
#endif

/* wfs__TransactionSummaryType has binding name 'wfs__TransactionSummaryType' for type 'wfs:TransactionSummaryType' */
#ifndef SOAP_TYPE_wfs__TransactionSummaryType
#define SOAP_TYPE_wfs__TransactionSummaryType (101)
#endif

/* wfs__TransactionResponseType has binding name 'wfs__TransactionResponseType' for type 'wfs:TransactionResponseType' */
#ifndef SOAP_TYPE_wfs__TransactionResponseType
#define SOAP_TYPE_wfs__TransactionResponseType (100)
#endif

/* wfs__NativeType has binding name 'wfs__NativeType' for type 'wfs:NativeType' */
#ifndef SOAP_TYPE_wfs__NativeType
#define SOAP_TYPE_wfs__NativeType (99)
#endif

/* wfs__DeleteType has binding name 'wfs__DeleteType' for type 'wfs:DeleteType' */
#ifndef SOAP_TYPE_wfs__DeleteType
#define SOAP_TYPE_wfs__DeleteType (98)
#endif

/* wfs__ReplaceType has binding name 'wfs__ReplaceType' for type 'wfs:ReplaceType' */
#ifndef SOAP_TYPE_wfs__ReplaceType
#define SOAP_TYPE_wfs__ReplaceType (97)
#endif

/* wfs__PropertyType has binding name 'wfs__PropertyType' for type 'wfs:PropertyType' */
#ifndef SOAP_TYPE_wfs__PropertyType
#define SOAP_TYPE_wfs__PropertyType (96)
#endif

/* wfs__UpdateType has binding name 'wfs__UpdateType' for type 'wfs:UpdateType' */
#ifndef SOAP_TYPE_wfs__UpdateType
#define SOAP_TYPE_wfs__UpdateType (95)
#endif

/* wfs__InsertType has binding name 'wfs__InsertType' for type 'wfs:InsertType' */
#ifndef SOAP_TYPE_wfs__InsertType
#define SOAP_TYPE_wfs__InsertType (94)
#endif

/* wfs__AbstractTransactionActionType has binding name 'wfs__AbstractTransactionActionType' for type 'wfs:AbstractTransactionActionType' */
#ifndef SOAP_TYPE_wfs__AbstractTransactionActionType
#define SOAP_TYPE_wfs__AbstractTransactionActionType (93)
#endif

/* wfs__TransactionType has binding name 'wfs__TransactionType' for type 'wfs:TransactionType' */
#ifndef SOAP_TYPE_wfs__TransactionType
#define SOAP_TYPE_wfs__TransactionType (92)
#endif

/* wfs__FeaturesNotLockedType has binding name 'wfs__FeaturesNotLockedType' for type 'wfs:FeaturesNotLockedType' */
#ifndef SOAP_TYPE_wfs__FeaturesNotLockedType
#define SOAP_TYPE_wfs__FeaturesNotLockedType (91)
#endif

/* wfs__FeaturesLockedType has binding name 'wfs__FeaturesLockedType' for type 'wfs:FeaturesLockedType' */
#ifndef SOAP_TYPE_wfs__FeaturesLockedType
#define SOAP_TYPE_wfs__FeaturesLockedType (90)
#endif

/* wfs__LockFeatureResponseType has binding name 'wfs__LockFeatureResponseType' for type 'wfs:LockFeatureResponseType' */
#ifndef SOAP_TYPE_wfs__LockFeatureResponseType
#define SOAP_TYPE_wfs__LockFeatureResponseType (89)
#endif

/* wfs__LockFeatureType has binding name 'wfs__LockFeatureType' for type 'wfs:LockFeatureType' */
#ifndef SOAP_TYPE_wfs__LockFeatureType
#define SOAP_TYPE_wfs__LockFeatureType (88)
#endif

/* wfs__CreateStoredQueryResponseType has binding name 'wfs__CreateStoredQueryResponseType' for type 'wfs:CreateStoredQueryResponseType' */
#ifndef SOAP_TYPE_wfs__CreateStoredQueryResponseType
#define SOAP_TYPE_wfs__CreateStoredQueryResponseType (87)
#endif

/* wfs__ExecutionStatusType has binding name 'wfs__ExecutionStatusType' for type 'wfs:ExecutionStatusType' */
#ifndef SOAP_TYPE_wfs__ExecutionStatusType
#define SOAP_TYPE_wfs__ExecutionStatusType (86)
#endif

/* wfs__QueryExpressionTextType has binding name 'wfs__QueryExpressionTextType' for type 'wfs:QueryExpressionTextType' */
#ifndef SOAP_TYPE_wfs__QueryExpressionTextType
#define SOAP_TYPE_wfs__QueryExpressionTextType (85)
#endif

/* wfs__ParameterExpressionType has binding name 'wfs__ParameterExpressionType' for type 'wfs:ParameterExpressionType' */
#ifndef SOAP_TYPE_wfs__ParameterExpressionType
#define SOAP_TYPE_wfs__ParameterExpressionType (84)
#endif

/* wfs__CreateStoredQueryType has binding name 'wfs__CreateStoredQueryType' for type 'wfs:CreateStoredQueryType' */
#ifndef SOAP_TYPE_wfs__CreateStoredQueryType
#define SOAP_TYPE_wfs__CreateStoredQueryType (83)
#endif

/* wfs__StoredQueryDescriptionType has binding name 'wfs__StoredQueryDescriptionType' for type 'wfs:StoredQueryDescriptionType' */
#ifndef SOAP_TYPE_wfs__StoredQueryDescriptionType
#define SOAP_TYPE_wfs__StoredQueryDescriptionType (82)
#endif

/* wfs__DescribeStoredQueriesResponseType has binding name 'wfs__DescribeStoredQueriesResponseType' for type 'wfs:DescribeStoredQueriesResponseType' */
#ifndef SOAP_TYPE_wfs__DescribeStoredQueriesResponseType
#define SOAP_TYPE_wfs__DescribeStoredQueriesResponseType (81)
#endif

/* wfs__DescribeStoredQueriesType has binding name 'wfs__DescribeStoredQueriesType' for type 'wfs:DescribeStoredQueriesType' */
#ifndef SOAP_TYPE_wfs__DescribeStoredQueriesType
#define SOAP_TYPE_wfs__DescribeStoredQueriesType (80)
#endif

/* wfs__StoredQueryListItemType has binding name 'wfs__StoredQueryListItemType' for type 'wfs:StoredQueryListItemType' */
#ifndef SOAP_TYPE_wfs__StoredQueryListItemType
#define SOAP_TYPE_wfs__StoredQueryListItemType (79)
#endif

/* wfs__ListStoredQueriesResponseType has binding name 'wfs__ListStoredQueriesResponseType' for type 'wfs:ListStoredQueriesResponseType' */
#ifndef SOAP_TYPE_wfs__ListStoredQueriesResponseType
#define SOAP_TYPE_wfs__ListStoredQueriesResponseType (78)
#endif

/* wfs__ListStoredQueriesType has binding name 'wfs__ListStoredQueriesType' for type 'wfs:ListStoredQueriesType' */
#ifndef SOAP_TYPE_wfs__ListStoredQueriesType
#define SOAP_TYPE_wfs__ListStoredQueriesType (77)
#endif

/* wfs__EnvelopePropertyType has binding name 'wfs__EnvelopePropertyType' for type 'wfs:EnvelopePropertyType' */
#ifndef SOAP_TYPE_wfs__EnvelopePropertyType
#define SOAP_TYPE_wfs__EnvelopePropertyType (76)
#endif

/* wfs__SimpleFeatureCollectionType has binding name 'wfs__SimpleFeatureCollectionType' for type 'wfs:SimpleFeatureCollectionType' */
#ifndef SOAP_TYPE_wfs__SimpleFeatureCollectionType
#define SOAP_TYPE_wfs__SimpleFeatureCollectionType (75)
#endif

/* wfs__FeatureCollectionType has binding name 'wfs__FeatureCollectionType' for type 'wfs:FeatureCollectionType' */
#ifndef SOAP_TYPE_wfs__FeatureCollectionType
#define SOAP_TYPE_wfs__FeatureCollectionType (74)
#endif

/* wfs__GetFeatureWithLockType has binding name 'wfs__GetFeatureWithLockType' for type 'wfs:GetFeatureWithLockType' */
#ifndef SOAP_TYPE_wfs__GetFeatureWithLockType
#define SOAP_TYPE_wfs__GetFeatureWithLockType (73)
#endif

/* wfs__GetFeatureType has binding name 'wfs__GetFeatureType' for type 'wfs:GetFeatureType' */
#ifndef SOAP_TYPE_wfs__GetFeatureType
#define SOAP_TYPE_wfs__GetFeatureType (72)
#endif

/* wfs__TupleType has binding name 'wfs__TupleType' for type 'wfs:TupleType' */
#ifndef SOAP_TYPE_wfs__TupleType
#define SOAP_TYPE_wfs__TupleType (71)
#endif

/* wfs__MemberPropertyType has binding name 'wfs__MemberPropertyType' for type 'wfs:MemberPropertyType' */
#ifndef SOAP_TYPE_wfs__MemberPropertyType
#define SOAP_TYPE_wfs__MemberPropertyType (70)
#endif

/* wfs__ValueCollectionType has binding name 'wfs__ValueCollectionType' for type 'wfs:ValueCollectionType' */
#ifndef SOAP_TYPE_wfs__ValueCollectionType
#define SOAP_TYPE_wfs__ValueCollectionType (69)
#endif

/* wfs__GetPropertyValueType has binding name 'wfs__GetPropertyValueType' for type 'wfs:GetPropertyValueType' */
#ifndef SOAP_TYPE_wfs__GetPropertyValueType
#define SOAP_TYPE_wfs__GetPropertyValueType (68)
#endif

/* wfs__DescribeFeatureTypeType has binding name 'wfs__DescribeFeatureTypeType' for type 'wfs:DescribeFeatureTypeType' */
#ifndef SOAP_TYPE_wfs__DescribeFeatureTypeType
#define SOAP_TYPE_wfs__DescribeFeatureTypeType (67)
#endif

/* wfs__ValueListType has binding name 'wfs__ValueListType' for type 'wfs:ValueListType' */
#ifndef SOAP_TYPE_wfs__ValueListType
#define SOAP_TYPE_wfs__ValueListType (66)
#endif

/* wfs__ElementType has binding name 'wfs__ElementType' for type 'wfs:ElementType' */
#ifndef SOAP_TYPE_wfs__ElementType
#define SOAP_TYPE_wfs__ElementType (65)
#endif

/* wfs__ExtendedDescriptionType has binding name 'wfs__ExtendedDescriptionType' for type 'wfs:ExtendedDescriptionType' */
#ifndef SOAP_TYPE_wfs__ExtendedDescriptionType
#define SOAP_TYPE_wfs__ExtendedDescriptionType (64)
#endif

/* wfs__MetadataURLType has binding name 'wfs__MetadataURLType' for type 'wfs:MetadataURLType' */
#ifndef SOAP_TYPE_wfs__MetadataURLType
#define SOAP_TYPE_wfs__MetadataURLType (63)
#endif

/* wfs__OutputFormatListType has binding name 'wfs__OutputFormatListType' for type 'wfs:OutputFormatListType' */
#ifndef SOAP_TYPE_wfs__OutputFormatListType
#define SOAP_TYPE_wfs__OutputFormatListType (62)
#endif

/* wfs__FeatureTypeType has binding name 'wfs__FeatureTypeType' for type 'wfs:FeatureTypeType' */
#ifndef SOAP_TYPE_wfs__FeatureTypeType
#define SOAP_TYPE_wfs__FeatureTypeType (61)
#endif

/* wfs__FeatureTypeListType has binding name 'wfs__FeatureTypeListType' for type 'wfs:FeatureTypeListType' */
#ifndef SOAP_TYPE_wfs__FeatureTypeListType
#define SOAP_TYPE_wfs__FeatureTypeListType (60)
#endif

/* wfs__WFS_x005fCapabilitiesType has binding name 'wfs__WFS_x005fCapabilitiesType' for type 'wfs:WFS_CapabilitiesType' */
#ifndef SOAP_TYPE_wfs__WFS_x005fCapabilitiesType
#define SOAP_TYPE_wfs__WFS_x005fCapabilitiesType (59)
#endif

/* wfs__GetCapabilitiesType has binding name 'wfs__GetCapabilitiesType' for type 'wfs:GetCapabilitiesType' */
#ifndef SOAP_TYPE_wfs__GetCapabilitiesType
#define SOAP_TYPE_wfs__GetCapabilitiesType (58)
#endif

/* wfs__ParameterType has binding name 'wfs__ParameterType' for type 'wfs:ParameterType' */
#ifndef SOAP_TYPE_wfs__ParameterType
#define SOAP_TYPE_wfs__ParameterType (57)
#endif

/* wfs__StoredQueryType has binding name 'wfs__StoredQueryType' for type 'wfs:StoredQueryType' */
#ifndef SOAP_TYPE_wfs__StoredQueryType
#define SOAP_TYPE_wfs__StoredQueryType (56)
#endif

/* wfs__StoredQueryPropertyType has binding name 'wfs__StoredQueryPropertyType' for type 'wfs:StoredQueryPropertyType' */
#ifndef SOAP_TYPE_wfs__StoredQueryPropertyType
#define SOAP_TYPE_wfs__StoredQueryPropertyType (55)
#endif

/* wfs__QueryType has binding name 'wfs__QueryType' for type 'wfs:QueryType' */
#ifndef SOAP_TYPE_wfs__QueryType
#define SOAP_TYPE_wfs__QueryType (54)
#endif

/* wfs__QueryPropertyType has binding name 'wfs__QueryPropertyType' for type 'wfs:QueryPropertyType' */
#ifndef SOAP_TYPE_wfs__QueryPropertyType
#define SOAP_TYPE_wfs__QueryPropertyType (53)
#endif

/* wfs__BaseRequestType has binding name 'wfs__BaseRequestType' for type 'wfs:BaseRequestType' */
#ifndef SOAP_TYPE_wfs__BaseRequestType
#define SOAP_TYPE_wfs__BaseRequestType (52)
#endif

/* xsd__hexBinary has binding name 'xsd__hexBinary' for type 'xsd:hexBinary' */
#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (17)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (13)
#endif

/* xsd__anyType has binding name 'xsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (10)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (1227)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (1226)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (1224)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (1223)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (1175)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (1229)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (1228)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (1225)
#endif

/* wfs__TransactionType * has binding name 'PointerTowfs__TransactionType' for type 'wfs:TransactionType' */
#ifndef SOAP_TYPE_PointerTowfs__TransactionType
#define SOAP_TYPE_PointerTowfs__TransactionType (1219)
#endif

/* wfs__LockFeatureType * has binding name 'PointerTowfs__LockFeatureType' for type 'wfs:LockFeatureType' */
#ifndef SOAP_TYPE_PointerTowfs__LockFeatureType
#define SOAP_TYPE_PointerTowfs__LockFeatureType (1215)
#endif

/* wfs__GetPropertyValueType * has binding name 'PointerTowfs__GetPropertyValueType' for type 'wfs:GetPropertyValueType' */
#ifndef SOAP_TYPE_PointerTowfs__GetPropertyValueType
#define SOAP_TYPE_PointerTowfs__GetPropertyValueType (1211)
#endif

/* wfs__GetFeatureWithLockType * has binding name 'PointerTowfs__GetFeatureWithLockType' for type 'wfs:GetFeatureWithLockType' */
#ifndef SOAP_TYPE_PointerTowfs__GetFeatureWithLockType
#define SOAP_TYPE_PointerTowfs__GetFeatureWithLockType (1208)
#endif

/* ows__GetCapabilitiesType * has binding name 'PointerToows__GetCapabilitiesType' for type 'ows:GetCapabilitiesType' */
#ifndef SOAP_TYPE_PointerToows__GetCapabilitiesType
#define SOAP_TYPE_PointerToows__GetCapabilitiesType (1204)
#endif

/* _wfs__DropStoredQuery * has binding name 'PointerTo_wfs__DropStoredQuery' for type '' */
#ifndef SOAP_TYPE_PointerTo_wfs__DropStoredQuery
#define SOAP_TYPE_PointerTo_wfs__DropStoredQuery (1199)
#endif

/* wfs__ListStoredQueriesType * has binding name 'PointerTowfs__ListStoredQueriesType' for type 'wfs:ListStoredQueriesType' */
#ifndef SOAP_TYPE_PointerTowfs__ListStoredQueriesType
#define SOAP_TYPE_PointerTowfs__ListStoredQueriesType (1195)
#endif

/* wfs__DescribeStoredQueriesType * has binding name 'PointerTowfs__DescribeStoredQueriesType' for type 'wfs:DescribeStoredQueriesType' */
#ifndef SOAP_TYPE_PointerTowfs__DescribeStoredQueriesType
#define SOAP_TYPE_PointerTowfs__DescribeStoredQueriesType (1191)
#endif

/* wfs__GetFeatureType * has binding name 'PointerTowfs__GetFeatureType' for type 'wfs:GetFeatureType' */
#ifndef SOAP_TYPE_PointerTowfs__GetFeatureType
#define SOAP_TYPE_PointerTowfs__GetFeatureType (1187)
#endif

/* wfs__DescribeFeatureTypeType * has binding name 'PointerTowfs__DescribeFeatureTypeType' for type 'wfs:DescribeFeatureTypeType' */
#ifndef SOAP_TYPE_PointerTowfs__DescribeFeatureTypeType
#define SOAP_TYPE_PointerTowfs__DescribeFeatureTypeType (1183)
#endif

/* wfs__CreateStoredQueryType * has binding name 'PointerTowfs__CreateStoredQueryType' for type 'wfs:CreateStoredQueryType' */
#ifndef SOAP_TYPE_PointerTowfs__CreateStoredQueryType
#define SOAP_TYPE_PointerTowfs__CreateStoredQueryType (1178)
#endif

/* _idls__crs has binding name '_idls__crs' for type '' */
#ifndef SOAP_TYPE__idls__crs
#define SOAP_TYPE__idls__crs (1119)
#endif

/* _idls__spatial_x005fdataset_x005fidentifier_x005fnamespace has binding name '_idls__spatial_x005fdataset_x005fidentifier_x005fnamespace' for type '' */
#ifndef SOAP_TYPE__idls__spatial_x005fdataset_x005fidentifier_x005fnamespace
#define SOAP_TYPE__idls__spatial_x005fdataset_x005fidentifier_x005fnamespace (1118)
#endif

/* _ows__reference has binding name '_ows__reference' for type '' */
#ifndef SOAP_TYPE__ows__reference
#define SOAP_TYPE__ows__reference (1115)
#endif

/* _ows__Language has binding name '_ows__Language' for type '' */
#ifndef SOAP_TYPE__ows__Language
#define SOAP_TYPE__ows__Language (1082)
#endif

/* _ows__SupportedCRS has binding name '_ows__SupportedCRS' for type '' */
#ifndef SOAP_TYPE__ows__SupportedCRS
#define SOAP_TYPE__ows__SupportedCRS (1079)
#endif

/* _ows__AvailableCRS has binding name '_ows__AvailableCRS' for type '' */
#ifndef SOAP_TYPE__ows__AvailableCRS
#define SOAP_TYPE__ows__AvailableCRS (1078)
#endif

/* icommon__layers * has binding name 'PointerToicommon__layers' for type 'icommon:layers' */
#ifndef SOAP_TYPE_PointerToicommon__layers
#define SOAP_TYPE_PointerToicommon__layers (1037)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fswe * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005fswe' for type 'icommon:resLocInspireInteroperabilityRegulation_swe' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fswe
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fswe (1036)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fswe_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fswe_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_swe-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fswe_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fswe_DateOfPublication (1034)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fspa * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005fspa' for type 'icommon:resLocInspireInteroperabilityRegulation_spa' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fspa
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fspa (1029)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fspa_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fspa_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_spa-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fspa_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fspa_DateOfPublication (1027)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fslv * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005fslv' for type 'icommon:resLocInspireInteroperabilityRegulation_slv' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fslv
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fslv (1022)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fslv_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fslv_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_slv-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fslv_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fslv_DateOfPublication (1020)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fslo * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005fslo' for type 'icommon:resLocInspireInteroperabilityRegulation_slo' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fslo
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fslo (1015)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fslo_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fslo_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_slo-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fslo_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fslo_DateOfPublication (1013)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005frum * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005frum' for type 'icommon:resLocInspireInteroperabilityRegulation_rum' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005frum
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005frum (1008)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005frum_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005frum_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_rum-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005frum_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005frum_DateOfPublication (1006)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fpor * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005fpor' for type 'icommon:resLocInspireInteroperabilityRegulation_por' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fpor
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fpor (1001)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fpor_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fpor_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_por-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fpor_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fpor_DateOfPublication (999)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fpol * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005fpol' for type 'icommon:resLocInspireInteroperabilityRegulation_pol' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fpol
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fpol (994)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fpol_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fpol_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_pol-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fpol_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fpol_DateOfPublication (992)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fmlt * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005fmlt' for type 'icommon:resLocInspireInteroperabilityRegulation_mlt' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fmlt
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fmlt (987)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fmlt_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fmlt_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_mlt-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fmlt_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fmlt_DateOfPublication (985)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005flit * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005flit' for type 'icommon:resLocInspireInteroperabilityRegulation_lit' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005flit
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005flit (980)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005flit_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005flit_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_lit-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005flit_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005flit_DateOfPublication (978)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005flav * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005flav' for type 'icommon:resLocInspireInteroperabilityRegulation_lav' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005flav
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005flav (973)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005flav_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005flav_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_lav-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005flav_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005flav_DateOfPublication (971)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fita * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005fita' for type 'icommon:resLocInspireInteroperabilityRegulation_ita' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fita
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fita (966)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fita_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fita_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_ita-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fita_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fita_DateOfPublication (964)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fhun * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005fhun' for type 'icommon:resLocInspireInteroperabilityRegulation_hun' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fhun
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fhun (959)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fhun_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fhun_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_hun-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fhun_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fhun_DateOfPublication (957)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fgre * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005fgre' for type 'icommon:resLocInspireInteroperabilityRegulation_gre' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fgre
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fgre (952)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fgre_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fgre_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_gre-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fgre_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fgre_DateOfPublication (950)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fgle * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005fgle' for type 'icommon:resLocInspireInteroperabilityRegulation_gle' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fgle
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fgle (945)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fgle_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fgle_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_gle-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fgle_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fgle_DateOfPublication (943)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fger * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005fger' for type 'icommon:resLocInspireInteroperabilityRegulation_ger' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fger
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fger (938)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fger_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fger_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_ger-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fger_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fger_DateOfPublication (936)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005ffre * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005ffre' for type 'icommon:resLocInspireInteroperabilityRegulation_fre' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005ffre
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005ffre (931)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005ffre_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005ffre_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_fre-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005ffre_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005ffre_DateOfPublication (929)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005ffin * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005ffin' for type 'icommon:resLocInspireInteroperabilityRegulation_fin' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005ffin
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005ffin (924)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005ffin_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005ffin_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_fin-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005ffin_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005ffin_DateOfPublication (922)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fest * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005fest' for type 'icommon:resLocInspireInteroperabilityRegulation_est' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fest
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fest (917)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fest_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fest_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_est-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fest_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fest_DateOfPublication (915)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005feng * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005feng' for type 'icommon:resLocInspireInteroperabilityRegulation_eng' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005feng
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005feng (910)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005feng_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005feng_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_eng-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005feng_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005feng_DateOfPublication (908)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fdut * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005fdut' for type 'icommon:resLocInspireInteroperabilityRegulation_dut' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fdut
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fdut (903)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fdut_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fdut_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_dut-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fdut_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fdut_DateOfPublication (901)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fdan * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005fdan' for type 'icommon:resLocInspireInteroperabilityRegulation_dan' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fdan
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fdan (896)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fdan_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fdan_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_dan-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fdan_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fdan_DateOfPublication (894)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fcze * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005fcze' for type 'icommon:resLocInspireInteroperabilityRegulation_cze' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fcze
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fcze (889)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fcze_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fcze_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_cze-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fcze_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fcze_DateOfPublication (887)
#endif

/* icommon__resLocInspireInteroperabilityRegulation_x005fbul * has binding name 'PointerToicommon__resLocInspireInteroperabilityRegulation_x005fbul' for type 'icommon:resLocInspireInteroperabilityRegulation_bul' */
#ifndef SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fbul
#define SOAP_TYPE_PointerToicommon__resLocInspireInteroperabilityRegulation_x005fbul (882)
#endif

/* enum _icommon__citationInspireInteroperabilityRegulation_x005fbul_DateOfPublication * has binding name 'PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fbul_DateOfPublication' for type 'icommon:citationInspireInteroperabilityRegulation_bul-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fbul_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationInspireInteroperabilityRegulation_x005fbul_DateOfPublication (880)
#endif

/* enum _icommon__originatingControlledVocabularyMD_DateOfPublication * has binding name 'PointerTo_icommon__originatingControlledVocabularyMD_DateOfPublication' for type 'icommon:originatingControlledVocabularyMD-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__originatingControlledVocabularyMD_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__originatingControlledVocabularyMD_DateOfPublication (875)
#endif

/* enum _icommon__originatingControlledVocabularyGemetInspireThemes_DateOfPublication * has binding name 'PointerTo_icommon__originatingControlledVocabularyGemetInspireThemes_DateOfPublication' for type 'icommon:originatingControlledVocabularyGemetInspireThemes-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__originatingControlledVocabularyGemetInspireThemes_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__originatingControlledVocabularyGemetInspireThemes_DateOfPublication (871)
#endif

/* icommon__inspireTheme * has binding name 'PointerToicommon__inspireTheme' for type 'icommon:inspireTheme' */
#ifndef SOAP_TYPE_PointerToicommon__inspireTheme
#define SOAP_TYPE_PointerToicommon__inspireTheme (865)
#endif

/* ows__ReferenceGroupType * has binding name 'PointerToows__ReferenceGroupType' for type 'ows:ReferenceGroupType' */
#ifndef SOAP_TYPE_PointerToows__ReferenceGroupType
#define SOAP_TYPE_PointerToows__ReferenceGroupType (862)
#endif

/* __ows__union_ReferenceGroupType * has binding name 'PointerTo__ows__union_ReferenceGroupType' for type '-ows:union-ReferenceGroupType' */
#ifndef SOAP_TYPE_PointerTo__ows__union_ReferenceGroupType
#define SOAP_TYPE_PointerTo__ows__union_ReferenceGroupType (861)
#endif

/* ows__ServiceReferenceType * has binding name 'PointerToows__ServiceReferenceType' for type 'ows:ServiceReferenceType' */
#ifndef SOAP_TYPE_PointerToows__ServiceReferenceType
#define SOAP_TYPE_PointerToows__ServiceReferenceType (860)
#endif

/* ows__ReferenceType * has binding name 'PointerToows__ReferenceType' for type 'ows:ReferenceType' */
#ifndef SOAP_TYPE_PointerToows__ReferenceType
#define SOAP_TYPE_PointerToows__ReferenceType (859)
#endif

/* __ows__union_IdentificationType_ * has binding name 'PointerTo__ows__union_IdentificationType_' for type '-ows:union-IdentificationType' */
#ifndef SOAP_TYPE_PointerTo__ows__union_IdentificationType_
#define SOAP_TYPE_PointerTo__ows__union_IdentificationType_ (855)
#endif

/* std::vector<char *> * has binding name 'PointerTostd__vectorTemplateOfxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOfxsd__anyURI
#define SOAP_TYPE_PointerTostd__vectorTemplateOfxsd__anyURI (854)
#endif

/* __ows__union_IdentificationType * has binding name 'PointerTo__ows__union_IdentificationType' for type '-ows:union-IdentificationType' */
#ifndef SOAP_TYPE_PointerTo__ows__union_IdentificationType
#define SOAP_TYPE_PointerTo__ows__union_IdentificationType (851)
#endif

/* icommon__resLocGEMETInspireThemes_x005feng * has binding name 'PointerToicommon__resLocGEMETInspireThemes_x005feng' for type 'icommon:resLocGEMETInspireThemes_eng' */
#ifndef SOAP_TYPE_PointerToicommon__resLocGEMETInspireThemes_x005feng
#define SOAP_TYPE_PointerToicommon__resLocGEMETInspireThemes_x005feng (810)
#endif

/* enum _icommon__citationGEMETInspireThemes_x005feng_DateOfPublication * has binding name 'PointerTo_icommon__citationGEMETInspireThemes_x005feng_DateOfPublication' for type 'icommon:citationGEMETInspireThemes_eng-DateOfPublication' */
#ifndef SOAP_TYPE_PointerTo_icommon__citationGEMETInspireThemes_x005feng_DateOfPublication
#define SOAP_TYPE_PointerTo_icommon__citationGEMETInspireThemes_x005feng_DateOfPublication (809)
#endif

/* icommon__originatingControlledVocabularyGemetInspireThemes * has binding name 'PointerToicommon__originatingControlledVocabularyGemetInspireThemes' for type 'icommon:originatingControlledVocabularyGemetInspireThemes' */
#ifndef SOAP_TYPE_PointerToicommon__originatingControlledVocabularyGemetInspireThemes
#define SOAP_TYPE_PointerToicommon__originatingControlledVocabularyGemetInspireThemes (795)
#endif

/* __fes__union_UnaryLogicOpType_______ * has binding name 'PointerTo__fes__union_UnaryLogicOpType_______' for type '-fes:union-UnaryLogicOpType' */
#ifndef SOAP_TYPE_PointerTo__fes__union_UnaryLogicOpType_______
#define SOAP_TYPE_PointerTo__fes__union_UnaryLogicOpType_______ (788)
#endif

/* __fes__union_BinaryLogicOpType_______ * has binding name 'PointerTo__fes__union_BinaryLogicOpType_______' for type '-fes:union-BinaryLogicOpType' */
#ifndef SOAP_TYPE_PointerTo__fes__union_BinaryLogicOpType_______
#define SOAP_TYPE_PointerTo__fes__union_BinaryLogicOpType_______ (782)
#endif

/* fes__MeasureType * has binding name 'PointerTofes__MeasureType' for type 'fes:MeasureType' */
#ifndef SOAP_TYPE_PointerTofes__MeasureType
#define SOAP_TYPE_PointerTofes__MeasureType (776)
#endif

/* fes__UpperBoundaryType * has binding name 'PointerTofes__UpperBoundaryType' for type 'fes:UpperBoundaryType' */
#ifndef SOAP_TYPE_PointerTofes__UpperBoundaryType
#define SOAP_TYPE_PointerTofes__UpperBoundaryType (763)
#endif

/* fes__LowerBoundaryType * has binding name 'PointerTofes__LowerBoundaryType' for type 'fes:LowerBoundaryType' */
#ifndef SOAP_TYPE_PointerTofes__LowerBoundaryType
#define SOAP_TYPE_PointerTofes__LowerBoundaryType (762)
#endif

/* __fes__union_PropertyIsLikeType * has binding name 'PointerTo__fes__union_PropertyIsLikeType' for type '-fes:union-PropertyIsLikeType' */
#ifndef SOAP_TYPE_PointerTo__fes__union_PropertyIsLikeType
#define SOAP_TYPE_PointerTo__fes__union_PropertyIsLikeType (758)
#endif

/* __fes__union_BinaryComparisonOpType * has binding name 'PointerTo__fes__union_BinaryComparisonOpType' for type '-fes:union-BinaryComparisonOpType' */
#ifndef SOAP_TYPE_PointerTo__fes__union_BinaryComparisonOpType
#define SOAP_TYPE_PointerTo__fes__union_BinaryComparisonOpType (755)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerTodateTime
#define SOAP_TYPE_PointerTodateTime (752)
#endif

/* std::string * has binding name 'PointerTofes__VersionType' for type 'fes:VersionType' */
#ifndef SOAP_TYPE_PointerTofes__VersionType
#define SOAP_TYPE_PointerTofes__VersionType (751)
#endif

/* __fes__union_FilterType______ * has binding name 'PointerTo__fes__union_FilterType______' for type '-fes:union-FilterType' */
#ifndef SOAP_TYPE_PointerTo__fes__union_FilterType______
#define SOAP_TYPE_PointerTo__fes__union_FilterType______ (750)
#endif

/* fes__UnaryLogicOpType * has binding name 'PointerTofes__UnaryLogicOpType' for type 'fes:UnaryLogicOpType' */
#ifndef SOAP_TYPE_PointerTofes__UnaryLogicOpType
#define SOAP_TYPE_PointerTofes__UnaryLogicOpType (746)
#endif

/* fes__BinaryLogicOpType * has binding name 'PointerTofes__BinaryLogicOpType' for type 'fes:BinaryLogicOpType' */
#ifndef SOAP_TYPE_PointerTofes__BinaryLogicOpType
#define SOAP_TYPE_PointerTofes__BinaryLogicOpType (745)
#endif

/* fes__BinaryTemporalOpType * has binding name 'PointerTofes__BinaryTemporalOpType' for type 'fes:BinaryTemporalOpType' */
#ifndef SOAP_TYPE_PointerTofes__BinaryTemporalOpType
#define SOAP_TYPE_PointerTofes__BinaryTemporalOpType (744)
#endif

/* fes__BBOXType * has binding name 'PointerTofes__BBOXType' for type 'fes:BBOXType' */
#ifndef SOAP_TYPE_PointerTofes__BBOXType
#define SOAP_TYPE_PointerTofes__BBOXType (743)
#endif

/* fes__DistanceBufferType * has binding name 'PointerTofes__DistanceBufferType' for type 'fes:DistanceBufferType' */
#ifndef SOAP_TYPE_PointerTofes__DistanceBufferType
#define SOAP_TYPE_PointerTofes__DistanceBufferType (742)
#endif

/* fes__BinarySpatialOpType * has binding name 'PointerTofes__BinarySpatialOpType' for type 'fes:BinarySpatialOpType' */
#ifndef SOAP_TYPE_PointerTofes__BinarySpatialOpType
#define SOAP_TYPE_PointerTofes__BinarySpatialOpType (741)
#endif

/* fes__PropertyIsBetweenType * has binding name 'PointerTofes__PropertyIsBetweenType' for type 'fes:PropertyIsBetweenType' */
#ifndef SOAP_TYPE_PointerTofes__PropertyIsBetweenType
#define SOAP_TYPE_PointerTofes__PropertyIsBetweenType (740)
#endif

/* fes__PropertyIsNilType * has binding name 'PointerTofes__PropertyIsNilType' for type 'fes:PropertyIsNilType' */
#ifndef SOAP_TYPE_PointerTofes__PropertyIsNilType
#define SOAP_TYPE_PointerTofes__PropertyIsNilType (739)
#endif

/* fes__PropertyIsNullType * has binding name 'PointerTofes__PropertyIsNullType' for type 'fes:PropertyIsNullType' */
#ifndef SOAP_TYPE_PointerTofes__PropertyIsNullType
#define SOAP_TYPE_PointerTofes__PropertyIsNullType (738)
#endif

/* fes__PropertyIsLikeType * has binding name 'PointerTofes__PropertyIsLikeType' for type 'fes:PropertyIsLikeType' */
#ifndef SOAP_TYPE_PointerTofes__PropertyIsLikeType
#define SOAP_TYPE_PointerTofes__PropertyIsLikeType (737)
#endif

/* fes__BinaryComparisonOpType * has binding name 'PointerTofes__BinaryComparisonOpType' for type 'fes:BinaryComparisonOpType' */
#ifndef SOAP_TYPE_PointerTofes__BinaryComparisonOpType
#define SOAP_TYPE_PointerTofes__BinaryComparisonOpType (736)
#endif

/* std::string * has binding name 'PointerTofes__AliasesType' for type 'fes:AliasesType' */
#ifndef SOAP_TYPE_PointerTofes__AliasesType
#define SOAP_TYPE_PointerTofes__AliasesType (734)
#endif

/* fes__SortByType * has binding name 'PointerTofes__SortByType' for type 'fes:SortByType' */
#ifndef SOAP_TYPE_PointerTofes__SortByType
#define SOAP_TYPE_PointerTofes__SortByType (733)
#endif

/* __fes__union_AbstractAdhocQueryExpressionType * has binding name 'PointerTo__fes__union_AbstractAdhocQueryExpressionType' for type '-fes:union-AbstractAdhocQueryExpressionType' */
#ifndef SOAP_TYPE_PointerTo__fes__union_AbstractAdhocQueryExpressionType
#define SOAP_TYPE_PointerTo__fes__union_AbstractAdhocQueryExpressionType (730)
#endif

/* _wfs__PropertyName * has binding name 'PointerTo_wfs__PropertyName' for type '' */
#ifndef SOAP_TYPE_PointerTo_wfs__PropertyName
#define SOAP_TYPE_PointerTo_wfs__PropertyName (729)
#endif

/* __ows__union_DatasetDescriptionSummaryBaseType * has binding name 'PointerTo__ows__union_DatasetDescriptionSummaryBaseType' for type '-ows:union-DatasetDescriptionSummaryBaseType' */
#ifndef SOAP_TYPE_PointerTo__ows__union_DatasetDescriptionSummaryBaseType
#define SOAP_TYPE_PointerTo__ows__union_DatasetDescriptionSummaryBaseType (726)
#endif

/* std::vector<ows__BoundingBoxType *> * has binding name 'PointerTostd__vectorTemplateOfPointerToows__BoundingBoxType' for type 'ows:BoundingBoxType' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOfPointerToows__BoundingBoxType
#define SOAP_TYPE_PointerTostd__vectorTemplateOfPointerToows__BoundingBoxType (725)
#endif

/* ows__BoundingBoxType * has binding name 'PointerToows__BoundingBoxType' for type 'ows:BoundingBoxType' */
#ifndef SOAP_TYPE_PointerToows__BoundingBoxType
#define SOAP_TYPE_PointerToows__BoundingBoxType (723)
#endif

/* fes__FilterType * has binding name 'PointerTofes__FilterType' for type 'fes:FilterType' */
#ifndef SOAP_TYPE_PointerTofes__FilterType
#define SOAP_TYPE_PointerTofes__FilterType (720)
#endif

/* wfs__PropertyType * has binding name 'PointerTowfs__PropertyType' for type 'wfs:PropertyType' */
#ifndef SOAP_TYPE_PointerTowfs__PropertyType
#define SOAP_TYPE_PointerTowfs__PropertyType (718)
#endif

/* wfs__NativeType * has binding name 'PointerTowfs__NativeType' for type 'wfs:NativeType' */
#ifndef SOAP_TYPE_PointerTowfs__NativeType
#define SOAP_TYPE_PointerTowfs__NativeType (716)
#endif

/* wfs__DeleteType * has binding name 'PointerTowfs__DeleteType' for type 'wfs:DeleteType' */
#ifndef SOAP_TYPE_PointerTowfs__DeleteType
#define SOAP_TYPE_PointerTowfs__DeleteType (715)
#endif

/* wfs__ReplaceType * has binding name 'PointerTowfs__ReplaceType' for type 'wfs:ReplaceType' */
#ifndef SOAP_TYPE_PointerTowfs__ReplaceType
#define SOAP_TYPE_PointerTowfs__ReplaceType (714)
#endif

/* wfs__UpdateType * has binding name 'PointerTowfs__UpdateType' for type 'wfs:UpdateType' */
#ifndef SOAP_TYPE_PointerTowfs__UpdateType
#define SOAP_TYPE_PointerTowfs__UpdateType (713)
#endif

/* wfs__InsertType * has binding name 'PointerTowfs__InsertType' for type 'wfs:InsertType' */
#ifndef SOAP_TYPE_PointerTowfs__InsertType
#define SOAP_TYPE_PointerTowfs__InsertType (712)
#endif

/* __wfs__union_LockFeatureType * has binding name 'PointerTo__wfs__union_LockFeatureType' for type '-wfs:union-LockFeatureType' */
#ifndef SOAP_TYPE_PointerTo__wfs__union_LockFeatureType
#define SOAP_TYPE_PointerTo__wfs__union_LockFeatureType (709)
#endif

/* _wfs__additionalObjects * has binding name 'PointerTo_wfs__additionalObjects' for type '' */
#ifndef SOAP_TYPE_PointerTo_wfs__additionalObjects
#define SOAP_TYPE_PointerTo_wfs__additionalObjects (706)
#endif

/* __wfs__union_GetFeatureType * has binding name 'PointerTo__wfs__union_GetFeatureType' for type '-wfs:union-GetFeatureType' */
#ifndef SOAP_TYPE_PointerTo__wfs__union_GetFeatureType
#define SOAP_TYPE_PointerTo__wfs__union_GetFeatureType (705)
#endif

/* _fes__Filter_x005fCapabilities * has binding name 'PointerTo_fes__Filter_x005fCapabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_fes__Filter_x005fCapabilities
#define SOAP_TYPE_PointerTo_fes__Filter_x005fCapabilities (701)
#endif

/* wfs__FeatureTypeListType * has binding name 'PointerTowfs__FeatureTypeListType' for type 'wfs:FeatureTypeListType' */
#ifndef SOAP_TYPE_PointerTowfs__FeatureTypeListType
#define SOAP_TYPE_PointerTowfs__FeatureTypeListType (700)
#endif

/* _wfs__WFS_x005fCapabilitiesType_WSDL * has binding name 'PointerTo_wfs__WFS_x005fCapabilitiesType_WSDL' for type '' */
#ifndef SOAP_TYPE_PointerTo_wfs__WFS_x005fCapabilitiesType_WSDL
#define SOAP_TYPE_PointerTo_wfs__WFS_x005fCapabilitiesType_WSDL (699)
#endif

/* wfs__ParameterType * has binding name 'PointerTowfs__ParameterType' for type 'wfs:ParameterType' */
#ifndef SOAP_TYPE_PointerTowfs__ParameterType
#define SOAP_TYPE_PointerTowfs__ParameterType (696)
#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_PointerTobool
#define SOAP_TYPE_PointerTobool (695)
#endif

/* icommon__uniqueResourceIdentifier * has binding name 'PointerToicommon__uniqueResourceIdentifier' for type 'icommon:uniqueResourceIdentifier' */
#ifndef SOAP_TYPE_PointerToicommon__uniqueResourceIdentifier
#define SOAP_TYPE_PointerToicommon__uniqueResourceIdentifier (681)
#endif

/* icommon__classificationOfSpatialDataService * has binding name 'PointerToicommon__classificationOfSpatialDataService' for type 'icommon:classificationOfSpatialDataService' */
#ifndef SOAP_TYPE_PointerToicommon__classificationOfSpatialDataService
#define SOAP_TYPE_PointerToicommon__classificationOfSpatialDataService (677)
#endif

/* enum icommon__spatialDataServiceType * has binding name 'PointerToicommon__spatialDataServiceType' for type 'icommon:spatialDataServiceType' */
#ifndef SOAP_TYPE_PointerToicommon__spatialDataServiceType
#define SOAP_TYPE_PointerToicommon__spatialDataServiceType (676)
#endif

/* enum icommon__serviceSpatialDataResourceType * has binding name 'PointerToicommon__serviceSpatialDataResourceType' for type 'icommon:serviceSpatialDataResourceType' */
#ifndef SOAP_TYPE_PointerToicommon__serviceSpatialDataResourceType
#define SOAP_TYPE_PointerToicommon__serviceSpatialDataResourceType (675)
#endif

/* icommon__languageElementISO6392B * has binding name 'PointerToicommon__languageElementISO6392B' for type 'icommon:languageElementISO6392B' */
#ifndef SOAP_TYPE_PointerToicommon__languageElementISO6392B
#define SOAP_TYPE_PointerToicommon__languageElementISO6392B (674)
#endif

/* icommon__supportedLanguagesType * has binding name 'PointerToicommon__supportedLanguagesType' for type 'icommon:supportedLanguagesType' */
#ifndef SOAP_TYPE_PointerToicommon__supportedLanguagesType
#define SOAP_TYPE_PointerToicommon__supportedLanguagesType (673)
#endif

/* long * has binding name 'PointerTolong' for type 'xsd:long' */
#ifndef SOAP_TYPE_PointerTolong
#define SOAP_TYPE_PointerTolong (672)
#endif

/* icommon__originatingControlledVocabulary * has binding name 'PointerToicommon__originatingControlledVocabulary' for type 'icommon:originatingControlledVocabulary' */
#ifndef SOAP_TYPE_PointerToicommon__originatingControlledVocabulary
#define SOAP_TYPE_PointerToicommon__originatingControlledVocabulary (669)
#endif

/* __icommon__union_temporalExtent * has binding name 'PointerTo__icommon__union_temporalExtent' for type '-icommon:union-temporalExtent' */
#ifndef SOAP_TYPE_PointerTo__icommon__union_temporalExtent
#define SOAP_TYPE_PointerTo__icommon__union_temporalExtent (668)
#endif

/* _icommon__IntervalOfDates * has binding name 'PointerTo_icommon__IntervalOfDates' for type '' */
#ifndef SOAP_TYPE_PointerTo_icommon__IntervalOfDates
#define SOAP_TYPE_PointerTo_icommon__IntervalOfDates (667)
#endif

/* icommon__temporalExtent * has binding name 'PointerToicommon__temporalExtent' for type 'icommon:temporalExtent' */
#ifndef SOAP_TYPE_PointerToicommon__temporalExtent
#define SOAP_TYPE_PointerToicommon__temporalExtent (663)
#endif

/* icommon__citationConformity * has binding name 'PointerToicommon__citationConformity' for type 'icommon:citationConformity' */
#ifndef SOAP_TYPE_PointerToicommon__citationConformity
#define SOAP_TYPE_PointerToicommon__citationConformity (661)
#endif

/* std::string * has binding name 'PointerToicommon__iso8601Date' for type 'icommon:iso8601Date' */
#ifndef SOAP_TYPE_PointerToicommon__iso8601Date
#define SOAP_TYPE_PointerToicommon__iso8601Date (660)
#endif

/* icommon__metadataPointOfContact * has binding name 'PointerToicommon__metadataPointOfContact' for type 'icommon:metadataPointOfContact' */
#ifndef SOAP_TYPE_PointerToicommon__metadataPointOfContact
#define SOAP_TYPE_PointerToicommon__metadataPointOfContact (656)
#endif

/* icommon__responsibleOrganisation * has binding name 'PointerToicommon__responsibleOrganisation' for type 'icommon:responsibleOrganisation' */
#ifndef SOAP_TYPE_PointerToicommon__responsibleOrganisation
#define SOAP_TYPE_PointerToicommon__responsibleOrganisation (654)
#endif

/* icommon__conformity * has binding name 'PointerToicommon__conformity' for type 'icommon:conformity' */
#ifndef SOAP_TYPE_PointerToicommon__conformity
#define SOAP_TYPE_PointerToicommon__conformity (651)
#endif

/* icommon__spatialResolution * has binding name 'PointerToicommon__spatialResolution' for type 'icommon:spatialResolution' */
#ifndef SOAP_TYPE_PointerToicommon__spatialResolution
#define SOAP_TYPE_PointerToicommon__spatialResolution (649)
#endif

/* icommon__temporalReference * has binding name 'PointerToicommon__temporalReference' for type 'icommon:temporalReference' */
#ifndef SOAP_TYPE_PointerToicommon__temporalReference
#define SOAP_TYPE_PointerToicommon__temporalReference (647)
#endif

/* icommon__geographicBoundingBox * has binding name 'PointerToicommon__geographicBoundingBox' for type 'icommon:geographicBoundingBox' */
#ifndef SOAP_TYPE_PointerToicommon__geographicBoundingBox
#define SOAP_TYPE_PointerToicommon__geographicBoundingBox (645)
#endif

/* icommon__keyword * has binding name 'PointerToicommon__keyword' for type 'icommon:keyword' */
#ifndef SOAP_TYPE_PointerToicommon__keyword
#define SOAP_TYPE_PointerToicommon__keyword (643)
#endif

/* icommon__resourceLocatorType * has binding name 'PointerToicommon__resourceLocatorType' for type 'icommon:resourceLocatorType' */
#ifndef SOAP_TYPE_PointerToicommon__resourceLocatorType
#define SOAP_TYPE_PointerToicommon__resourceLocatorType (641)
#endif

/* fes__Extended_x005fCapabilitiesType * has binding name 'PointerTofes__Extended_x005fCapabilitiesType' for type 'fes:Extended_CapabilitiesType' */
#ifndef SOAP_TYPE_PointerTofes__Extended_x005fCapabilitiesType
#define SOAP_TYPE_PointerTofes__Extended_x005fCapabilitiesType (640)
#endif

/* fes__AvailableFunctionsType * has binding name 'PointerTofes__AvailableFunctionsType' for type 'fes:AvailableFunctionsType' */
#ifndef SOAP_TYPE_PointerTofes__AvailableFunctionsType
#define SOAP_TYPE_PointerTofes__AvailableFunctionsType (639)
#endif

/* fes__Temporal_x005fCapabilitiesType * has binding name 'PointerTofes__Temporal_x005fCapabilitiesType' for type 'fes:Temporal_CapabilitiesType' */
#ifndef SOAP_TYPE_PointerTofes__Temporal_x005fCapabilitiesType
#define SOAP_TYPE_PointerTofes__Temporal_x005fCapabilitiesType (638)
#endif

/* fes__Spatial_x005fCapabilitiesType * has binding name 'PointerTofes__Spatial_x005fCapabilitiesType' for type 'fes:Spatial_CapabilitiesType' */
#ifndef SOAP_TYPE_PointerTofes__Spatial_x005fCapabilitiesType
#define SOAP_TYPE_PointerTofes__Spatial_x005fCapabilitiesType (637)
#endif

/* fes__Scalar_x005fCapabilitiesType * has binding name 'PointerTofes__Scalar_x005fCapabilitiesType' for type 'fes:Scalar_CapabilitiesType' */
#ifndef SOAP_TYPE_PointerTofes__Scalar_x005fCapabilitiesType
#define SOAP_TYPE_PointerTofes__Scalar_x005fCapabilitiesType (636)
#endif

/* fes__Id_x005fCapabilitiesType * has binding name 'PointerTofes__Id_x005fCapabilitiesType' for type 'fes:Id_CapabilitiesType' */
#ifndef SOAP_TYPE_PointerTofes__Id_x005fCapabilitiesType
#define SOAP_TYPE_PointerTofes__Id_x005fCapabilitiesType (635)
#endif

/* fes__ConformanceType * has binding name 'PointerTofes__ConformanceType' for type 'fes:ConformanceType' */
#ifndef SOAP_TYPE_PointerTofes__ConformanceType
#define SOAP_TYPE_PointerTofes__ConformanceType (634)
#endif

/* enum fes__SortOrderType * has binding name 'PointerTofes__SortOrderType' for type 'fes:SortOrderType' */
#ifndef SOAP_TYPE_PointerTofes__SortOrderType
#define SOAP_TYPE_PointerTofes__SortOrderType (633)
#endif

/* fes__SortPropertyType * has binding name 'PointerTofes__SortPropertyType' for type 'fes:SortPropertyType' */
#ifndef SOAP_TYPE_PointerTofes__SortPropertyType
#define SOAP_TYPE_PointerTofes__SortPropertyType (631)
#endif

/* fes__ExtensionOperatorType * has binding name 'PointerTofes__ExtensionOperatorType' for type 'fes:ExtensionOperatorType' */
#ifndef SOAP_TYPE_PointerTofes__ExtensionOperatorType
#define SOAP_TYPE_PointerTofes__ExtensionOperatorType (629)
#endif

/* fes__AdditionalOperatorsType * has binding name 'PointerTofes__AdditionalOperatorsType' for type 'fes:AdditionalOperatorsType' */
#ifndef SOAP_TYPE_PointerTofes__AdditionalOperatorsType
#define SOAP_TYPE_PointerTofes__AdditionalOperatorsType (628)
#endif

/* fes__TemporalOperatorType * has binding name 'PointerTofes__TemporalOperatorType' for type 'fes:TemporalOperatorType' */
#ifndef SOAP_TYPE_PointerTofes__TemporalOperatorType
#define SOAP_TYPE_PointerTofes__TemporalOperatorType (626)
#endif

/* fes__TemporalOperatorsType * has binding name 'PointerTofes__TemporalOperatorsType' for type 'fes:TemporalOperatorsType' */
#ifndef SOAP_TYPE_PointerTofes__TemporalOperatorsType
#define SOAP_TYPE_PointerTofes__TemporalOperatorsType (623)
#endif

/* fes__TemporalOperandsType * has binding name 'PointerTofes__TemporalOperandsType' for type 'fes:TemporalOperandsType' */
#ifndef SOAP_TYPE_PointerTofes__TemporalOperandsType
#define SOAP_TYPE_PointerTofes__TemporalOperandsType (622)
#endif

/* std::string * has binding name 'PointerTofes__SpatialOperatorNameType' for type 'fes:SpatialOperatorNameType' */
#ifndef SOAP_TYPE_PointerTofes__SpatialOperatorNameType
#define SOAP_TYPE_PointerTofes__SpatialOperatorNameType (621)
#endif

/* fes__SpatialOperatorType * has binding name 'PointerTofes__SpatialOperatorType' for type 'fes:SpatialOperatorType' */
#ifndef SOAP_TYPE_PointerTofes__SpatialOperatorType
#define SOAP_TYPE_PointerTofes__SpatialOperatorType (619)
#endif

/* fes__SpatialOperatorsType * has binding name 'PointerTofes__SpatialOperatorsType' for type 'fes:SpatialOperatorsType' */
#ifndef SOAP_TYPE_PointerTofes__SpatialOperatorsType
#define SOAP_TYPE_PointerTofes__SpatialOperatorsType (616)
#endif

/* fes__GeometryOperandsType * has binding name 'PointerTofes__GeometryOperandsType' for type 'fes:GeometryOperandsType' */
#ifndef SOAP_TYPE_PointerTofes__GeometryOperandsType
#define SOAP_TYPE_PointerTofes__GeometryOperandsType (615)
#endif

/* fes__ArgumentType * has binding name 'PointerTofes__ArgumentType' for type 'fes:ArgumentType' */
#ifndef SOAP_TYPE_PointerTofes__ArgumentType
#define SOAP_TYPE_PointerTofes__ArgumentType (613)
#endif

/* fes__ArgumentsType * has binding name 'PointerTofes__ArgumentsType' for type 'fes:ArgumentsType' */
#ifndef SOAP_TYPE_PointerTofes__ArgumentsType
#define SOAP_TYPE_PointerTofes__ArgumentsType (612)
#endif

/* fes__AvailableFunctionType * has binding name 'PointerTofes__AvailableFunctionType' for type 'fes:AvailableFunctionType' */
#ifndef SOAP_TYPE_PointerTofes__AvailableFunctionType
#define SOAP_TYPE_PointerTofes__AvailableFunctionType (610)
#endif

/* fes__ComparisonOperatorType * has binding name 'PointerTofes__ComparisonOperatorType' for type 'fes:ComparisonOperatorType' */
#ifndef SOAP_TYPE_PointerTofes__ComparisonOperatorType
#define SOAP_TYPE_PointerTofes__ComparisonOperatorType (608)
#endif

/* fes__ComparisonOperatorsType * has binding name 'PointerTofes__ComparisonOperatorsType' for type 'fes:ComparisonOperatorsType' */
#ifndef SOAP_TYPE_PointerTofes__ComparisonOperatorsType
#define SOAP_TYPE_PointerTofes__ComparisonOperatorsType (606)
#endif

/* _fes__LogicalOperators * has binding name 'PointerTo_fes__LogicalOperators' for type '' */
#ifndef SOAP_TYPE_PointerTo_fes__LogicalOperators
#define SOAP_TYPE_PointerTo_fes__LogicalOperators (605)
#endif

/* fes__ResourceIdentifierType * has binding name 'PointerTofes__ResourceIdentifierType' for type 'fes:ResourceIdentifierType' */
#ifndef SOAP_TYPE_PointerTofes__ResourceIdentifierType
#define SOAP_TYPE_PointerTofes__ResourceIdentifierType (603)
#endif

/* char ** has binding name 'PointerToxsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_PointerToxsd__QName
#define SOAP_TYPE_PointerToxsd__QName (602)
#endif

/* __fes__union_FunctionType * has binding name 'PointerTo__fes__union_FunctionType' for type '-fes:union-FunctionType' */
#ifndef SOAP_TYPE_PointerTo__fes__union_FunctionType
#define SOAP_TYPE_PointerTo__fes__union_FunctionType (601)
#endif

/* fes__LiteralType * has binding name 'PointerTofes__LiteralType' for type 'fes:LiteralType' */
#ifndef SOAP_TYPE_PointerTofes__LiteralType
#define SOAP_TYPE_PointerTofes__LiteralType (597)
#endif

/* fes__FunctionType * has binding name 'PointerTofes__FunctionType' for type 'fes:FunctionType' */
#ifndef SOAP_TYPE_PointerTofes__FunctionType
#define SOAP_TYPE_PointerTofes__FunctionType (596)
#endif

/* char ** has binding name 'PointerToxlink__toType' for type 'xlink:toType' */
#ifndef SOAP_TYPE_PointerToxlink__toType
#define SOAP_TYPE_PointerToxlink__toType (594)
#endif

/* char ** has binding name 'PointerToxlink__fromType' for type 'xlink:fromType' */
#ifndef SOAP_TYPE_PointerToxlink__fromType
#define SOAP_TYPE_PointerToxlink__fromType (593)
#endif

/* __xlink__union_arcType * has binding name 'PointerTo__xlink__union_arcType' for type '-xlink:union-arcType' */
#ifndef SOAP_TYPE_PointerTo__xlink__union_arcType
#define SOAP_TYPE_PointerTo__xlink__union_arcType (592)
#endif

/* __xlink__union_locatorType * has binding name 'PointerTo__xlink__union_locatorType' for type '-xlink:union-locatorType' */
#ifndef SOAP_TYPE_PointerTo__xlink__union_locatorType
#define SOAP_TYPE_PointerTo__xlink__union_locatorType (589)
#endif

/* char ** has binding name 'PointerToxlink__labelType' for type 'xlink:labelType' */
#ifndef SOAP_TYPE_PointerToxlink__labelType
#define SOAP_TYPE_PointerToxlink__labelType (586)
#endif

/* ows__RangeType * has binding name 'PointerToows__RangeType' for type 'ows:RangeType' */
#ifndef SOAP_TYPE_PointerToows__RangeType
#define SOAP_TYPE_PointerToows__RangeType (581)
#endif

/* ows__RequestMethodType * has binding name 'PointerToows__RequestMethodType' for type 'ows:RequestMethodType' */
#ifndef SOAP_TYPE_PointerToows__RequestMethodType
#define SOAP_TYPE_PointerToows__RequestMethodType (577)
#endif

/* _ows__HTTP * has binding name 'PointerTo_ows__HTTP' for type '' */
#ifndef SOAP_TYPE_PointerTo_ows__HTTP
#define SOAP_TYPE_PointerTo_ows__HTTP (574)
#endif

/* _ows__DCP * has binding name 'PointerTo_ows__DCP' for type '' */
#ifndef SOAP_TYPE_PointerTo_ows__DCP
#define SOAP_TYPE_PointerTo_ows__DCP (571)
#endif

/* idls__ExtendedCapabilitiesType * has binding name 'PointerToidls__ExtendedCapabilitiesType' for type 'idls:ExtendedCapabilitiesType' */
#ifndef SOAP_TYPE_PointerToidls__ExtendedCapabilitiesType
#define SOAP_TYPE_PointerToidls__ExtendedCapabilitiesType (570)
#endif

/* ows__DomainType * has binding name 'PointerToows__DomainType' for type 'ows:DomainType' */
#ifndef SOAP_TYPE_PointerToows__DomainType
#define SOAP_TYPE_PointerToows__DomainType (568)
#endif

/* _ows__Operation * has binding name 'PointerTo_ows__Operation' for type '' */
#ifndef SOAP_TYPE_PointerTo_ows__Operation
#define SOAP_TYPE_PointerTo_ows__Operation (566)
#endif

/* ows__ResponsiblePartySubsetType * has binding name 'PointerToows__ResponsiblePartySubsetType' for type 'ows:ResponsiblePartySubsetType' */
#ifndef SOAP_TYPE_PointerToows__ResponsiblePartySubsetType
#define SOAP_TYPE_PointerToows__ResponsiblePartySubsetType (565)
#endif

/* char ** has binding name 'PointerTo_xml__lang' for type '' */
#ifndef SOAP_TYPE_PointerTo_xml__lang
#define SOAP_TYPE_PointerTo_xml__lang (564)
#endif

/* ows__ExceptionType * has binding name 'PointerToows__ExceptionType' for type 'ows:ExceptionType' */
#ifndef SOAP_TYPE_PointerToows__ExceptionType
#define SOAP_TYPE_PointerToows__ExceptionType (562)
#endif

/* ows__DatasetDescriptionSummaryBaseType * has binding name 'PointerToows__DatasetDescriptionSummaryBaseType' for type 'ows:DatasetDescriptionSummaryBaseType' */
#ifndef SOAP_TYPE_PointerToows__DatasetDescriptionSummaryBaseType
#define SOAP_TYPE_PointerToows__DatasetDescriptionSummaryBaseType (560)
#endif

/* ows__DomainMetadataType * has binding name 'PointerToows__DomainMetadataType' for type 'ows:DomainMetadataType' */
#ifndef SOAP_TYPE_PointerToows__DomainMetadataType
#define SOAP_TYPE_PointerToows__DomainMetadataType (558)
#endif

/* ows__ValueType * has binding name 'PointerToows__ValueType' for type 'ows:ValueType' */
#ifndef SOAP_TYPE_PointerToows__ValueType
#define SOAP_TYPE_PointerToows__ValueType (557)
#endif

/* _ows__ValuesReference * has binding name 'PointerTo_ows__ValuesReference' for type '' */
#ifndef SOAP_TYPE_PointerTo_ows__ValuesReference
#define SOAP_TYPE_PointerTo_ows__ValuesReference (556)
#endif

/* _ows__NoValues * has binding name 'PointerTo_ows__NoValues' for type '' */
#ifndef SOAP_TYPE_PointerTo_ows__NoValues
#define SOAP_TYPE_PointerTo_ows__NoValues (555)
#endif

/* _ows__AnyValue * has binding name 'PointerTo_ows__AnyValue' for type '' */
#ifndef SOAP_TYPE_PointerTo_ows__AnyValue
#define SOAP_TYPE_PointerTo_ows__AnyValue (554)
#endif

/* _ows__AllowedValues * has binding name 'PointerTo_ows__AllowedValues' for type '' */
#ifndef SOAP_TYPE_PointerTo_ows__AllowedValues
#define SOAP_TYPE_PointerTo_ows__AllowedValues (553)
#endif

/* ows__AcceptFormatsType * has binding name 'PointerToows__AcceptFormatsType' for type 'ows:AcceptFormatsType' */
#ifndef SOAP_TYPE_PointerToows__AcceptFormatsType
#define SOAP_TYPE_PointerToows__AcceptFormatsType (549)
#endif

/* ows__SectionsType * has binding name 'PointerToows__SectionsType' for type 'ows:SectionsType' */
#ifndef SOAP_TYPE_PointerToows__SectionsType
#define SOAP_TYPE_PointerToows__SectionsType (548)
#endif

/* ows__AcceptVersionsType * has binding name 'PointerToows__AcceptVersionsType' for type 'ows:AcceptVersionsType' */
#ifndef SOAP_TYPE_PointerToows__AcceptVersionsType
#define SOAP_TYPE_PointerToows__AcceptVersionsType (547)
#endif

/* std::string * has binding name 'PointerToows__UpdateSequenceType' for type 'ows:UpdateSequenceType' */
#ifndef SOAP_TYPE_PointerToows__UpdateSequenceType
#define SOAP_TYPE_PointerToows__UpdateSequenceType (546)
#endif

/* _ows__OperationsMetadata * has binding name 'PointerTo_ows__OperationsMetadata' for type '' */
#ifndef SOAP_TYPE_PointerTo_ows__OperationsMetadata
#define SOAP_TYPE_PointerTo_ows__OperationsMetadata (545)
#endif

/* _ows__ServiceProvider * has binding name 'PointerTo_ows__ServiceProvider' for type '' */
#ifndef SOAP_TYPE_PointerTo_ows__ServiceProvider
#define SOAP_TYPE_PointerTo_ows__ServiceProvider (544)
#endif

/* _ows__ServiceIdentification * has binding name 'PointerTo_ows__ServiceIdentification' for type '' */
#ifndef SOAP_TYPE_PointerTo_ows__ServiceIdentification
#define SOAP_TYPE_PointerTo_ows__ServiceIdentification (543)
#endif

/* ows__OnlineResourceType * has binding name 'PointerToows__OnlineResourceType' for type 'ows:OnlineResourceType' */
#ifndef SOAP_TYPE_PointerToows__OnlineResourceType
#define SOAP_TYPE_PointerToows__OnlineResourceType (542)
#endif

/* ows__AddressType * has binding name 'PointerToows__AddressType' for type 'ows:AddressType' */
#ifndef SOAP_TYPE_PointerToows__AddressType
#define SOAP_TYPE_PointerToows__AddressType (541)
#endif

/* ows__TelephoneType * has binding name 'PointerToows__TelephoneType' for type 'ows:TelephoneType' */
#ifndef SOAP_TYPE_PointerToows__TelephoneType
#define SOAP_TYPE_PointerToows__TelephoneType (540)
#endif

/* ows__ContactType * has binding name 'PointerToows__ContactType' for type 'ows:ContactType' */
#ifndef SOAP_TYPE_PointerToows__ContactType
#define SOAP_TYPE_PointerToows__ContactType (539)
#endif

/* ows__CodeType * has binding name 'PointerToows__CodeType' for type 'ows:CodeType' */
#ifndef SOAP_TYPE_PointerToows__CodeType
#define SOAP_TYPE_PointerToows__CodeType (538)
#endif

/* ULONG64 * has binding name 'PointerToxsd__positiveInteger' for type 'xsd:positiveInteger' */
#ifndef SOAP_TYPE_PointerToxsd__positiveInteger
#define SOAP_TYPE_PointerToxsd__positiveInteger (537)
#endif

/* ows__LanguageStringType * has binding name 'PointerToows__LanguageStringType' for type 'ows:LanguageStringType' */
#ifndef SOAP_TYPE_PointerToows__LanguageStringType
#define SOAP_TYPE_PointerToows__LanguageStringType (534)
#endif

/* std::string * has binding name 'PointerToows__MimeType' for type 'ows:MimeType' */
#ifndef SOAP_TYPE_PointerToows__MimeType
#define SOAP_TYPE_PointerToows__MimeType (533)
#endif

/* _ows__ExceptionReport * has binding name 'PointerTo_ows__ExceptionReport' for type '' */
#ifndef SOAP_TYPE_PointerTo_ows__ExceptionReport
#define SOAP_TYPE_PointerTo_ows__ExceptionReport (530)
#endif

/* wfs__ValueCollectionType * has binding name 'PointerTowfs__ValueCollectionType' for type 'wfs:ValueCollectionType' */
#ifndef SOAP_TYPE_PointerTowfs__ValueCollectionType
#define SOAP_TYPE_PointerTowfs__ValueCollectionType (529)
#endif

/* wfs__CreatedOrModifiedFeatureType * has binding name 'PointerTowfs__CreatedOrModifiedFeatureType' for type 'wfs:CreatedOrModifiedFeatureType' */
#ifndef SOAP_TYPE_PointerTowfs__CreatedOrModifiedFeatureType
#define SOAP_TYPE_PointerTowfs__CreatedOrModifiedFeatureType (524)
#endif

/* ULONG64 * has binding name 'PointerToxsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_PointerToxsd__nonNegativeInteger
#define SOAP_TYPE_PointerToxsd__nonNegativeInteger (523)
#endif

/* wfs__ActionResultsType * has binding name 'PointerTowfs__ActionResultsType' for type 'wfs:ActionResultsType' */
#ifndef SOAP_TYPE_PointerTowfs__ActionResultsType
#define SOAP_TYPE_PointerTowfs__ActionResultsType (522)
#endif

/* wfs__TransactionSummaryType * has binding name 'PointerTowfs__TransactionSummaryType' for type 'wfs:TransactionSummaryType' */
#ifndef SOAP_TYPE_PointerTowfs__TransactionSummaryType
#define SOAP_TYPE_PointerTowfs__TransactionSummaryType (521)
#endif

/* fes__ResourceIdType * has binding name 'PointerTofes__ResourceIdType' for type 'fes:ResourceIdType' */
#ifndef SOAP_TYPE_PointerTofes__ResourceIdType
#define SOAP_TYPE_PointerTofes__ResourceIdType (516)
#endif

/* wfs__FeaturesNotLockedType * has binding name 'PointerTowfs__FeaturesNotLockedType' for type 'wfs:FeaturesNotLockedType' */
#ifndef SOAP_TYPE_PointerTowfs__FeaturesNotLockedType
#define SOAP_TYPE_PointerTowfs__FeaturesNotLockedType (514)
#endif

/* wfs__FeaturesLockedType * has binding name 'PointerTowfs__FeaturesLockedType' for type 'wfs:FeaturesLockedType' */
#ifndef SOAP_TYPE_PointerTowfs__FeaturesLockedType
#define SOAP_TYPE_PointerTowfs__FeaturesLockedType (513)
#endif

/* std::vector<wfs__QueryType *> * has binding name 'PointerTostd__vectorTemplateOfPointerTowfs__QueryType' for type 'wfs:QueryType' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTowfs__QueryType
#define SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTowfs__QueryType (511)
#endif

/* std::vector<wfs__StoredQueryType *> * has binding name 'PointerTostd__vectorTemplateOfPointerTowfs__StoredQueryType' for type 'wfs:StoredQueryType' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTowfs__StoredQueryType
#define SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTowfs__StoredQueryType (509)
#endif

/* std::vector<char *> * has binding name 'PointerTostd__vectorTemplateOf_XML' for type '' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOf_XML
#define SOAP_TYPE_PointerTostd__vectorTemplateOf_XML (507)
#endif

/* wfs__QueryExpressionTextType * has binding name 'PointerTowfs__QueryExpressionTextType' for type 'wfs:QueryExpressionTextType' */
#ifndef SOAP_TYPE_PointerTowfs__QueryExpressionTextType
#define SOAP_TYPE_PointerTowfs__QueryExpressionTextType (503)
#endif

/* wfs__ParameterExpressionType * has binding name 'PointerTowfs__ParameterExpressionType' for type 'wfs:ParameterExpressionType' */
#ifndef SOAP_TYPE_PointerTowfs__ParameterExpressionType
#define SOAP_TYPE_PointerTowfs__ParameterExpressionType (501)
#endif

/* wfs__StoredQueryDescriptionType * has binding name 'PointerTowfs__StoredQueryDescriptionType' for type 'wfs:StoredQueryDescriptionType' */
#ifndef SOAP_TYPE_PointerTowfs__StoredQueryDescriptionType
#define SOAP_TYPE_PointerTowfs__StoredQueryDescriptionType (498)
#endif

/* wfs__StoredQueryListItemType * has binding name 'PointerTowfs__StoredQueryListItemType' for type 'wfs:StoredQueryListItemType' */
#ifndef SOAP_TYPE_PointerTowfs__StoredQueryListItemType
#define SOAP_TYPE_PointerTowfs__StoredQueryListItemType (495)
#endif

/* wfs__EnvelopePropertyType * has binding name 'PointerTowfs__EnvelopePropertyType' for type 'wfs:EnvelopePropertyType' */
#ifndef SOAP_TYPE_PointerTowfs__EnvelopePropertyType
#define SOAP_TYPE_PointerTowfs__EnvelopePropertyType (494)
#endif

/* std::string * has binding name 'PointerTowfs__StateValueType' for type 'wfs:StateValueType' */
#ifndef SOAP_TYPE_PointerTowfs__StateValueType
#define SOAP_TYPE_PointerTowfs__StateValueType (493)
#endif

/* wfs__FeatureCollectionType * has binding name 'PointerTowfs__FeatureCollectionType' for type 'wfs:FeatureCollectionType' */
#ifndef SOAP_TYPE_PointerTowfs__FeatureCollectionType
#define SOAP_TYPE_PointerTowfs__FeatureCollectionType (492)
#endif

/* wfs__SimpleFeatureCollectionType * has binding name 'PointerTowfs__SimpleFeatureCollectionType' for type 'wfs:SimpleFeatureCollectionType' */
#ifndef SOAP_TYPE_PointerTowfs__SimpleFeatureCollectionType
#define SOAP_TYPE_PointerTowfs__SimpleFeatureCollectionType (491)
#endif

/* wfs__TupleType * has binding name 'PointerTowfs__TupleType' for type 'wfs:TupleType' */
#ifndef SOAP_TYPE_PointerTowfs__TupleType
#define SOAP_TYPE_PointerTowfs__TupleType (490)
#endif

/* _wfs__truncatedResponse * has binding name 'PointerTo_wfs__truncatedResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_wfs__truncatedResponse
#define SOAP_TYPE_PointerTo_wfs__truncatedResponse (487)
#endif

/* _wfs__additionalValues * has binding name 'PointerTo_wfs__additionalValues' for type '' */
#ifndef SOAP_TYPE_PointerTo_wfs__additionalValues
#define SOAP_TYPE_PointerTo_wfs__additionalValues (486)
#endif

/* wfs__MemberPropertyType * has binding name 'PointerTowfs__MemberPropertyType' for type 'wfs:MemberPropertyType' */
#ifndef SOAP_TYPE_PointerTowfs__MemberPropertyType
#define SOAP_TYPE_PointerTowfs__MemberPropertyType (484)
#endif

/* xsd__anyType * has binding name 'PointerToxsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_PointerToxsd__anyType
#define SOAP_TYPE_PointerToxsd__anyType (482)
#endif

/* wfs__ValueListType * has binding name 'PointerTowfs__ValueListType' for type 'wfs:ValueListType' */
#ifndef SOAP_TYPE_PointerTowfs__ValueListType
#define SOAP_TYPE_PointerTowfs__ValueListType (480)
#endif

/* ows__MetadataType * has binding name 'PointerToows__MetadataType' for type 'ows:MetadataType' */
#ifndef SOAP_TYPE_PointerToows__MetadataType
#define SOAP_TYPE_PointerToows__MetadataType (479)
#endif

/* wfs__ElementType * has binding name 'PointerTowfs__ElementType' for type 'wfs:ElementType' */
#ifndef SOAP_TYPE_PointerTowfs__ElementType
#define SOAP_TYPE_PointerTowfs__ElementType (477)
#endif

/* enum xlink__actuateType * has binding name 'PointerToxlink__actuateType' for type 'xlink:actuateType' */
#ifndef SOAP_TYPE_PointerToxlink__actuateType
#define SOAP_TYPE_PointerToxlink__actuateType (476)
#endif

/* enum xlink__showType * has binding name 'PointerToxlink__showType' for type 'xlink:showType' */
#ifndef SOAP_TYPE_PointerToxlink__showType
#define SOAP_TYPE_PointerToxlink__showType (475)
#endif

/* std::string * has binding name 'PointerToxlink__titleAttrType' for type 'xlink:titleAttrType' */
#ifndef SOAP_TYPE_PointerToxlink__titleAttrType
#define SOAP_TYPE_PointerToxlink__titleAttrType (474)
#endif

/* char ** has binding name 'PointerToxlink__arcroleType' for type 'xlink:arcroleType' */
#ifndef SOAP_TYPE_PointerToxlink__arcroleType
#define SOAP_TYPE_PointerToxlink__arcroleType (473)
#endif

/* char ** has binding name 'PointerToxlink__roleType' for type 'xlink:roleType' */
#ifndef SOAP_TYPE_PointerToxlink__roleType
#define SOAP_TYPE_PointerToxlink__roleType (472)
#endif

/* char ** has binding name 'PointerToxlink__hrefType' for type 'xlink:hrefType' */
#ifndef SOAP_TYPE_PointerToxlink__hrefType
#define SOAP_TYPE_PointerToxlink__hrefType (471)
#endif

/* wfs__ExtendedDescriptionType * has binding name 'PointerTowfs__ExtendedDescriptionType' for type 'wfs:ExtendedDescriptionType' */
#ifndef SOAP_TYPE_PointerTowfs__ExtendedDescriptionType
#define SOAP_TYPE_PointerTowfs__ExtendedDescriptionType (468)
#endif

/* wfs__MetadataURLType * has binding name 'PointerTowfs__MetadataURLType' for type 'wfs:MetadataURLType' */
#ifndef SOAP_TYPE_PointerTowfs__MetadataURLType
#define SOAP_TYPE_PointerTowfs__MetadataURLType (466)
#endif

/* ows__WGS84BoundingBoxType * has binding name 'PointerToows__WGS84BoundingBoxType' for type 'ows:WGS84BoundingBoxType' */
#ifndef SOAP_TYPE_PointerToows__WGS84BoundingBoxType
#define SOAP_TYPE_PointerToows__WGS84BoundingBoxType (464)
#endif

/* wfs__OutputFormatListType * has binding name 'PointerTowfs__OutputFormatListType' for type 'wfs:OutputFormatListType' */
#ifndef SOAP_TYPE_PointerTowfs__OutputFormatListType
#define SOAP_TYPE_PointerTowfs__OutputFormatListType (463)
#endif

/* _wfs__FeatureTypeType_NoCRS * has binding name 'PointerTo_wfs__FeatureTypeType_NoCRS' for type '' */
#ifndef SOAP_TYPE_PointerTo_wfs__FeatureTypeType_NoCRS
#define SOAP_TYPE_PointerTo_wfs__FeatureTypeType_NoCRS (462)
#endif

/* char ** has binding name 'PointerToxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_PointerToxsd__anyURI
#define SOAP_TYPE_PointerToxsd__anyURI (459)
#endif

/* ows__KeywordsType * has binding name 'PointerToows__KeywordsType' for type 'ows:KeywordsType' */
#ifndef SOAP_TYPE_PointerToows__KeywordsType
#define SOAP_TYPE_PointerToows__KeywordsType (457)
#endif

/* _wfs__Abstract * has binding name 'PointerTo_wfs__Abstract' for type '' */
#ifndef SOAP_TYPE_PointerTo_wfs__Abstract
#define SOAP_TYPE_PointerTo_wfs__Abstract (455)
#endif

/* _wfs__Title * has binding name 'PointerTo_wfs__Title' for type '' */
#ifndef SOAP_TYPE_PointerTo_wfs__Title
#define SOAP_TYPE_PointerTo_wfs__Title (453)
#endif

/* wfs__FeatureTypeType * has binding name 'PointerTowfs__FeatureTypeType' for type 'wfs:FeatureTypeType' */
#ifndef SOAP_TYPE_PointerTowfs__FeatureTypeType
#define SOAP_TYPE_PointerTowfs__FeatureTypeType (451)
#endif

/* struct __wfs__StoredQueryPropertyType_sequence * has binding name 'PointerTo__wfs__StoredQueryPropertyType_sequence' for type '-wfs:StoredQueryPropertyType-sequence' */
#ifndef SOAP_TYPE_PointerTo__wfs__StoredQueryPropertyType_sequence
#define SOAP_TYPE_PointerTo__wfs__StoredQueryPropertyType_sequence (450)
#endif

/* wfs__StoredQueryType * has binding name 'PointerTowfs__StoredQueryType' for type 'wfs:StoredQueryType' */
#ifndef SOAP_TYPE_PointerTowfs__StoredQueryType
#define SOAP_TYPE_PointerTowfs__StoredQueryType (449)
#endif

/* struct __wfs__QueryPropertyType_sequence * has binding name 'PointerTo__wfs__QueryPropertyType_sequence' for type '-wfs:QueryPropertyType-sequence' */
#ifndef SOAP_TYPE_PointerTo__wfs__QueryPropertyType_sequence
#define SOAP_TYPE_PointerTo__wfs__QueryPropertyType_sequence (447)
#endif

/* wfs__QueryType * has binding name 'PointerTowfs__QueryType' for type 'wfs:QueryType' */
#ifndef SOAP_TYPE_PointerTowfs__QueryType
#define SOAP_TYPE_PointerTowfs__QueryType (446)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (444)
#endif

/* icommon__languageIETF has binding name 'icommon__languageIETF' for type 'icommon:languageIETF' */
#ifndef SOAP_TYPE_icommon__languageIETF
#define SOAP_TYPE_icommon__languageIETF (420)
#endif

/* fes__UomURI has binding name 'fes__UomURI' for type 'fes:UomURI' */
#ifndef SOAP_TYPE_fes__UomURI
#define SOAP_TYPE_fes__UomURI (398)
#endif

/* xlink__toType has binding name 'xlink__toType' for type 'xlink:toType' */
#ifndef SOAP_TYPE_xlink__toType
#define SOAP_TYPE_xlink__toType (388)
#endif

/* xlink__fromType has binding name 'xlink__fromType' for type 'xlink:fromType' */
#ifndef SOAP_TYPE_xlink__fromType
#define SOAP_TYPE_xlink__fromType (386)
#endif

/* xlink__labelType has binding name 'xlink__labelType' for type 'xlink:labelType' */
#ifndef SOAP_TYPE_xlink__labelType
#define SOAP_TYPE_xlink__labelType (384)
#endif

/* xlink__arcroleType has binding name 'xlink__arcroleType' for type 'xlink:arcroleType' */
#ifndef SOAP_TYPE_xlink__arcroleType
#define SOAP_TYPE_xlink__arcroleType (376)
#endif

/* xlink__roleType has binding name 'xlink__roleType' for type 'xlink:roleType' */
#ifndef SOAP_TYPE_xlink__roleType
#define SOAP_TYPE_xlink__roleType (374)
#endif

/* xlink__hrefType has binding name 'xlink__hrefType' for type 'xlink:hrefType' */
#ifndef SOAP_TYPE_xlink__hrefType
#define SOAP_TYPE_xlink__hrefType (372)
#endif

/* wfs__ReturnFeatureTypesListType has binding name 'wfs__ReturnFeatureTypesListType' for type 'xsd:QName' */
#ifndef SOAP_TYPE_wfs__ReturnFeatureTypesListType
#define SOAP_TYPE_wfs__ReturnFeatureTypesListType (338)
#endif

/* _ows__Resource has binding name '_ows__Resource' for type '' */
#ifndef SOAP_TYPE__ows__Resource
#define SOAP_TYPE__ows__Resource (149)
#endif

/* _SOAP_ENC__actor has binding name '_SOAP_ENC__actor' for type '' */
#ifndef SOAP_TYPE__SOAP_ENC__actor
#define SOAP_TYPE__SOAP_ENC__actor (50)
#endif

/* xsd__token has binding name 'xsd__token' for type 'xsd:token' */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (42)
#endif

/* xsd__time has binding name 'xsd__time' for type 'xsd:time' */
#ifndef SOAP_TYPE_xsd__time
#define SOAP_TYPE_xsd__time (41)
#endif

/* xsd__QName has binding name 'xsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (40)
#endif

/* xsd__normalizedString has binding name 'xsd__normalizedString' for type 'xsd:normalizedString' */
#ifndef SOAP_TYPE_xsd__normalizedString
#define SOAP_TYPE_xsd__normalizedString (38)
#endif

/* xsd__NMTOKEN has binding name 'xsd__NMTOKEN' for type 'xsd:NMTOKEN' */
#ifndef SOAP_TYPE_xsd__NMTOKEN
#define SOAP_TYPE_xsd__NMTOKEN (33)
#endif

/* xsd__NCName has binding name 'xsd__NCName' for type 'xsd:NCName' */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (32)
#endif

/* xsd__Name has binding name 'xsd__Name' for type 'xsd:Name' */
#ifndef SOAP_TYPE_xsd__Name
#define SOAP_TYPE_xsd__Name (31)
#endif

/* xsd__language has binding name 'xsd__language' for type 'xsd:language' */
#ifndef SOAP_TYPE_xsd__language
#define SOAP_TYPE_xsd__language (29)
#endif

/* xsd__ID has binding name 'xsd__ID' for type 'xsd:ID' */
#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (26)
#endif

/* xsd__duration has binding name 'xsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (23)
#endif

/* xsd__date has binding name 'xsd__date' for type 'xsd:date' */
#ifndef SOAP_TYPE_xsd__date
#define SOAP_TYPE_xsd__date (19)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (16)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (12)
#endif

/* _xsd__schema has binding name '_xsd__schema' for type '' */
#ifndef SOAP_TYPE__xsd__schema
#define SOAP_TYPE__xsd__schema (9)
#endif

/* _xml__lang has binding name '_xml__lang' for type '' */
#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (8)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<icommon__inspireTheme *>  has binding name 'std__vectorTemplateOfPointerToicommon__inspireTheme' for type 'icommon:inspireTheme' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToicommon__inspireTheme
#define SOAP_TYPE_std__vectorTemplateOfPointerToicommon__inspireTheme (866)
#endif

/* std::vector<ows__ReferenceGroupType *>  has binding name 'std__vectorTemplateOfPointerToows__ReferenceGroupType' for type 'ows:ReferenceGroupType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToows__ReferenceGroupType
#define SOAP_TYPE_std__vectorTemplateOfPointerToows__ReferenceGroupType (863)
#endif

/* std::vector<icommon__originatingControlledVocabulary *>  has binding name 'std__vectorTemplateOfPointerToicommon__originatingControlledVocabulary' for type 'icommon:originatingControlledVocabulary' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToicommon__originatingControlledVocabulary
#define SOAP_TYPE_std__vectorTemplateOfPointerToicommon__originatingControlledVocabulary (793)
#endif

/* std::vector<enum icommon__topicCategory>  has binding name 'std__vectorTemplateOficommon__topicCategory' for type 'icommon:topicCategory' */
#ifndef SOAP_TYPE_std__vectorTemplateOficommon__topicCategory
#define SOAP_TYPE_std__vectorTemplateOficommon__topicCategory (790)
#endif

/* std::vector<enum icommon__languageISO6392B>  has binding name 'std__vectorTemplateOficommon__languageISO6392B' for type 'icommon:languageISO6392B' */
#ifndef SOAP_TYPE_std__vectorTemplateOficommon__languageISO6392B
#define SOAP_TYPE_std__vectorTemplateOficommon__languageISO6392B (789)
#endif

/* std::vector<__fes__union_BinaryLogicOpType>  has binding name 'std__vectorTemplateOf__fes__union_BinaryLogicOpType' for type '-fes:union-BinaryLogicOpType' */
#ifndef SOAP_TYPE_std__vectorTemplateOf__fes__union_BinaryLogicOpType
#define SOAP_TYPE_std__vectorTemplateOf__fes__union_BinaryLogicOpType (783)
#endif

/* std::vector<__fes__union_DistanceBufferType>  has binding name 'std__vectorTemplateOf__fes__union_DistanceBufferType' for type '-fes:union-DistanceBufferType' */
#ifndef SOAP_TYPE_std__vectorTemplateOf__fes__union_DistanceBufferType
#define SOAP_TYPE_std__vectorTemplateOf__fes__union_DistanceBufferType (775)
#endif

/* std::vector<__fes__union_BBOXType>  has binding name 'std__vectorTemplateOf__fes__union_BBOXType' for type '-fes:union-BBOXType' */
#ifndef SOAP_TYPE_std__vectorTemplateOf__fes__union_BBOXType
#define SOAP_TYPE_std__vectorTemplateOf__fes__union_BBOXType (772)
#endif

/* std::vector<__fes__union_BinaryTemporalOpType>  has binding name 'std__vectorTemplateOf__fes__union_BinaryTemporalOpType' for type '-fes:union-BinaryTemporalOpType' */
#ifndef SOAP_TYPE_std__vectorTemplateOf__fes__union_BinaryTemporalOpType
#define SOAP_TYPE_std__vectorTemplateOf__fes__union_BinaryTemporalOpType (769)
#endif

/* std::vector<__fes__union_BinarySpatialOpType>  has binding name 'std__vectorTemplateOf__fes__union_BinarySpatialOpType' for type '-fes:union-BinarySpatialOpType' */
#ifndef SOAP_TYPE_std__vectorTemplateOf__fes__union_BinarySpatialOpType
#define SOAP_TYPE_std__vectorTemplateOf__fes__union_BinarySpatialOpType (766)
#endif

/* std::vector<ows__BoundingBoxType *>  has binding name 'std__vectorTemplateOfPointerToows__BoundingBoxType' for type 'ows:BoundingBoxType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToows__BoundingBoxType
#define SOAP_TYPE_std__vectorTemplateOfPointerToows__BoundingBoxType (724)
#endif

/* std::vector<wfs__PropertyType *>  has binding name 'std__vectorTemplateOfPointerTowfs__PropertyType' for type 'wfs:PropertyType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowfs__PropertyType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowfs__PropertyType (719)
#endif

/* std::vector<struct __wfs__TransactionType_sequence>  has binding name 'std__vectorTemplateOf__wfs__TransactionType_sequence' for type '-wfs:TransactionType-sequence' */
#ifndef SOAP_TYPE_std__vectorTemplateOf__wfs__TransactionType_sequence
#define SOAP_TYPE_std__vectorTemplateOf__wfs__TransactionType_sequence (717)
#endif

/* std::vector<wfs__ParameterType *>  has binding name 'std__vectorTemplateOfPointerTowfs__ParameterType' for type 'wfs:ParameterType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowfs__ParameterType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowfs__ParameterType (697)
#endif

/* std::vector<_icommon__layers_Layer_CoordinateReferenceSystems_CRS>  has binding name 'std__vectorTemplateOf_icommon__layers_Layer_CoordinateReferenceSystems_CRS' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_icommon__layers_Layer_CoordinateReferenceSystems_CRS
#define SOAP_TYPE_std__vectorTemplateOf_icommon__layers_Layer_CoordinateReferenceSystems_CRS (685)
#endif

/* std::vector<icommon__uniqueResourceIdentifier *>  has binding name 'std__vectorTemplateOfPointerToicommon__uniqueResourceIdentifier' for type 'icommon:uniqueResourceIdentifier' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToicommon__uniqueResourceIdentifier
#define SOAP_TYPE_std__vectorTemplateOfPointerToicommon__uniqueResourceIdentifier (682)
#endif

/* std::vector<icommon__languageElementISO6392B *>  has binding name 'std__vectorTemplateOfPointerToicommon__languageElementISO6392B' for type 'icommon:languageElementISO6392B' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToicommon__languageElementISO6392B
#define SOAP_TYPE_std__vectorTemplateOfPointerToicommon__languageElementISO6392B (679)
#endif

/* std::vector<icommon__classificationOfSpatialDataService *>  has binding name 'std__vectorTemplateOfPointerToicommon__classificationOfSpatialDataService' for type 'icommon:classificationOfSpatialDataService' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToicommon__classificationOfSpatialDataService
#define SOAP_TYPE_std__vectorTemplateOfPointerToicommon__classificationOfSpatialDataService (678)
#endif

/* std::vector<enum icommon__mediaType>  has binding name 'std__vectorTemplateOficommon__mediaType' for type 'icommon:mediaType' */
#ifndef SOAP_TYPE_std__vectorTemplateOficommon__mediaType
#define SOAP_TYPE_std__vectorTemplateOficommon__mediaType (670)
#endif

/* std::vector<icommon__temporalExtent *>  has binding name 'std__vectorTemplateOfPointerToicommon__temporalExtent' for type 'icommon:temporalExtent' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToicommon__temporalExtent
#define SOAP_TYPE_std__vectorTemplateOfPointerToicommon__temporalExtent (664)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOficommon__iso8601Date' for type 'icommon:iso8601Date' */
#ifndef SOAP_TYPE_std__vectorTemplateOficommon__iso8601Date
#define SOAP_TYPE_std__vectorTemplateOficommon__iso8601Date (662)
#endif

/* std::vector<icommon__metadataPointOfContact *>  has binding name 'std__vectorTemplateOfPointerToicommon__metadataPointOfContact' for type 'icommon:metadataPointOfContact' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToicommon__metadataPointOfContact
#define SOAP_TYPE_std__vectorTemplateOfPointerToicommon__metadataPointOfContact (657)
#endif

/* std::vector<icommon__responsibleOrganisation *>  has binding name 'std__vectorTemplateOfPointerToicommon__responsibleOrganisation' for type 'icommon:responsibleOrganisation' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToicommon__responsibleOrganisation
#define SOAP_TYPE_std__vectorTemplateOfPointerToicommon__responsibleOrganisation (655)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOficommon__notEmptyString' for type 'icommon:notEmptyString' */
#ifndef SOAP_TYPE_std__vectorTemplateOficommon__notEmptyString
#define SOAP_TYPE_std__vectorTemplateOficommon__notEmptyString (653)
#endif

/* std::vector<icommon__conformity *>  has binding name 'std__vectorTemplateOfPointerToicommon__conformity' for type 'icommon:conformity' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToicommon__conformity
#define SOAP_TYPE_std__vectorTemplateOfPointerToicommon__conformity (652)
#endif

/* std::vector<icommon__spatialResolution *>  has binding name 'std__vectorTemplateOfPointerToicommon__spatialResolution' for type 'icommon:spatialResolution' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToicommon__spatialResolution
#define SOAP_TYPE_std__vectorTemplateOfPointerToicommon__spatialResolution (650)
#endif

/* std::vector<icommon__temporalReference *>  has binding name 'std__vectorTemplateOfPointerToicommon__temporalReference' for type 'icommon:temporalReference' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToicommon__temporalReference
#define SOAP_TYPE_std__vectorTemplateOfPointerToicommon__temporalReference (648)
#endif

/* std::vector<icommon__geographicBoundingBox *>  has binding name 'std__vectorTemplateOfPointerToicommon__geographicBoundingBox' for type 'icommon:geographicBoundingBox' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToicommon__geographicBoundingBox
#define SOAP_TYPE_std__vectorTemplateOfPointerToicommon__geographicBoundingBox (646)
#endif

/* std::vector<icommon__keyword *>  has binding name 'std__vectorTemplateOfPointerToicommon__keyword' for type 'icommon:keyword' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToicommon__keyword
#define SOAP_TYPE_std__vectorTemplateOfPointerToicommon__keyword (644)
#endif

/* std::vector<icommon__resourceLocatorType *>  has binding name 'std__vectorTemplateOfPointerToicommon__resourceLocatorType' for type 'icommon:resourceLocatorType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToicommon__resourceLocatorType
#define SOAP_TYPE_std__vectorTemplateOfPointerToicommon__resourceLocatorType (642)
#endif

/* std::vector<fes__SortPropertyType *>  has binding name 'std__vectorTemplateOfPointerTofes__SortPropertyType' for type 'fes:SortPropertyType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTofes__SortPropertyType
#define SOAP_TYPE_std__vectorTemplateOfPointerTofes__SortPropertyType (632)
#endif

/* std::vector<fes__ExtensionOperatorType *>  has binding name 'std__vectorTemplateOfPointerTofes__ExtensionOperatorType' for type 'fes:ExtensionOperatorType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTofes__ExtensionOperatorType
#define SOAP_TYPE_std__vectorTemplateOfPointerTofes__ExtensionOperatorType (630)
#endif

/* std::vector<fes__TemporalOperatorType *>  has binding name 'std__vectorTemplateOfPointerTofes__TemporalOperatorType' for type 'fes:TemporalOperatorType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTofes__TemporalOperatorType
#define SOAP_TYPE_std__vectorTemplateOfPointerTofes__TemporalOperatorType (627)
#endif

/* std::vector<_fes__TemporalOperandsType_TemporalOperand>  has binding name 'std__vectorTemplateOf_fes__TemporalOperandsType_TemporalOperand' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_fes__TemporalOperandsType_TemporalOperand
#define SOAP_TYPE_std__vectorTemplateOf_fes__TemporalOperandsType_TemporalOperand (625)
#endif

/* std::vector<fes__SpatialOperatorType *>  has binding name 'std__vectorTemplateOfPointerTofes__SpatialOperatorType' for type 'fes:SpatialOperatorType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTofes__SpatialOperatorType
#define SOAP_TYPE_std__vectorTemplateOfPointerTofes__SpatialOperatorType (620)
#endif

/* std::vector<_fes__GeometryOperandsType_GeometryOperand>  has binding name 'std__vectorTemplateOf_fes__GeometryOperandsType_GeometryOperand' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_fes__GeometryOperandsType_GeometryOperand
#define SOAP_TYPE_std__vectorTemplateOf_fes__GeometryOperandsType_GeometryOperand (618)
#endif

/* std::vector<fes__ArgumentType *>  has binding name 'std__vectorTemplateOfPointerTofes__ArgumentType' for type 'fes:ArgumentType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTofes__ArgumentType
#define SOAP_TYPE_std__vectorTemplateOfPointerTofes__ArgumentType (614)
#endif

/* std::vector<fes__AvailableFunctionType *>  has binding name 'std__vectorTemplateOfPointerTofes__AvailableFunctionType' for type 'fes:AvailableFunctionType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTofes__AvailableFunctionType
#define SOAP_TYPE_std__vectorTemplateOfPointerTofes__AvailableFunctionType (611)
#endif

/* std::vector<struct __fes__ComparisonOperatorsType_sequence>  has binding name 'std__vectorTemplateOf__fes__ComparisonOperatorsType_sequence' for type '-fes:ComparisonOperatorsType-sequence' */
#ifndef SOAP_TYPE_std__vectorTemplateOf__fes__ComparisonOperatorsType_sequence
#define SOAP_TYPE_std__vectorTemplateOf__fes__ComparisonOperatorsType_sequence (609)
#endif

/* std::vector<fes__ResourceIdentifierType *>  has binding name 'std__vectorTemplateOfPointerTofes__ResourceIdentifierType' for type 'fes:ResourceIdentifierType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTofes__ResourceIdentifierType
#define SOAP_TYPE_std__vectorTemplateOfPointerTofes__ResourceIdentifierType (604)
#endif

/* std::vector<__xlink__union_extended>  has binding name 'std__vectorTemplateOf__xlink__union_extended' for type '-xlink:union-extended' */
#ifndef SOAP_TYPE_std__vectorTemplateOf__xlink__union_extended
#define SOAP_TYPE_std__vectorTemplateOf__xlink__union_extended (585)
#endif

/* std::vector<__ows__union_AllowedValues>  has binding name 'std__vectorTemplateOf__ows__union_AllowedValues' for type '-ows:union-AllowedValues' */
#ifndef SOAP_TYPE_std__vectorTemplateOf__ows__union_AllowedValues
#define SOAP_TYPE_std__vectorTemplateOf__ows__union_AllowedValues (582)
#endif

/* std::vector<__ows__union_HTTP>  has binding name 'std__vectorTemplateOf__ows__union_HTTP' for type '-ows:union-HTTP' */
#ifndef SOAP_TYPE_std__vectorTemplateOf__ows__union_HTTP
#define SOAP_TYPE_std__vectorTemplateOf__ows__union_HTTP (578)
#endif

/* std::vector<_ows__DCP *>  has binding name 'std__vectorTemplateOfPointerTo_ows__DCP' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTo_ows__DCP
#define SOAP_TYPE_std__vectorTemplateOfPointerTo_ows__DCP (572)
#endif

/* std::vector<ows__DomainType *>  has binding name 'std__vectorTemplateOfPointerToows__DomainType' for type 'ows:DomainType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToows__DomainType
#define SOAP_TYPE_std__vectorTemplateOfPointerToows__DomainType (569)
#endif

/* std::vector<_ows__Operation *>  has binding name 'std__vectorTemplateOfPointerTo_ows__Operation' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTo_ows__Operation
#define SOAP_TYPE_std__vectorTemplateOfPointerTo_ows__Operation (567)
#endif

/* std::vector<ows__ExceptionType *>  has binding name 'std__vectorTemplateOfPointerToows__ExceptionType' for type 'ows:ExceptionType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToows__ExceptionType
#define SOAP_TYPE_std__vectorTemplateOfPointerToows__ExceptionType (563)
#endif

/* std::vector<ows__DatasetDescriptionSummaryBaseType *>  has binding name 'std__vectorTemplateOfPointerToows__DatasetDescriptionSummaryBaseType' for type 'ows:DatasetDescriptionSummaryBaseType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToows__DatasetDescriptionSummaryBaseType
#define SOAP_TYPE_std__vectorTemplateOfPointerToows__DatasetDescriptionSummaryBaseType (561)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfows__MimeType' for type 'ows:MimeType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfows__MimeType
#define SOAP_TYPE_std__vectorTemplateOfows__MimeType (551)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfows__VersionType' for type 'ows:VersionType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfows__VersionType
#define SOAP_TYPE_std__vectorTemplateOfows__VersionType (550)
#endif

/* std::vector<ows__LanguageStringType *>  has binding name 'std__vectorTemplateOfPointerToows__LanguageStringType' for type 'ows:LanguageStringType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToows__LanguageStringType
#define SOAP_TYPE_std__vectorTemplateOfPointerToows__LanguageStringType (535)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string
#define SOAP_TYPE_std__vectorTemplateOfstd__string (532)
#endif

/* std::vector<struct __wfs__CreatedOrModifiedFeatureType_sequence>  has binding name 'std__vectorTemplateOf__wfs__CreatedOrModifiedFeatureType_sequence' for type '-wfs:CreatedOrModifiedFeatureType-sequence' */
#ifndef SOAP_TYPE_std__vectorTemplateOf__wfs__CreatedOrModifiedFeatureType_sequence
#define SOAP_TYPE_std__vectorTemplateOf__wfs__CreatedOrModifiedFeatureType_sequence (527)
#endif

/* std::vector<wfs__CreatedOrModifiedFeatureType *>  has binding name 'std__vectorTemplateOfPointerTowfs__CreatedOrModifiedFeatureType' for type 'wfs:CreatedOrModifiedFeatureType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowfs__CreatedOrModifiedFeatureType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowfs__CreatedOrModifiedFeatureType (525)
#endif

/* std::vector<struct __wfs__FeaturesNotLockedType_sequence>  has binding name 'std__vectorTemplateOf__wfs__FeaturesNotLockedType_sequence' for type '-wfs:FeaturesNotLockedType-sequence' */
#ifndef SOAP_TYPE_std__vectorTemplateOf__wfs__FeaturesNotLockedType_sequence
#define SOAP_TYPE_std__vectorTemplateOf__wfs__FeaturesNotLockedType_sequence (519)
#endif

/* std::vector<struct __wfs__FeaturesLockedType_sequence>  has binding name 'std__vectorTemplateOf__wfs__FeaturesLockedType_sequence' for type '-wfs:FeaturesLockedType-sequence' */
#ifndef SOAP_TYPE_std__vectorTemplateOf__wfs__FeaturesLockedType_sequence
#define SOAP_TYPE_std__vectorTemplateOf__wfs__FeaturesLockedType_sequence (517)
#endif

/* std::vector<wfs__QueryType *>  has binding name 'std__vectorTemplateOfPointerTowfs__QueryType' for type 'wfs:QueryType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowfs__QueryType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowfs__QueryType (510)
#endif

/* std::vector<wfs__StoredQueryType *>  has binding name 'std__vectorTemplateOfPointerTowfs__StoredQueryType' for type 'wfs:StoredQueryType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowfs__StoredQueryType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowfs__StoredQueryType (508)
#endif

/* std::vector<char *>  has binding name 'std__vectorTemplateOf_XML' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_XML
#define SOAP_TYPE_std__vectorTemplateOf_XML (506)
#endif

/* std::vector<wfs__QueryExpressionTextType *>  has binding name 'std__vectorTemplateOfPointerTowfs__QueryExpressionTextType' for type 'wfs:QueryExpressionTextType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowfs__QueryExpressionTextType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowfs__QueryExpressionTextType (504)
#endif

/* std::vector<wfs__ParameterExpressionType *>  has binding name 'std__vectorTemplateOfPointerTowfs__ParameterExpressionType' for type 'wfs:ParameterExpressionType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowfs__ParameterExpressionType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowfs__ParameterExpressionType (502)
#endif

/* std::vector<ows__MetadataType *>  has binding name 'std__vectorTemplateOfPointerToows__MetadataType' for type 'ows:MetadataType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToows__MetadataType
#define SOAP_TYPE_std__vectorTemplateOfPointerToows__MetadataType (500)
#endif

/* std::vector<wfs__StoredQueryDescriptionType *>  has binding name 'std__vectorTemplateOfPointerTowfs__StoredQueryDescriptionType' for type 'wfs:StoredQueryDescriptionType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowfs__StoredQueryDescriptionType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowfs__StoredQueryDescriptionType (499)
#endif

/* std::vector<char *>  has binding name 'std__vectorTemplateOfxsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__QName
#define SOAP_TYPE_std__vectorTemplateOfxsd__QName (497)
#endif

/* std::vector<wfs__StoredQueryListItemType *>  has binding name 'std__vectorTemplateOfPointerTowfs__StoredQueryListItemType' for type 'wfs:StoredQueryListItemType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowfs__StoredQueryListItemType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowfs__StoredQueryListItemType (496)
#endif

/* std::vector<wfs__MemberPropertyType *>  has binding name 'std__vectorTemplateOfPointerTowfs__MemberPropertyType' for type 'wfs:MemberPropertyType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowfs__MemberPropertyType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowfs__MemberPropertyType (485)
#endif

/* std::vector<struct __wfs__ValueListType_sequence>  has binding name 'std__vectorTemplateOf__wfs__ValueListType_sequence' for type '-wfs:ValueListType-sequence' */
#ifndef SOAP_TYPE_std__vectorTemplateOf__wfs__ValueListType_sequence
#define SOAP_TYPE_std__vectorTemplateOf__wfs__ValueListType_sequence (483)
#endif

/* std::vector<wfs__ElementType *>  has binding name 'std__vectorTemplateOfPointerTowfs__ElementType' for type 'wfs:ElementType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowfs__ElementType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowfs__ElementType (478)
#endif

/* std::vector<struct __wfs__OutputFormatListType_sequence>  has binding name 'std__vectorTemplateOf__wfs__OutputFormatListType_sequence' for type '-wfs:OutputFormatListType-sequence' */
#ifndef SOAP_TYPE_std__vectorTemplateOf__wfs__OutputFormatListType_sequence
#define SOAP_TYPE_std__vectorTemplateOf__wfs__OutputFormatListType_sequence (470)
#endif

/* std::vector<wfs__MetadataURLType *>  has binding name 'std__vectorTemplateOfPointerTowfs__MetadataURLType' for type 'wfs:MetadataURLType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowfs__MetadataURLType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowfs__MetadataURLType (467)
#endif

/* std::vector<ows__WGS84BoundingBoxType *>  has binding name 'std__vectorTemplateOfPointerToows__WGS84BoundingBoxType' for type 'ows:WGS84BoundingBoxType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToows__WGS84BoundingBoxType
#define SOAP_TYPE_std__vectorTemplateOfPointerToows__WGS84BoundingBoxType (465)
#endif

/* std::vector<char *>  has binding name 'std__vectorTemplateOfxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__anyURI
#define SOAP_TYPE_std__vectorTemplateOfxsd__anyURI (460)
#endif

/* std::vector<ows__KeywordsType *>  has binding name 'std__vectorTemplateOfPointerToows__KeywordsType' for type 'ows:KeywordsType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToows__KeywordsType
#define SOAP_TYPE_std__vectorTemplateOfPointerToows__KeywordsType (458)
#endif

/* std::vector<_wfs__Abstract *>  has binding name 'std__vectorTemplateOfPointerTo_wfs__Abstract' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTo_wfs__Abstract
#define SOAP_TYPE_std__vectorTemplateOfPointerTo_wfs__Abstract (456)
#endif

/* std::vector<_wfs__Title *>  has binding name 'std__vectorTemplateOfPointerTo_wfs__Title' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTo_wfs__Title
#define SOAP_TYPE_std__vectorTemplateOfPointerTo_wfs__Title (454)
#endif

/* std::vector<wfs__FeatureTypeType *>  has binding name 'std__vectorTemplateOfPointerTowfs__FeatureTypeType' for type 'wfs:FeatureTypeType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowfs__FeatureTypeType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowfs__FeatureTypeType (452)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stub Functions                                            *
 *                                                                            *
\******************************************************************************/

    
    /** Web service synchronous operation 'soap_call___f2i_plu__wfs_x002ecreateStoredQuery' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___f2i_plu__wfs_x002ecreateStoredQuery(struct soap *soap, const char *soap_endpoint, const char *soap_action, wfs__CreateStoredQueryType *wfs__CreateStoredQuery, wfs__CreateStoredQueryResponseType &wfs__CreateStoredQueryResponse);
    /** Web service asynchronous operation 'soap_send___f2i_plu__wfs_x002ecreateStoredQuery' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___f2i_plu__wfs_x002ecreateStoredQuery(struct soap *soap, const char *soap_endpoint, const char *soap_action, wfs__CreateStoredQueryType *wfs__CreateStoredQuery);
    /** Web service asynchronous operation 'soap_recv___f2i_plu__wfs_x002ecreateStoredQuery' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___f2i_plu__wfs_x002ecreateStoredQuery(struct soap *soap, wfs__CreateStoredQueryResponseType &wfs__CreateStoredQueryResponse);
    
    /** Web service synchronous operation 'soap_call___f2i_plu__wfs_x002edescribeFeatureType' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___f2i_plu__wfs_x002edescribeFeatureType(struct soap *soap, const char *soap_endpoint, const char *soap_action, wfs__DescribeFeatureTypeType *wfs__DescribeFeatureType, util__DescribeFeatureTypeResponseType &util__DescribeFeatureTypeResponse);
    /** Web service asynchronous operation 'soap_send___f2i_plu__wfs_x002edescribeFeatureType' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___f2i_plu__wfs_x002edescribeFeatureType(struct soap *soap, const char *soap_endpoint, const char *soap_action, wfs__DescribeFeatureTypeType *wfs__DescribeFeatureType);
    /** Web service asynchronous operation 'soap_recv___f2i_plu__wfs_x002edescribeFeatureType' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___f2i_plu__wfs_x002edescribeFeatureType(struct soap *soap, util__DescribeFeatureTypeResponseType &util__DescribeFeatureTypeResponse);
    
    /** Web service synchronous operation 'soap_call___f2i_plu__wfs_x002egetFeature' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___f2i_plu__wfs_x002egetFeature(struct soap *soap, const char *soap_endpoint, const char *soap_action, wfs__GetFeatureType *wfs__GetFeature, wfs__FeatureCollectionType &wfs__FeatureCollection);
    /** Web service asynchronous operation 'soap_send___f2i_plu__wfs_x002egetFeature' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___f2i_plu__wfs_x002egetFeature(struct soap *soap, const char *soap_endpoint, const char *soap_action, wfs__GetFeatureType *wfs__GetFeature);
    /** Web service asynchronous operation 'soap_recv___f2i_plu__wfs_x002egetFeature' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___f2i_plu__wfs_x002egetFeature(struct soap *soap, wfs__FeatureCollectionType &wfs__FeatureCollection);
    
    /** Web service synchronous operation 'soap_call___f2i_plu__wfs_x002edescribeStoredQueries' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___f2i_plu__wfs_x002edescribeStoredQueries(struct soap *soap, const char *soap_endpoint, const char *soap_action, wfs__DescribeStoredQueriesType *wfs__DescribeStoredQueries, wfs__DescribeStoredQueriesResponseType &wfs__DescribeStoredQueriesResponse);
    /** Web service asynchronous operation 'soap_send___f2i_plu__wfs_x002edescribeStoredQueries' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___f2i_plu__wfs_x002edescribeStoredQueries(struct soap *soap, const char *soap_endpoint, const char *soap_action, wfs__DescribeStoredQueriesType *wfs__DescribeStoredQueries);
    /** Web service asynchronous operation 'soap_recv___f2i_plu__wfs_x002edescribeStoredQueries' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___f2i_plu__wfs_x002edescribeStoredQueries(struct soap *soap, wfs__DescribeStoredQueriesResponseType &wfs__DescribeStoredQueriesResponse);
    
    /** Web service synchronous operation 'soap_call___f2i_plu__wfs_x002elistStoredQueries' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___f2i_plu__wfs_x002elistStoredQueries(struct soap *soap, const char *soap_endpoint, const char *soap_action, wfs__ListStoredQueriesType *wfs__ListStoredQueries, wfs__ListStoredQueriesResponseType &wfs__ListStoredQueriesResponse);
    /** Web service asynchronous operation 'soap_send___f2i_plu__wfs_x002elistStoredQueries' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___f2i_plu__wfs_x002elistStoredQueries(struct soap *soap, const char *soap_endpoint, const char *soap_action, wfs__ListStoredQueriesType *wfs__ListStoredQueries);
    /** Web service asynchronous operation 'soap_recv___f2i_plu__wfs_x002elistStoredQueries' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___f2i_plu__wfs_x002elistStoredQueries(struct soap *soap, wfs__ListStoredQueriesResponseType &wfs__ListStoredQueriesResponse);
    
    /** Web service synchronous operation 'soap_call___f2i_plu__wfs_x002edropStoredQuery' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___f2i_plu__wfs_x002edropStoredQuery(struct soap *soap, const char *soap_endpoint, const char *soap_action, _wfs__DropStoredQuery *wfs__DropStoredQuery, wfs__ExecutionStatusType &wfs__DropStoredQueryResponse);
    /** Web service asynchronous operation 'soap_send___f2i_plu__wfs_x002edropStoredQuery' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___f2i_plu__wfs_x002edropStoredQuery(struct soap *soap, const char *soap_endpoint, const char *soap_action, _wfs__DropStoredQuery *wfs__DropStoredQuery);
    /** Web service asynchronous operation 'soap_recv___f2i_plu__wfs_x002edropStoredQuery' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___f2i_plu__wfs_x002edropStoredQuery(struct soap *soap, wfs__ExecutionStatusType &wfs__DropStoredQueryResponse);
    
    /** Web service synchronous operation 'soap_call___f2i_plu__wfs_x002egetCapabilities' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___f2i_plu__wfs_x002egetCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, ows__GetCapabilitiesType *ows__GetCapabilities, wfs__WFS_x005fCapabilitiesType &wfs__WFS_x005fCapabilities);
    /** Web service asynchronous operation 'soap_send___f2i_plu__wfs_x002egetCapabilities' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___f2i_plu__wfs_x002egetCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, ows__GetCapabilitiesType *ows__GetCapabilities);
    /** Web service asynchronous operation 'soap_recv___f2i_plu__wfs_x002egetCapabilities' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___f2i_plu__wfs_x002egetCapabilities(struct soap *soap, wfs__WFS_x005fCapabilitiesType &wfs__WFS_x005fCapabilities);
    
    /** Web service synchronous operation 'soap_call___f2i_plu__wfs_x002egetFeatureWithLock' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___f2i_plu__wfs_x002egetFeatureWithLock(struct soap *soap, const char *soap_endpoint, const char *soap_action, wfs__GetFeatureWithLockType *wfs__GetFeatureWithLock, wfs__FeatureCollectionType &wfs__FeatureCollection);
    /** Web service asynchronous operation 'soap_send___f2i_plu__wfs_x002egetFeatureWithLock' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___f2i_plu__wfs_x002egetFeatureWithLock(struct soap *soap, const char *soap_endpoint, const char *soap_action, wfs__GetFeatureWithLockType *wfs__GetFeatureWithLock);
    /** Web service asynchronous operation 'soap_recv___f2i_plu__wfs_x002egetFeatureWithLock' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___f2i_plu__wfs_x002egetFeatureWithLock(struct soap *soap, wfs__FeatureCollectionType &wfs__FeatureCollection);
    
    /** Web service synchronous operation 'soap_call___f2i_plu__wfs_x002egetPropertyValue' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___f2i_plu__wfs_x002egetPropertyValue(struct soap *soap, const char *soap_endpoint, const char *soap_action, wfs__GetPropertyValueType *wfs__GetPropertyValue, wfs__ValueCollectionType &wfs__ValueCollection);
    /** Web service asynchronous operation 'soap_send___f2i_plu__wfs_x002egetPropertyValue' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___f2i_plu__wfs_x002egetPropertyValue(struct soap *soap, const char *soap_endpoint, const char *soap_action, wfs__GetPropertyValueType *wfs__GetPropertyValue);
    /** Web service asynchronous operation 'soap_recv___f2i_plu__wfs_x002egetPropertyValue' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___f2i_plu__wfs_x002egetPropertyValue(struct soap *soap, wfs__ValueCollectionType &wfs__ValueCollection);
    
    /** Web service synchronous operation 'soap_call___f2i_plu__wfs_x002elockFeature' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___f2i_plu__wfs_x002elockFeature(struct soap *soap, const char *soap_endpoint, const char *soap_action, wfs__LockFeatureType *wfs__LockFeature, wfs__LockFeatureResponseType &wfs__LockFeatureResponse);
    /** Web service asynchronous operation 'soap_send___f2i_plu__wfs_x002elockFeature' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___f2i_plu__wfs_x002elockFeature(struct soap *soap, const char *soap_endpoint, const char *soap_action, wfs__LockFeatureType *wfs__LockFeature);
    /** Web service asynchronous operation 'soap_recv___f2i_plu__wfs_x002elockFeature' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___f2i_plu__wfs_x002elockFeature(struct soap *soap, wfs__LockFeatureResponseType &wfs__LockFeatureResponse);
    
    /** Web service synchronous operation 'soap_call___f2i_plu__wfs_x002etransaction' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___f2i_plu__wfs_x002etransaction(struct soap *soap, const char *soap_endpoint, const char *soap_action, wfs__TransactionType *wfs__Transaction, wfs__TransactionResponseType &wfs__TransactionResponse);
    /** Web service asynchronous operation 'soap_send___f2i_plu__wfs_x002etransaction' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___f2i_plu__wfs_x002etransaction(struct soap *soap, const char *soap_endpoint, const char *soap_action, wfs__TransactionType *wfs__Transaction);
    /** Web service asynchronous operation 'soap_recv___f2i_plu__wfs_x002etransaction' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___f2i_plu__wfs_x002etransaction(struct soap *soap, wfs__TransactionResponseType &wfs__TransactionResponse);

/******************************************************************************\
 *                                                                            *
 * Server-Side Operations                                                     *
 *                                                                            *
\******************************************************************************/

    /** Web service operation '__f2i_plu__wfs_x002ecreateStoredQuery' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __f2i_plu__wfs_x002ecreateStoredQuery(struct soap*, wfs__CreateStoredQueryType *wfs__CreateStoredQuery, wfs__CreateStoredQueryResponseType &wfs__CreateStoredQueryResponse);
    /** Web service operation '__f2i_plu__wfs_x002edescribeFeatureType' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __f2i_plu__wfs_x002edescribeFeatureType(struct soap*, wfs__DescribeFeatureTypeType *wfs__DescribeFeatureType, util__DescribeFeatureTypeResponseType &util__DescribeFeatureTypeResponse);
    /** Web service operation '__f2i_plu__wfs_x002egetFeature' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __f2i_plu__wfs_x002egetFeature(struct soap*, wfs__GetFeatureType *wfs__GetFeature, wfs__FeatureCollectionType &wfs__FeatureCollection);
    /** Web service operation '__f2i_plu__wfs_x002edescribeStoredQueries' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __f2i_plu__wfs_x002edescribeStoredQueries(struct soap*, wfs__DescribeStoredQueriesType *wfs__DescribeStoredQueries, wfs__DescribeStoredQueriesResponseType &wfs__DescribeStoredQueriesResponse);
    /** Web service operation '__f2i_plu__wfs_x002elistStoredQueries' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __f2i_plu__wfs_x002elistStoredQueries(struct soap*, wfs__ListStoredQueriesType *wfs__ListStoredQueries, wfs__ListStoredQueriesResponseType &wfs__ListStoredQueriesResponse);
    /** Web service operation '__f2i_plu__wfs_x002edropStoredQuery' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __f2i_plu__wfs_x002edropStoredQuery(struct soap*, _wfs__DropStoredQuery *wfs__DropStoredQuery, wfs__ExecutionStatusType &wfs__DropStoredQueryResponse);
    /** Web service operation '__f2i_plu__wfs_x002egetCapabilities' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __f2i_plu__wfs_x002egetCapabilities(struct soap*, ows__GetCapabilitiesType *ows__GetCapabilities, wfs__WFS_x005fCapabilitiesType &wfs__WFS_x005fCapabilities);
    /** Web service operation '__f2i_plu__wfs_x002egetFeatureWithLock' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __f2i_plu__wfs_x002egetFeatureWithLock(struct soap*, wfs__GetFeatureWithLockType *wfs__GetFeatureWithLock, wfs__FeatureCollectionType &wfs__FeatureCollection);
    /** Web service operation '__f2i_plu__wfs_x002egetPropertyValue' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __f2i_plu__wfs_x002egetPropertyValue(struct soap*, wfs__GetPropertyValueType *wfs__GetPropertyValue, wfs__ValueCollectionType &wfs__ValueCollection);
    /** Web service operation '__f2i_plu__wfs_x002elockFeature' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __f2i_plu__wfs_x002elockFeature(struct soap*, wfs__LockFeatureType *wfs__LockFeature, wfs__LockFeatureResponseType &wfs__LockFeatureResponse);
    /** Web service operation '__f2i_plu__wfs_x002etransaction' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __f2i_plu__wfs_x002etransaction(struct soap*, wfs__TransactionType *wfs__Transaction, wfs__TransactionResponseType &wfs__TransactionResponse);

/******************************************************************************\
 *                                                                            *
 * Server-Side Skeletons to Invoke Service Operations                         *
 *                                                                            *
\******************************************************************************/

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___f2i_plu__wfs_x002ecreateStoredQuery(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___f2i_plu__wfs_x002edescribeFeatureType(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___f2i_plu__wfs_x002egetFeature(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___f2i_plu__wfs_x002edescribeStoredQueries(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___f2i_plu__wfs_x002elistStoredQueries(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___f2i_plu__wfs_x002edropStoredQuery(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___f2i_plu__wfs_x002egetCapabilities(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___f2i_plu__wfs_x002egetFeatureWithLock(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___f2i_plu__wfs_x002egetPropertyValue(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___f2i_plu__wfs_x002elockFeature(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___f2i_plu__wfs_x002etransaction(struct soap*);

#endif

/* End of soapStub.h */
