/* pluStub.h
   Generated by gSOAP 2.8.92 for PlannedLandUse_v3.0.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_NAMESPACE_OF_plu	"http://inspire.ec.europa.eu/schemas/plu/3.0"
#define SOAP_NAMESPACE_OF_base	"http://inspire.ec.europa.eu/schemas/base/3.3"
#define SOAP_NAMESPACE_OF_base2	"http://inspire.ec.europa.eu/schemas/base2/1.0"
#define SOAP_NAMESPACE_OF_lunom	"http://inspire.ec.europa.eu/schemas/lunom/3.0"
#define SOAP_NAMESPACE_OF_sc	"http://www.interactive-instruments.de/ShapeChange/AppInfo"
#define SOAP_NAMESPACE_OF_gml	"http://www.opengis.net/gml/3.2"
#define SOAP_NAMESPACE_OF_gmd	"http://www.isotc211.org/2005/gmd"
#define SOAP_NAMESPACE_OF_xlink	"http://www.w3.org/1999/xlink"
#define SOAP_NAMESPACE_OF_gco	"http://www.isotc211.org/2005/gco"
#define SOAP_NAMESPACE_OF_gss	"http://www.isotc211.org/2005/gss"
#define SOAP_NAMESPACE_OF_gts	"http://www.isotc211.org/2005/gts"
#define SOAP_NAMESPACE_OF_gsr	"http://www.isotc211.org/2005/gsr"

#ifndef pluStub_H
#define pluStub_H
#ifndef WITH_NOGLOBAL
#define WITH_NOGLOBAL
#endif
#include "stdsoap2.h"
#if GSOAP_VERSION != 20892
# error "GSOAP VERSION 20892 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


namespace plu {

/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* PlannedLandUse_v3.0.h:2565 */
#ifndef SOAP_TYPE_plu_base__VerticalPositionValueType
#define SOAP_TYPE_plu_base__VerticalPositionValueType (-757)

/* base:VerticalPositionValueType */
enum base__VerticalPositionValueType {
	base__VerticalPositionValueType__onGroundSurface = 0,
	base__VerticalPositionValueType__suspendedOrElevated = 1,
	base__VerticalPositionValueType__underground = 2
};
#endif

/* PlannedLandUse_v3.0.h:2629 */
#ifndef SOAP_TYPE_plu_gml__CurveInterpolationType
#define SOAP_TYPE_plu_gml__CurveInterpolationType (-759)

/* gml:CurveInterpolationType */
enum gml__CurveInterpolationType {
	gml__CurveInterpolationType__linear = 0,
	gml__CurveInterpolationType__geodesic = 1,
	gml__CurveInterpolationType__circularArc3Points = 2,
	gml__CurveInterpolationType__circularArc2PointWithBulge = 3,
	gml__CurveInterpolationType__circularArcCenterPointWithRadius = 4,
	gml__CurveInterpolationType__elliptical = 5,
	gml__CurveInterpolationType__clothoid = 6,
	gml__CurveInterpolationType__conic = 7,
	gml__CurveInterpolationType__polynomialSpline = 8,
	gml__CurveInterpolationType__cubicSpline = 9,
	gml__CurveInterpolationType__rationalSpline = 10
};
#endif

/* PlannedLandUse_v3.0.h:2657 */
#ifndef SOAP_TYPE_plu_gml__KnotTypesType
#define SOAP_TYPE_plu_gml__KnotTypesType (-761)

/* gml:KnotTypesType */
enum gml__KnotTypesType {
	gml__KnotTypesType__uniform = 0,
	gml__KnotTypesType__quasiUniform = 1,
	gml__KnotTypesType__piecewiseBezier = 2
};
#endif

/* PlannedLandUse_v3.0.h:2677 */
#ifndef SOAP_TYPE_plu_gml__SurfaceInterpolationType
#define SOAP_TYPE_plu_gml__SurfaceInterpolationType (-763)

/* gml:SurfaceInterpolationType */
enum gml__SurfaceInterpolationType {
	gml__SurfaceInterpolationType__none = 0,
	gml__SurfaceInterpolationType__planar = 1,
	gml__SurfaceInterpolationType__spherical = 2,
	gml__SurfaceInterpolationType__elliptical = 3,
	gml__SurfaceInterpolationType__conic = 4,
	gml__SurfaceInterpolationType__tin = 5,
	gml__SurfaceInterpolationType__parametricCurve = 6,
	gml__SurfaceInterpolationType__polynomialSpline = 7,
	gml__SurfaceInterpolationType__rationalSpline = 8,
	gml__SurfaceInterpolationType__triangulatedSpline = 9
};
#endif

/* PlannedLandUse_v3.0.h:2701 */
#ifndef SOAP_TYPE_plu_gml__AggregationType
#define SOAP_TYPE_plu_gml__AggregationType (-765)

/* gml:AggregationType */
enum gml__AggregationType {
	gml__AggregationType__set = 0,
	gml__AggregationType__bag = 1,
	gml__AggregationType__sequence = 2,
	gml__AggregationType__array = 3,
	gml__AggregationType__record = 4,
	gml__AggregationType__table = 5
};
#endif

/* PlannedLandUse_v3.0.h:2724 */
#ifndef SOAP_TYPE_plu_gml__SignType
#define SOAP_TYPE_plu_gml__SignType (-767)

/* gml:SignType */
enum gml__SignType {
	gml__SignType___x002d = 0,
	gml__SignType___x002b = 1
};
#endif

/* PlannedLandUse_v3.0.h:2772 */
#ifndef SOAP_TYPE_plu_gml__SequenceRuleEnumeration
#define SOAP_TYPE_plu_gml__SequenceRuleEnumeration (-773)

/* gml:SequenceRuleEnumeration */
enum gml__SequenceRuleEnumeration {
	gml__SequenceRuleEnumeration__Linear = 0,
	gml__SequenceRuleEnumeration__Boustrophedonic = 1,
	gml__SequenceRuleEnumeration__Cantor_diagonal = 2,
	gml__SequenceRuleEnumeration__Spiral = 3,
	gml__SequenceRuleEnumeration__Morton = 4,
	gml__SequenceRuleEnumeration__Hilbert = 5
};
#endif

/* PlannedLandUse_v3.0.h:2814 */
#ifndef SOAP_TYPE_plu_gml__TimeIndeterminateValueType
#define SOAP_TYPE_plu_gml__TimeIndeterminateValueType (-777)

/* gml:TimeIndeterminateValueType */
enum gml__TimeIndeterminateValueType {
	gml__TimeIndeterminateValueType__after = 0,
	gml__TimeIndeterminateValueType__before = 1,
	gml__TimeIndeterminateValueType__now = 2,
	gml__TimeIndeterminateValueType__unknown = 3
};
#endif

/* PlannedLandUse_v3.0.h:2839 */
#ifndef SOAP_TYPE_plu_gml__CompassPointEnumeration
#define SOAP_TYPE_plu_gml__CompassPointEnumeration (-780)

/* gml:CompassPointEnumeration */
enum gml__CompassPointEnumeration {
	gml__CompassPointEnumeration__N = 'N',
	gml__CompassPointEnumeration__E = 'E',
	gml__CompassPointEnumeration__S = 'S',
	gml__CompassPointEnumeration__W = 'W',
	gml__CompassPointEnumeration__NNE = 'X',
	gml__CompassPointEnumeration__NE = 'Y',
	gml__CompassPointEnumeration__ENE = 'Z',
	gml__CompassPointEnumeration__ESE = 91,
	gml__CompassPointEnumeration__SE = 92,
	gml__CompassPointEnumeration__SSE = 93,
	gml__CompassPointEnumeration__SSW = 94,
	gml__CompassPointEnumeration__SW = 95,
	gml__CompassPointEnumeration__WSW = 96,
	gml__CompassPointEnumeration__WNW = 'a',
	gml__CompassPointEnumeration__NW = 'b',
	gml__CompassPointEnumeration__NNW = 'c'
};
#endif

/* PlannedLandUse_v3.0.h:2869 */
#ifndef SOAP_TYPE_plu_gml__SuccessionType
#define SOAP_TYPE_plu_gml__SuccessionType (-782)

/* gml:SuccessionType */
enum gml__SuccessionType {
	gml__SuccessionType__substitution = 0,
	gml__SuccessionType__division = 1,
	gml__SuccessionType__fusion = 2,
	gml__SuccessionType__initiation = 3
};
#endif

/* PlannedLandUse_v3.0.h:2935 */
#ifndef SOAP_TYPE_plu_gml__IncrementOrder
#define SOAP_TYPE_plu_gml__IncrementOrder (-792)

/* gml:IncrementOrder */
enum gml__IncrementOrder {
	gml__IncrementOrder___x002bx_x002by = 0,
	gml__IncrementOrder___x002by_x002bx = 1,
	gml__IncrementOrder___x002bx_y = 2,
	gml__IncrementOrder___x002dx_y = 3
};
#endif

/* PlannedLandUse_v3.0.h:2961 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fPixelOrientationCode_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fPixelOrientationCode_x005fType (-794)

/* gmd:MD_PixelOrientationCode_Type */
enum gmd__MD_x005fPixelOrientationCode_x005fType {
	gmd__MD_x005fPixelOrientationCode_x005fType__center = 0,
	gmd__MD_x005fPixelOrientationCode_x005fType__lowerLeft = 1,
	gmd__MD_x005fPixelOrientationCode_x005fType__lowerRight = 2,
	gmd__MD_x005fPixelOrientationCode_x005fType__upperRight = 3,
	gmd__MD_x005fPixelOrientationCode_x005fType__upperLeft = 4
};
#endif

/* PlannedLandUse_v3.0.h:2980 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fObligationCode_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fObligationCode_x005fType (-796)

/* gmd:MD_ObligationCode_Type */
enum gmd__MD_x005fObligationCode_x005fType {
	gmd__MD_x005fObligationCode_x005fType__mandatory = 0,
	gmd__MD_x005fObligationCode_x005fType__optional = 1,
	gmd__MD_x005fObligationCode_x005fType__conditional = 2
};
#endif

/* PlannedLandUse_v3.0.h:3000 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fTopicCategoryCode_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fTopicCategoryCode_x005fType (-798)

/* gmd:MD_TopicCategoryCode_Type */
enum gmd__MD_x005fTopicCategoryCode_x005fType {
	gmd__MD_x005fTopicCategoryCode_x005fType__farming = 0,
	gmd__MD_x005fTopicCategoryCode_x005fType__biota = 1,
	gmd__MD_x005fTopicCategoryCode_x005fType__boundaries = 2,
	gmd__MD_x005fTopicCategoryCode_x005fType__climatologyMeteorologyAtmosphere = 3,
	gmd__MD_x005fTopicCategoryCode_x005fType__economy = 4,
	gmd__MD_x005fTopicCategoryCode_x005fType__elevation = 5,
	gmd__MD_x005fTopicCategoryCode_x005fType__environment = 6,
	gmd__MD_x005fTopicCategoryCode_x005fType__geoscientificInformation = 7,
	gmd__MD_x005fTopicCategoryCode_x005fType__health = 8,
	gmd__MD_x005fTopicCategoryCode_x005fType__imageryBaseMapsEarthCover = 9,
	gmd__MD_x005fTopicCategoryCode_x005fType__intelligenceMilitary = 10,
	gmd__MD_x005fTopicCategoryCode_x005fType__inlandWaters = 11,
	gmd__MD_x005fTopicCategoryCode_x005fType__location = 12,
	gmd__MD_x005fTopicCategoryCode_x005fType__oceans = 13,
	gmd__MD_x005fTopicCategoryCode_x005fType__planningCadastre = 14,
	gmd__MD_x005fTopicCategoryCode_x005fType__society = 15,
	gmd__MD_x005fTopicCategoryCode_x005fType__structure = 16,
	gmd__MD_x005fTopicCategoryCode_x005fType__transportation = 17,
	gmd__MD_x005fTopicCategoryCode_x005fType__utilitiesCommunication = 18
};
#endif

/* PlannedLandUse_v3.0.h:3041 */
#ifndef SOAP_TYPE_plu_xlink__typeType
#define SOAP_TYPE_plu_xlink__typeType (-800)

/* xlink:typeType */
enum xlink__typeType {
	xlink__typeType__simple = 0,
	xlink__typeType__extended = 1,
	xlink__typeType__title = 2,
	xlink__typeType__resource = 3,
	xlink__typeType__locator = 4,
	xlink__typeType__arc = 5
};
#endif

/* PlannedLandUse_v3.0.h:3107 */
#ifndef SOAP_TYPE_plu_xlink__showType
#define SOAP_TYPE_plu_xlink__showType (-810)

/* xlink:showType */
enum xlink__showType {
	xlink__showType__new_ = 0,
	xlink__showType__replace = 1,
	xlink__showType__embed = 2,
	xlink__showType__other = 3,
	xlink__showType__none = 4
};
#endif

/* PlannedLandUse_v3.0.h:3126 */
#ifndef SOAP_TYPE_plu_xlink__actuateType
#define SOAP_TYPE_plu_xlink__actuateType (-812)

/* xlink:actuateType */
enum xlink__actuateType {
	xlink__actuateType__onLoad = 0,
	xlink__actuateType__onRequest = 1,
	xlink__actuateType__other = 2,
	xlink__actuateType__none = 3
};
#endif

/* PlannedLandUse_v3.0.h:23009 */
#ifndef SOAP_TYPE_plu__gml__RelatedTimeType_relativePosition
#define SOAP_TYPE_plu__gml__RelatedTimeType_relativePosition (-1898)

/* gml:RelatedTimeType-relativePosition */
enum _gml__RelatedTimeType_relativePosition {
	_gml__RelatedTimeType_relativePosition__Before = 0,
	_gml__RelatedTimeType_relativePosition__After = 1,
	_gml__RelatedTimeType_relativePosition__Begins = 2,
	_gml__RelatedTimeType_relativePosition__Ends = 3,
	_gml__RelatedTimeType_relativePosition__During = 4,
	_gml__RelatedTimeType_relativePosition__Equals = 5,
	_gml__RelatedTimeType_relativePosition__Contains = 6,
	_gml__RelatedTimeType_relativePosition__Overlaps = 7,
	_gml__RelatedTimeType_relativePosition__Meets = 8,
	_gml__RelatedTimeType_relativePosition__OverlappedBy = 9,
	_gml__RelatedTimeType_relativePosition__MetBy = 10,
	_gml__RelatedTimeType_relativePosition__BegunBy = 11,
	_gml__RelatedTimeType_relativePosition__EndedBy = 12
};
#endif

/* PlannedLandUse_v3.0.h:29178 */
#ifndef SOAP_TYPE_plu__gml__DegreesType_direction
#define SOAP_TYPE_plu__gml__DegreesType_direction (-2173)

/* gml:DegreesType-direction */
enum _gml__DegreesType_direction {
	_gml__DegreesType_direction__N = 'N',
	_gml__DegreesType_direction__E = 'E',
	_gml__DegreesType_direction__S = 'S',
	_gml__DegreesType_direction__W = 'W',
	_gml__DegreesType_direction___x002b = 'X',
	_gml__DegreesType_direction___x002d = 'Y'
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xsd__anyType;	/* xsd.h:57 */
class xsd__base64Binary;	/* xsd.h:64 */
class xsd__hexBinary;	/* xsd.h:71 */
class base__VerticalPositionValueType_;	/* PlannedLandUse_v3.0.h:2585 */
class gml__CurveInterpolationType_;	/* PlannedLandUse_v3.0.h:2645 */
class gml__KnotTypesType_;	/* PlannedLandUse_v3.0.h:2665 */
class gml__SurfaceInterpolationType_;	/* PlannedLandUse_v3.0.h:2692 */
class gml__AggregationType_;	/* PlannedLandUse_v3.0.h:2712 */
class gml__SignType_;	/* PlannedLandUse_v3.0.h:2731 */
class gml__UomSymbol__;	/* PlannedLandUse_v3.0.h:2746 */
class gml__UomURI__;	/* PlannedLandUse_v3.0.h:2763 */
class gml__SequenceRuleEnumeration_;	/* PlannedLandUse_v3.0.h:2783 */
class gml__AxisDirection__;	/* PlannedLandUse_v3.0.h:2798 */
class gml__TimeIndeterminateValueType_;	/* PlannedLandUse_v3.0.h:2823 */
class gml__CompassPointEnumeration_;	/* PlannedLandUse_v3.0.h:2860 */
class gml__SuccessionType_;	/* PlannedLandUse_v3.0.h:2878 */
class gml__DegreeValueType__;	/* PlannedLandUse_v3.0.h:2890 */
class gml__DecimalMinutesType__;	/* PlannedLandUse_v3.0.h:2902 */
class gml__ArcMinutesType__;	/* PlannedLandUse_v3.0.h:2914 */
class gml__ArcSecondsType__;	/* PlannedLandUse_v3.0.h:2926 */
class gml__IncrementOrder_;	/* PlannedLandUse_v3.0.h:2944 */
class gmd__MD_x005fPixelOrientationCode_x005fType_;	/* PlannedLandUse_v3.0.h:2971 */
class gmd__MD_x005fObligationCode_x005fType_;	/* PlannedLandUse_v3.0.h:2988 */
class gmd__MD_x005fTopicCategoryCode_x005fType_;	/* PlannedLandUse_v3.0.h:3024 */
class xlink__typeType_;	/* PlannedLandUse_v3.0.h:3052 */
class xlink__hrefType__;	/* PlannedLandUse_v3.0.h:3063 */
class xlink__roleType__;	/* PlannedLandUse_v3.0.h:3075 */
class xlink__arcroleType__;	/* PlannedLandUse_v3.0.h:3087 */
class xlink__titleAttrType__;	/* PlannedLandUse_v3.0.h:3098 */
class xlink__showType_;	/* PlannedLandUse_v3.0.h:3117 */
class xlink__actuateType_;	/* PlannedLandUse_v3.0.h:3135 */
class xlink__labelType__;	/* PlannedLandUse_v3.0.h:3146 */
class xlink__fromType__;	/* PlannedLandUse_v3.0.h:3157 */
class xlink__toType__;	/* PlannedLandUse_v3.0.h:3168 */
class __plu__ZoningElementPropertyType_sequence;	/* PlannedLandUse_v3.0.h:3508 */
class plu__ZoningElementPropertyType;	/* PlannedLandUse_v3.0.h:305 */
class __plu__OfficialDocumentationPropertyType_sequence;	/* PlannedLandUse_v3.0.h:3565 */
class plu__OfficialDocumentationPropertyType;	/* PlannedLandUse_v3.0.h:311 */
class plu__DimensioningIndicationMeasureValuePropertyType;	/* PlannedLandUse_v3.0.h:317 */
class plu__DimensioningIndicationIntegerValuePropertyType;	/* PlannedLandUse_v3.0.h:323 */
class plu__DimensioningIndicationCharacterValuePropertyType;	/* PlannedLandUse_v3.0.h:329 */
class __plu__SupplementaryRegulationPropertyType_sequence;	/* PlannedLandUse_v3.0.h:3695 */
class plu__SupplementaryRegulationPropertyType;	/* PlannedLandUse_v3.0.h:335 */
class plu__DimensioningIndicationValueType;	/* PlannedLandUse_v3.0.h:338 */
union _plu__union_DimensioningIndicationValuePropertyType;	/* PlannedLandUse_v3.0.h:3784 */
class plu__DimensioningIndicationValuePropertyType;	/* PlannedLandUse_v3.0.h:341 */
class __plu__SpatialPlanPropertyType_sequence;	/* PlannedLandUse_v3.0.h:3844 */
class plu__SpatialPlanPropertyType;	/* PlannedLandUse_v3.0.h:347 */
class plu__DimensioningIndicationRealValuePropertyType;	/* PlannedLandUse_v3.0.h:353 */
class plu__OrdinanceValueType;	/* PlannedLandUse_v3.0.h:356 */
class plu__OrdinanceValuePropertyType;	/* PlannedLandUse_v3.0.h:359 */
class _plu__BackgroundMapValueType_backgroudMapURI;	/* PlannedLandUse_v3.0.h:4006 */
class plu__BackgroundMapValueType;	/* PlannedLandUse_v3.0.h:362 */
class plu__BackgroundMapValuePropertyType;	/* PlannedLandUse_v3.0.h:365 */
class __base__SpatialDataSetPropertyType_sequence;	/* PlannedLandUse_v3.0.h:4060 */
class base__SpatialDataSetPropertyType;	/* PlannedLandUse_v3.0.h:371 */
class _base__IdentifierType_versionId;	/* PlannedLandUse_v3.0.h:4148 */
class base__IdentifierType;	/* PlannedLandUse_v3.0.h:374 */
class base__IdentifierPropertyType;	/* PlannedLandUse_v3.0.h:377 */
class base2__OfficialJournalInformationType;	/* PlannedLandUse_v3.0.h:380 */
class base2__OfficialJournalInformationPropertyType;	/* PlannedLandUse_v3.0.h:383 */
class __base2__LegislationCitationPropertyType_sequence;	/* PlannedLandUse_v3.0.h:4286 */
class base2__LegislationCitationPropertyType;	/* PlannedLandUse_v3.0.h:389 */
class _base2__ContactType_electronicMailAddress;	/* PlannedLandUse_v3.0.h:4368 */
class _base2__ContactType_telephoneFacsimile;	/* PlannedLandUse_v3.0.h:4399 */
class _base2__ContactType_telephoneVoice;	/* PlannedLandUse_v3.0.h:4423 */
class _base2__ContactType_website;	/* PlannedLandUse_v3.0.h:4445 */
class base2__ContactType;	/* PlannedLandUse_v3.0.h:392 */
class base2__ContactPropertyType;	/* PlannedLandUse_v3.0.h:395 */
class _base2__RelatedPartyType_contact;	/* PlannedLandUse_v3.0.h:4533 */
class base2__RelatedPartyType;	/* PlannedLandUse_v3.0.h:398 */
class base2__RelatedPartyPropertyType;	/* PlannedLandUse_v3.0.h:401 */
union _base2__union_DocumentCitationPropertyType;	/* PlannedLandUse_v3.0.h:4608 */
class __base2__DocumentCitationPropertyType_sequence;	/* PlannedLandUse_v3.0.h:4596 */
class base2__DocumentCitationPropertyType;	/* PlannedLandUse_v3.0.h:407 */
class base2__ThematicIdentifierType;	/* PlannedLandUse_v3.0.h:410 */
class base2__ThematicIdentifierPropertyType;	/* PlannedLandUse_v3.0.h:413 */
union _lunom__union_HILUCSPresenceType;	/* PlannedLandUse_v3.0.h:4742 */
class lunom__HILUCSPresenceType;	/* PlannedLandUse_v3.0.h:416 */
class lunom__HILUCSPresencePropertyType;	/* PlannedLandUse_v3.0.h:419 */
class lunom__SpecificPercentageType;	/* PlannedLandUse_v3.0.h:422 */
class lunom__SpecificPercentagePropertyType;	/* PlannedLandUse_v3.0.h:425 */
union _lunom__union_SpecificPresenceType;	/* PlannedLandUse_v3.0.h:4850 */
class lunom__SpecificPresenceType;	/* PlannedLandUse_v3.0.h:428 */
class lunom__SpecificPresencePropertyType;	/* PlannedLandUse_v3.0.h:431 */
class lunom__HILUCSPercentageType;	/* PlannedLandUse_v3.0.h:434 */
class lunom__HILUCSPercentagePropertyType;	/* PlannedLandUse_v3.0.h:437 */
union _gml__union_HistoryPropertyType;	/* PlannedLandUse_v3.0.h:4988 */
class __gml__union_HistoryPropertyType;	/* PlannedLandUse_v3.0.h:4983 */
class gml__HistoryPropertyType;	/* PlannedLandUse_v3.0.h:455 */
union _gml__union_NodeOrEdgePropertyType;	/* PlannedLandUse_v3.0.h:5018 */
class gml__NodeOrEdgePropertyType;	/* PlannedLandUse_v3.0.h:464 */
union _gml__union_NodePropertyType;	/* PlannedLandUse_v3.0.h:5081 */
class gml__NodePropertyType;	/* PlannedLandUse_v3.0.h:467 */
union _gml__union_FaceOrTopoSolidPropertyType;	/* PlannedLandUse_v3.0.h:5137 */
class gml__FaceOrTopoSolidPropertyType;	/* PlannedLandUse_v3.0.h:470 */
union _gml__union_TopoSolidPropertyType;	/* PlannedLandUse_v3.0.h:5199 */
class gml__TopoSolidPropertyType;	/* PlannedLandUse_v3.0.h:473 */
class __gml__DirectedNodePropertyType_sequence;	/* PlannedLandUse_v3.0.h:5251 */
class gml__DirectedNodePropertyType;	/* PlannedLandUse_v3.0.h:479 */
class __gml__DirectedEdgePropertyType_sequence;	/* PlannedLandUse_v3.0.h:5307 */
class gml__DirectedEdgePropertyType;	/* PlannedLandUse_v3.0.h:485 */
class __gml__DirectedFacePropertyType_sequence;	/* PlannedLandUse_v3.0.h:5363 */
class gml__DirectedFacePropertyType;	/* PlannedLandUse_v3.0.h:491 */
class __gml__DirectedTopoSolidPropertyType_sequence;	/* PlannedLandUse_v3.0.h:5419 */
class gml__DirectedTopoSolidPropertyType;	/* PlannedLandUse_v3.0.h:497 */
class gml__TopoPointPropertyType;	/* PlannedLandUse_v3.0.h:503 */
class gml__TopoCurvePropertyType;	/* PlannedLandUse_v3.0.h:509 */
class gml__TopoSurfacePropertyType;	/* PlannedLandUse_v3.0.h:515 */
class gml__TopoVolumePropertyType;	/* PlannedLandUse_v3.0.h:521 */
union _gml__union_TopoPrimitiveMemberType;	/* PlannedLandUse_v3.0.h:5585 */
class __gml__TopoPrimitiveMemberType_sequence;	/* PlannedLandUse_v3.0.h:5575 */
class gml__TopoPrimitiveMemberType;	/* PlannedLandUse_v3.0.h:527 */
union _gml__union_TopoPrimitiveArrayAssociationType;	/* PlannedLandUse_v3.0.h:5671 */
class __gml__TopoPrimitiveArrayAssociationType_sequence;	/* PlannedLandUse_v3.0.h:5661 */
class gml__TopoPrimitiveArrayAssociationType;	/* PlannedLandUse_v3.0.h:530 */
class __gml__TopoComplexPropertyType_sequence;	/* PlannedLandUse_v3.0.h:5724 */
class gml__TopoComplexPropertyType;	/* PlannedLandUse_v3.0.h:533 */
union _gml__union_GeometricComplexPropertyType;	/* PlannedLandUse_v3.0.h:5781 */
class __gml__GeometricComplexPropertyType_sequence;	/* PlannedLandUse_v3.0.h:5776 */
class gml__GeometricComplexPropertyType;	/* PlannedLandUse_v3.0.h:539 */
union _gml__union_MultiGeometryPropertyType;	/* PlannedLandUse_v3.0.h:5860 */
class __gml__MultiGeometryPropertyType_sequence;	/* PlannedLandUse_v3.0.h:5850 */
class gml__MultiGeometryPropertyType;	/* PlannedLandUse_v3.0.h:557 */
class __gml__MultiPointPropertyType_sequence;	/* PlannedLandUse_v3.0.h:5940 */
class gml__MultiPointPropertyType;	/* PlannedLandUse_v3.0.h:563 */
class __gml__MultiCurvePropertyType_sequence;	/* PlannedLandUse_v3.0.h:5996 */
class gml__MultiCurvePropertyType;	/* PlannedLandUse_v3.0.h:569 */
class __gml__MultiSurfacePropertyType_sequence;	/* PlannedLandUse_v3.0.h:6052 */
class gml__MultiSurfacePropertyType;	/* PlannedLandUse_v3.0.h:575 */
class __gml__MultiSolidPropertyType_sequence;	/* PlannedLandUse_v3.0.h:6108 */
class gml__MultiSolidPropertyType;	/* PlannedLandUse_v3.0.h:581 */
class gml__AbstractCurveSegmentType;	/* PlannedLandUse_v3.0.h:590 */
union _gml__union_CurveSegmentArrayPropertyType;	/* PlannedLandUse_v3.0.h:6200 */
class __gml__CurveSegmentArrayPropertyType_sequence;	/* PlannedLandUse_v3.0.h:6187 */
class gml__CurveSegmentArrayPropertyType;	/* PlannedLandUse_v3.0.h:593 */
class gml__KnotType;	/* PlannedLandUse_v3.0.h:626 */
class gml__KnotPropertyType;	/* PlannedLandUse_v3.0.h:629 */
class gml__AffinePlacementType;	/* PlannedLandUse_v3.0.h:638 */
class gml__AbstractSurfacePatchType;	/* PlannedLandUse_v3.0.h:656 */
union _gml__union_SurfacePatchArrayPropertyType;	/* PlannedLandUse_v3.0.h:6477 */
class __gml__SurfacePatchArrayPropertyType_sequence;	/* PlannedLandUse_v3.0.h:6466 */
class gml__SurfacePatchArrayPropertyType;	/* PlannedLandUse_v3.0.h:659 */
class gml__RingPropertyType;	/* PlannedLandUse_v3.0.h:674 */
class __gml__LineStringSegmentArrayPropertyType_sequence;	/* PlannedLandUse_v3.0.h:6548 */
class gml__LineStringSegmentArrayPropertyType;	/* PlannedLandUse_v3.0.h:695 */
union _gml__union_SolidPropertyType;	/* PlannedLandUse_v3.0.h:6588 */
class __gml__SolidPropertyType_sequence;	/* PlannedLandUse_v3.0.h:6578 */
class gml__SolidPropertyType;	/* PlannedLandUse_v3.0.h:701 */
union _gml__union_SolidArrayPropertyType;	/* PlannedLandUse_v3.0.h:6660 */
class __gml__SolidArrayPropertyType_sequence;	/* PlannedLandUse_v3.0.h:6650 */
class gml__SolidArrayPropertyType;	/* PlannedLandUse_v3.0.h:704 */
class gml__ShellPropertyType;	/* PlannedLandUse_v3.0.h:713 */
union _gml__union_SurfacePropertyType;	/* PlannedLandUse_v3.0.h:6734 */
class __gml__SurfacePropertyType_sequence;	/* PlannedLandUse_v3.0.h:6724 */
class gml__SurfacePropertyType;	/* PlannedLandUse_v3.0.h:719 */
union _gml__union_SurfaceArrayPropertyType;	/* PlannedLandUse_v3.0.h:6853 */
class __gml__SurfaceArrayPropertyType_sequence;	/* PlannedLandUse_v3.0.h:6843 */
class gml__SurfaceArrayPropertyType;	/* PlannedLandUse_v3.0.h:722 */
union _gml__union_AbstractRingPropertyType;	/* PlannedLandUse_v3.0.h:6947 */
class gml__AbstractRingPropertyType;	/* PlannedLandUse_v3.0.h:731 */
class gml__LinearRingPropertyType;	/* PlannedLandUse_v3.0.h:737 */
union _gml__union_GeometryPropertyType;	/* PlannedLandUse_v3.0.h:7017 */
class __gml__GeometryPropertyType_sequence;	/* PlannedLandUse_v3.0.h:7007 */
class gml__GeometryPropertyType;	/* PlannedLandUse_v3.0.h:743 */
union _gml__union_GeometryArrayPropertyType;	/* PlannedLandUse_v3.0.h:7081 */
class __gml__GeometryArrayPropertyType_sequence;	/* PlannedLandUse_v3.0.h:7071 */
class gml__GeometryArrayPropertyType;	/* PlannedLandUse_v3.0.h:746 */
class gml__EnvelopeType;	/* PlannedLandUse_v3.0.h:758 */
union _gml__union_GeometricPrimitivePropertyType;	/* PlannedLandUse_v3.0.h:7163 */
class __gml__GeometricPrimitivePropertyType_sequence;	/* PlannedLandUse_v3.0.h:7153 */
class gml__GeometricPrimitivePropertyType;	/* PlannedLandUse_v3.0.h:764 */
class __gml__PointPropertyType_sequence;	/* PlannedLandUse_v3.0.h:7219 */
class gml__PointPropertyType;	/* PlannedLandUse_v3.0.h:770 */
class __gml__PointArrayPropertyType_sequence;	/* PlannedLandUse_v3.0.h:7275 */
class gml__PointArrayPropertyType;	/* PlannedLandUse_v3.0.h:773 */
union _gml__union_CurvePropertyType;	/* PlannedLandUse_v3.0.h:7318 */
class __gml__CurvePropertyType_sequence;	/* PlannedLandUse_v3.0.h:7308 */
class gml__CurvePropertyType;	/* PlannedLandUse_v3.0.h:779 */
union _gml__union_CurveArrayPropertyType;	/* PlannedLandUse_v3.0.h:7402 */
class __gml__CurveArrayPropertyType_sequence;	/* PlannedLandUse_v3.0.h:7392 */
class gml__CurveArrayPropertyType;	/* PlannedLandUse_v3.0.h:782 */
class gml__UnitOfMeasureType;	/* PlannedLandUse_v3.0.h:812 */
class gml__FormulaType;	/* PlannedLandUse_v3.0.h:833 */
class gml__AbstractGMLType;	/* PlannedLandUse_v3.0.h:848 */
class __gml__AssociationRoleType_sequence;	/* PlannedLandUse_v3.0.h:7537 */
class gml__AssociationRoleType;	/* PlannedLandUse_v3.0.h:851 */
class gml__ReferenceType;	/* PlannedLandUse_v3.0.h:854 */
class gml__InlinePropertyType;	/* PlannedLandUse_v3.0.h:857 */
class gml__AbstractMemberType;	/* PlannedLandUse_v3.0.h:860 */
class gml__AbstractMetadataPropertyType;	/* PlannedLandUse_v3.0.h:863 */
union _gml__union_DomainSetType;	/* PlannedLandUse_v3.0.h:7715 */
class __gml__DomainSetType_sequence;	/* PlannedLandUse_v3.0.h:7710 */
class gml__DomainSetType;	/* PlannedLandUse_v3.0.h:899 */
union _gml__union_RangeSetType_;	/* PlannedLandUse_v3.0.h:7800 */
class __gml__union_RangeSetType_;	/* PlannedLandUse_v3.0.h:7795 */
struct ___gml__union_RangeSetType_;	/* PlannedLandUse_v3.0.h:7793 */
union _gml__union_RangeSetType;	/* PlannedLandUse_v3.0.h:7780 */
class gml__RangeSetType;	/* PlannedLandUse_v3.0.h:902 */
union _gml__union_DataBlockType;	/* PlannedLandUse_v3.0.h:7853 */
class gml__DataBlockType;	/* PlannedLandUse_v3.0.h:905 */
union _gml__union_FileType;	/* PlannedLandUse_v3.0.h:7888 */
class gml__FileType;	/* PlannedLandUse_v3.0.h:908 */
union _gml__union_CoverageFunctionType;	/* PlannedLandUse_v3.0.h:7921 */
class gml__CoverageFunctionType;	/* PlannedLandUse_v3.0.h:911 */
union _gml__union_MappingRuleType;	/* PlannedLandUse_v3.0.h:7958 */
class gml__MappingRuleType;	/* PlannedLandUse_v3.0.h:914 */
class gml__GridFunctionType;	/* PlannedLandUse_v3.0.h:917 */
union _gml__union_FeaturePropertyType;	/* PlannedLandUse_v3.0.h:8012 */
class __gml__FeaturePropertyType_sequence;	/* PlannedLandUse_v3.0.h:8002 */
class gml__FeaturePropertyType;	/* PlannedLandUse_v3.0.h:926 */
union _gml__union_BoundingShapeType;	/* PlannedLandUse_v3.0.h:8211 */
class gml__BoundingShapeType;	/* PlannedLandUse_v3.0.h:929 */
class gml__AbstractFeatureMemberType;	/* PlannedLandUse_v3.0.h:935 */
union _gml__union_TimePrimitivePropertyType;	/* PlannedLandUse_v3.0.h:8289 */
class __gml__TimePrimitivePropertyType_sequence;	/* PlannedLandUse_v3.0.h:8279 */
class gml__TimePrimitivePropertyType;	/* PlannedLandUse_v3.0.h:944 */
class __gml__TimeInstantPropertyType_sequence;	/* PlannedLandUse_v3.0.h:8340 */
class gml__TimeInstantPropertyType;	/* PlannedLandUse_v3.0.h:959 */
class __gml__TimePeriodPropertyType_sequence;	/* PlannedLandUse_v3.0.h:8395 */
class gml__TimePeriodPropertyType;	/* PlannedLandUse_v3.0.h:965 */
union _gml__union_ValuePropertyType;	/* PlannedLandUse_v3.0.h:8458 */
class __gml__ValuePropertyType_sequence;	/* PlannedLandUse_v3.0.h:8449 */
class gml__ValuePropertyType;	/* PlannedLandUse_v3.0.h:974 */
union _gml__union_ValueArrayPropertyType;	/* PlannedLandUse_v3.0.h:8562 */
class __gml__ValueArrayPropertyType_sequence;	/* PlannedLandUse_v3.0.h:8553 */
class gml__ValueArrayPropertyType;	/* PlannedLandUse_v3.0.h:977 */
class __gml__BooleanPropertyType_sequence;	/* PlannedLandUse_v3.0.h:8634 */
class gml__BooleanPropertyType;	/* PlannedLandUse_v3.0.h:992 */
class __gml__CategoryPropertyType_sequence;	/* PlannedLandUse_v3.0.h:8679 */
class gml__CategoryPropertyType;	/* PlannedLandUse_v3.0.h:995 */
class __gml__QuantityPropertyType_sequence;	/* PlannedLandUse_v3.0.h:8727 */
class gml__QuantityPropertyType;	/* PlannedLandUse_v3.0.h:998 */
class __gml__CountPropertyType_sequence;	/* PlannedLandUse_v3.0.h:8775 */
class gml__CountPropertyType;	/* PlannedLandUse_v3.0.h:1001 */
class gml__GridLimitsType;	/* PlannedLandUse_v3.0.h:1007 */
class gml__GridEnvelopeType;	/* PlannedLandUse_v3.0.h:1010 */
union _gml__union_SingleCRSPropertyType;	/* PlannedLandUse_v3.0.h:8871 */
class __gml__SingleCRSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:8861 */
class gml__SingleCRSPropertyType;	/* PlannedLandUse_v3.0.h:1016 */
class __gml__CompoundCRSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:8946 */
class gml__CompoundCRSPropertyType;	/* PlannedLandUse_v3.0.h:1025 */
class __gml__GeodeticCRSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:8997 */
class gml__GeodeticCRSPropertyType;	/* PlannedLandUse_v3.0.h:1031 */
class __gml__VerticalCRSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:9045 */
class gml__VerticalCRSPropertyType;	/* PlannedLandUse_v3.0.h:1037 */
class __gml__ProjectedCRSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:9096 */
class gml__ProjectedCRSPropertyType;	/* PlannedLandUse_v3.0.h:1043 */
class __gml__DerivedCRSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:9147 */
class gml__DerivedCRSPropertyType;	/* PlannedLandUse_v3.0.h:1049 */
class __gml__EngineeringCRSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:9198 */
class gml__EngineeringCRSPropertyType;	/* PlannedLandUse_v3.0.h:1055 */
class __gml__ImageCRSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:9251 */
class gml__ImageCRSPropertyType;	/* PlannedLandUse_v3.0.h:1061 */
class __gml__TemporalCRSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:9302 */
class gml__TemporalCRSPropertyType;	/* PlannedLandUse_v3.0.h:1067 */
class __gml__CoordinateSystemAxisPropertyType_sequence;	/* PlannedLandUse_v3.0.h:9353 */
class gml__CoordinateSystemAxisPropertyType;	/* PlannedLandUse_v3.0.h:1073 */
union _gml__union_CoordinateSystemPropertyType;	/* PlannedLandUse_v3.0.h:9414 */
class __gml__CoordinateSystemPropertyType_sequence;	/* PlannedLandUse_v3.0.h:9404 */
class gml__CoordinateSystemPropertyType;	/* PlannedLandUse_v3.0.h:1079 */
class __gml__EllipsoidalCSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:9515 */
class gml__EllipsoidalCSPropertyType;	/* PlannedLandUse_v3.0.h:1085 */
class __gml__CartesianCSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:9566 */
class gml__CartesianCSPropertyType;	/* PlannedLandUse_v3.0.h:1091 */
class __gml__VerticalCSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:9617 */
class gml__VerticalCSPropertyType;	/* PlannedLandUse_v3.0.h:1097 */
class __gml__TimeCSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:9668 */
class gml__TimeCSPropertyType;	/* PlannedLandUse_v3.0.h:1103 */
class __gml__LinearCSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:9719 */
class gml__LinearCSPropertyType;	/* PlannedLandUse_v3.0.h:1109 */
class __gml__UserDefinedCSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:9770 */
class gml__UserDefinedCSPropertyType;	/* PlannedLandUse_v3.0.h:1115 */
class __gml__SphericalCSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:9821 */
class gml__SphericalCSPropertyType;	/* PlannedLandUse_v3.0.h:1121 */
class __gml__PolarCSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:9872 */
class gml__PolarCSPropertyType;	/* PlannedLandUse_v3.0.h:1127 */
class __gml__CylindricalCSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:9923 */
class gml__CylindricalCSPropertyType;	/* PlannedLandUse_v3.0.h:1133 */
class __gml__AffineCSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:9974 */
class gml__AffineCSPropertyType;	/* PlannedLandUse_v3.0.h:1139 */
union _gml__union_CRSPropertyType;	/* PlannedLandUse_v3.0.h:10035 */
class __gml__CRSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:10025 */
class gml__CRSPropertyType;	/* PlannedLandUse_v3.0.h:1148 */
union _gml__union_DatumPropertyType;	/* PlannedLandUse_v3.0.h:10097 */
class __gml__DatumPropertyType_sequence;	/* PlannedLandUse_v3.0.h:10087 */
class gml__DatumPropertyType;	/* PlannedLandUse_v3.0.h:1154 */
class __gml__GeodeticDatumPropertyType_sequence;	/* PlannedLandUse_v3.0.h:10169 */
class gml__GeodeticDatumPropertyType;	/* PlannedLandUse_v3.0.h:1160 */
class __gml__EllipsoidPropertyType_sequence;	/* PlannedLandUse_v3.0.h:10220 */
class gml__EllipsoidPropertyType;	/* PlannedLandUse_v3.0.h:1166 */
class __gml__PrimeMeridianPropertyType_sequence;	/* PlannedLandUse_v3.0.h:10271 */
class gml__PrimeMeridianPropertyType;	/* PlannedLandUse_v3.0.h:1172 */
class __gml__EngineeringDatumPropertyType_sequence;	/* PlannedLandUse_v3.0.h:10322 */
class gml__EngineeringDatumPropertyType;	/* PlannedLandUse_v3.0.h:1178 */
class __gml__ImageDatumPropertyType_sequence;	/* PlannedLandUse_v3.0.h:10373 */
class gml__ImageDatumPropertyType;	/* PlannedLandUse_v3.0.h:1184 */
class __gml__VerticalDatumPropertyType_sequence;	/* PlannedLandUse_v3.0.h:10424 */
class gml__VerticalDatumPropertyType;	/* PlannedLandUse_v3.0.h:1190 */
class __gml__TemporalDatumPropertyType_sequence;	/* PlannedLandUse_v3.0.h:10475 */
class gml__TemporalDatumPropertyType;	/* PlannedLandUse_v3.0.h:1199 */
union _gml__union_CoordinateOperationPropertyType;	/* PlannedLandUse_v3.0.h:10537 */
class __gml__CoordinateOperationPropertyType_sequence;	/* PlannedLandUse_v3.0.h:10526 */
class gml__CoordinateOperationPropertyType;	/* PlannedLandUse_v3.0.h:1205 */
union _gml__union_SingleOperationPropertyType;	/* PlannedLandUse_v3.0.h:10596 */
class __gml__SingleOperationPropertyType_sequence;	/* PlannedLandUse_v3.0.h:10586 */
class gml__SingleOperationPropertyType;	/* PlannedLandUse_v3.0.h:1208 */
union _gml__union_GeneralConversionPropertyType;	/* PlannedLandUse_v3.0.h:10660 */
class __gml__GeneralConversionPropertyType_sequence;	/* PlannedLandUse_v3.0.h:10649 */
class gml__GeneralConversionPropertyType;	/* PlannedLandUse_v3.0.h:1214 */
union _gml__union_GeneralTransformationPropertyType;	/* PlannedLandUse_v3.0.h:10725 */
class __gml__GeneralTransformationPropertyType_sequence;	/* PlannedLandUse_v3.0.h:10714 */
class gml__GeneralTransformationPropertyType;	/* PlannedLandUse_v3.0.h:1220 */
class __gml__ConcatenatedOperationPropertyType_sequence;	/* PlannedLandUse_v3.0.h:10779 */
class gml__ConcatenatedOperationPropertyType;	/* PlannedLandUse_v3.0.h:1226 */
class __gml__PassThroughOperationPropertyType_sequence;	/* PlannedLandUse_v3.0.h:10827 */
class gml__PassThroughOperationPropertyType;	/* PlannedLandUse_v3.0.h:1232 */
class __gml__ConversionPropertyType_sequence;	/* PlannedLandUse_v3.0.h:10879 */
class gml__ConversionPropertyType;	/* PlannedLandUse_v3.0.h:1238 */
class __gml__TransformationPropertyType_sequence;	/* PlannedLandUse_v3.0.h:10932 */
class gml__TransformationPropertyType;	/* PlannedLandUse_v3.0.h:1244 */
class gml__AbstractGeneralParameterValueType;	/* PlannedLandUse_v3.0.h:1247 */
union _gml__union_AbstractGeneralParameterValuePropertyType;	/* PlannedLandUse_v3.0.h:11009 */
class gml__AbstractGeneralParameterValuePropertyType;	/* PlannedLandUse_v3.0.h:1250 */
class __gml__OperationMethodPropertyType_sequence;	/* PlannedLandUse_v3.0.h:11043 */
class gml__OperationMethodPropertyType;	/* PlannedLandUse_v3.0.h:1262 */
union _gml__union_AbstractGeneralOperationParameterPropertyType;	/* PlannedLandUse_v3.0.h:11105 */
class __gml__AbstractGeneralOperationParameterPropertyType_sequence;	/* PlannedLandUse_v3.0.h:11095 */
class gml__AbstractGeneralOperationParameterPropertyType;	/* PlannedLandUse_v3.0.h:1268 */
class __gml__OperationParameterPropertyType_sequence;	/* PlannedLandUse_v3.0.h:11163 */
class gml__OperationParameterPropertyType;	/* PlannedLandUse_v3.0.h:1274 */
class __gml__OperationParameterGroupPropertyType_sequence;	/* PlannedLandUse_v3.0.h:11214 */
class gml__OperationParameterGroupPropertyType;	/* PlannedLandUse_v3.0.h:1280 */
union _gml__union_ProcedurePropertyType;	/* PlannedLandUse_v3.0.h:11273 */
class __gml__ProcedurePropertyType_sequence;	/* PlannedLandUse_v3.0.h:11263 */
class gml__ProcedurePropertyType;	/* PlannedLandUse_v3.0.h:1286 */
union _gml__union_TargetPropertyType;	/* PlannedLandUse_v3.0.h:11473 */
class gml__TargetPropertyType;	/* PlannedLandUse_v3.0.h:1289 */
class __gml__ResultType_sequence;	/* PlannedLandUse_v3.0.h:11682 */
class gml__ResultType;	/* PlannedLandUse_v3.0.h:1292 */
union _gml__union_DirectionPropertyType;	/* PlannedLandUse_v3.0.h:11738 */
class gml__DirectionPropertyType;	/* PlannedLandUse_v3.0.h:1301 */
class gml__DirectionVectorType;	/* PlannedLandUse_v3.0.h:1304 */
union _gml__union_DirectionDescriptionType;	/* PlannedLandUse_v3.0.h:11831 */
class gml__DirectionDescriptionType;	/* PlannedLandUse_v3.0.h:1307 */
class __gml__TimeCalendarPropertyType_sequence;	/* PlannedLandUse_v3.0.h:11862 */
class gml__TimeCalendarPropertyType;	/* PlannedLandUse_v3.0.h:1322 */
class __gml__TimeCalendarEraPropertyType_sequence;	/* PlannedLandUse_v3.0.h:11918 */
class gml__TimeCalendarEraPropertyType;	/* PlannedLandUse_v3.0.h:1325 */
class __gml__TimeClockPropertyType_sequence;	/* PlannedLandUse_v3.0.h:11977 */
class gml__TimeClockPropertyType;	/* PlannedLandUse_v3.0.h:1331 */
class __gml__TimeOrdinalEraPropertyType_sequence;	/* PlannedLandUse_v3.0.h:12036 */
class gml__TimeOrdinalEraPropertyType;	/* PlannedLandUse_v3.0.h:1340 */
union _gml__union_TimeTopologyPrimitivePropertyType;	/* PlannedLandUse_v3.0.h:12104 */
class __gml__TimeTopologyPrimitivePropertyType_sequence;	/* PlannedLandUse_v3.0.h:12092 */
class gml__TimeTopologyPrimitivePropertyType;	/* PlannedLandUse_v3.0.h:1346 */
class __gml__TimeTopologyComplexPropertyType_sequence;	/* PlannedLandUse_v3.0.h:12165 */
class gml__TimeTopologyComplexPropertyType;	/* PlannedLandUse_v3.0.h:1352 */
class __gml__TimeNodePropertyType_sequence;	/* PlannedLandUse_v3.0.h:12222 */
class gml__TimeNodePropertyType;	/* PlannedLandUse_v3.0.h:1358 */
class __gml__TimeEdgePropertyType_sequence;	/* PlannedLandUse_v3.0.h:12277 */
class gml__TimeEdgePropertyType;	/* PlannedLandUse_v3.0.h:1364 */
union _gml__union_OperationPropertyType;	/* PlannedLandUse_v3.0.h:12336 */
class __gml__OperationPropertyType_sequence;	/* PlannedLandUse_v3.0.h:12329 */
class gml__OperationPropertyType;	/* PlannedLandUse_v3.0.h:1367 */
class __gml__TemporalCSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:12380 */
class gml__TemporalCSPropertyType;	/* PlannedLandUse_v3.0.h:1373 */
class __gml__ObliqueCartesianCSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:12425 */
class gml__ObliqueCartesianCSPropertyType;	/* PlannedLandUse_v3.0.h:1379 */
class __gml__GeographicCRSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:12470 */
class gml__GeographicCRSPropertyType;	/* PlannedLandUse_v3.0.h:1385 */
class __gml__GeocentricCRSPropertyType_sequence;	/* PlannedLandUse_v3.0.h:12515 */
class gml__GeocentricCRSPropertyType;	/* PlannedLandUse_v3.0.h:1391 */
class gml__DMSAngleType;	/* PlannedLandUse_v3.0.h:1394 */
union _gml__union_AngleChoiceType;	/* PlannedLandUse_v3.0.h:12592 */
class gml__AngleChoiceType;	/* PlannedLandUse_v3.0.h:1400 */
union _gml__union_ArrayAssociationType;	/* PlannedLandUse_v3.0.h:12629 */
class __gml__union_ArrayAssociationType;	/* PlannedLandUse_v3.0.h:12624 */
class gml__ArrayAssociationType;	/* PlannedLandUse_v3.0.h:1403 */
union _gml__union_MetaDataPropertyType;	/* PlannedLandUse_v3.0.h:12938 */
class __gml__MetaDataPropertyType_sequence;	/* PlannedLandUse_v3.0.h:12931 */
class gml__MetaDataPropertyType;	/* PlannedLandUse_v3.0.h:1415 */
class gml__AbstractMetaDataType;	/* PlannedLandUse_v3.0.h:1418 */
union _gml__union_LocationPropertyType;	/* PlannedLandUse_v3.0.h:13013 */
class gml__LocationPropertyType;	/* PlannedLandUse_v3.0.h:1424 */
union _gml__union_FeatureArrayPropertyType;	/* PlannedLandUse_v3.0.h:13080 */
class __gml__FeatureArrayPropertyType_sequence;	/* PlannedLandUse_v3.0.h:13070 */
class gml__FeatureArrayPropertyType;	/* PlannedLandUse_v3.0.h:1430 */
class gml__IndirectEntryType;	/* PlannedLandUse_v3.0.h:1442 */
class __gml__domainOfValidity_sequence;	/* PlannedLandUse_v3.0.h:13273 */
class _gml__domainOfValidity;	/* PlannedLandUse_v3.0.h:1463 */
class _gml__secondDefiningParameter;	/* PlannedLandUse_v3.0.h:1466 */
union _gml__union_SecondDefiningParameter;	/* PlannedLandUse_v3.0.h:13350 */
class _gml__SecondDefiningParameter;	/* PlannedLandUse_v3.0.h:1469 */
union _gml__union_coordinateOperationAccuracy;	/* PlannedLandUse_v3.0.h:13389 */
class __gml__coordinateOperationAccuracy_sequence;	/* PlannedLandUse_v3.0.h:13382 */
class _gml__coordinateOperationAccuracy;	/* PlannedLandUse_v3.0.h:1472 */
class __gml__formulaCitation_sequence;	/* PlannedLandUse_v3.0.h:13445 */
class _gml__formulaCitation;	/* PlannedLandUse_v3.0.h:1475 */
union _gmd__union_DS_x005fAggregate_x005fPropertyType;	/* PlannedLandUse_v3.0.h:13507 */
class __gmd__DS_x005fAggregate_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:13500 */
class gmd__DS_x005fAggregate_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1481 */
class __gmd__DS_x005fDataSet_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:13569 */
class gmd__DS_x005fDataSet_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1487 */
union _gmd__union_DS_x005fOtherAggregate_x005fPropertyType;	/* PlannedLandUse_v3.0.h:13620 */
class __gmd__DS_x005fOtherAggregate_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:13614 */
class gmd__DS_x005fOtherAggregate_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1493 */
union _gmd__union_DS_x005fSeries_x005fPropertyType;	/* PlannedLandUse_v3.0.h:13674 */
class __gmd__DS_x005fSeries_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:13668 */
class gmd__DS_x005fSeries_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1499 */
class __gmd__DS_x005fInitiative_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:13726 */
class gmd__DS_x005fInitiative_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1505 */
class __gmd__DS_x005fPlatform_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:13771 */
class gmd__DS_x005fPlatform_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1511 */
class __gmd__DS_x005fSensor_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:13816 */
class gmd__DS_x005fSensor_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1517 */
class __gmd__DS_x005fProductionSeries_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:13861 */
class gmd__DS_x005fProductionSeries_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1523 */
class __gmd__DS_x005fStereoMate_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:13906 */
class gmd__DS_x005fStereoMate_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1529 */
class __gmd__MD_x005fMetadata_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:13951 */
class gmd__MD_x005fMetadata_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1535 */
union _gmd__union_MD_x005fGridSpatialRepresentation_x005fPropertyType;	/* PlannedLandUse_v3.0.h:14002 */
class __gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:13996 */
class gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1541 */
class __gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14052 */
class gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1547 */
union _gmd__union_MD_x005fSpatialRepresentation_x005fPropertyType;	/* PlannedLandUse_v3.0.h:14104 */
class __gmd__MD_x005fSpatialRepresentation_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14097 */
class gmd__MD_x005fSpatialRepresentation_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1553 */
class __gmd__MD_x005fGeoreferenceable_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14158 */
class gmd__MD_x005fGeoreferenceable_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1559 */
class __gmd__MD_x005fDimension_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14203 */
class gmd__MD_x005fDimension_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1565 */
class __gmd__MD_x005fGeorectified_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14248 */
class gmd__MD_x005fGeorectified_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1571 */
class __gmd__MD_x005fGeometricObjects_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14293 */
class gmd__MD_x005fGeometricObjects_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1577 */
class __gmd__MD_x005fPixelOrientationCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14338 */
class gmd__MD_x005fPixelOrientationCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1580 */
class __gmd__MD_x005fTopologyLevelCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14363 */
class gmd__MD_x005fTopologyLevelCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1583 */
class __gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14388 */
class gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1586 */
class __gmd__MD_x005fCellGeometryCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14413 */
class gmd__MD_x005fCellGeometryCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1589 */
class __gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14438 */
class gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1592 */
class __gmd__CI_x005fResponsibleParty_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14463 */
class gmd__CI_x005fResponsibleParty_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1598 */
class __gmd__CI_x005fCitation_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14508 */
class gmd__CI_x005fCitation_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1604 */
class __gmd__CI_x005fAddress_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14553 */
class gmd__CI_x005fAddress_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1610 */
class __gmd__CI_x005fOnlineResource_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14598 */
class gmd__CI_x005fOnlineResource_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1616 */
class __gmd__CI_x005fContact_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14643 */
class gmd__CI_x005fContact_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1622 */
class __gmd__CI_x005fTelephone_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14688 */
class gmd__CI_x005fTelephone_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1628 */
class __gmd__CI_x005fDate_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14733 */
class gmd__CI_x005fDate_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1634 */
class __gmd__CI_x005fSeries_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14778 */
class gmd__CI_x005fSeries_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1640 */
class __gmd__URL_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14823 */
class gmd__URL_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1643 */
class __gmd__CI_x005fRoleCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14848 */
class gmd__CI_x005fRoleCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1646 */
class __gmd__CI_x005fPresentationFormCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14873 */
class gmd__CI_x005fPresentationFormCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1649 */
class __gmd__CI_x005fOnLineFunctionCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14898 */
class gmd__CI_x005fOnLineFunctionCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1652 */
class __gmd__CI_x005fDateTypeCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14923 */
class gmd__CI_x005fDateTypeCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1655 */
class __gmd__RS_x005fIdentifier_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14948 */
class gmd__RS_x005fIdentifier_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1661 */
class __gmd__MD_x005fReferenceSystem_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:14993 */
class gmd__MD_x005fReferenceSystem_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1667 */
union _gmd__union_MD_x005fIdentifier_x005fPropertyType;	/* PlannedLandUse_v3.0.h:15044 */
class __gmd__MD_x005fIdentifier_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15038 */
class gmd__MD_x005fIdentifier_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1673 */
union _gmd__union_RS_x005fReferenceSystem_x005fPropertyType;	/* PlannedLandUse_v3.0.h:15099 */
class __gmd__RS_x005fReferenceSystem_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15092 */
class gmd__RS_x005fReferenceSystem_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1679 */
union _gmd__union_EX_x005fTemporalExtent_x005fPropertyType;	/* PlannedLandUse_v3.0.h:15149 */
class __gmd__EX_x005fTemporalExtent_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15143 */
class gmd__EX_x005fTemporalExtent_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1685 */
class __gmd__EX_x005fVerticalExtent_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15197 */
class gmd__EX_x005fVerticalExtent_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1691 */
class __gmd__EX_x005fBoundingPolygon_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15242 */
class gmd__EX_x005fBoundingPolygon_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1697 */
class __gmd__EX_x005fExtent_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15287 */
class gmd__EX_x005fExtent_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1703 */
union _gmd__union_EX_x005fGeographicExtent_x005fPropertyType;	/* PlannedLandUse_v3.0.h:15339 */
class __gmd__EX_x005fGeographicExtent_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15332 */
class gmd__EX_x005fGeographicExtent_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1709 */
class __gmd__EX_x005fGeographicBoundingBox_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15389 */
class gmd__EX_x005fGeographicBoundingBox_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1715 */
class __gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15434 */
class gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1721 */
class __gmd__EX_x005fGeographicDescription_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15479 */
class gmd__EX_x005fGeographicDescription_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1727 */
class __gmd__MD_x005fExtendedElementInformation_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15524 */
class gmd__MD_x005fExtendedElementInformation_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1733 */
class __gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15569 */
class gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1739 */
class __gmd__MD_x005fObligationCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15614 */
class gmd__MD_x005fObligationCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1742 */
class __gmd__MD_x005fDatatypeCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15639 */
class gmd__MD_x005fDatatypeCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1745 */
class __gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15664 */
class gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1751 */
union _gmd__union_MD_x005fCoverageDescription_x005fPropertyType;	/* PlannedLandUse_v3.0.h:15715 */
class __gmd__MD_x005fCoverageDescription_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15709 */
class gmd__MD_x005fCoverageDescription_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1757 */
class __gmd__MD_x005fImageDescription_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15763 */
class gmd__MD_x005fImageDescription_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1763 */
union _gmd__union_MD_x005fContentInformation_x005fPropertyType;	/* PlannedLandUse_v3.0.h:15815 */
class __gmd__MD_x005fContentInformation_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15808 */
class gmd__MD_x005fContentInformation_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1769 */
union _gmd__union_MD_x005fRangeDimension_x005fPropertyType;	/* PlannedLandUse_v3.0.h:15873 */
class __gmd__MD_x005fRangeDimension_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15867 */
class gmd__MD_x005fRangeDimension_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1775 */
class __gmd__MD_x005fBand_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15921 */
class gmd__MD_x005fBand_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1781 */
class __gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15966 */
class gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1784 */
class __gmd__MD_x005fImagingConditionCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:15991 */
class gmd__MD_x005fImagingConditionCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1787 */
class __gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16016 */
class gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1793 */
class __gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16061 */
class gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1799 */
class __gmd__LI_x005fProcessStep_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16106 */
class gmd__LI_x005fProcessStep_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1805 */
class __gmd__LI_x005fSource_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16151 */
class gmd__LI_x005fSource_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1811 */
class __gmd__LI_x005fLineage_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16196 */
class gmd__LI_x005fLineage_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1817 */
class __gmd__DQ_x005fConformanceResult_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16241 */
class gmd__DQ_x005fConformanceResult_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1823 */
class __gmd__DQ_x005fQuantitativeResult_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16286 */
class gmd__DQ_x005fQuantitativeResult_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1829 */
union _gmd__union_DQ_x005fResult_x005fPropertyType;	/* PlannedLandUse_v3.0.h:16338 */
class __gmd__DQ_x005fResult_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16331 */
class gmd__DQ_x005fResult_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1835 */
class __gmd__DQ_x005fTemporalValidity_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16386 */
class gmd__DQ_x005fTemporalValidity_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1841 */
class __gmd__DQ_x005fTemporalConsistency_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16431 */
class gmd__DQ_x005fTemporalConsistency_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1847 */
class __gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16476 */
class gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1853 */
class __gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16521 */
class gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1859 */
class __gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16566 */
class gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1865 */
class __gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16611 */
class gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1871 */
class __gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16656 */
class gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1877 */
class __gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16701 */
class gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1883 */
class __gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16746 */
class gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1889 */
class __gmd__DQ_x005fTopologicalConsistency_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16791 */
class gmd__DQ_x005fTopologicalConsistency_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1895 */
class __gmd__DQ_x005fFormatConsistency_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16836 */
class gmd__DQ_x005fFormatConsistency_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1901 */
class __gmd__DQ_x005fDomainConsistency_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16881 */
class gmd__DQ_x005fDomainConsistency_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1907 */
class __gmd__DQ_x005fConceptualConsistency_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16926 */
class gmd__DQ_x005fConceptualConsistency_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1913 */
class __gmd__DQ_x005fCompletenessOmission_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:16971 */
class gmd__DQ_x005fCompletenessOmission_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1919 */
class __gmd__DQ_x005fCompletenessCommission_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:17016 */
class gmd__DQ_x005fCompletenessCommission_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1925 */
union _gmd__union_DQ_x005fTemporalAccuracy_x005fPropertyType;	/* PlannedLandUse_v3.0.h:17068 */
class __gmd__DQ_x005fTemporalAccuracy_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:17061 */
class gmd__DQ_x005fTemporalAccuracy_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1931 */
union _gmd__union_DQ_x005fThematicAccuracy_x005fPropertyType;	/* PlannedLandUse_v3.0.h:17125 */
class __gmd__DQ_x005fThematicAccuracy_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:17118 */
class gmd__DQ_x005fThematicAccuracy_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1937 */
union _gmd__union_DQ_x005fPositionalAccuracy_x005fPropertyType;	/* PlannedLandUse_v3.0.h:17182 */
class __gmd__DQ_x005fPositionalAccuracy_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:17175 */
class gmd__DQ_x005fPositionalAccuracy_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1943 */
union _gmd__union_DQ_x005fLogicalConsistency_x005fPropertyType;	/* PlannedLandUse_v3.0.h:17239 */
class __gmd__DQ_x005fLogicalConsistency_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:17232 */
class gmd__DQ_x005fLogicalConsistency_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1949 */
union _gmd__union_DQ_x005fCompleteness_x005fPropertyType;	/* PlannedLandUse_v3.0.h:17298 */
class __gmd__DQ_x005fCompleteness_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:17291 */
class gmd__DQ_x005fCompleteness_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1955 */
union _gmd__union_DQ_x005fElement_x005fPropertyType;	/* PlannedLandUse_v3.0.h:17353 */
class __gmd__DQ_x005fElement_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:17346 */
class gmd__DQ_x005fElement_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1961 */
class __gmd__DQ_x005fDataQuality_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:17397 */
class gmd__DQ_x005fDataQuality_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1967 */
class __gmd__DQ_x005fScope_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:17442 */
class gmd__DQ_x005fScope_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1973 */
class __gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:17487 */
class gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1976 */
union _gmd__union_MD_x005fIdentification_x005fPropertyType;	/* PlannedLandUse_v3.0.h:17519 */
class __gmd__MD_x005fIdentification_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:17512 */
class gmd__MD_x005fIdentification_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1982 */
class __gmd__MD_x005fBrowseGraphic_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:17567 */
class gmd__MD_x005fBrowseGraphic_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1988 */
class __gmd__MD_x005fDataIdentification_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:17612 */
class gmd__MD_x005fDataIdentification_x005fPropertyType;	/* PlannedLandUse_v3.0.h:1994 */
class __gmd__MD_x005fServiceIdentification_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:17657 */
class gmd__MD_x005fServiceIdentification_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2000 */
class __gmd__MD_x005fRepresentativeFraction_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:17702 */
class gmd__MD_x005fRepresentativeFraction_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2006 */
class __gmd__MD_x005fUsage_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:17747 */
class gmd__MD_x005fUsage_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2012 */
class __gmd__MD_x005fKeywords_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:17792 */
class gmd__MD_x005fKeywords_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2018 */
class __gmd__DS_x005fAssociation_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:17837 */
class gmd__DS_x005fAssociation_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2024 */
class __gmd__MD_x005fAggregateInformation_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:17882 */
class gmd__MD_x005fAggregateInformation_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2030 */
union _gmd__union_MD_x005fResolution_x005fType;	/* PlannedLandUse_v3.0.h:17930 */
class gmd__MD_x005fResolution_x005fType;	/* PlannedLandUse_v3.0.h:2033 */
class __gmd__MD_x005fResolution_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:17954 */
class gmd__MD_x005fResolution_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2036 */
class __gmd__MD_x005fTopicCategoryCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:17979 */
class gmd__MD_x005fTopicCategoryCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2039 */
class __gmd__MD_x005fCharacterSetCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18004 */
class gmd__MD_x005fCharacterSetCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2042 */
class __gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18029 */
class gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2045 */
class __gmd__MD_x005fProgressCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18054 */
class gmd__MD_x005fProgressCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2048 */
class __gmd__MD_x005fKeywordTypeCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18079 */
class gmd__MD_x005fKeywordTypeCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2051 */
class __gmd__DS_x005fAssociationTypeCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18104 */
class gmd__DS_x005fAssociationTypeCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2054 */
class __gmd__DS_x005fInitiativeTypeCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18129 */
class gmd__DS_x005fInitiativeTypeCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2057 */
union _gmd__union_MD_x005fConstraints_x005fPropertyType;	/* PlannedLandUse_v3.0.h:18160 */
class __gmd__MD_x005fConstraints_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18154 */
class gmd__MD_x005fConstraints_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2063 */
class __gmd__MD_x005fLegalConstraints_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18210 */
class gmd__MD_x005fLegalConstraints_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2069 */
class __gmd__MD_x005fSecurityConstraints_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18255 */
class gmd__MD_x005fSecurityConstraints_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2075 */
class __gmd__MD_x005fClassificationCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18300 */
class gmd__MD_x005fClassificationCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2078 */
class __gmd__MD_x005fRestrictionCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18325 */
class gmd__MD_x005fRestrictionCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2081 */
class __gmd__MD_x005fMedium_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18350 */
class gmd__MD_x005fMedium_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2087 */
class __gmd__MD_x005fDigitalTransferOptions_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18395 */
class gmd__MD_x005fDigitalTransferOptions_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2093 */
class __gmd__MD_x005fStandardOrderProcess_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18440 */
class gmd__MD_x005fStandardOrderProcess_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2099 */
class __gmd__MD_x005fDistributor_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18485 */
class gmd__MD_x005fDistributor_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2105 */
class __gmd__MD_x005fDistribution_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18530 */
class gmd__MD_x005fDistribution_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2111 */
class __gmd__MD_x005fFormat_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18575 */
class gmd__MD_x005fFormat_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2117 */
class __gmd__MD_x005fDistributionUnits_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18620 */
class gmd__MD_x005fDistributionUnits_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2120 */
class __gmd__MD_x005fMediumFormatCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18645 */
class gmd__MD_x005fMediumFormatCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2123 */
class __gmd__MD_x005fMediumNameCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18670 */
class gmd__MD_x005fMediumNameCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2126 */
class __gmd__MD_x005fMaintenanceInformation_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18695 */
class gmd__MD_x005fMaintenanceInformation_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2132 */
union _gmd__union_MD_x005fScopeDescription_x005fType;	/* PlannedLandUse_v3.0.h:18746 */
class gmd__MD_x005fScopeDescription_x005fType;	/* PlannedLandUse_v3.0.h:2135 */
class __gmd__MD_x005fScopeDescription_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18778 */
class gmd__MD_x005fScopeDescription_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2138 */
class __gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18803 */
class gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2141 */
class __gmd__MD_x005fScopeCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18828 */
class gmd__MD_x005fScopeCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2144 */
class __gmd__PT_x005fLocale_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18853 */
class gmd__PT_x005fLocale_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2156 */
class gmd__PT_x005fLocaleContainer_x005fType;	/* PlannedLandUse_v3.0.h:2165 */
class __gmd__PT_x005fLocaleContainer_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18924 */
class gmd__PT_x005fLocaleContainer_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2168 */
class __gmd__LanguageCode_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18969 */
class gmd__LanguageCode_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2171 */
class __gmd__Country_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:18994 */
class gmd__Country_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2174 */
class xlink__simple;	/* PlannedLandUse_v3.0.h:2177 */
union _xlink__union_extended;	/* PlannedLandUse_v3.0.h:19088 */
class __xlink__union_extended;	/* PlannedLandUse_v3.0.h:19084 */
class xlink__extended;	/* PlannedLandUse_v3.0.h:2180 */
class xlink__titleEltType;	/* PlannedLandUse_v3.0.h:2183 */
class xlink__resourceType;	/* PlannedLandUse_v3.0.h:2186 */
union _xlink__union_locatorType;	/* PlannedLandUse_v3.0.h:19215 */
class __xlink__union_locatorType;	/* PlannedLandUse_v3.0.h:19210 */
class xlink__locatorType;	/* PlannedLandUse_v3.0.h:2189 */
union _xlink__union_arcType;	/* PlannedLandUse_v3.0.h:19261 */
class __xlink__union_arcType;	/* PlannedLandUse_v3.0.h:19256 */
class xlink__arcType;	/* PlannedLandUse_v3.0.h:2192 */
class __gco__TypeName_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:19310 */
class gco__TypeName_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2198 */
class __gco__MemberName_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:19355 */
class gco__MemberName_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2204 */
class __gco__Multiplicity_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:19400 */
class gco__Multiplicity_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2210 */
class __gco__MultiplicityRange_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:19445 */
class gco__MultiplicityRange_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2216 */
union _gco__union_Measure_x005fPropertyType;	/* PlannedLandUse_v3.0.h:19496 */
class __gco__Measure_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:19490 */
class gco__Measure_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2219 */
union _gco__union_Length_x005fPropertyType;	/* PlannedLandUse_v3.0.h:19538 */
class __gco__Length_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:19532 */
class gco__Length_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2222 */
class __gco__Angle_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:19566 */
class gco__Angle_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2225 */
class __gco__Scale_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:19591 */
class gco__Scale_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2228 */
class __gco__Distance_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:19616 */
class gco__Distance_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2231 */
union _gco__union_CharacterString_x005fPropertyType;	/* PlannedLandUse_v3.0.h:19647 */
class __gco__CharacterString_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:19641 */
class gco__CharacterString_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2234 */
class __gco__Boolean_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:19797 */
class gco__Boolean_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2237 */
union _gco__union_GenericName_x005fPropertyType;	/* PlannedLandUse_v3.0.h:19829 */
class __gco__GenericName_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:19822 */
class gco__GenericName_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2240 */
class __gco__LocalName_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:19857 */
class gco__LocalName_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2243 */
class __gco__ScopedName_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:19882 */
class gco__ScopedName_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2246 */
union _gco__union_UomAngle_x005fPropertyType;	/* PlannedLandUse_v3.0.h:19917 */
class __gco__UomAngle_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:19907 */
class gco__UomAngle_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2249 */
union _gco__union_UomLength_x005fPropertyType;	/* PlannedLandUse_v3.0.h:19995 */
class __gco__UomLength_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:19985 */
class gco__UomLength_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2252 */
union _gco__union_UomScale_x005fPropertyType;	/* PlannedLandUse_v3.0.h:20073 */
class __gco__UomScale_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:20063 */
class gco__UomScale_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2255 */
union _gco__union_UnitOfMeasure_x005fPropertyType;	/* PlannedLandUse_v3.0.h:20151 */
class __gco__UnitOfMeasure_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:20141 */
class gco__UnitOfMeasure_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2258 */
union _gco__union_UomArea_x005fPropertyType;	/* PlannedLandUse_v3.0.h:20229 */
class __gco__UomArea_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:20219 */
class gco__UomArea_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2261 */
union _gco__union_UomVelocity_x005fPropertyType;	/* PlannedLandUse_v3.0.h:20307 */
class __gco__UomVelocity_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:20297 */
class gco__UomVelocity_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2264 */
union _gco__union_UomTime_x005fPropertyType;	/* PlannedLandUse_v3.0.h:20385 */
class __gco__UomTime_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:20375 */
class gco__UomTime_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2267 */
union _gco__union_UomVolume_x005fPropertyType;	/* PlannedLandUse_v3.0.h:20463 */
class __gco__UomVolume_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:20453 */
class gco__UomVolume_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2270 */
class __gco__DateTime_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:20531 */
class gco__DateTime_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2273 */
union _gco__union_Date_x005fPropertyType;	/* PlannedLandUse_v3.0.h:20559 */
class gco__Date_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2276 */
union _gco__union_Number_x005fPropertyType;	/* PlannedLandUse_v3.0.h:20588 */
class gco__Number_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2279 */
class __gco__Decimal_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:20616 */
class gco__Decimal_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2282 */
class __gco__Real_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:20641 */
class gco__Real_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2285 */
class __gco__Integer_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:20666 */
class gco__Integer_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2288 */
class __gco__UnlimitedInteger_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:20691 */
class gco__UnlimitedInteger_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2294 */
class __gco__Record_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:20716 */
class gco__Record_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2297 */
class __gco__RecordType_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:20761 */
class gco__RecordType_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2303 */
class __gco__Binary_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:20786 */
class gco__Binary_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2309 */
class gco__AbstractObject_x005fType;	/* PlannedLandUse_v3.0.h:2312 */
class gco__ObjectReference_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2315 */
class __gss__GM_x005fPoint_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:20879 */
class gss__GM_x005fPoint_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2324 */
union _gss__union_GM_x005fObject_x005fPropertyType;	/* PlannedLandUse_v3.0.h:20937 */
class __gss__GM_x005fObject_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:20927 */
class gss__GM_x005fObject_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2327 */
union _gts__union_TM_x005fPrimitive_x005fPropertyType;	/* PlannedLandUse_v3.0.h:21001 */
class __gts__TM_x005fPrimitive_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:20991 */
class gts__TM_x005fPrimitive_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2330 */
class __gts__TM_x005fPeriodDuration_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:21045 */
class gts__TM_x005fPeriodDuration_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2333 */
union _gsr__union_SC_x005fCRS_x005fPropertyType;	/* PlannedLandUse_v3.0.h:21088 */
class __gsr__SC_x005fCRS_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:21078 */
class gsr__SC_x005fCRS_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2336 */
class plu__DimensioningIndicationMeasureValueType;	/* PlannedLandUse_v3.0.h:314 */
class plu__DimensioningIndicationIntegerValueType;	/* PlannedLandUse_v3.0.h:320 */
class plu__DimensioningIndicationCharacterValueType;	/* PlannedLandUse_v3.0.h:326 */
class plu__DimensioningIndicationRealValueType;	/* PlannedLandUse_v3.0.h:350 */
class _base2__DocumentCitationType_shortName;	/* PlannedLandUse_v3.0.h:21306 */
class _base2__DocumentCitationType_date;	/* PlannedLandUse_v3.0.h:21329 */
class _base2__DocumentCitationType_link;	/* PlannedLandUse_v3.0.h:21360 */
class _base2__DocumentCitationType_specificReference;	/* PlannedLandUse_v3.0.h:21387 */
class base2__DocumentCitationType;	/* PlannedLandUse_v3.0.h:404 */
class _sc__taggedValue;	/* PlannedLandUse_v3.0.h:440 */
union _gml__union_DynamicFeatureMemberType;	/* PlannedLandUse_v3.0.h:21450 */
class __gml__union_DynamicFeatureMemberType;	/* PlannedLandUse_v3.0.h:21445 */
class gml__DynamicFeatureMemberType;	/* PlannedLandUse_v3.0.h:449 */
class gml__AbstractTimeSliceType;	/* PlannedLandUse_v3.0.h:452 */
class gml__AbstractTopologyType;	/* PlannedLandUse_v3.0.h:458 */
union _gml__union_LineStringSegmentType_;	/* PlannedLandUse_v3.0.h:21631 */
class __gml__union_LineStringSegmentType_;	/* PlannedLandUse_v3.0.h:21627 */
struct ___gml__union_LineStringSegmentType_;	/* PlannedLandUse_v3.0.h:21625 */
union _gml__union_LineStringSegmentType;	/* PlannedLandUse_v3.0.h:21622 */
class gml__LineStringSegmentType;	/* PlannedLandUse_v3.0.h:596 */
union _gml__union_ArcStringType_;	/* PlannedLandUse_v3.0.h:21689 */
class __gml__union_ArcStringType_;	/* PlannedLandUse_v3.0.h:21685 */
struct ___gml__union_ArcStringType_;	/* PlannedLandUse_v3.0.h:21683 */
union _gml__union_ArcStringType;	/* PlannedLandUse_v3.0.h:21680 */
class gml__ArcStringType;	/* PlannedLandUse_v3.0.h:599 */
union _gml__union_ArcStringByBulgeType_;	/* PlannedLandUse_v3.0.h:21749 */
class __gml__union_ArcStringByBulgeType_;	/* PlannedLandUse_v3.0.h:21745 */
struct ___gml__union_ArcStringByBulgeType_;	/* PlannedLandUse_v3.0.h:21743 */
union _gml__union_ArcStringByBulgeType;	/* PlannedLandUse_v3.0.h:21740 */
class gml__ArcStringByBulgeType;	/* PlannedLandUse_v3.0.h:608 */
union _gml__union_ArcByCenterPointType;	/* PlannedLandUse_v3.0.h:21804 */
class gml__ArcByCenterPointType;	/* PlannedLandUse_v3.0.h:614 */
union _gml__union_CubicSplineType_;	/* PlannedLandUse_v3.0.h:21868 */
class __gml__union_CubicSplineType_;	/* PlannedLandUse_v3.0.h:21864 */
struct ___gml__union_CubicSplineType_;	/* PlannedLandUse_v3.0.h:21862 */
union _gml__union_CubicSplineType;	/* PlannedLandUse_v3.0.h:21859 */
class gml__CubicSplineType;	/* PlannedLandUse_v3.0.h:620 */
union _gml__union_BSplineType_;	/* PlannedLandUse_v3.0.h:21932 */
class __gml__union_BSplineType_;	/* PlannedLandUse_v3.0.h:21928 */
struct ___gml__union_BSplineType_;	/* PlannedLandUse_v3.0.h:21926 */
union _gml__union_BSplineType;	/* PlannedLandUse_v3.0.h:21923 */
class gml__BSplineType;	/* PlannedLandUse_v3.0.h:623 */
class gml__OffsetCurveType;	/* PlannedLandUse_v3.0.h:635 */
class _gml__ClothoidType_refLocation;	/* PlannedLandUse_v3.0.h:22026 */
class gml__ClothoidType;	/* PlannedLandUse_v3.0.h:641 */
union _gml__union_GeodesicStringType_;	/* PlannedLandUse_v3.0.h:22082 */
class __gml__union_GeodesicStringType_;	/* PlannedLandUse_v3.0.h:22078 */
class gml__GeodesicStringType;	/* PlannedLandUse_v3.0.h:644 */
class gml__PolygonPatchType;	/* PlannedLandUse_v3.0.h:662 */
class gml__TriangleType;	/* PlannedLandUse_v3.0.h:665 */
class gml__RectangleType;	/* PlannedLandUse_v3.0.h:668 */
class gml__AbstractParametricCurveSurfaceType;	/* PlannedLandUse_v3.0.h:677 */
class gml__AbstractGeometryType;	/* PlannedLandUse_v3.0.h:740 */
class gml__DirectPositionType;	/* PlannedLandUse_v3.0.h:749 */
class gml__DirectPositionListType;	/* PlannedLandUse_v3.0.h:752 */
class gml__DerivationUnitTermType;	/* PlannedLandUse_v3.0.h:824 */
union _gml__union_ConversionToPreferredUnitType;	/* PlannedLandUse_v3.0.h:22385 */
class gml__ConversionToPreferredUnitType;	/* PlannedLandUse_v3.0.h:830 */
class gml__DefinitionBaseType;	/* PlannedLandUse_v3.0.h:836 */
union _gml__union_DictionaryEntryType;	/* PlannedLandUse_v3.0.h:22476 */
class __gml__DictionaryEntryType_sequence;	/* PlannedLandUse_v3.0.h:22465 */
class gml__DictionaryEntryType;	/* PlannedLandUse_v3.0.h:845 */
class gml__CodeType;	/* PlannedLandUse_v3.0.h:866 */
class gml__MeasureType;	/* PlannedLandUse_v3.0.h:872 */
class gml__CoordinatesType;	/* PlannedLandUse_v3.0.h:875 */
class gml__CodeListType;	/* PlannedLandUse_v3.0.h:878 */
class gml__CodeOrNilReasonListType;	/* PlannedLandUse_v3.0.h:881 */
class gml__MeasureListType;	/* PlannedLandUse_v3.0.h:884 */
class gml__MeasureOrNilReasonListType;	/* PlannedLandUse_v3.0.h:887 */
union _gml__union_AbstractFeatureType;	/* PlannedLandUse_v3.0.h:22842 */
class gml__AbstractFeatureType;	/* PlannedLandUse_v3.0.h:923 */
class gml__EnvelopeWithTimePeriodType;	/* PlannedLandUse_v3.0.h:932 */
class gml__AbstractTimeObjectType;	/* PlannedLandUse_v3.0.h:938 */
class gml__RelatedTimeType;	/* PlannedLandUse_v3.0.h:947 */
class gml__TimePositionType;	/* PlannedLandUse_v3.0.h:968 */
class gml__TimeIntervalLengthType;	/* PlannedLandUse_v3.0.h:971 */
class gml__CompositeValueType;	/* PlannedLandUse_v3.0.h:980 */
union _gml__union_ParameterValueType;	/* PlannedLandUse_v3.0.h:23161 */
union _gml__union_ParameterValueType_;	/* PlannedLandUse_v3.0.h:23208 */
class gml__ParameterValueType;	/* PlannedLandUse_v3.0.h:1253 */
union _gml__union_ParameterValueGroupType;	/* PlannedLandUse_v3.0.h:23246 */
class __gml__union_ParameterValueGroupType;	/* PlannedLandUse_v3.0.h:23241 */
union _gml__union_ParameterValueGroupType_;	/* PlannedLandUse_v3.0.h:23266 */
class gml__ParameterValueGroupType;	/* PlannedLandUse_v3.0.h:1256 */
class gml__StringOrRefType;	/* PlannedLandUse_v3.0.h:1406 */
class gml__BagType;	/* PlannedLandUse_v3.0.h:1409 */
class gml__ArrayType;	/* PlannedLandUse_v3.0.h:1412 */
class gml__GenericMetaDataType;	/* PlannedLandUse_v3.0.h:1421 */
class gml__PriorityLocationPropertyType;	/* PlannedLandUse_v3.0.h:1427 */
class _gml__Boolean;	/* PlannedLandUse_v3.0.h:1451 */
class _gml__Count;	/* PlannedLandUse_v3.0.h:1457 */
class gmd__AbstractDS_x005fAggregate_x005fType;	/* PlannedLandUse_v3.0.h:1478 */
class gmd__DS_x005fDataSet_x005fType;	/* PlannedLandUse_v3.0.h:1484 */
class gmd__MD_x005fMetadata_x005fType;	/* PlannedLandUse_v3.0.h:1532 */
class gmd__AbstractMD_x005fSpatialRepresentation_x005fType;	/* PlannedLandUse_v3.0.h:1550 */
class gmd__MD_x005fDimension_x005fType;	/* PlannedLandUse_v3.0.h:1562 */
class gmd__MD_x005fGeometricObjects_x005fType;	/* PlannedLandUse_v3.0.h:1574 */
class gmd__CI_x005fResponsibleParty_x005fType;	/* PlannedLandUse_v3.0.h:1595 */
class gmd__CI_x005fCitation_x005fType;	/* PlannedLandUse_v3.0.h:1601 */
class gmd__CI_x005fAddress_x005fType;	/* PlannedLandUse_v3.0.h:1607 */
class gmd__CI_x005fOnlineResource_x005fType;	/* PlannedLandUse_v3.0.h:1613 */
class gmd__CI_x005fContact_x005fType;	/* PlannedLandUse_v3.0.h:1619 */
class gmd__CI_x005fTelephone_x005fType;	/* PlannedLandUse_v3.0.h:1625 */
class gmd__CI_x005fDate_x005fType;	/* PlannedLandUse_v3.0.h:1631 */
class gmd__CI_x005fSeries_x005fType;	/* PlannedLandUse_v3.0.h:1637 */
class gmd__MD_x005fReferenceSystem_x005fType;	/* PlannedLandUse_v3.0.h:1664 */
class gmd__MD_x005fIdentifier_x005fType;	/* PlannedLandUse_v3.0.h:1670 */
class gmd__AbstractRS_x005fReferenceSystem_x005fType;	/* PlannedLandUse_v3.0.h:1676 */
class gmd__EX_x005fTemporalExtent_x005fType;	/* PlannedLandUse_v3.0.h:1682 */
class gmd__EX_x005fVerticalExtent_x005fType;	/* PlannedLandUse_v3.0.h:1688 */
class gmd__EX_x005fExtent_x005fType;	/* PlannedLandUse_v3.0.h:1700 */
class gmd__AbstractEX_x005fGeographicExtent_x005fType;	/* PlannedLandUse_v3.0.h:1706 */
class gmd__MD_x005fExtendedElementInformation_x005fType;	/* PlannedLandUse_v3.0.h:1730 */
class gmd__MD_x005fMetadataExtensionInformation_x005fType;	/* PlannedLandUse_v3.0.h:1736 */
class gmd__AbstractMD_x005fContentInformation_x005fType;	/* PlannedLandUse_v3.0.h:1766 */
class gmd__MD_x005fRangeDimension_x005fType;	/* PlannedLandUse_v3.0.h:1772 */
class gmd__MD_x005fApplicationSchemaInformation_x005fType;	/* PlannedLandUse_v3.0.h:1790 */
class gmd__MD_x005fPortrayalCatalogueReference_x005fType;	/* PlannedLandUse_v3.0.h:1796 */
class gmd__LI_x005fProcessStep_x005fType;	/* PlannedLandUse_v3.0.h:1802 */
class gmd__LI_x005fSource_x005fType;	/* PlannedLandUse_v3.0.h:1808 */
class gmd__LI_x005fLineage_x005fType;	/* PlannedLandUse_v3.0.h:1814 */
class gmd__AbstractDQ_x005fResult_x005fType;	/* PlannedLandUse_v3.0.h:1832 */
class gmd__AbstractDQ_x005fElement_x005fType;	/* PlannedLandUse_v3.0.h:1958 */
class gmd__DQ_x005fDataQuality_x005fType;	/* PlannedLandUse_v3.0.h:1964 */
class gmd__DQ_x005fScope_x005fType;	/* PlannedLandUse_v3.0.h:1970 */
class gmd__AbstractMD_x005fIdentification_x005fType;	/* PlannedLandUse_v3.0.h:1979 */
class gmd__MD_x005fBrowseGraphic_x005fType;	/* PlannedLandUse_v3.0.h:1985 */
class gmd__MD_x005fRepresentativeFraction_x005fType;	/* PlannedLandUse_v3.0.h:2003 */
class gmd__MD_x005fUsage_x005fType;	/* PlannedLandUse_v3.0.h:2009 */
class gmd__MD_x005fKeywords_x005fType;	/* PlannedLandUse_v3.0.h:2015 */
class gmd__DS_x005fAssociation_x005fType;	/* PlannedLandUse_v3.0.h:2021 */
class gmd__MD_x005fAggregateInformation_x005fType;	/* PlannedLandUse_v3.0.h:2027 */
class gmd__MD_x005fConstraints_x005fType;	/* PlannedLandUse_v3.0.h:2060 */
class gmd__MD_x005fMedium_x005fType;	/* PlannedLandUse_v3.0.h:2084 */
class gmd__MD_x005fDigitalTransferOptions_x005fType;	/* PlannedLandUse_v3.0.h:2090 */
class gmd__MD_x005fStandardOrderProcess_x005fType;	/* PlannedLandUse_v3.0.h:2096 */
class gmd__MD_x005fDistributor_x005fType;	/* PlannedLandUse_v3.0.h:2102 */
class gmd__MD_x005fDistribution_x005fType;	/* PlannedLandUse_v3.0.h:2108 */
class gmd__MD_x005fFormat_x005fType;	/* PlannedLandUse_v3.0.h:2114 */
class gmd__MD_x005fMaintenanceInformation_x005fType;	/* PlannedLandUse_v3.0.h:2129 */
class gmd__PT_x005fFreeText_x005fType;	/* PlannedLandUse_v3.0.h:2147 */
class __gmd__PT_x005fFreeText_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:25439 */
class gmd__PT_x005fFreeText_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2150 */
class gmd__PT_x005fLocale_x005fType;	/* PlannedLandUse_v3.0.h:2153 */
class gmd__LocalisedCharacterString_x005fType;	/* PlannedLandUse_v3.0.h:2159 */
class __gmd__LocalisedCharacterString_x005fPropertyType_sequence;	/* PlannedLandUse_v3.0.h:25538 */
class gmd__LocalisedCharacterString_x005fPropertyType;	/* PlannedLandUse_v3.0.h:2162 */
class gco__TypeName_x005fType;	/* PlannedLandUse_v3.0.h:2195 */
class gco__MemberName_x005fType;	/* PlannedLandUse_v3.0.h:2201 */
class gco__Multiplicity_x005fType;	/* PlannedLandUse_v3.0.h:2207 */
class gco__MultiplicityRange_x005fType;	/* PlannedLandUse_v3.0.h:2213 */
class gco__UnlimitedInteger_x005fType;	/* PlannedLandUse_v3.0.h:2291 */
class gco__RecordType_x005fType;	/* PlannedLandUse_v3.0.h:2300 */
class gco__Binary_x005fType;	/* PlannedLandUse_v3.0.h:2306 */
class gco__CodeListValue_x005fType;	/* PlannedLandUse_v3.0.h:2318 */
class _plu__ZoningElementType_validFrom;	/* PlannedLandUse_v3.0.h:25855 */
class _plu__ZoningElementType_validTo;	/* PlannedLandUse_v3.0.h:25876 */
class _plu__ZoningElementType_beginLifespanVersion;	/* PlannedLandUse_v3.0.h:25903 */
class _plu__ZoningElementType_hilucsPresence;	/* PlannedLandUse_v3.0.h:25926 */
class _plu__ZoningElementType_specificPresence;	/* PlannedLandUse_v3.0.h:25966 */
class _plu__ZoningElementType_endLifespanVersion;	/* PlannedLandUse_v3.0.h:26006 */
class _plu__ZoningElementType_backgroundMap;	/* PlannedLandUse_v3.0.h:26037 */
union _plu__union_ZoningElementType_dimensioningIndication;	/* PlannedLandUse_v3.0.h:26076 */
class _plu__ZoningElementType_dimensioningIndication;	/* PlannedLandUse_v3.0.h:26064 */
class plu__ZoningElementType;	/* PlannedLandUse_v3.0.h:302 */
class __plu__OfficialDocumentationType_legislationCitation_sequence;	/* PlannedLandUse_v3.0.h:26230 */
class _plu__OfficialDocumentationType_legislationCitation;	/* PlannedLandUse_v3.0.h:26221 */
class _plu__OfficialDocumentationType_regulationText;	/* PlannedLandUse_v3.0.h:26279 */
union _plu__union_OfficialDocumentationType_planDocument;	/* PlannedLandUse_v3.0.h:26321 */
class __plu__OfficialDocumentationType_planDocument_sequence;	/* PlannedLandUse_v3.0.h:26309 */
class _plu__OfficialDocumentationType_planDocument;	/* PlannedLandUse_v3.0.h:26300 */
class plu__OfficialDocumentationType;	/* PlannedLandUse_v3.0.h:308 */
class _plu__SupplementaryRegulationType_validFrom;	/* PlannedLandUse_v3.0.h:26444 */
class _plu__SupplementaryRegulationType_validTo;	/* PlannedLandUse_v3.0.h:26465 */
class _plu__SupplementaryRegulationType_backgroundMap;	/* PlannedLandUse_v3.0.h:26502 */
class _plu__SupplementaryRegulationType_beginLifespanVersion;	/* PlannedLandUse_v3.0.h:26527 */
union _plu__union_SupplementaryRegulationType_dimensioningIndication;	/* PlannedLandUse_v3.0.h:26562 */
class _plu__SupplementaryRegulationType_dimensioningIndication;	/* PlannedLandUse_v3.0.h:26550 */
class _plu__SupplementaryRegulationType_endLifespanVersion;	/* PlannedLandUse_v3.0.h:26630 */
class _plu__SupplementaryRegulationType_inheritedFromOtherPlans;	/* PlannedLandUse_v3.0.h:26659 */
class _plu__SupplementaryRegulationType_specificRegulationNature;	/* PlannedLandUse_v3.0.h:26685 */
class _plu__SupplementaryRegulationType_name;	/* PlannedLandUse_v3.0.h:26708 */
class plu__SupplementaryRegulationType;	/* PlannedLandUse_v3.0.h:332 */
class _plu__SpatialPlanType_beginLifespanVersion;	/* PlannedLandUse_v3.0.h:26834 */
class _plu__SpatialPlanType_endLifespanVersion;	/* PlannedLandUse_v3.0.h:26871 */
class _plu__SpatialPlanType_validFrom;	/* PlannedLandUse_v3.0.h:26892 */
class _plu__SpatialPlanType_validTo;	/* PlannedLandUse_v3.0.h:26913 */
class _plu__SpatialPlanType_alternativeTitle;	/* PlannedLandUse_v3.0.h:26934 */
class _plu__SpatialPlanType_backgroundMap;	/* PlannedLandUse_v3.0.h:26975 */
class _plu__SpatialPlanType_ordinance;	/* PlannedLandUse_v3.0.h:27004 */
class plu__SpatialPlanType;	/* PlannedLandUse_v3.0.h:344 */
class __base__SpatialDataSetType_metadata_sequence;	/* PlannedLandUse_v3.0.h:27127 */
class _base__SpatialDataSetType_metadata;	/* PlannedLandUse_v3.0.h:27118 */
class base__SpatialDataSetType;	/* PlannedLandUse_v3.0.h:368 */
class base2__LegislationCitationType;	/* PlannedLandUse_v3.0.h:386 */
union _gml__union_DynamicFeatureType_;	/* PlannedLandUse_v3.0.h:27466 */
class gml__DynamicFeatureType;	/* PlannedLandUse_v3.0.h:443 */
class gml__AbstractTopoPrimitiveType;	/* PlannedLandUse_v3.0.h:461 */
class gml__TopoPointType;	/* PlannedLandUse_v3.0.h:500 */
class gml__TopoCurveType;	/* PlannedLandUse_v3.0.h:506 */
class gml__TopoSurfaceType;	/* PlannedLandUse_v3.0.h:512 */
class gml__TopoVolumeType;	/* PlannedLandUse_v3.0.h:518 */
class gml__TopoComplexType;	/* PlannedLandUse_v3.0.h:524 */
class gml__GeometricComplexType;	/* PlannedLandUse_v3.0.h:536 */
class gml__AbstractGeometricAggregateType;	/* PlannedLandUse_v3.0.h:551 */
union _gml__union_ArcType_;	/* PlannedLandUse_v3.0.h:28005 */
class __gml__union_ArcType_;	/* PlannedLandUse_v3.0.h:28001 */
struct ___gml__union_ArcType_;	/* PlannedLandUse_v3.0.h:27999 */
union _gml__union_ArcType;	/* PlannedLandUse_v3.0.h:27996 */
class gml__ArcType;	/* PlannedLandUse_v3.0.h:602 */
union _gml__union_ArcByBulgeType_;	/* PlannedLandUse_v3.0.h:28069 */
class __gml__union_ArcByBulgeType_;	/* PlannedLandUse_v3.0.h:28065 */
struct ___gml__union_ArcByBulgeType_;	/* PlannedLandUse_v3.0.h:28063 */
union _gml__union_ArcByBulgeType;	/* PlannedLandUse_v3.0.h:28060 */
class gml__ArcByBulgeType;	/* PlannedLandUse_v3.0.h:611 */
union _gml__union_CircleByCenterPointType;	/* PlannedLandUse_v3.0.h:28128 */
class gml__CircleByCenterPointType;	/* PlannedLandUse_v3.0.h:617 */
union _gml__union_BezierType_;	/* PlannedLandUse_v3.0.h:28190 */
class __gml__union_BezierType_;	/* PlannedLandUse_v3.0.h:28186 */
struct ___gml__union_BezierType_;	/* PlannedLandUse_v3.0.h:28184 */
union _gml__union_BezierType;	/* PlannedLandUse_v3.0.h:28181 */
class gml__BezierType;	/* PlannedLandUse_v3.0.h:632 */
class gml__GeodesicType;	/* PlannedLandUse_v3.0.h:647 */
union _gml__union_AbstractGriddedSurfaceType_rows_Row_;	/* PlannedLandUse_v3.0.h:28367 */
class __gml__union_AbstractGriddedSurfaceType_rows_Row_;	/* PlannedLandUse_v3.0.h:28363 */
class _gml__AbstractGriddedSurfaceType_rows_Row;	/* PlannedLandUse_v3.0.h:28345 */
class _gml__AbstractGriddedSurfaceType_rows;	/* PlannedLandUse_v3.0.h:28331 */
class gml__AbstractGriddedSurfaceType;	/* PlannedLandUse_v3.0.h:680 */
class gml__VectorType;	/* PlannedLandUse_v3.0.h:755 */
class gml__AbstractGeometricPrimitiveType;	/* PlannedLandUse_v3.0.h:761 */
class gml__LengthType;	/* PlannedLandUse_v3.0.h:788 */
class gml__ScaleType;	/* PlannedLandUse_v3.0.h:791 */
class gml__TimeType;	/* PlannedLandUse_v3.0.h:794 */
class gml__GridLengthType;	/* PlannedLandUse_v3.0.h:797 */
class gml__AreaType;	/* PlannedLandUse_v3.0.h:800 */
class gml__VolumeType;	/* PlannedLandUse_v3.0.h:803 */
class gml__SpeedType;	/* PlannedLandUse_v3.0.h:806 */
class gml__AngleType;	/* PlannedLandUse_v3.0.h:809 */
class gml__DefinitionType;	/* PlannedLandUse_v3.0.h:839 */
class gml__CodeWithAuthorityType;	/* PlannedLandUse_v3.0.h:869 */
union _gml__union_AbstractCoverageType_;	/* PlannedLandUse_v3.0.h:28737 */
class gml__AbstractCoverageType;	/* PlannedLandUse_v3.0.h:890 */
class gml__SequenceRuleType;	/* PlannedLandUse_v3.0.h:920 */
class gml__AbstractTimePrimitiveType;	/* PlannedLandUse_v3.0.h:941 */
class gml__AbstractTimeComplexType;	/* PlannedLandUse_v3.0.h:950 */
class gml__ValueArrayType;	/* PlannedLandUse_v3.0.h:983 */
class gml__CategoryExtentType;	/* PlannedLandUse_v3.0.h:986 */
class gml__QuantityExtentType;	/* PlannedLandUse_v3.0.h:989 */
union _gml__union_GridType;	/* PlannedLandUse_v3.0.h:29065 */
class gml__GridType;	/* PlannedLandUse_v3.0.h:1004 */
union _gml__union_ObservationType_;	/* PlannedLandUse_v3.0.h:29150 */
class gml__ObservationType;	/* PlannedLandUse_v3.0.h:1283 */
class gml__DegreesType;	/* PlannedLandUse_v3.0.h:1397 */
union _gml__union_BoundedFeatureType;	/* PlannedLandUse_v3.0.h:29236 */
class gml__BoundedFeatureType;	/* PlannedLandUse_v3.0.h:1433 */
class gml__AbstractFeatureCollectionType;	/* PlannedLandUse_v3.0.h:1436 */
union _gml__union_MovingObjectStatusType;	/* PlannedLandUse_v3.0.h:29383 */
class gml__MovingObjectStatusType;	/* PlannedLandUse_v3.0.h:1448 */
class _gml__Category;	/* PlannedLandUse_v3.0.h:1454 */
class _gml__Quantity;	/* PlannedLandUse_v3.0.h:1460 */
class gmd__DS_x005fOtherAggregate_x005fType;	/* PlannedLandUse_v3.0.h:1490 */
class gmd__DS_x005fSeries_x005fType;	/* PlannedLandUse_v3.0.h:1496 */
class gmd__DS_x005fInitiative_x005fType;	/* PlannedLandUse_v3.0.h:1502 */
class gmd__MD_x005fGridSpatialRepresentation_x005fType;	/* PlannedLandUse_v3.0.h:1538 */
class gmd__MD_x005fVectorSpatialRepresentation_x005fType;	/* PlannedLandUse_v3.0.h:1544 */
class gmd__RS_x005fIdentifier_x005fType;	/* PlannedLandUse_v3.0.h:1658 */
class gmd__EX_x005fBoundingPolygon_x005fType;	/* PlannedLandUse_v3.0.h:1694 */
class gmd__EX_x005fGeographicBoundingBox_x005fType;	/* PlannedLandUse_v3.0.h:1712 */
class gmd__EX_x005fSpatialTemporalExtent_x005fType;	/* PlannedLandUse_v3.0.h:1718 */
class gmd__EX_x005fGeographicDescription_x005fType;	/* PlannedLandUse_v3.0.h:1724 */
class gmd__MD_x005fFeatureCatalogueDescription_x005fType;	/* PlannedLandUse_v3.0.h:1748 */
class gmd__MD_x005fCoverageDescription_x005fType;	/* PlannedLandUse_v3.0.h:1754 */
class gmd__MD_x005fBand_x005fType;	/* PlannedLandUse_v3.0.h:1778 */
class gmd__DQ_x005fConformanceResult_x005fType;	/* PlannedLandUse_v3.0.h:1820 */
class gmd__DQ_x005fQuantitativeResult_x005fType;	/* PlannedLandUse_v3.0.h:1826 */
class gmd__AbstractDQ_x005fTemporalAccuracy_x005fType;	/* PlannedLandUse_v3.0.h:1928 */
class gmd__AbstractDQ_x005fThematicAccuracy_x005fType;	/* PlannedLandUse_v3.0.h:1934 */
class gmd__AbstractDQ_x005fPositionalAccuracy_x005fType;	/* PlannedLandUse_v3.0.h:1940 */
class gmd__AbstractDQ_x005fLogicalConsistency_x005fType;	/* PlannedLandUse_v3.0.h:1946 */
class gmd__AbstractDQ_x005fCompleteness_x005fType;	/* PlannedLandUse_v3.0.h:1952 */
class gmd__MD_x005fDataIdentification_x005fType;	/* PlannedLandUse_v3.0.h:1991 */
class gmd__MD_x005fServiceIdentification_x005fType;	/* PlannedLandUse_v3.0.h:1997 */
class gmd__MD_x005fLegalConstraints_x005fType;	/* PlannedLandUse_v3.0.h:2066 */
class gmd__MD_x005fSecurityConstraints_x005fType;	/* PlannedLandUse_v3.0.h:2072 */
class gml__DynamicFeatureCollectionType;	/* PlannedLandUse_v3.0.h:446 */
class gml__NodeType;	/* PlannedLandUse_v3.0.h:476 */
class gml__EdgeType;	/* PlannedLandUse_v3.0.h:482 */
class gml__FaceType;	/* PlannedLandUse_v3.0.h:488 */
class gml__TopoSolidType;	/* PlannedLandUse_v3.0.h:494 */
class gml__MultiGeometryType;	/* PlannedLandUse_v3.0.h:554 */
class gml__MultiPointType;	/* PlannedLandUse_v3.0.h:560 */
class gml__MultiCurveType;	/* PlannedLandUse_v3.0.h:566 */
class gml__MultiSurfaceType;	/* PlannedLandUse_v3.0.h:572 */
class gml__MultiSolidType;	/* PlannedLandUse_v3.0.h:578 */
class gml__CircleType;	/* PlannedLandUse_v3.0.h:605 */
class gml__ConeType;	/* PlannedLandUse_v3.0.h:683 */
class gml__CylinderType;	/* PlannedLandUse_v3.0.h:686 */
class gml__SphereType;	/* PlannedLandUse_v3.0.h:689 */
class gml__AbstractSolidType;	/* PlannedLandUse_v3.0.h:698 */
class gml__AbstractSurfaceType;	/* PlannedLandUse_v3.0.h:716 */
union _gml__union_PointType;	/* PlannedLandUse_v3.0.h:31704 */
class gml__PointType;	/* PlannedLandUse_v3.0.h:767 */
class gml__AbstractCurveType;	/* PlannedLandUse_v3.0.h:776 */
class gml__UnitDefinitionType;	/* PlannedLandUse_v3.0.h:815 */
union _gml__union_DictionaryType;	/* PlannedLandUse_v3.0.h:31845 */
class __gml__union_DictionaryType;	/* PlannedLandUse_v3.0.h:31840 */
class gml__DictionaryType;	/* PlannedLandUse_v3.0.h:842 */
class gml__DiscreteCoverageType;	/* PlannedLandUse_v3.0.h:893 */
class gml__AbstractContinuousCoverageType;	/* PlannedLandUse_v3.0.h:896 */
class gml__AbstractTimeGeometricPrimitiveType;	/* PlannedLandUse_v3.0.h:953 */
class gml__RectifiedGridType;	/* PlannedLandUse_v3.0.h:1013 */
class gml__IdentifiedObjectType;	/* PlannedLandUse_v3.0.h:1142 */
class gml__DirectedObservationType;	/* PlannedLandUse_v3.0.h:1295 */
class gml__TimeReferenceSystemType;	/* PlannedLandUse_v3.0.h:1310 */
class gml__TimeCalendarEraType;	/* PlannedLandUse_v3.0.h:1319 */
class gml__TimeOrdinalEraType;	/* PlannedLandUse_v3.0.h:1337 */
class gml__AbstractTimeTopologyPrimitiveType;	/* PlannedLandUse_v3.0.h:1343 */
class gml__TimeTopologyComplexType;	/* PlannedLandUse_v3.0.h:1349 */
class gml__FeatureCollectionType;	/* PlannedLandUse_v3.0.h:1439 */
class gml__DefinitionProxyType;	/* PlannedLandUse_v3.0.h:1445 */
class gmd__DS_x005fPlatform_x005fType;	/* PlannedLandUse_v3.0.h:1508 */
class gmd__DS_x005fSensor_x005fType;	/* PlannedLandUse_v3.0.h:1514 */
class gmd__DS_x005fProductionSeries_x005fType;	/* PlannedLandUse_v3.0.h:1520 */
class gmd__DS_x005fStereoMate_x005fType;	/* PlannedLandUse_v3.0.h:1526 */
class gmd__MD_x005fGeoreferenceable_x005fType;	/* PlannedLandUse_v3.0.h:1556 */
class gmd__MD_x005fGeorectified_x005fType;	/* PlannedLandUse_v3.0.h:1568 */
class gmd__MD_x005fImageDescription_x005fType;	/* PlannedLandUse_v3.0.h:1760 */
class gmd__DQ_x005fTemporalValidity_x005fType;	/* PlannedLandUse_v3.0.h:1838 */
class gmd__DQ_x005fTemporalConsistency_x005fType;	/* PlannedLandUse_v3.0.h:1844 */
class gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType;	/* PlannedLandUse_v3.0.h:1850 */
class gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType;	/* PlannedLandUse_v3.0.h:1856 */
class gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType;	/* PlannedLandUse_v3.0.h:1862 */
class gmd__DQ_x005fThematicClassificationCorrectness_x005fType;	/* PlannedLandUse_v3.0.h:1868 */
class gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType;	/* PlannedLandUse_v3.0.h:1874 */
class gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType;	/* PlannedLandUse_v3.0.h:1880 */
class gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType;	/* PlannedLandUse_v3.0.h:1886 */
class gmd__DQ_x005fTopologicalConsistency_x005fType;	/* PlannedLandUse_v3.0.h:1892 */
class gmd__DQ_x005fFormatConsistency_x005fType;	/* PlannedLandUse_v3.0.h:1898 */
class gmd__DQ_x005fDomainConsistency_x005fType;	/* PlannedLandUse_v3.0.h:1904 */
class gmd__DQ_x005fConceptualConsistency_x005fType;	/* PlannedLandUse_v3.0.h:1910 */
class gmd__DQ_x005fCompletenessOmission_x005fType;	/* PlannedLandUse_v3.0.h:1916 */
class gmd__DQ_x005fCompletenessCommission_x005fType;	/* PlannedLandUse_v3.0.h:1922 */
class gml__CompositeCurveType;	/* PlannedLandUse_v3.0.h:542 */
class gml__CompositeSurfaceType;	/* PlannedLandUse_v3.0.h:545 */
class gml__CompositeSolidType;	/* PlannedLandUse_v3.0.h:548 */
class gml__CurveType;	/* PlannedLandUse_v3.0.h:584 */
class gml__OrientableCurveType;	/* PlannedLandUse_v3.0.h:587 */
union _gml__union_SurfaceType;	/* PlannedLandUse_v3.0.h:34028 */
class gml__SurfaceType;	/* PlannedLandUse_v3.0.h:650 */
class gml__OrientableSurfaceType;	/* PlannedLandUse_v3.0.h:653 */
class gml__SolidType;	/* PlannedLandUse_v3.0.h:707 */
class gml__ShellType;	/* PlannedLandUse_v3.0.h:710 */
class gml__PolygonType;	/* PlannedLandUse_v3.0.h:725 */
class gml__AbstractRingType;	/* PlannedLandUse_v3.0.h:728 */
union _gml__union_LineStringType_;	/* PlannedLandUse_v3.0.h:34472 */
class __gml__union_LineStringType_;	/* PlannedLandUse_v3.0.h:34468 */
struct ___gml__union_LineStringType_;	/* PlannedLandUse_v3.0.h:34466 */
union _gml__union_LineStringType;	/* PlannedLandUse_v3.0.h:34463 */
class gml__LineStringType;	/* PlannedLandUse_v3.0.h:785 */
class gml__BaseUnitType;	/* PlannedLandUse_v3.0.h:818 */
class gml__DerivedUnitType;	/* PlannedLandUse_v3.0.h:821 */
union _gml__union_ConventionalUnitType;	/* PlannedLandUse_v3.0.h:34626 */
class gml__ConventionalUnitType;	/* PlannedLandUse_v3.0.h:827 */
class gml__TimeInstantType;	/* PlannedLandUse_v3.0.h:956 */
union _gml__union_TimePeriodType;	/* PlannedLandUse_v3.0.h:34767 */
union _gml__union_TimePeriodType_;	/* PlannedLandUse_v3.0.h:34777 */
union _gml__union_TimePeriodType__;	/* PlannedLandUse_v3.0.h:34791 */
class gml__TimePeriodType;	/* PlannedLandUse_v3.0.h:962 */
class gml__CoordinateSystemAxisType;	/* PlannedLandUse_v3.0.h:1070 */
union _gml__union_AbstractCoordinateSystemType;	/* PlannedLandUse_v3.0.h:34897 */
class __gml__union_AbstractCoordinateSystemType;	/* PlannedLandUse_v3.0.h:34892 */
class gml__AbstractCoordinateSystemType;	/* PlannedLandUse_v3.0.h:1076 */
class gml__AbstractCRSType;	/* PlannedLandUse_v3.0.h:1145 */
union _gml__union_AbstractDatumType;	/* PlannedLandUse_v3.0.h:34991 */
class gml__AbstractDatumType;	/* PlannedLandUse_v3.0.h:1151 */
class gml__EllipsoidType;	/* PlannedLandUse_v3.0.h:1163 */
class gml__PrimeMeridianType;	/* PlannedLandUse_v3.0.h:1169 */
class gml__AbstractCoordinateOperationType;	/* PlannedLandUse_v3.0.h:1202 */
union _gml__union_OperationMethodType;	/* PlannedLandUse_v3.0.h:35156 */
union _gml__union_OperationMethodType__;	/* PlannedLandUse_v3.0.h:35196 */
class __gml__union_OperationMethodType__;	/* PlannedLandUse_v3.0.h:35191 */
class gml__OperationMethodType;	/* PlannedLandUse_v3.0.h:1259 */
class gml__AbstractGeneralOperationParameterType;	/* PlannedLandUse_v3.0.h:1265 */
class gml__DirectedObservationAtDistanceType;	/* PlannedLandUse_v3.0.h:1298 */
union _gml__union_TimeCoordinateSystemType;	/* PlannedLandUse_v3.0.h:35367 */
class gml__TimeCoordinateSystemType;	/* PlannedLandUse_v3.0.h:1313 */
class gml__TimeCalendarType;	/* PlannedLandUse_v3.0.h:1316 */
class gml__TimeClockType;	/* PlannedLandUse_v3.0.h:1328 */
class gml__TimeOrdinalReferenceSystemType;	/* PlannedLandUse_v3.0.h:1334 */
class gml__TimeNodeType;	/* PlannedLandUse_v3.0.h:1355 */
class gml__TimeEdgeType;	/* PlannedLandUse_v3.0.h:1361 */
class gml__RingType;	/* PlannedLandUse_v3.0.h:671 */
union _gml__union_TinType_controlPoint_;	/* PlannedLandUse_v3.0.h:35785 */
class __gml__union_TinType_controlPoint_;	/* PlannedLandUse_v3.0.h:35781 */
class _gml__TinType_controlPoint;	/* PlannedLandUse_v3.0.h:35767 */
class gml__TinType;	/* PlannedLandUse_v3.0.h:692 */
union _gml__union_LinearRingType_;	/* PlannedLandUse_v3.0.h:35878 */
class __gml__union_LinearRingType_;	/* PlannedLandUse_v3.0.h:35874 */
struct ___gml__union_LinearRingType_;	/* PlannedLandUse_v3.0.h:35872 */
union _gml__union_LinearRingType;	/* PlannedLandUse_v3.0.h:35869 */
class gml__LinearRingType;	/* PlannedLandUse_v3.0.h:734 */
union _gml__union_AbstractGeneralDerivedCRSType;	/* PlannedLandUse_v3.0.h:35941 */
class gml__AbstractGeneralDerivedCRSType;	/* PlannedLandUse_v3.0.h:1019 */
union _gml__union_CompoundCRSType;	/* PlannedLandUse_v3.0.h:35997 */
class __gml__union_CompoundCRSType;	/* PlannedLandUse_v3.0.h:35992 */
class gml__CompoundCRSType;	/* PlannedLandUse_v3.0.h:1022 */
union _gml__union_GeodeticCRSType;	/* PlannedLandUse_v3.0.h:36054 */
union _gml__union_GeodeticCRSType____;	/* PlannedLandUse_v3.0.h:36100 */
class gml__GeodeticCRSType;	/* PlannedLandUse_v3.0.h:1028 */
union _gml__union_VerticalCRSType;	/* PlannedLandUse_v3.0.h:36153 */
union _gml__union_VerticalCRSType_;	/* PlannedLandUse_v3.0.h:36170 */
class gml__VerticalCRSType;	/* PlannedLandUse_v3.0.h:1034 */
union _gml__union_EngineeringCRSType;	/* PlannedLandUse_v3.0.h:36219 */
union _gml__union_EngineeringCRSType_____;	/* PlannedLandUse_v3.0.h:36297 */
class gml__EngineeringCRSType;	/* PlannedLandUse_v3.0.h:1052 */
union _gml__union_ImageCRSType;	/* PlannedLandUse_v3.0.h:36346 */
union _gml__union_ImageCRSType___;	/* PlannedLandUse_v3.0.h:36382 */
class gml__ImageCRSType;	/* PlannedLandUse_v3.0.h:1058 */
union _gml__union_TemporalCRSType;	/* PlannedLandUse_v3.0.h:36431 */
union _gml__union_TemporalCRSType__;	/* PlannedLandUse_v3.0.h:36455 */
class gml__TemporalCRSType;	/* PlannedLandUse_v3.0.h:1064 */
class gml__EllipsoidalCSType;	/* PlannedLandUse_v3.0.h:1082 */
class gml__CartesianCSType;	/* PlannedLandUse_v3.0.h:1088 */
class gml__VerticalCSType;	/* PlannedLandUse_v3.0.h:1094 */
class gml__TimeCSType;	/* PlannedLandUse_v3.0.h:1100 */
class gml__LinearCSType;	/* PlannedLandUse_v3.0.h:1106 */
class gml__UserDefinedCSType;	/* PlannedLandUse_v3.0.h:1112 */
class gml__SphericalCSType;	/* PlannedLandUse_v3.0.h:1118 */
class gml__PolarCSType;	/* PlannedLandUse_v3.0.h:1124 */
class gml__CylindricalCSType;	/* PlannedLandUse_v3.0.h:1130 */
class gml__AffineCSType;	/* PlannedLandUse_v3.0.h:1136 */
union _gml__union_GeodeticDatumType_;	/* PlannedLandUse_v3.0.h:37048 */
union _gml__union_GeodeticDatumType__;	/* PlannedLandUse_v3.0.h:37065 */
class gml__GeodeticDatumType;	/* PlannedLandUse_v3.0.h:1157 */
class gml__EngineeringDatumType;	/* PlannedLandUse_v3.0.h:1175 */
class gml__ImageDatumType;	/* PlannedLandUse_v3.0.h:1181 */
class gml__VerticalDatumType;	/* PlannedLandUse_v3.0.h:1187 */
class gml__TemporalDatumBaseType;	/* PlannedLandUse_v3.0.h:1196 */
class gml__AbstractGeneralConversionType;	/* PlannedLandUse_v3.0.h:1211 */
class gml__AbstractGeneralTransformationType;	/* PlannedLandUse_v3.0.h:1217 */
union _gml__union_ConcatenatedOperationType;	/* PlannedLandUse_v3.0.h:37601 */
class __gml__union_ConcatenatedOperationType;	/* PlannedLandUse_v3.0.h:37596 */
class gml__ConcatenatedOperationType;	/* PlannedLandUse_v3.0.h:1223 */
union _gml__union_PassThroughOperationType;	/* PlannedLandUse_v3.0.h:37686 */
class gml__PassThroughOperationType;	/* PlannedLandUse_v3.0.h:1229 */
class gml__OperationParameterType;	/* PlannedLandUse_v3.0.h:1271 */
union _gml__union_OperationParameterGroupType;	/* PlannedLandUse_v3.0.h:37779 */
class __gml__union_OperationParameterGroupType;	/* PlannedLandUse_v3.0.h:37774 */
class gml__OperationParameterGroupType;	/* PlannedLandUse_v3.0.h:1277 */
class gml__TemporalCSType;	/* PlannedLandUse_v3.0.h:1370 */
class gml__ObliqueCartesianCSType;	/* PlannedLandUse_v3.0.h:1376 */
class gml__GeographicCRSType;	/* PlannedLandUse_v3.0.h:1382 */
union _gml__union_GeocentricCRSType;	/* PlannedLandUse_v3.0.h:37977 */
class gml__GeocentricCRSType;	/* PlannedLandUse_v3.0.h:1388 */
union _gml__union_ProjectedCRSType_;	/* PlannedLandUse_v3.0.h:38044 */
union _gml__union_ProjectedCRSType__;	/* PlannedLandUse_v3.0.h:38061 */
class gml__ProjectedCRSType;	/* PlannedLandUse_v3.0.h:1040 */
union _gml__union_DerivedCRSType_;	/* PlannedLandUse_v3.0.h:38143 */
class gml__DerivedCRSType;	/* PlannedLandUse_v3.0.h:1046 */
class gml__TemporalDatumType;	/* PlannedLandUse_v3.0.h:1193 */
union _gml__union_ConversionType;	/* PlannedLandUse_v3.0.h:38201 */
union _gml__union_ConversionType_;	/* PlannedLandUse_v3.0.h:38221 */
class __gml__union_ConversionType_;	/* PlannedLandUse_v3.0.h:38216 */
class gml__ConversionType;	/* PlannedLandUse_v3.0.h:1235 */
union _gml__union_TransformationType;	/* PlannedLandUse_v3.0.h:38259 */
union _gml__union_TransformationType_;	/* PlannedLandUse_v3.0.h:38279 */
class __gml__union_TransformationType_;	/* PlannedLandUse_v3.0.h:38274 */
class gml__TransformationType;	/* PlannedLandUse_v3.0.h:1241 */

/* xsd.h:57 */
#ifndef SOAP_TYPE_plu_xsd__anyType
#define SOAP_TYPE_plu_xsd__anyType (-13)
/* simple XML schema type 'xsd:anyType': */
class SOAP_CMAC xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:anyType' wrapped by this struct
        char *__item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_plu_xsd__anyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_xsd__anyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyType, default initialized and not managed by a soap context
        virtual xsd__anyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__anyType); }
      public:
        /// Constructor with default initializations
        xsd__anyType() : __item(), soap() { }
        virtual ~xsd__anyType() { }
        /// Friend allocator used by soap_new_xsd__anyType(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xsd.h:64 */
#ifndef SOAP_TYPE_plu_xsd__base64Binary
#define SOAP_TYPE_plu_xsd__base64Binary (-16)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XML schema type 'xsd:string'
        char *id;
        /// Optional element 'type' of XML schema type 'xsd:string'
        char *type;
        /// Optional element 'options' of XML schema type 'xsd:string'
        char *options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_plu_xsd__base64Binary
        virtual long soap_type(void) const { return SOAP_TYPE_plu_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary); }
      public:
        /// Constructor with default initializations
        xsd__base64Binary() : __ptr(), __size(), id(), type(), options(), soap() { }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xsd.h:71 */
#ifndef SOAP_TYPE_plu_xsd__hexBinary
#define SOAP_TYPE_plu_xsd__hexBinary (-20)
/* hexBinary XML schema type: */
class SOAP_CMAC xsd__hexBinary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_plu_xsd__hexBinary
        virtual long soap_type(void) const { return SOAP_TYPE_plu_xsd__hexBinary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__hexBinary, default initialized and not managed by a soap context
        virtual xsd__hexBinary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__hexBinary); }
      public:
        /// Constructor with default initializations
        xsd__hexBinary() : __ptr(), __size(), soap() { }
        virtual ~xsd__hexBinary() { }
        /// Friend allocator used by soap_new_xsd__hexBinary(struct soap*, int)
        friend SOAP_FMAC1 xsd__hexBinary * SOAP_FMAC2 soap_instantiate_xsd__hexBinary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2585 */
#ifndef SOAP_TYPE_plu_base__VerticalPositionValueType_
#define SOAP_TYPE_plu_base__VerticalPositionValueType_ (-758)
/* simple XML schema type 'base:VerticalPositionValueType': */
class SOAP_CMAC base__VerticalPositionValueType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'base:VerticalPositionValueType' wrapped by this struct
        enum base__VerticalPositionValueType __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_base__VerticalPositionValueType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu_base__VerticalPositionValueType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type base__VerticalPositionValueType_, default initialized and not managed by a soap context
        virtual base__VerticalPositionValueType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(base__VerticalPositionValueType_); }
      public:
        /// Constructor with default initializations
        base__VerticalPositionValueType_() : __item() { }
        virtual ~base__VerticalPositionValueType_() { }
        /// Friend allocator used by soap_new_base__VerticalPositionValueType_(struct soap*, int)
        friend SOAP_FMAC1 base__VerticalPositionValueType_ * SOAP_FMAC2 soap_instantiate_base__VerticalPositionValueType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2645 */
#ifndef SOAP_TYPE_plu_gml__CurveInterpolationType_
#define SOAP_TYPE_plu_gml__CurveInterpolationType_ (-760)
/* simple XML schema type 'gml:CurveInterpolationType': */
class SOAP_CMAC gml__CurveInterpolationType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:CurveInterpolationType' wrapped by this struct
        enum gml__CurveInterpolationType __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CurveInterpolationType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CurveInterpolationType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CurveInterpolationType_, default initialized and not managed by a soap context
        virtual gml__CurveInterpolationType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CurveInterpolationType_); }
      public:
        /// Constructor with default initializations
        gml__CurveInterpolationType_() : __item() { }
        virtual ~gml__CurveInterpolationType_() { }
        /// Friend allocator used by soap_new_gml__CurveInterpolationType_(struct soap*, int)
        friend SOAP_FMAC1 gml__CurveInterpolationType_ * SOAP_FMAC2 soap_instantiate_gml__CurveInterpolationType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2665 */
#ifndef SOAP_TYPE_plu_gml__KnotTypesType_
#define SOAP_TYPE_plu_gml__KnotTypesType_ (-762)
/* simple XML schema type 'gml:KnotTypesType': */
class SOAP_CMAC gml__KnotTypesType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:KnotTypesType' wrapped by this struct
        enum gml__KnotTypesType __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__KnotTypesType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__KnotTypesType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__KnotTypesType_, default initialized and not managed by a soap context
        virtual gml__KnotTypesType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__KnotTypesType_); }
      public:
        /// Constructor with default initializations
        gml__KnotTypesType_() : __item() { }
        virtual ~gml__KnotTypesType_() { }
        /// Friend allocator used by soap_new_gml__KnotTypesType_(struct soap*, int)
        friend SOAP_FMAC1 gml__KnotTypesType_ * SOAP_FMAC2 soap_instantiate_gml__KnotTypesType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2692 */
#ifndef SOAP_TYPE_plu_gml__SurfaceInterpolationType_
#define SOAP_TYPE_plu_gml__SurfaceInterpolationType_ (-764)
/* simple XML schema type 'gml:SurfaceInterpolationType': */
class SOAP_CMAC gml__SurfaceInterpolationType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:SurfaceInterpolationType' wrapped by this struct
        enum gml__SurfaceInterpolationType __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__SurfaceInterpolationType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__SurfaceInterpolationType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SurfaceInterpolationType_, default initialized and not managed by a soap context
        virtual gml__SurfaceInterpolationType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__SurfaceInterpolationType_); }
      public:
        /// Constructor with default initializations
        gml__SurfaceInterpolationType_() : __item() { }
        virtual ~gml__SurfaceInterpolationType_() { }
        /// Friend allocator used by soap_new_gml__SurfaceInterpolationType_(struct soap*, int)
        friend SOAP_FMAC1 gml__SurfaceInterpolationType_ * SOAP_FMAC2 soap_instantiate_gml__SurfaceInterpolationType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2712 */
#ifndef SOAP_TYPE_plu_gml__AggregationType_
#define SOAP_TYPE_plu_gml__AggregationType_ (-766)
/* simple XML schema type 'gml:AggregationType': */
class SOAP_CMAC gml__AggregationType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:AggregationType' wrapped by this struct
        enum gml__AggregationType __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AggregationType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AggregationType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AggregationType_, default initialized and not managed by a soap context
        virtual gml__AggregationType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AggregationType_); }
      public:
        /// Constructor with default initializations
        gml__AggregationType_() : __item() { }
        virtual ~gml__AggregationType_() { }
        /// Friend allocator used by soap_new_gml__AggregationType_(struct soap*, int)
        friend SOAP_FMAC1 gml__AggregationType_ * SOAP_FMAC2 soap_instantiate_gml__AggregationType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2731 */
#ifndef SOAP_TYPE_plu_gml__SignType_
#define SOAP_TYPE_plu_gml__SignType_ (-768)
/* simple XML schema type 'gml:SignType': */
class SOAP_CMAC gml__SignType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:SignType' wrapped by this struct
        enum gml__SignType __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__SignType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__SignType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SignType_, default initialized and not managed by a soap context
        virtual gml__SignType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__SignType_); }
      public:
        /// Constructor with default initializations
        gml__SignType_() : __item() { }
        virtual ~gml__SignType_() { }
        /// Friend allocator used by soap_new_gml__SignType_(struct soap*, int)
        friend SOAP_FMAC1 gml__SignType_ * SOAP_FMAC2 soap_instantiate_gml__SignType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2746 */
#ifndef SOAP_TYPE_plu_gml__UomSymbol__
#define SOAP_TYPE_plu_gml__UomSymbol__ (-770)
/* simple XML schema type 'gml:UomSymbol': */
class SOAP_CMAC gml__UomSymbol__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:UomSymbol' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__UomSymbol__
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__UomSymbol__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__UomSymbol__, default initialized and not managed by a soap context
        virtual gml__UomSymbol__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__UomSymbol__); }
      public:
        /// Constructor with default initializations
        gml__UomSymbol__() : __item() { }
        virtual ~gml__UomSymbol__() { }
        /// Friend allocator used by soap_new_gml__UomSymbol__(struct soap*, int)
        friend SOAP_FMAC1 gml__UomSymbol__ * SOAP_FMAC2 soap_instantiate_gml__UomSymbol__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2763 */
#ifndef SOAP_TYPE_plu_gml__UomURI__
#define SOAP_TYPE_plu_gml__UomURI__ (-772)
/* simple XML schema type 'gml:UomURI': */
class SOAP_CMAC gml__UomURI__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:UomURI' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__UomURI__
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__UomURI__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__UomURI__, default initialized and not managed by a soap context
        virtual gml__UomURI__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__UomURI__); }
      public:
        /// Constructor with default initializations
        gml__UomURI__() : __item() { }
        virtual ~gml__UomURI__() { }
        /// Friend allocator used by soap_new_gml__UomURI__(struct soap*, int)
        friend SOAP_FMAC1 gml__UomURI__ * SOAP_FMAC2 soap_instantiate_gml__UomURI__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2783 */
#ifndef SOAP_TYPE_plu_gml__SequenceRuleEnumeration_
#define SOAP_TYPE_plu_gml__SequenceRuleEnumeration_ (-774)
/* simple XML schema type 'gml:SequenceRuleEnumeration': */
class SOAP_CMAC gml__SequenceRuleEnumeration_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:SequenceRuleEnumeration' wrapped by this struct
        enum gml__SequenceRuleEnumeration __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__SequenceRuleEnumeration_
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__SequenceRuleEnumeration_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SequenceRuleEnumeration_, default initialized and not managed by a soap context
        virtual gml__SequenceRuleEnumeration_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__SequenceRuleEnumeration_); }
      public:
        /// Constructor with default initializations
        gml__SequenceRuleEnumeration_() : __item() { }
        virtual ~gml__SequenceRuleEnumeration_() { }
        /// Friend allocator used by soap_new_gml__SequenceRuleEnumeration_(struct soap*, int)
        friend SOAP_FMAC1 gml__SequenceRuleEnumeration_ * SOAP_FMAC2 soap_instantiate_gml__SequenceRuleEnumeration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2798 */
#ifndef SOAP_TYPE_plu_gml__AxisDirection__
#define SOAP_TYPE_plu_gml__AxisDirection__ (-776)
/* simple XML schema type 'gml:AxisDirection': */
class SOAP_CMAC gml__AxisDirection__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:AxisDirection' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AxisDirection__
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AxisDirection__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AxisDirection__, default initialized and not managed by a soap context
        virtual gml__AxisDirection__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AxisDirection__); }
      public:
        /// Constructor with default initializations
        gml__AxisDirection__() : __item() { }
        virtual ~gml__AxisDirection__() { }
        /// Friend allocator used by soap_new_gml__AxisDirection__(struct soap*, int)
        friend SOAP_FMAC1 gml__AxisDirection__ * SOAP_FMAC2 soap_instantiate_gml__AxisDirection__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2823 */
#ifndef SOAP_TYPE_plu_gml__TimeIndeterminateValueType_
#define SOAP_TYPE_plu_gml__TimeIndeterminateValueType_ (-778)
/* simple XML schema type 'gml:TimeIndeterminateValueType': */
class SOAP_CMAC gml__TimeIndeterminateValueType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:TimeIndeterminateValueType' wrapped by this struct
        enum gml__TimeIndeterminateValueType __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeIndeterminateValueType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeIndeterminateValueType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeIndeterminateValueType_, default initialized and not managed by a soap context
        virtual gml__TimeIndeterminateValueType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeIndeterminateValueType_); }
      public:
        /// Constructor with default initializations
        gml__TimeIndeterminateValueType_() : __item() { }
        virtual ~gml__TimeIndeterminateValueType_() { }
        /// Friend allocator used by soap_new_gml__TimeIndeterminateValueType_(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeIndeterminateValueType_ * SOAP_FMAC2 soap_instantiate_gml__TimeIndeterminateValueType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2860 */
#ifndef SOAP_TYPE_plu_gml__CompassPointEnumeration_
#define SOAP_TYPE_plu_gml__CompassPointEnumeration_ (-781)
/* simple XML schema type 'gml:CompassPointEnumeration': */
class SOAP_CMAC gml__CompassPointEnumeration_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:CompassPointEnumeration' wrapped by this struct
        enum gml__CompassPointEnumeration __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CompassPointEnumeration_
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CompassPointEnumeration_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CompassPointEnumeration_, default initialized and not managed by a soap context
        virtual gml__CompassPointEnumeration_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CompassPointEnumeration_); }
      public:
        /// Constructor with default initializations
        gml__CompassPointEnumeration_() : __item() { }
        virtual ~gml__CompassPointEnumeration_() { }
        /// Friend allocator used by soap_new_gml__CompassPointEnumeration_(struct soap*, int)
        friend SOAP_FMAC1 gml__CompassPointEnumeration_ * SOAP_FMAC2 soap_instantiate_gml__CompassPointEnumeration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2878 */
#ifndef SOAP_TYPE_plu_gml__SuccessionType_
#define SOAP_TYPE_plu_gml__SuccessionType_ (-783)
/* simple XML schema type 'gml:SuccessionType': */
class SOAP_CMAC gml__SuccessionType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:SuccessionType' wrapped by this struct
        enum gml__SuccessionType __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__SuccessionType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__SuccessionType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SuccessionType_, default initialized and not managed by a soap context
        virtual gml__SuccessionType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__SuccessionType_); }
      public:
        /// Constructor with default initializations
        gml__SuccessionType_() : __item() { }
        virtual ~gml__SuccessionType_() { }
        /// Friend allocator used by soap_new_gml__SuccessionType_(struct soap*, int)
        friend SOAP_FMAC1 gml__SuccessionType_ * SOAP_FMAC2 soap_instantiate_gml__SuccessionType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2890 */
#ifndef SOAP_TYPE_plu_gml__DegreeValueType__
#define SOAP_TYPE_plu_gml__DegreeValueType__ (-785)
/* simple XML schema type 'gml:DegreeValueType': */
class SOAP_CMAC gml__DegreeValueType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:DegreeValueType' wrapped by this struct
        ULONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DegreeValueType__
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DegreeValueType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DegreeValueType__, default initialized and not managed by a soap context
        virtual gml__DegreeValueType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DegreeValueType__); }
      public:
        /// Constructor with default initializations
        gml__DegreeValueType__() : __item() { }
        virtual ~gml__DegreeValueType__() { }
        /// Friend allocator used by soap_new_gml__DegreeValueType__(struct soap*, int)
        friend SOAP_FMAC1 gml__DegreeValueType__ * SOAP_FMAC2 soap_instantiate_gml__DegreeValueType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2902 */
#ifndef SOAP_TYPE_plu_gml__DecimalMinutesType__
#define SOAP_TYPE_plu_gml__DecimalMinutesType__ (-787)
/* simple XML schema type 'gml:DecimalMinutesType': */
class SOAP_CMAC gml__DecimalMinutesType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:DecimalMinutesType' wrapped by this struct
        double __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DecimalMinutesType__
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DecimalMinutesType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DecimalMinutesType__, default initialized and not managed by a soap context
        virtual gml__DecimalMinutesType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DecimalMinutesType__); }
      public:
        /// Constructor with default initializations
        gml__DecimalMinutesType__() : __item() { }
        virtual ~gml__DecimalMinutesType__() { }
        /// Friend allocator used by soap_new_gml__DecimalMinutesType__(struct soap*, int)
        friend SOAP_FMAC1 gml__DecimalMinutesType__ * SOAP_FMAC2 soap_instantiate_gml__DecimalMinutesType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2914 */
#ifndef SOAP_TYPE_plu_gml__ArcMinutesType__
#define SOAP_TYPE_plu_gml__ArcMinutesType__ (-789)
/* simple XML schema type 'gml:ArcMinutesType': */
class SOAP_CMAC gml__ArcMinutesType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:ArcMinutesType' wrapped by this struct
        ULONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ArcMinutesType__
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ArcMinutesType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ArcMinutesType__, default initialized and not managed by a soap context
        virtual gml__ArcMinutesType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ArcMinutesType__); }
      public:
        /// Constructor with default initializations
        gml__ArcMinutesType__() : __item() { }
        virtual ~gml__ArcMinutesType__() { }
        /// Friend allocator used by soap_new_gml__ArcMinutesType__(struct soap*, int)
        friend SOAP_FMAC1 gml__ArcMinutesType__ * SOAP_FMAC2 soap_instantiate_gml__ArcMinutesType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2926 */
#ifndef SOAP_TYPE_plu_gml__ArcSecondsType__
#define SOAP_TYPE_plu_gml__ArcSecondsType__ (-791)
/* simple XML schema type 'gml:ArcSecondsType': */
class SOAP_CMAC gml__ArcSecondsType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:ArcSecondsType' wrapped by this struct
        double __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ArcSecondsType__
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ArcSecondsType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ArcSecondsType__, default initialized and not managed by a soap context
        virtual gml__ArcSecondsType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ArcSecondsType__); }
      public:
        /// Constructor with default initializations
        gml__ArcSecondsType__() : __item() { }
        virtual ~gml__ArcSecondsType__() { }
        /// Friend allocator used by soap_new_gml__ArcSecondsType__(struct soap*, int)
        friend SOAP_FMAC1 gml__ArcSecondsType__ * SOAP_FMAC2 soap_instantiate_gml__ArcSecondsType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2944 */
#ifndef SOAP_TYPE_plu_gml__IncrementOrder_
#define SOAP_TYPE_plu_gml__IncrementOrder_ (-793)
/* simple XML schema type 'gml:IncrementOrder': */
class SOAP_CMAC gml__IncrementOrder_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:IncrementOrder' wrapped by this struct
        enum gml__IncrementOrder __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__IncrementOrder_
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__IncrementOrder_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__IncrementOrder_, default initialized and not managed by a soap context
        virtual gml__IncrementOrder_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__IncrementOrder_); }
      public:
        /// Constructor with default initializations
        gml__IncrementOrder_() : __item() { }
        virtual ~gml__IncrementOrder_() { }
        /// Friend allocator used by soap_new_gml__IncrementOrder_(struct soap*, int)
        friend SOAP_FMAC1 gml__IncrementOrder_ * SOAP_FMAC2 soap_instantiate_gml__IncrementOrder_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2971 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fPixelOrientationCode_x005fType_
#define SOAP_TYPE_plu_gmd__MD_x005fPixelOrientationCode_x005fType_ (-795)
/* simple XML schema type 'gmd:MD_PixelOrientationCode_Type': */
class SOAP_CMAC gmd__MD_x005fPixelOrientationCode_x005fType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gmd:MD_PixelOrientationCode_Type' wrapped by this struct
        enum gmd__MD_x005fPixelOrientationCode_x005fType __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fPixelOrientationCode_x005fType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fPixelOrientationCode_x005fType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fPixelOrientationCode_x005fType_, default initialized and not managed by a soap context
        virtual gmd__MD_x005fPixelOrientationCode_x005fType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fPixelOrientationCode_x005fType_); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fPixelOrientationCode_x005fType_() : __item() { }
        virtual ~gmd__MD_x005fPixelOrientationCode_x005fType_() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fPixelOrientationCode_x005fType_(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fPixelOrientationCode_x005fType_ * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fPixelOrientationCode_x005fType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2988 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fObligationCode_x005fType_
#define SOAP_TYPE_plu_gmd__MD_x005fObligationCode_x005fType_ (-797)
/* simple XML schema type 'gmd:MD_ObligationCode_Type': */
class SOAP_CMAC gmd__MD_x005fObligationCode_x005fType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gmd:MD_ObligationCode_Type' wrapped by this struct
        enum gmd__MD_x005fObligationCode_x005fType __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fObligationCode_x005fType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fObligationCode_x005fType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fObligationCode_x005fType_, default initialized and not managed by a soap context
        virtual gmd__MD_x005fObligationCode_x005fType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fObligationCode_x005fType_); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fObligationCode_x005fType_() : __item() { }
        virtual ~gmd__MD_x005fObligationCode_x005fType_() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fObligationCode_x005fType_(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fObligationCode_x005fType_ * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fObligationCode_x005fType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:3024 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fTopicCategoryCode_x005fType_
#define SOAP_TYPE_plu_gmd__MD_x005fTopicCategoryCode_x005fType_ (-799)
/* simple XML schema type 'gmd:MD_TopicCategoryCode_Type': */
class SOAP_CMAC gmd__MD_x005fTopicCategoryCode_x005fType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gmd:MD_TopicCategoryCode_Type' wrapped by this struct
        enum gmd__MD_x005fTopicCategoryCode_x005fType __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fTopicCategoryCode_x005fType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fTopicCategoryCode_x005fType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fTopicCategoryCode_x005fType_, default initialized and not managed by a soap context
        virtual gmd__MD_x005fTopicCategoryCode_x005fType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fTopicCategoryCode_x005fType_); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fTopicCategoryCode_x005fType_() : __item() { }
        virtual ~gmd__MD_x005fTopicCategoryCode_x005fType_() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fTopicCategoryCode_x005fType_(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fTopicCategoryCode_x005fType_ * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fTopicCategoryCode_x005fType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:3052 */
#ifndef SOAP_TYPE_plu_xlink__typeType_
#define SOAP_TYPE_plu_xlink__typeType_ (-801)
/* simple XML schema type 'xlink:typeType': */
class SOAP_CMAC xlink__typeType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xlink:typeType' wrapped by this struct
        enum xlink__typeType __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_xlink__typeType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu_xlink__typeType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__typeType_, default initialized and not managed by a soap context
        virtual xlink__typeType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__typeType_); }
      public:
        /// Constructor with default initializations
        xlink__typeType_() : __item() { }
        virtual ~xlink__typeType_() { }
        /// Friend allocator used by soap_new_xlink__typeType_(struct soap*, int)
        friend SOAP_FMAC1 xlink__typeType_ * SOAP_FMAC2 soap_instantiate_xlink__typeType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:3063 */
#ifndef SOAP_TYPE_plu_xlink__hrefType__
#define SOAP_TYPE_plu_xlink__hrefType__ (-803)
/* simple XML schema type 'xlink:hrefType': */
class SOAP_CMAC xlink__hrefType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xlink:hrefType' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_plu_xlink__hrefType__
        virtual long soap_type(void) const { return SOAP_TYPE_plu_xlink__hrefType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__hrefType__, default initialized and not managed by a soap context
        virtual xlink__hrefType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__hrefType__); }
      public:
        /// Constructor with default initializations
        xlink__hrefType__() : __item() { }
        virtual ~xlink__hrefType__() { }
        /// Friend allocator used by soap_new_xlink__hrefType__(struct soap*, int)
        friend SOAP_FMAC1 xlink__hrefType__ * SOAP_FMAC2 soap_instantiate_xlink__hrefType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:3075 */
#ifndef SOAP_TYPE_plu_xlink__roleType__
#define SOAP_TYPE_plu_xlink__roleType__ (-805)
/* simple XML schema type 'xlink:roleType': */
class SOAP_CMAC xlink__roleType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xlink:roleType' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_plu_xlink__roleType__
        virtual long soap_type(void) const { return SOAP_TYPE_plu_xlink__roleType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__roleType__, default initialized and not managed by a soap context
        virtual xlink__roleType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__roleType__); }
      public:
        /// Constructor with default initializations
        xlink__roleType__() : __item() { }
        virtual ~xlink__roleType__() { }
        /// Friend allocator used by soap_new_xlink__roleType__(struct soap*, int)
        friend SOAP_FMAC1 xlink__roleType__ * SOAP_FMAC2 soap_instantiate_xlink__roleType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:3087 */
#ifndef SOAP_TYPE_plu_xlink__arcroleType__
#define SOAP_TYPE_plu_xlink__arcroleType__ (-807)
/* simple XML schema type 'xlink:arcroleType': */
class SOAP_CMAC xlink__arcroleType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xlink:arcroleType' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_plu_xlink__arcroleType__
        virtual long soap_type(void) const { return SOAP_TYPE_plu_xlink__arcroleType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__arcroleType__, default initialized and not managed by a soap context
        virtual xlink__arcroleType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__arcroleType__); }
      public:
        /// Constructor with default initializations
        xlink__arcroleType__() : __item() { }
        virtual ~xlink__arcroleType__() { }
        /// Friend allocator used by soap_new_xlink__arcroleType__(struct soap*, int)
        friend SOAP_FMAC1 xlink__arcroleType__ * SOAP_FMAC2 soap_instantiate_xlink__arcroleType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:3098 */
#ifndef SOAP_TYPE_plu_xlink__titleAttrType__
#define SOAP_TYPE_plu_xlink__titleAttrType__ (-809)
/* simple XML schema type 'xlink:titleAttrType': */
class SOAP_CMAC xlink__titleAttrType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xlink:titleAttrType' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_xlink__titleAttrType__
        virtual long soap_type(void) const { return SOAP_TYPE_plu_xlink__titleAttrType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__titleAttrType__, default initialized and not managed by a soap context
        virtual xlink__titleAttrType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__titleAttrType__); }
      public:
        /// Constructor with default initializations
        xlink__titleAttrType__() : __item() { }
        virtual ~xlink__titleAttrType__() { }
        /// Friend allocator used by soap_new_xlink__titleAttrType__(struct soap*, int)
        friend SOAP_FMAC1 xlink__titleAttrType__ * SOAP_FMAC2 soap_instantiate_xlink__titleAttrType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:3117 */
#ifndef SOAP_TYPE_plu_xlink__showType_
#define SOAP_TYPE_plu_xlink__showType_ (-811)
/* simple XML schema type 'xlink:showType': */
class SOAP_CMAC xlink__showType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xlink:showType' wrapped by this struct
        enum xlink__showType __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_xlink__showType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu_xlink__showType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__showType_, default initialized and not managed by a soap context
        virtual xlink__showType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__showType_); }
      public:
        /// Constructor with default initializations
        xlink__showType_() : __item() { }
        virtual ~xlink__showType_() { }
        /// Friend allocator used by soap_new_xlink__showType_(struct soap*, int)
        friend SOAP_FMAC1 xlink__showType_ * SOAP_FMAC2 soap_instantiate_xlink__showType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:3135 */
#ifndef SOAP_TYPE_plu_xlink__actuateType_
#define SOAP_TYPE_plu_xlink__actuateType_ (-813)
/* simple XML schema type 'xlink:actuateType': */
class SOAP_CMAC xlink__actuateType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xlink:actuateType' wrapped by this struct
        enum xlink__actuateType __item;
      public:
        /// Return unique type id SOAP_TYPE_plu_xlink__actuateType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu_xlink__actuateType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__actuateType_, default initialized and not managed by a soap context
        virtual xlink__actuateType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__actuateType_); }
      public:
        /// Constructor with default initializations
        xlink__actuateType_() : __item() { }
        virtual ~xlink__actuateType_() { }
        /// Friend allocator used by soap_new_xlink__actuateType_(struct soap*, int)
        friend SOAP_FMAC1 xlink__actuateType_ * SOAP_FMAC2 soap_instantiate_xlink__actuateType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:3146 */
#ifndef SOAP_TYPE_plu_xlink__labelType__
#define SOAP_TYPE_plu_xlink__labelType__ (-815)
/* simple XML schema type 'xlink:labelType': */
class SOAP_CMAC xlink__labelType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xlink:labelType' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_plu_xlink__labelType__
        virtual long soap_type(void) const { return SOAP_TYPE_plu_xlink__labelType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__labelType__, default initialized and not managed by a soap context
        virtual xlink__labelType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__labelType__); }
      public:
        /// Constructor with default initializations
        xlink__labelType__() : __item() { }
        virtual ~xlink__labelType__() { }
        /// Friend allocator used by soap_new_xlink__labelType__(struct soap*, int)
        friend SOAP_FMAC1 xlink__labelType__ * SOAP_FMAC2 soap_instantiate_xlink__labelType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:3157 */
#ifndef SOAP_TYPE_plu_xlink__fromType__
#define SOAP_TYPE_plu_xlink__fromType__ (-817)
/* simple XML schema type 'xlink:fromType': */
class SOAP_CMAC xlink__fromType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xlink:fromType' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_plu_xlink__fromType__
        virtual long soap_type(void) const { return SOAP_TYPE_plu_xlink__fromType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__fromType__, default initialized and not managed by a soap context
        virtual xlink__fromType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__fromType__); }
      public:
        /// Constructor with default initializations
        xlink__fromType__() : __item() { }
        virtual ~xlink__fromType__() { }
        /// Friend allocator used by soap_new_xlink__fromType__(struct soap*, int)
        friend SOAP_FMAC1 xlink__fromType__ * SOAP_FMAC2 soap_instantiate_xlink__fromType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:3168 */
#ifndef SOAP_TYPE_plu_xlink__toType__
#define SOAP_TYPE_plu_xlink__toType__ (-819)
/* simple XML schema type 'xlink:toType': */
class SOAP_CMAC xlink__toType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xlink:toType' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_plu_xlink__toType__
        virtual long soap_type(void) const { return SOAP_TYPE_plu_xlink__toType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__toType__, default initialized and not managed by a soap context
        virtual xlink__toType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__toType__); }
      public:
        /// Constructor with default initializations
        xlink__toType__() : __item() { }
        virtual ~xlink__toType__() { }
        /// Friend allocator used by soap_new_xlink__toType__(struct soap*, int)
        friend SOAP_FMAC1 xlink__toType__ * SOAP_FMAC2 soap_instantiate_xlink__toType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:3508 */
#ifndef SOAP_TYPE_plu___plu__ZoningElementPropertyType_sequence
#define SOAP_TYPE_plu___plu__ZoningElementPropertyType_sequence (-820)
/* Wrapper: */
class SOAP_CMAC __plu__ZoningElementPropertyType_sequence {
      public:
        /// Required element 'plu:ZoningElement' of XML schema type 'plu:ZoningElementType'
        plu__ZoningElementType *ZoningElement;
      public:
        /// Return unique type id SOAP_TYPE_plu___plu__ZoningElementPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___plu__ZoningElementPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __plu__ZoningElementPropertyType_sequence, default initialized and not managed by a soap context
        virtual __plu__ZoningElementPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__plu__ZoningElementPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __plu__ZoningElementPropertyType_sequence() : ZoningElement() { }
        virtual ~__plu__ZoningElementPropertyType_sequence() { }
        /// Friend allocator used by soap_new___plu__ZoningElementPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __plu__ZoningElementPropertyType_sequence * SOAP_FMAC2 soap_instantiate___plu__ZoningElementPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:305 */
#ifndef SOAP_TYPE_plu_plu__ZoningElementPropertyType
#define SOAP_TYPE_plu_plu__ZoningElementPropertyType (-56)
/* complex XML schema type 'plu:ZoningElementPropertyType': */
class SOAP_CMAC plu__ZoningElementPropertyType : public xsd__anyType {
      public:
        __plu__ZoningElementPropertyType_sequence *__ZoningElementPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__ZoningElementPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__ZoningElementPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__ZoningElementPropertyType, default initialized and not managed by a soap context
        virtual plu__ZoningElementPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__ZoningElementPropertyType); }
      public:
        /// Constructor with default initializations
        plu__ZoningElementPropertyType() : __ZoningElementPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~plu__ZoningElementPropertyType() { }
        /// Friend allocator used by soap_new_plu__ZoningElementPropertyType(struct soap*, int)
        friend SOAP_FMAC1 plu__ZoningElementPropertyType * SOAP_FMAC2 soap_instantiate_plu__ZoningElementPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:3565 */
#ifndef SOAP_TYPE_plu___plu__OfficialDocumentationPropertyType_sequence
#define SOAP_TYPE_plu___plu__OfficialDocumentationPropertyType_sequence (-833)
/* Wrapper: */
class SOAP_CMAC __plu__OfficialDocumentationPropertyType_sequence {
      public:
        /// Required element 'plu:OfficialDocumentation' of XML schema type 'plu:OfficialDocumentationType'
        plu__OfficialDocumentationType *OfficialDocumentation;
      public:
        /// Return unique type id SOAP_TYPE_plu___plu__OfficialDocumentationPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___plu__OfficialDocumentationPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __plu__OfficialDocumentationPropertyType_sequence, default initialized and not managed by a soap context
        virtual __plu__OfficialDocumentationPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__plu__OfficialDocumentationPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __plu__OfficialDocumentationPropertyType_sequence() : OfficialDocumentation() { }
        virtual ~__plu__OfficialDocumentationPropertyType_sequence() { }
        /// Friend allocator used by soap_new___plu__OfficialDocumentationPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __plu__OfficialDocumentationPropertyType_sequence * SOAP_FMAC2 soap_instantiate___plu__OfficialDocumentationPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:311 */
#ifndef SOAP_TYPE_plu_plu__OfficialDocumentationPropertyType
#define SOAP_TYPE_plu_plu__OfficialDocumentationPropertyType (-58)
/* complex XML schema type 'plu:OfficialDocumentationPropertyType': */
class SOAP_CMAC plu__OfficialDocumentationPropertyType : public xsd__anyType {
      public:
        __plu__OfficialDocumentationPropertyType_sequence *__OfficialDocumentationPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__OfficialDocumentationPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__OfficialDocumentationPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__OfficialDocumentationPropertyType, default initialized and not managed by a soap context
        virtual plu__OfficialDocumentationPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__OfficialDocumentationPropertyType); }
      public:
        /// Constructor with default initializations
        plu__OfficialDocumentationPropertyType() : __OfficialDocumentationPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~plu__OfficialDocumentationPropertyType() { }
        /// Friend allocator used by soap_new_plu__OfficialDocumentationPropertyType(struct soap*, int)
        friend SOAP_FMAC1 plu__OfficialDocumentationPropertyType * SOAP_FMAC2 soap_instantiate_plu__OfficialDocumentationPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:317 */
#ifndef SOAP_TYPE_plu_plu__DimensioningIndicationMeasureValuePropertyType
#define SOAP_TYPE_plu_plu__DimensioningIndicationMeasureValuePropertyType (-60)
/* complex XML schema type 'plu:DimensioningIndicationMeasureValuePropertyType': */
class SOAP_CMAC plu__DimensioningIndicationMeasureValuePropertyType : public xsd__anyType {
      public:
        /// Required element 'plu:DimensioningIndicationMeasureValue' of XML schema type 'plu:DimensioningIndicationMeasureValueType'
        plu__DimensioningIndicationMeasureValueType *DimensioningIndicationMeasureValue;
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__DimensioningIndicationMeasureValuePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__DimensioningIndicationMeasureValuePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__DimensioningIndicationMeasureValuePropertyType, default initialized and not managed by a soap context
        virtual plu__DimensioningIndicationMeasureValuePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__DimensioningIndicationMeasureValuePropertyType); }
      public:
        /// Constructor with default initializations
        plu__DimensioningIndicationMeasureValuePropertyType() : DimensioningIndicationMeasureValue() { }
        virtual ~plu__DimensioningIndicationMeasureValuePropertyType() { }
        /// Friend allocator used by soap_new_plu__DimensioningIndicationMeasureValuePropertyType(struct soap*, int)
        friend SOAP_FMAC1 plu__DimensioningIndicationMeasureValuePropertyType * SOAP_FMAC2 soap_instantiate_plu__DimensioningIndicationMeasureValuePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:323 */
#ifndef SOAP_TYPE_plu_plu__DimensioningIndicationIntegerValuePropertyType
#define SOAP_TYPE_plu_plu__DimensioningIndicationIntegerValuePropertyType (-62)
/* complex XML schema type 'plu:DimensioningIndicationIntegerValuePropertyType': */
class SOAP_CMAC plu__DimensioningIndicationIntegerValuePropertyType : public xsd__anyType {
      public:
        /// Required element 'plu:DimensioningIndicationIntegerValue' of XML schema type 'plu:DimensioningIndicationIntegerValueType'
        plu__DimensioningIndicationIntegerValueType *DimensioningIndicationIntegerValue;
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__DimensioningIndicationIntegerValuePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__DimensioningIndicationIntegerValuePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__DimensioningIndicationIntegerValuePropertyType, default initialized and not managed by a soap context
        virtual plu__DimensioningIndicationIntegerValuePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__DimensioningIndicationIntegerValuePropertyType); }
      public:
        /// Constructor with default initializations
        plu__DimensioningIndicationIntegerValuePropertyType() : DimensioningIndicationIntegerValue() { }
        virtual ~plu__DimensioningIndicationIntegerValuePropertyType() { }
        /// Friend allocator used by soap_new_plu__DimensioningIndicationIntegerValuePropertyType(struct soap*, int)
        friend SOAP_FMAC1 plu__DimensioningIndicationIntegerValuePropertyType * SOAP_FMAC2 soap_instantiate_plu__DimensioningIndicationIntegerValuePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:329 */
#ifndef SOAP_TYPE_plu_plu__DimensioningIndicationCharacterValuePropertyType
#define SOAP_TYPE_plu_plu__DimensioningIndicationCharacterValuePropertyType (-64)
/* complex XML schema type 'plu:DimensioningIndicationCharacterValuePropertyType': */
class SOAP_CMAC plu__DimensioningIndicationCharacterValuePropertyType : public xsd__anyType {
      public:
        /// Required element 'plu:DimensioningIndicationCharacterValue' of XML schema type 'plu:DimensioningIndicationCharacterValueType'
        plu__DimensioningIndicationCharacterValueType *DimensioningIndicationCharacterValue;
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__DimensioningIndicationCharacterValuePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__DimensioningIndicationCharacterValuePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__DimensioningIndicationCharacterValuePropertyType, default initialized and not managed by a soap context
        virtual plu__DimensioningIndicationCharacterValuePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__DimensioningIndicationCharacterValuePropertyType); }
      public:
        /// Constructor with default initializations
        plu__DimensioningIndicationCharacterValuePropertyType() : DimensioningIndicationCharacterValue() { }
        virtual ~plu__DimensioningIndicationCharacterValuePropertyType() { }
        /// Friend allocator used by soap_new_plu__DimensioningIndicationCharacterValuePropertyType(struct soap*, int)
        friend SOAP_FMAC1 plu__DimensioningIndicationCharacterValuePropertyType * SOAP_FMAC2 soap_instantiate_plu__DimensioningIndicationCharacterValuePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:3695 */
#ifndef SOAP_TYPE_plu___plu__SupplementaryRegulationPropertyType_sequence
#define SOAP_TYPE_plu___plu__SupplementaryRegulationPropertyType_sequence (-839)
/* Wrapper: */
class SOAP_CMAC __plu__SupplementaryRegulationPropertyType_sequence {
      public:
        /// Required element 'plu:SupplementaryRegulation' of XML schema type 'plu:SupplementaryRegulationType'
        plu__SupplementaryRegulationType *SupplementaryRegulation;
      public:
        /// Return unique type id SOAP_TYPE_plu___plu__SupplementaryRegulationPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___plu__SupplementaryRegulationPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __plu__SupplementaryRegulationPropertyType_sequence, default initialized and not managed by a soap context
        virtual __plu__SupplementaryRegulationPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__plu__SupplementaryRegulationPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __plu__SupplementaryRegulationPropertyType_sequence() : SupplementaryRegulation() { }
        virtual ~__plu__SupplementaryRegulationPropertyType_sequence() { }
        /// Friend allocator used by soap_new___plu__SupplementaryRegulationPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __plu__SupplementaryRegulationPropertyType_sequence * SOAP_FMAC2 soap_instantiate___plu__SupplementaryRegulationPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:335 */
#ifndef SOAP_TYPE_plu_plu__SupplementaryRegulationPropertyType
#define SOAP_TYPE_plu_plu__SupplementaryRegulationPropertyType (-66)
/* complex XML schema type 'plu:SupplementaryRegulationPropertyType': */
class SOAP_CMAC plu__SupplementaryRegulationPropertyType : public xsd__anyType {
      public:
        __plu__SupplementaryRegulationPropertyType_sequence *__SupplementaryRegulationPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__SupplementaryRegulationPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__SupplementaryRegulationPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__SupplementaryRegulationPropertyType, default initialized and not managed by a soap context
        virtual plu__SupplementaryRegulationPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__SupplementaryRegulationPropertyType); }
      public:
        /// Constructor with default initializations
        plu__SupplementaryRegulationPropertyType() : __SupplementaryRegulationPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~plu__SupplementaryRegulationPropertyType() { }
        /// Friend allocator used by soap_new_plu__SupplementaryRegulationPropertyType(struct soap*, int)
        friend SOAP_FMAC1 plu__SupplementaryRegulationPropertyType * SOAP_FMAC2 soap_instantiate_plu__SupplementaryRegulationPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:338 */
#ifndef SOAP_TYPE_plu_plu__DimensioningIndicationValueType
#define SOAP_TYPE_plu_plu__DimensioningIndicationValueType (-67)
/* complex XML schema type 'plu:DimensioningIndicationValueType': */
class SOAP_CMAC plu__DimensioningIndicationValueType : public xsd__anyType {
      public:
        /// Required element 'plu:indicationReference' of XML schema type 'xsd:string'
        std::string indicationReference;
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__DimensioningIndicationValueType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__DimensioningIndicationValueType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__DimensioningIndicationValueType, default initialized and not managed by a soap context
        virtual plu__DimensioningIndicationValueType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__DimensioningIndicationValueType); }
      public:
        /// Constructor with default initializations
        plu__DimensioningIndicationValueType() : indicationReference() { }
        virtual ~plu__DimensioningIndicationValueType() { }
        /// Friend allocator used by soap_new_plu__DimensioningIndicationValueType(struct soap*, int)
        friend SOAP_FMAC1 plu__DimensioningIndicationValueType * SOAP_FMAC2 soap_instantiate_plu__DimensioningIndicationValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:3784 */
#ifndef SOAP_TYPE_plu__plu__union_DimensioningIndicationValuePropertyType
#define SOAP_TYPE_plu__plu__union_DimensioningIndicationValuePropertyType (-842)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _plu__union_DimensioningIndicationValuePropertyType
{
        #define SOAP_UNION_plu__plu__union_DimensioningIndicationValuePropertyType_DimensioningIndicationValue	(1)	/**< union variant selector value for member DimensioningIndicationValue */
        plu__DimensioningIndicationValueType *DimensioningIndicationValue;
        #define SOAP_UNION_plu__plu__union_DimensioningIndicationValuePropertyType_DimensioningIndicationMeasureValue	(2)	/**< union variant selector value for member DimensioningIndicationMeasureValue */
        plu__DimensioningIndicationMeasureValueType *DimensioningIndicationMeasureValue;
        #define SOAP_UNION_plu__plu__union_DimensioningIndicationValuePropertyType_DimensioningIndicationIntegerValue	(3)	/**< union variant selector value for member DimensioningIndicationIntegerValue */
        plu__DimensioningIndicationIntegerValueType *DimensioningIndicationIntegerValue;
        #define SOAP_UNION_plu__plu__union_DimensioningIndicationValuePropertyType_DimensioningIndicationCharacterValue	(4)	/**< union variant selector value for member DimensioningIndicationCharacterValue */
        plu__DimensioningIndicationCharacterValueType *DimensioningIndicationCharacterValue;
        #define SOAP_UNION_plu__plu__union_DimensioningIndicationValuePropertyType_DimensioningIndicationRealValue	(5)	/**< union variant selector value for member DimensioningIndicationRealValue */
        plu__DimensioningIndicationRealValueType *DimensioningIndicationRealValue;
};
#endif

/* PlannedLandUse_v3.0.h:341 */
#ifndef SOAP_TYPE_plu_plu__DimensioningIndicationValuePropertyType
#define SOAP_TYPE_plu_plu__DimensioningIndicationValuePropertyType (-68)
/* complex XML schema type 'plu:DimensioningIndicationValuePropertyType': */
class SOAP_CMAC plu__DimensioningIndicationValuePropertyType : public xsd__anyType {
      public:
        /// Union with union _plu__union_DimensioningIndicationValuePropertyType variant selector __unionDimensioningIndicationValue set to one of: SOAP_UNION_plu__plu__union_DimensioningIndicationValuePropertyType_DimensioningIndicationValue SOAP_UNION_plu__plu__union_DimensioningIndicationValuePropertyType_DimensioningIndicationMeasureValue SOAP_UNION_plu__plu__union_DimensioningIndicationValuePropertyType_DimensioningIndicationIntegerValue SOAP_UNION_plu__plu__union_DimensioningIndicationValuePropertyType_DimensioningIndicationCharacterValue SOAP_UNION_plu__plu__union_DimensioningIndicationValuePropertyType_DimensioningIndicationRealValue
        int __unionDimensioningIndicationValue;
        union _plu__union_DimensioningIndicationValuePropertyType union_DimensioningIndicationValuePropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__DimensioningIndicationValuePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__DimensioningIndicationValuePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__DimensioningIndicationValuePropertyType, default initialized and not managed by a soap context
        virtual plu__DimensioningIndicationValuePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__DimensioningIndicationValuePropertyType); }
      public:
        /// Constructor with default initializations
        plu__DimensioningIndicationValuePropertyType() : __unionDimensioningIndicationValue() { }
        virtual ~plu__DimensioningIndicationValuePropertyType() { }
        /// Friend allocator used by soap_new_plu__DimensioningIndicationValuePropertyType(struct soap*, int)
        friend SOAP_FMAC1 plu__DimensioningIndicationValuePropertyType * SOAP_FMAC2 soap_instantiate_plu__DimensioningIndicationValuePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:3844 */
#ifndef SOAP_TYPE_plu___plu__SpatialPlanPropertyType_sequence
#define SOAP_TYPE_plu___plu__SpatialPlanPropertyType_sequence (-845)
/* Wrapper: */
class SOAP_CMAC __plu__SpatialPlanPropertyType_sequence {
      public:
        /// Required element 'plu:SpatialPlan' of XML schema type 'plu:SpatialPlanType'
        plu__SpatialPlanType *SpatialPlan;
      public:
        /// Return unique type id SOAP_TYPE_plu___plu__SpatialPlanPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___plu__SpatialPlanPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __plu__SpatialPlanPropertyType_sequence, default initialized and not managed by a soap context
        virtual __plu__SpatialPlanPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__plu__SpatialPlanPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __plu__SpatialPlanPropertyType_sequence() : SpatialPlan() { }
        virtual ~__plu__SpatialPlanPropertyType_sequence() { }
        /// Friend allocator used by soap_new___plu__SpatialPlanPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __plu__SpatialPlanPropertyType_sequence * SOAP_FMAC2 soap_instantiate___plu__SpatialPlanPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:347 */
#ifndef SOAP_TYPE_plu_plu__SpatialPlanPropertyType
#define SOAP_TYPE_plu_plu__SpatialPlanPropertyType (-70)
/* complex XML schema type 'plu:SpatialPlanPropertyType': */
class SOAP_CMAC plu__SpatialPlanPropertyType : public xsd__anyType {
      public:
        __plu__SpatialPlanPropertyType_sequence *__SpatialPlanPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__SpatialPlanPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__SpatialPlanPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__SpatialPlanPropertyType, default initialized and not managed by a soap context
        virtual plu__SpatialPlanPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__SpatialPlanPropertyType); }
      public:
        /// Constructor with default initializations
        plu__SpatialPlanPropertyType() : __SpatialPlanPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~plu__SpatialPlanPropertyType() { }
        /// Friend allocator used by soap_new_plu__SpatialPlanPropertyType(struct soap*, int)
        friend SOAP_FMAC1 plu__SpatialPlanPropertyType * SOAP_FMAC2 soap_instantiate_plu__SpatialPlanPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:353 */
#ifndef SOAP_TYPE_plu_plu__DimensioningIndicationRealValuePropertyType
#define SOAP_TYPE_plu_plu__DimensioningIndicationRealValuePropertyType (-72)
/* complex XML schema type 'plu:DimensioningIndicationRealValuePropertyType': */
class SOAP_CMAC plu__DimensioningIndicationRealValuePropertyType : public xsd__anyType {
      public:
        /// Required element 'plu:DimensioningIndicationRealValue' of XML schema type 'plu:DimensioningIndicationRealValueType'
        plu__DimensioningIndicationRealValueType *DimensioningIndicationRealValue;
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__DimensioningIndicationRealValuePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__DimensioningIndicationRealValuePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__DimensioningIndicationRealValuePropertyType, default initialized and not managed by a soap context
        virtual plu__DimensioningIndicationRealValuePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__DimensioningIndicationRealValuePropertyType); }
      public:
        /// Constructor with default initializations
        plu__DimensioningIndicationRealValuePropertyType() : DimensioningIndicationRealValue() { }
        virtual ~plu__DimensioningIndicationRealValuePropertyType() { }
        /// Friend allocator used by soap_new_plu__DimensioningIndicationRealValuePropertyType(struct soap*, int)
        friend SOAP_FMAC1 plu__DimensioningIndicationRealValuePropertyType * SOAP_FMAC2 soap_instantiate_plu__DimensioningIndicationRealValuePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:356 */
#ifndef SOAP_TYPE_plu_plu__OrdinanceValueType
#define SOAP_TYPE_plu_plu__OrdinanceValueType (-73)
/* complex XML schema type 'plu:OrdinanceValueType': */
class SOAP_CMAC plu__OrdinanceValueType : public xsd__anyType {
      public:
        /// Required element 'plu:ordinanceDate' of XML schema type 'xsd:dateTime'
        time_t ordinanceDate;
        /// Required element 'plu:ordinanceReference' of XML schema type 'xsd:string'
        std::string ordinanceReference;
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__OrdinanceValueType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__OrdinanceValueType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__OrdinanceValueType, default initialized and not managed by a soap context
        virtual plu__OrdinanceValueType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__OrdinanceValueType); }
      public:
        /// Constructor with default initializations
        plu__OrdinanceValueType() : ordinanceDate(), ordinanceReference() { }
        virtual ~plu__OrdinanceValueType() { }
        /// Friend allocator used by soap_new_plu__OrdinanceValueType(struct soap*, int)
        friend SOAP_FMAC1 plu__OrdinanceValueType * SOAP_FMAC2 soap_instantiate_plu__OrdinanceValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:359 */
#ifndef SOAP_TYPE_plu_plu__OrdinanceValuePropertyType
#define SOAP_TYPE_plu_plu__OrdinanceValuePropertyType (-74)
/* complex XML schema type 'plu:OrdinanceValuePropertyType': */
class SOAP_CMAC plu__OrdinanceValuePropertyType : public xsd__anyType {
      public:
        /// Required element 'plu:OrdinanceValue' of XML schema type 'plu:OrdinanceValueType'
        plu__OrdinanceValueType *OrdinanceValue;
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__OrdinanceValuePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__OrdinanceValuePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__OrdinanceValuePropertyType, default initialized and not managed by a soap context
        virtual plu__OrdinanceValuePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__OrdinanceValuePropertyType); }
      public:
        /// Constructor with default initializations
        plu__OrdinanceValuePropertyType() : OrdinanceValue() { }
        virtual ~plu__OrdinanceValuePropertyType() { }
        /// Friend allocator used by soap_new_plu__OrdinanceValuePropertyType(struct soap*, int)
        friend SOAP_FMAC1 plu__OrdinanceValuePropertyType * SOAP_FMAC2 soap_instantiate_plu__OrdinanceValuePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:4006 */
#ifndef SOAP_TYPE_plu__plu__BackgroundMapValueType_backgroudMapURI
#define SOAP_TYPE_plu__plu__BackgroundMapValueType_backgroudMapURI (-850)
/* simple XML schema type 'plu:BackgroundMapValueType-backgroudMapURI': */
class SOAP_CMAC _plu__BackgroundMapValueType_backgroudMapURI {
      public:
        /// Simple content of XML schema type 'xsd:anyURI' wrapped by this struct
        char *__item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__BackgroundMapValueType_backgroudMapURI
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__BackgroundMapValueType_backgroudMapURI; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__BackgroundMapValueType_backgroudMapURI, default initialized and not managed by a soap context
        virtual _plu__BackgroundMapValueType_backgroudMapURI *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__BackgroundMapValueType_backgroudMapURI); }
      public:
        /// Constructor with default initializations
        _plu__BackgroundMapValueType_backgroudMapURI() : __item(), nilReason() { }
        virtual ~_plu__BackgroundMapValueType_backgroudMapURI() { }
        /// Friend allocator used by soap_new__plu__BackgroundMapValueType_backgroudMapURI(struct soap*, int)
        friend SOAP_FMAC1 _plu__BackgroundMapValueType_backgroudMapURI * SOAP_FMAC2 soap_instantiate__plu__BackgroundMapValueType_backgroudMapURI(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:362 */
#ifndef SOAP_TYPE_plu_plu__BackgroundMapValueType
#define SOAP_TYPE_plu_plu__BackgroundMapValueType (-75)
/* complex XML schema type 'plu:BackgroundMapValueType': */
class SOAP_CMAC plu__BackgroundMapValueType : public xsd__anyType {
      public:
        /// Required element 'plu:backgroundMapDate' of XML schema type 'xsd:dateTime'
        time_t backgroundMapDate;
        /// Required element 'plu:backgroundMapReference' of XML schema type 'xsd:string'
        std::string backgroundMapReference;
        /// Required nillable (xsi:nil when NULL) element 'plu:backgroudMapURI' of XML schema type 'plu:BackgroundMapValueType-backgroudMapURI'
        _plu__BackgroundMapValueType_backgroudMapURI *backgroudMapURI;
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__BackgroundMapValueType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__BackgroundMapValueType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__BackgroundMapValueType, default initialized and not managed by a soap context
        virtual plu__BackgroundMapValueType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__BackgroundMapValueType); }
      public:
        /// Constructor with default initializations
        plu__BackgroundMapValueType() : backgroundMapDate(), backgroundMapReference(), backgroudMapURI() { }
        virtual ~plu__BackgroundMapValueType() { }
        /// Friend allocator used by soap_new_plu__BackgroundMapValueType(struct soap*, int)
        friend SOAP_FMAC1 plu__BackgroundMapValueType * SOAP_FMAC2 soap_instantiate_plu__BackgroundMapValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:365 */
#ifndef SOAP_TYPE_plu_plu__BackgroundMapValuePropertyType
#define SOAP_TYPE_plu_plu__BackgroundMapValuePropertyType (-76)
/* complex XML schema type 'plu:BackgroundMapValuePropertyType': */
class SOAP_CMAC plu__BackgroundMapValuePropertyType : public xsd__anyType {
      public:
        /// Required element 'plu:BackgroundMapValue' of XML schema type 'plu:BackgroundMapValueType'
        plu__BackgroundMapValueType *BackgroundMapValue;
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__BackgroundMapValuePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__BackgroundMapValuePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__BackgroundMapValuePropertyType, default initialized and not managed by a soap context
        virtual plu__BackgroundMapValuePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__BackgroundMapValuePropertyType); }
      public:
        /// Constructor with default initializations
        plu__BackgroundMapValuePropertyType() : BackgroundMapValue() { }
        virtual ~plu__BackgroundMapValuePropertyType() { }
        /// Friend allocator used by soap_new_plu__BackgroundMapValuePropertyType(struct soap*, int)
        friend SOAP_FMAC1 plu__BackgroundMapValuePropertyType * SOAP_FMAC2 soap_instantiate_plu__BackgroundMapValuePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:4060 */
#ifndef SOAP_TYPE_plu___base__SpatialDataSetPropertyType_sequence
#define SOAP_TYPE_plu___base__SpatialDataSetPropertyType_sequence (-853)
/* Wrapper: */
class SOAP_CMAC __base__SpatialDataSetPropertyType_sequence {
      public:
        /// Required element 'base:SpatialDataSet' of XML schema type 'base:SpatialDataSetType'
        base__SpatialDataSetType *SpatialDataSet;
      public:
        /// Return unique type id SOAP_TYPE_plu___base__SpatialDataSetPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___base__SpatialDataSetPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __base__SpatialDataSetPropertyType_sequence, default initialized and not managed by a soap context
        virtual __base__SpatialDataSetPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__base__SpatialDataSetPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __base__SpatialDataSetPropertyType_sequence() : SpatialDataSet() { }
        virtual ~__base__SpatialDataSetPropertyType_sequence() { }
        /// Friend allocator used by soap_new___base__SpatialDataSetPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __base__SpatialDataSetPropertyType_sequence * SOAP_FMAC2 soap_instantiate___base__SpatialDataSetPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:371 */
#ifndef SOAP_TYPE_plu_base__SpatialDataSetPropertyType
#define SOAP_TYPE_plu_base__SpatialDataSetPropertyType (-78)
/* complex XML schema type 'base:SpatialDataSetPropertyType': */
class SOAP_CMAC base__SpatialDataSetPropertyType : public xsd__anyType {
      public:
        __base__SpatialDataSetPropertyType_sequence *__SpatialDataSetPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_base__SpatialDataSetPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_base__SpatialDataSetPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type base__SpatialDataSetPropertyType, default initialized and not managed by a soap context
        virtual base__SpatialDataSetPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(base__SpatialDataSetPropertyType); }
      public:
        /// Constructor with default initializations
        base__SpatialDataSetPropertyType() : __SpatialDataSetPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~base__SpatialDataSetPropertyType() { }
        /// Friend allocator used by soap_new_base__SpatialDataSetPropertyType(struct soap*, int)
        friend SOAP_FMAC1 base__SpatialDataSetPropertyType * SOAP_FMAC2 soap_instantiate_base__SpatialDataSetPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:4148 */
#ifndef SOAP_TYPE_plu__base__IdentifierType_versionId
#define SOAP_TYPE_plu__base__IdentifierType_versionId (-856)
/* simple XML schema type 'base:IdentifierType-versionId': */
class SOAP_CMAC _base__IdentifierType_versionId {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__base__IdentifierType_versionId
        virtual long soap_type(void) const { return SOAP_TYPE_plu__base__IdentifierType_versionId; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _base__IdentifierType_versionId, default initialized and not managed by a soap context
        virtual _base__IdentifierType_versionId *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_base__IdentifierType_versionId); }
      public:
        /// Constructor with default initializations
        _base__IdentifierType_versionId() : __item(), nilReason() { }
        virtual ~_base__IdentifierType_versionId() { }
        /// Friend allocator used by soap_new__base__IdentifierType_versionId(struct soap*, int)
        friend SOAP_FMAC1 _base__IdentifierType_versionId * SOAP_FMAC2 soap_instantiate__base__IdentifierType_versionId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:374 */
#ifndef SOAP_TYPE_plu_base__IdentifierType
#define SOAP_TYPE_plu_base__IdentifierType (-79)
/* complex XML schema type 'base:IdentifierType': */
class SOAP_CMAC base__IdentifierType : public xsd__anyType {
      public:
        /// Required element 'base:localId' of XML schema type 'xsd:string'
        std::string localId;
        /// Required element 'base:namespace' of XML schema type 'xsd:string'
        std::string namespace_;
        /// Optional element 'base:versionId' of XML schema type 'base:IdentifierType-versionId'
        _base__IdentifierType_versionId *versionId;
      public:
        /// Return unique type id SOAP_TYPE_plu_base__IdentifierType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_base__IdentifierType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type base__IdentifierType, default initialized and not managed by a soap context
        virtual base__IdentifierType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(base__IdentifierType); }
      public:
        /// Constructor with default initializations
        base__IdentifierType() : localId(), namespace_(), versionId() { }
        virtual ~base__IdentifierType() { }
        /// Friend allocator used by soap_new_base__IdentifierType(struct soap*, int)
        friend SOAP_FMAC1 base__IdentifierType * SOAP_FMAC2 soap_instantiate_base__IdentifierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:377 */
#ifndef SOAP_TYPE_plu_base__IdentifierPropertyType
#define SOAP_TYPE_plu_base__IdentifierPropertyType (-80)
/* complex XML schema type 'base:IdentifierPropertyType': */
class SOAP_CMAC base__IdentifierPropertyType : public xsd__anyType {
      public:
        /// Required element 'base:Identifier' of XML schema type 'base:IdentifierType'
        base__IdentifierType *Identifier;
      public:
        /// Return unique type id SOAP_TYPE_plu_base__IdentifierPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_base__IdentifierPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type base__IdentifierPropertyType, default initialized and not managed by a soap context
        virtual base__IdentifierPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(base__IdentifierPropertyType); }
      public:
        /// Constructor with default initializations
        base__IdentifierPropertyType() : Identifier() { }
        virtual ~base__IdentifierPropertyType() { }
        /// Friend allocator used by soap_new_base__IdentifierPropertyType(struct soap*, int)
        friend SOAP_FMAC1 base__IdentifierPropertyType * SOAP_FMAC2 soap_instantiate_base__IdentifierPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:380 */
#ifndef SOAP_TYPE_plu_base2__OfficialJournalInformationType
#define SOAP_TYPE_plu_base2__OfficialJournalInformationType (-81)
/* complex XML schema type 'base2:OfficialJournalInformationType': */
class SOAP_CMAC base2__OfficialJournalInformationType : public xsd__anyType {
      public:
        /// Required element 'base2:officialJournalIdentification' of XML schema type 'xsd:string'
        std::string officialJournalIdentification;
        /// Optional element 'base2:ISSN' of XML schema type 'xsd:string'
        std::string *ISSN;
        /// Optional element 'base2:ISBN' of XML schema type 'xsd:string'
        std::string *ISBN;
        /// Optional element 'base2:linkToJournal' of XML schema type 'xsd:anyURI'
        char **linkToJournal;
      public:
        /// Return unique type id SOAP_TYPE_plu_base2__OfficialJournalInformationType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_base2__OfficialJournalInformationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type base2__OfficialJournalInformationType, default initialized and not managed by a soap context
        virtual base2__OfficialJournalInformationType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(base2__OfficialJournalInformationType); }
      public:
        /// Constructor with default initializations
        base2__OfficialJournalInformationType() : officialJournalIdentification(), ISSN(), ISBN(), linkToJournal() { }
        virtual ~base2__OfficialJournalInformationType() { }
        /// Friend allocator used by soap_new_base2__OfficialJournalInformationType(struct soap*, int)
        friend SOAP_FMAC1 base2__OfficialJournalInformationType * SOAP_FMAC2 soap_instantiate_base2__OfficialJournalInformationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:383 */
#ifndef SOAP_TYPE_plu_base2__OfficialJournalInformationPropertyType
#define SOAP_TYPE_plu_base2__OfficialJournalInformationPropertyType (-82)
/* complex XML schema type 'base2:OfficialJournalInformationPropertyType': */
class SOAP_CMAC base2__OfficialJournalInformationPropertyType : public xsd__anyType {
      public:
        /// Required element 'base2:OfficialJournalInformation' of XML schema type 'base2:OfficialJournalInformationType'
        base2__OfficialJournalInformationType *OfficialJournalInformation;
      public:
        /// Return unique type id SOAP_TYPE_plu_base2__OfficialJournalInformationPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_base2__OfficialJournalInformationPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type base2__OfficialJournalInformationPropertyType, default initialized and not managed by a soap context
        virtual base2__OfficialJournalInformationPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(base2__OfficialJournalInformationPropertyType); }
      public:
        /// Constructor with default initializations
        base2__OfficialJournalInformationPropertyType() : OfficialJournalInformation() { }
        virtual ~base2__OfficialJournalInformationPropertyType() { }
        /// Friend allocator used by soap_new_base2__OfficialJournalInformationPropertyType(struct soap*, int)
        friend SOAP_FMAC1 base2__OfficialJournalInformationPropertyType * SOAP_FMAC2 soap_instantiate_base2__OfficialJournalInformationPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:4286 */
#ifndef SOAP_TYPE_plu___base2__LegislationCitationPropertyType_sequence
#define SOAP_TYPE_plu___base2__LegislationCitationPropertyType_sequence (-861)
/* Wrapper: */
class SOAP_CMAC __base2__LegislationCitationPropertyType_sequence {
      public:
        /// Required element 'base2:LegislationCitation' of XML schema type 'base2:LegislationCitationType'
        base2__LegislationCitationType *LegislationCitation;
      public:
        /// Return unique type id SOAP_TYPE_plu___base2__LegislationCitationPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___base2__LegislationCitationPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __base2__LegislationCitationPropertyType_sequence, default initialized and not managed by a soap context
        virtual __base2__LegislationCitationPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__base2__LegislationCitationPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __base2__LegislationCitationPropertyType_sequence() : LegislationCitation() { }
        virtual ~__base2__LegislationCitationPropertyType_sequence() { }
        /// Friend allocator used by soap_new___base2__LegislationCitationPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __base2__LegislationCitationPropertyType_sequence * SOAP_FMAC2 soap_instantiate___base2__LegislationCitationPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:389 */
#ifndef SOAP_TYPE_plu_base2__LegislationCitationPropertyType
#define SOAP_TYPE_plu_base2__LegislationCitationPropertyType (-84)
/* complex XML schema type 'base2:LegislationCitationPropertyType': */
class SOAP_CMAC base2__LegislationCitationPropertyType : public xsd__anyType {
      public:
        __base2__LegislationCitationPropertyType_sequence *__LegislationCitationPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_base2__LegislationCitationPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_base2__LegislationCitationPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type base2__LegislationCitationPropertyType, default initialized and not managed by a soap context
        virtual base2__LegislationCitationPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(base2__LegislationCitationPropertyType); }
      public:
        /// Constructor with default initializations
        base2__LegislationCitationPropertyType() : __LegislationCitationPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~base2__LegislationCitationPropertyType() { }
        /// Friend allocator used by soap_new_base2__LegislationCitationPropertyType(struct soap*, int)
        friend SOAP_FMAC1 base2__LegislationCitationPropertyType * SOAP_FMAC2 soap_instantiate_base2__LegislationCitationPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:4368 */
#ifndef SOAP_TYPE_plu__base2__ContactType_electronicMailAddress
#define SOAP_TYPE_plu__base2__ContactType_electronicMailAddress (-865)
/* simple XML schema type 'base2:ContactType-electronicMailAddress': */
class SOAP_CMAC _base2__ContactType_electronicMailAddress {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__base2__ContactType_electronicMailAddress
        virtual long soap_type(void) const { return SOAP_TYPE_plu__base2__ContactType_electronicMailAddress; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _base2__ContactType_electronicMailAddress, default initialized and not managed by a soap context
        virtual _base2__ContactType_electronicMailAddress *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_base2__ContactType_electronicMailAddress); }
      public:
        /// Constructor with default initializations
        _base2__ContactType_electronicMailAddress() : __item(), nilReason() { }
        virtual ~_base2__ContactType_electronicMailAddress() { }
        /// Friend allocator used by soap_new__base2__ContactType_electronicMailAddress(struct soap*, int)
        friend SOAP_FMAC1 _base2__ContactType_electronicMailAddress * SOAP_FMAC2 soap_instantiate__base2__ContactType_electronicMailAddress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:4399 */
#ifndef SOAP_TYPE_plu__base2__ContactType_telephoneFacsimile
#define SOAP_TYPE_plu__base2__ContactType_telephoneFacsimile (-867)
/* simple XML schema type 'base2:ContactType-telephoneFacsimile': */
class SOAP_CMAC _base2__ContactType_telephoneFacsimile {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__base2__ContactType_telephoneFacsimile
        virtual long soap_type(void) const { return SOAP_TYPE_plu__base2__ContactType_telephoneFacsimile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _base2__ContactType_telephoneFacsimile, default initialized and not managed by a soap context
        virtual _base2__ContactType_telephoneFacsimile *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_base2__ContactType_telephoneFacsimile); }
      public:
        /// Constructor with default initializations
        _base2__ContactType_telephoneFacsimile() : __item(), nilReason() { }
        virtual ~_base2__ContactType_telephoneFacsimile() { }
        /// Friend allocator used by soap_new__base2__ContactType_telephoneFacsimile(struct soap*, int)
        friend SOAP_FMAC1 _base2__ContactType_telephoneFacsimile * SOAP_FMAC2 soap_instantiate__base2__ContactType_telephoneFacsimile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:4423 */
#ifndef SOAP_TYPE_plu__base2__ContactType_telephoneVoice
#define SOAP_TYPE_plu__base2__ContactType_telephoneVoice (-870)
/* simple XML schema type 'base2:ContactType-telephoneVoice': */
class SOAP_CMAC _base2__ContactType_telephoneVoice {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__base2__ContactType_telephoneVoice
        virtual long soap_type(void) const { return SOAP_TYPE_plu__base2__ContactType_telephoneVoice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _base2__ContactType_telephoneVoice, default initialized and not managed by a soap context
        virtual _base2__ContactType_telephoneVoice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_base2__ContactType_telephoneVoice); }
      public:
        /// Constructor with default initializations
        _base2__ContactType_telephoneVoice() : __item(), nilReason() { }
        virtual ~_base2__ContactType_telephoneVoice() { }
        /// Friend allocator used by soap_new__base2__ContactType_telephoneVoice(struct soap*, int)
        friend SOAP_FMAC1 _base2__ContactType_telephoneVoice * SOAP_FMAC2 soap_instantiate__base2__ContactType_telephoneVoice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:4445 */
#ifndef SOAP_TYPE_plu__base2__ContactType_website
#define SOAP_TYPE_plu__base2__ContactType_website (-873)
/* simple XML schema type 'base2:ContactType-website': */
class SOAP_CMAC _base2__ContactType_website {
      public:
        /// Simple content of XML schema type 'xsd:anyURI' wrapped by this struct
        char *__item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__base2__ContactType_website
        virtual long soap_type(void) const { return SOAP_TYPE_plu__base2__ContactType_website; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _base2__ContactType_website, default initialized and not managed by a soap context
        virtual _base2__ContactType_website *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_base2__ContactType_website); }
      public:
        /// Constructor with default initializations
        _base2__ContactType_website() : __item(), nilReason() { }
        virtual ~_base2__ContactType_website() { }
        /// Friend allocator used by soap_new__base2__ContactType_website(struct soap*, int)
        friend SOAP_FMAC1 _base2__ContactType_website * SOAP_FMAC2 soap_instantiate__base2__ContactType_website(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:392 */
#ifndef SOAP_TYPE_plu_base2__ContactType
#define SOAP_TYPE_plu_base2__ContactType (-85)
/* complex XML schema type 'base2:ContactType': */
class SOAP_CMAC base2__ContactType : public xsd__anyType {
      public:
        /// Optional element 'base2:address' of XML schema type 'gmd:PT_FreeText_PropertyType'
        gmd__PT_x005fFreeText_x005fPropertyType *address;
        /// Optional element 'base2:contactInstructions' of XML schema type 'gmd:PT_FreeText_PropertyType'
        gmd__PT_x005fFreeText_x005fPropertyType *contactInstructions;
        /// Optional element 'base2:electronicMailAddress' of XML schema type 'base2:ContactType-electronicMailAddress'
        _base2__ContactType_electronicMailAddress *electronicMailAddress;
        /// Optional element 'base2:hoursOfService' of XML schema type 'gmd:PT_FreeText_PropertyType'
        gmd__PT_x005fFreeText_x005fPropertyType *hoursOfService;
        /// Optional element 'base2:telephoneFacsimile' of XML schema type 'base2:ContactType-telephoneFacsimile'
        std::vector<_base2__ContactType_telephoneFacsimile> *telephoneFacsimile;
        /// Optional element 'base2:telephoneVoice' of XML schema type 'base2:ContactType-telephoneVoice'
        std::vector<_base2__ContactType_telephoneVoice> *telephoneVoice;
        /// Optional element 'base2:website' of XML schema type 'base2:ContactType-website'
        _base2__ContactType_website *website;
      public:
        /// Return unique type id SOAP_TYPE_plu_base2__ContactType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_base2__ContactType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type base2__ContactType, default initialized and not managed by a soap context
        virtual base2__ContactType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(base2__ContactType); }
      public:
        /// Constructor with default initializations
        base2__ContactType() : address(), contactInstructions(), electronicMailAddress(), hoursOfService(), telephoneFacsimile(), telephoneVoice(), website() { }
        virtual ~base2__ContactType() { }
        /// Friend allocator used by soap_new_base2__ContactType(struct soap*, int)
        friend SOAP_FMAC1 base2__ContactType * SOAP_FMAC2 soap_instantiate_base2__ContactType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:395 */
#ifndef SOAP_TYPE_plu_base2__ContactPropertyType
#define SOAP_TYPE_plu_base2__ContactPropertyType (-86)
/* complex XML schema type 'base2:ContactPropertyType': */
class SOAP_CMAC base2__ContactPropertyType : public xsd__anyType {
      public:
        /// Required element 'base2:Contact' of XML schema type 'base2:ContactType'
        base2__ContactType *Contact;
      public:
        /// Return unique type id SOAP_TYPE_plu_base2__ContactPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_base2__ContactPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type base2__ContactPropertyType, default initialized and not managed by a soap context
        virtual base2__ContactPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(base2__ContactPropertyType); }
      public:
        /// Constructor with default initializations
        base2__ContactPropertyType() : Contact() { }
        virtual ~base2__ContactPropertyType() { }
        /// Friend allocator used by soap_new_base2__ContactPropertyType(struct soap*, int)
        friend SOAP_FMAC1 base2__ContactPropertyType * SOAP_FMAC2 soap_instantiate_base2__ContactPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:4533 */
#ifndef SOAP_TYPE_plu__base2__RelatedPartyType_contact
#define SOAP_TYPE_plu__base2__RelatedPartyType_contact (-876)
/* complex XML schema type 'base2:RelatedPartyType-contact': */
class SOAP_CMAC _base2__RelatedPartyType_contact {
      public:
        /// Required element 'base2:Contact' of XML schema type 'base2:ContactType'
        base2__ContactType *Contact;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__base2__RelatedPartyType_contact
        virtual long soap_type(void) const { return SOAP_TYPE_plu__base2__RelatedPartyType_contact; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _base2__RelatedPartyType_contact, default initialized and not managed by a soap context
        virtual _base2__RelatedPartyType_contact *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_base2__RelatedPartyType_contact); }
      public:
        /// Constructor with default initializations
        _base2__RelatedPartyType_contact() : Contact(), nilReason() { }
        virtual ~_base2__RelatedPartyType_contact() { }
        /// Friend allocator used by soap_new__base2__RelatedPartyType_contact(struct soap*, int)
        friend SOAP_FMAC1 _base2__RelatedPartyType_contact * SOAP_FMAC2 soap_instantiate__base2__RelatedPartyType_contact(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:398 */
#ifndef SOAP_TYPE_plu_base2__RelatedPartyType
#define SOAP_TYPE_plu_base2__RelatedPartyType (-87)
/* complex XML schema type 'base2:RelatedPartyType': */
class SOAP_CMAC base2__RelatedPartyType : public xsd__anyType {
      public:
        /// Optional element 'base2:individualName' of XML schema type 'gmd:PT_FreeText_PropertyType'
        gmd__PT_x005fFreeText_x005fPropertyType *individualName;
        /// Optional element 'base2:organisationName' of XML schema type 'gmd:PT_FreeText_PropertyType'
        gmd__PT_x005fFreeText_x005fPropertyType *organisationName;
        /// Optional element 'base2:positionName' of XML schema type 'gmd:PT_FreeText_PropertyType'
        gmd__PT_x005fFreeText_x005fPropertyType *positionName;
        /// Optional element 'base2:contact' of XML schema type 'base2:RelatedPartyType-contact'
        _base2__RelatedPartyType_contact *contact;
        /// Optional element 'base2:role' of XML schema type 'gml:ReferenceType'
        std::vector<gml__ReferenceType *> role;
      public:
        /// Return unique type id SOAP_TYPE_plu_base2__RelatedPartyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_base2__RelatedPartyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type base2__RelatedPartyType, default initialized and not managed by a soap context
        virtual base2__RelatedPartyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(base2__RelatedPartyType); }
      public:
        /// Constructor with default initializations
        base2__RelatedPartyType() : individualName(), organisationName(), positionName(), contact(), role() { }
        virtual ~base2__RelatedPartyType() { }
        /// Friend allocator used by soap_new_base2__RelatedPartyType(struct soap*, int)
        friend SOAP_FMAC1 base2__RelatedPartyType * SOAP_FMAC2 soap_instantiate_base2__RelatedPartyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:401 */
#ifndef SOAP_TYPE_plu_base2__RelatedPartyPropertyType
#define SOAP_TYPE_plu_base2__RelatedPartyPropertyType (-88)
/* complex XML schema type 'base2:RelatedPartyPropertyType': */
class SOAP_CMAC base2__RelatedPartyPropertyType : public xsd__anyType {
      public:
        /// Required element 'base2:RelatedParty' of XML schema type 'base2:RelatedPartyType'
        base2__RelatedPartyType *RelatedParty;
      public:
        /// Return unique type id SOAP_TYPE_plu_base2__RelatedPartyPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_base2__RelatedPartyPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type base2__RelatedPartyPropertyType, default initialized and not managed by a soap context
        virtual base2__RelatedPartyPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(base2__RelatedPartyPropertyType); }
      public:
        /// Constructor with default initializations
        base2__RelatedPartyPropertyType() : RelatedParty() { }
        virtual ~base2__RelatedPartyPropertyType() { }
        /// Friend allocator used by soap_new_base2__RelatedPartyPropertyType(struct soap*, int)
        friend SOAP_FMAC1 base2__RelatedPartyPropertyType * SOAP_FMAC2 soap_instantiate_base2__RelatedPartyPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:4608 */
#ifndef SOAP_TYPE_plu__base2__union_DocumentCitationPropertyType
#define SOAP_TYPE_plu__base2__union_DocumentCitationPropertyType (-882)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _base2__union_DocumentCitationPropertyType
{
        #define SOAP_UNION_plu__base2__union_DocumentCitationPropertyType_DocumentCitation	(1)	/**< union variant selector value for member DocumentCitation */
        base2__DocumentCitationType *DocumentCitation;
        #define SOAP_UNION_plu__base2__union_DocumentCitationPropertyType_LegislationCitation	(2)	/**< union variant selector value for member LegislationCitation */
        base2__LegislationCitationType *LegislationCitation;
};
#endif

/* PlannedLandUse_v3.0.h:4596 */
#ifndef SOAP_TYPE_plu___base2__DocumentCitationPropertyType_sequence
#define SOAP_TYPE_plu___base2__DocumentCitationPropertyType_sequence (-881)
/* Wrapper: */
class SOAP_CMAC __base2__DocumentCitationPropertyType_sequence {
      public:
        /// Union with union _base2__union_DocumentCitationPropertyType variant selector __unionDocumentCitation set to one of: SOAP_UNION_plu__base2__union_DocumentCitationPropertyType_DocumentCitation SOAP_UNION_plu__base2__union_DocumentCitationPropertyType_LegislationCitation
        int __unionDocumentCitation;
        union _base2__union_DocumentCitationPropertyType union_DocumentCitationPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___base2__DocumentCitationPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___base2__DocumentCitationPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __base2__DocumentCitationPropertyType_sequence, default initialized and not managed by a soap context
        virtual __base2__DocumentCitationPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__base2__DocumentCitationPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __base2__DocumentCitationPropertyType_sequence() : __unionDocumentCitation() { }
        virtual ~__base2__DocumentCitationPropertyType_sequence() { }
        /// Friend allocator used by soap_new___base2__DocumentCitationPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __base2__DocumentCitationPropertyType_sequence * SOAP_FMAC2 soap_instantiate___base2__DocumentCitationPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:407 */
#ifndef SOAP_TYPE_plu_base2__DocumentCitationPropertyType
#define SOAP_TYPE_plu_base2__DocumentCitationPropertyType (-90)
/* complex XML schema type 'base2:DocumentCitationPropertyType': */
class SOAP_CMAC base2__DocumentCitationPropertyType : public xsd__anyType {
      public:
        __base2__DocumentCitationPropertyType_sequence *__DocumentCitationPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_base2__DocumentCitationPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_base2__DocumentCitationPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type base2__DocumentCitationPropertyType, default initialized and not managed by a soap context
        virtual base2__DocumentCitationPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(base2__DocumentCitationPropertyType); }
      public:
        /// Constructor with default initializations
        base2__DocumentCitationPropertyType() : __DocumentCitationPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~base2__DocumentCitationPropertyType() { }
        /// Friend allocator used by soap_new_base2__DocumentCitationPropertyType(struct soap*, int)
        friend SOAP_FMAC1 base2__DocumentCitationPropertyType * SOAP_FMAC2 soap_instantiate_base2__DocumentCitationPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:410 */
#ifndef SOAP_TYPE_plu_base2__ThematicIdentifierType
#define SOAP_TYPE_plu_base2__ThematicIdentifierType (-91)
/* complex XML schema type 'base2:ThematicIdentifierType': */
class SOAP_CMAC base2__ThematicIdentifierType : public xsd__anyType {
      public:
        /// Required element 'base2:identifier' of XML schema type 'xsd:string'
        std::string identifier;
        /// Required element 'base2:identifierScheme' of XML schema type 'xsd:string'
        std::string identifierScheme;
      public:
        /// Return unique type id SOAP_TYPE_plu_base2__ThematicIdentifierType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_base2__ThematicIdentifierType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type base2__ThematicIdentifierType, default initialized and not managed by a soap context
        virtual base2__ThematicIdentifierType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(base2__ThematicIdentifierType); }
      public:
        /// Constructor with default initializations
        base2__ThematicIdentifierType() : identifier(), identifierScheme() { }
        virtual ~base2__ThematicIdentifierType() { }
        /// Friend allocator used by soap_new_base2__ThematicIdentifierType(struct soap*, int)
        friend SOAP_FMAC1 base2__ThematicIdentifierType * SOAP_FMAC2 soap_instantiate_base2__ThematicIdentifierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:413 */
#ifndef SOAP_TYPE_plu_base2__ThematicIdentifierPropertyType
#define SOAP_TYPE_plu_base2__ThematicIdentifierPropertyType (-92)
/* complex XML schema type 'base2:ThematicIdentifierPropertyType': */
class SOAP_CMAC base2__ThematicIdentifierPropertyType : public xsd__anyType {
      public:
        /// Required element 'base2:ThematicIdentifier' of XML schema type 'base2:ThematicIdentifierType'
        base2__ThematicIdentifierType *ThematicIdentifier;
      public:
        /// Return unique type id SOAP_TYPE_plu_base2__ThematicIdentifierPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_base2__ThematicIdentifierPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type base2__ThematicIdentifierPropertyType, default initialized and not managed by a soap context
        virtual base2__ThematicIdentifierPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(base2__ThematicIdentifierPropertyType); }
      public:
        /// Constructor with default initializations
        base2__ThematicIdentifierPropertyType() : ThematicIdentifier() { }
        virtual ~base2__ThematicIdentifierPropertyType() { }
        /// Friend allocator used by soap_new_base2__ThematicIdentifierPropertyType(struct soap*, int)
        friend SOAP_FMAC1 base2__ThematicIdentifierPropertyType * SOAP_FMAC2 soap_instantiate_base2__ThematicIdentifierPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:4742 */
#ifndef SOAP_TYPE_plu__lunom__union_HILUCSPresenceType
#define SOAP_TYPE_plu__lunom__union_HILUCSPresenceType (-886)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _lunom__union_HILUCSPresenceType
{
        #define SOAP_UNION_plu__lunom__union_HILUCSPresenceType_orderedList	(1)	/**< union variant selector value for member orderedList */
        std::vector<gml__ReferenceType *> *orderedList;
        #define SOAP_UNION_plu__lunom__union_HILUCSPresenceType_percentageList	(2)	/**< union variant selector value for member percentageList */
        std::vector<lunom__HILUCSPercentagePropertyType *> *percentageList;
};
#endif

/* PlannedLandUse_v3.0.h:416 */
#ifndef SOAP_TYPE_plu_lunom__HILUCSPresenceType
#define SOAP_TYPE_plu_lunom__HILUCSPresenceType (-93)
/* complex XML schema type 'lunom:HILUCSPresenceType': */
class SOAP_CMAC lunom__HILUCSPresenceType : public xsd__anyType {
      public:
        /// Union with union _lunom__union_HILUCSPresenceType variant selector __union_HILUCSPresenceType set to one of: SOAP_UNION_plu__lunom__union_HILUCSPresenceType_orderedList SOAP_UNION_plu__lunom__union_HILUCSPresenceType_percentageList
        int __union_HILUCSPresenceType;
        union _lunom__union_HILUCSPresenceType union_HILUCSPresenceType;
      public:
        /// Return unique type id SOAP_TYPE_plu_lunom__HILUCSPresenceType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_lunom__HILUCSPresenceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lunom__HILUCSPresenceType, default initialized and not managed by a soap context
        virtual lunom__HILUCSPresenceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lunom__HILUCSPresenceType); }
      public:
        /// Constructor with default initializations
        lunom__HILUCSPresenceType() : __union_HILUCSPresenceType() { }
        virtual ~lunom__HILUCSPresenceType() { }
        /// Friend allocator used by soap_new_lunom__HILUCSPresenceType(struct soap*, int)
        friend SOAP_FMAC1 lunom__HILUCSPresenceType * SOAP_FMAC2 soap_instantiate_lunom__HILUCSPresenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:419 */
#ifndef SOAP_TYPE_plu_lunom__HILUCSPresencePropertyType
#define SOAP_TYPE_plu_lunom__HILUCSPresencePropertyType (-94)
/* complex XML schema type 'lunom:HILUCSPresencePropertyType': */
class SOAP_CMAC lunom__HILUCSPresencePropertyType : public xsd__anyType {
      public:
        /// Required element 'lunom:HILUCSPresence' of XML schema type 'lunom:HILUCSPresenceType'
        lunom__HILUCSPresenceType *HILUCSPresence;
      public:
        /// Return unique type id SOAP_TYPE_plu_lunom__HILUCSPresencePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_lunom__HILUCSPresencePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lunom__HILUCSPresencePropertyType, default initialized and not managed by a soap context
        virtual lunom__HILUCSPresencePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lunom__HILUCSPresencePropertyType); }
      public:
        /// Constructor with default initializations
        lunom__HILUCSPresencePropertyType() : HILUCSPresence() { }
        virtual ~lunom__HILUCSPresencePropertyType() { }
        /// Friend allocator used by soap_new_lunom__HILUCSPresencePropertyType(struct soap*, int)
        friend SOAP_FMAC1 lunom__HILUCSPresencePropertyType * SOAP_FMAC2 soap_instantiate_lunom__HILUCSPresencePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:422 */
#ifndef SOAP_TYPE_plu_lunom__SpecificPercentageType
#define SOAP_TYPE_plu_lunom__SpecificPercentageType (-95)
/* complex XML schema type 'lunom:SpecificPercentageType': */
class SOAP_CMAC lunom__SpecificPercentageType : public xsd__anyType {
      public:
        /// Required element 'lunom:specificValue' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *specificValue;
        /// Required element 'lunom:percentage' of XML schema type 'xsd:long'
        long percentage;
      public:
        /// Return unique type id SOAP_TYPE_plu_lunom__SpecificPercentageType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_lunom__SpecificPercentageType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lunom__SpecificPercentageType, default initialized and not managed by a soap context
        virtual lunom__SpecificPercentageType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lunom__SpecificPercentageType); }
      public:
        /// Constructor with default initializations
        lunom__SpecificPercentageType() : specificValue(), percentage() { }
        virtual ~lunom__SpecificPercentageType() { }
        /// Friend allocator used by soap_new_lunom__SpecificPercentageType(struct soap*, int)
        friend SOAP_FMAC1 lunom__SpecificPercentageType * SOAP_FMAC2 soap_instantiate_lunom__SpecificPercentageType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:425 */
#ifndef SOAP_TYPE_plu_lunom__SpecificPercentagePropertyType
#define SOAP_TYPE_plu_lunom__SpecificPercentagePropertyType (-96)
/* complex XML schema type 'lunom:SpecificPercentagePropertyType': */
class SOAP_CMAC lunom__SpecificPercentagePropertyType : public xsd__anyType {
      public:
        /// Required element 'lunom:SpecificPercentage' of XML schema type 'lunom:SpecificPercentageType'
        lunom__SpecificPercentageType *SpecificPercentage;
      public:
        /// Return unique type id SOAP_TYPE_plu_lunom__SpecificPercentagePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_lunom__SpecificPercentagePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lunom__SpecificPercentagePropertyType, default initialized and not managed by a soap context
        virtual lunom__SpecificPercentagePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lunom__SpecificPercentagePropertyType); }
      public:
        /// Constructor with default initializations
        lunom__SpecificPercentagePropertyType() : SpecificPercentage() { }
        virtual ~lunom__SpecificPercentagePropertyType() { }
        /// Friend allocator used by soap_new_lunom__SpecificPercentagePropertyType(struct soap*, int)
        friend SOAP_FMAC1 lunom__SpecificPercentagePropertyType * SOAP_FMAC2 soap_instantiate_lunom__SpecificPercentagePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:4850 */
#ifndef SOAP_TYPE_plu__lunom__union_SpecificPresenceType
#define SOAP_TYPE_plu__lunom__union_SpecificPresenceType (-894)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _lunom__union_SpecificPresenceType
{
        #define SOAP_UNION_plu__lunom__union_SpecificPresenceType_orderedList	(1)	/**< union variant selector value for member orderedList */
        std::vector<gml__ReferenceType *> *orderedList;
        #define SOAP_UNION_plu__lunom__union_SpecificPresenceType_percentageList	(2)	/**< union variant selector value for member percentageList */
        std::vector<lunom__SpecificPercentagePropertyType *> *percentageList;
};
#endif

/* PlannedLandUse_v3.0.h:428 */
#ifndef SOAP_TYPE_plu_lunom__SpecificPresenceType
#define SOAP_TYPE_plu_lunom__SpecificPresenceType (-97)
/* complex XML schema type 'lunom:SpecificPresenceType': */
class SOAP_CMAC lunom__SpecificPresenceType : public xsd__anyType {
      public:
        /// Union with union _lunom__union_SpecificPresenceType variant selector __union_SpecificPresenceType set to one of: SOAP_UNION_plu__lunom__union_SpecificPresenceType_orderedList SOAP_UNION_plu__lunom__union_SpecificPresenceType_percentageList
        int __union_SpecificPresenceType;
        union _lunom__union_SpecificPresenceType union_SpecificPresenceType;
      public:
        /// Return unique type id SOAP_TYPE_plu_lunom__SpecificPresenceType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_lunom__SpecificPresenceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lunom__SpecificPresenceType, default initialized and not managed by a soap context
        virtual lunom__SpecificPresenceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lunom__SpecificPresenceType); }
      public:
        /// Constructor with default initializations
        lunom__SpecificPresenceType() : __union_SpecificPresenceType() { }
        virtual ~lunom__SpecificPresenceType() { }
        /// Friend allocator used by soap_new_lunom__SpecificPresenceType(struct soap*, int)
        friend SOAP_FMAC1 lunom__SpecificPresenceType * SOAP_FMAC2 soap_instantiate_lunom__SpecificPresenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:431 */
#ifndef SOAP_TYPE_plu_lunom__SpecificPresencePropertyType
#define SOAP_TYPE_plu_lunom__SpecificPresencePropertyType (-98)
/* complex XML schema type 'lunom:SpecificPresencePropertyType': */
class SOAP_CMAC lunom__SpecificPresencePropertyType : public xsd__anyType {
      public:
        /// Required element 'lunom:SpecificPresence' of XML schema type 'lunom:SpecificPresenceType'
        lunom__SpecificPresenceType *SpecificPresence;
      public:
        /// Return unique type id SOAP_TYPE_plu_lunom__SpecificPresencePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_lunom__SpecificPresencePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lunom__SpecificPresencePropertyType, default initialized and not managed by a soap context
        virtual lunom__SpecificPresencePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lunom__SpecificPresencePropertyType); }
      public:
        /// Constructor with default initializations
        lunom__SpecificPresencePropertyType() : SpecificPresence() { }
        virtual ~lunom__SpecificPresencePropertyType() { }
        /// Friend allocator used by soap_new_lunom__SpecificPresencePropertyType(struct soap*, int)
        friend SOAP_FMAC1 lunom__SpecificPresencePropertyType * SOAP_FMAC2 soap_instantiate_lunom__SpecificPresencePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:434 */
#ifndef SOAP_TYPE_plu_lunom__HILUCSPercentageType
#define SOAP_TYPE_plu_lunom__HILUCSPercentageType (-99)
/* complex XML schema type 'lunom:HILUCSPercentageType': */
class SOAP_CMAC lunom__HILUCSPercentageType : public xsd__anyType {
      public:
        /// Required element 'lunom:hilucsValue' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *hilucsValue;
        /// Required element 'lunom:percentage' of XML schema type 'xsd:long'
        long percentage;
      public:
        /// Return unique type id SOAP_TYPE_plu_lunom__HILUCSPercentageType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_lunom__HILUCSPercentageType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lunom__HILUCSPercentageType, default initialized and not managed by a soap context
        virtual lunom__HILUCSPercentageType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lunom__HILUCSPercentageType); }
      public:
        /// Constructor with default initializations
        lunom__HILUCSPercentageType() : hilucsValue(), percentage() { }
        virtual ~lunom__HILUCSPercentageType() { }
        /// Friend allocator used by soap_new_lunom__HILUCSPercentageType(struct soap*, int)
        friend SOAP_FMAC1 lunom__HILUCSPercentageType * SOAP_FMAC2 soap_instantiate_lunom__HILUCSPercentageType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:437 */
#ifndef SOAP_TYPE_plu_lunom__HILUCSPercentagePropertyType
#define SOAP_TYPE_plu_lunom__HILUCSPercentagePropertyType (-100)
/* complex XML schema type 'lunom:HILUCSPercentagePropertyType': */
class SOAP_CMAC lunom__HILUCSPercentagePropertyType : public xsd__anyType {
      public:
        /// Required element 'lunom:HILUCSPercentage' of XML schema type 'lunom:HILUCSPercentageType'
        lunom__HILUCSPercentageType *HILUCSPercentage;
      public:
        /// Return unique type id SOAP_TYPE_plu_lunom__HILUCSPercentagePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_lunom__HILUCSPercentagePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lunom__HILUCSPercentagePropertyType, default initialized and not managed by a soap context
        virtual lunom__HILUCSPercentagePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lunom__HILUCSPercentagePropertyType); }
      public:
        /// Constructor with default initializations
        lunom__HILUCSPercentagePropertyType() : HILUCSPercentage() { }
        virtual ~lunom__HILUCSPercentagePropertyType() { }
        /// Friend allocator used by soap_new_lunom__HILUCSPercentagePropertyType(struct soap*, int)
        friend SOAP_FMAC1 lunom__HILUCSPercentagePropertyType * SOAP_FMAC2 soap_instantiate_lunom__HILUCSPercentagePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:4988 */
#ifndef SOAP_TYPE_plu__gml__union_HistoryPropertyType
#define SOAP_TYPE_plu__gml__union_HistoryPropertyType (-901)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_HistoryPropertyType
{
        #define SOAP_UNION_plu__gml__union_HistoryPropertyType_MovingObjectStatus	(1)	/**< union variant selector value for member MovingObjectStatus */
        gml__MovingObjectStatusType *MovingObjectStatus;
};
#endif

/* PlannedLandUse_v3.0.h:4983 */
#ifndef SOAP_TYPE_plu___gml__union_HistoryPropertyType
#define SOAP_TYPE_plu___gml__union_HistoryPropertyType (-900)
/* Wrapper: */
class SOAP_CMAC __gml__union_HistoryPropertyType {
      public:
        /// Union with union _gml__union_HistoryPropertyType variant selector __unionAbstractTimeSlice set to one of: SOAP_UNION_plu__gml__union_HistoryPropertyType_MovingObjectStatus
        int __unionAbstractTimeSlice;
        union _gml__union_HistoryPropertyType union_HistoryPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_HistoryPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_HistoryPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_HistoryPropertyType, default initialized and not managed by a soap context
        virtual __gml__union_HistoryPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_HistoryPropertyType); }
      public:
        /// Constructor with default initializations
        __gml__union_HistoryPropertyType() : __unionAbstractTimeSlice() { }
        virtual ~__gml__union_HistoryPropertyType() { }
        /// Friend allocator used by soap_new___gml__union_HistoryPropertyType(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_HistoryPropertyType * SOAP_FMAC2 soap_instantiate___gml__union_HistoryPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:455 */
#ifndef SOAP_TYPE_plu_gml__HistoryPropertyType
#define SOAP_TYPE_plu_gml__HistoryPropertyType (-106)
/* complex XML schema type 'gml:HistoryPropertyType': */
class SOAP_CMAC gml__HistoryPropertyType : public xsd__anyType {
      public:
        /// Sequence of elements '-union-HistoryPropertyType' of XML schema type '-gml:union-HistoryPropertyType' stored in dynamic array __union_HistoryPropertyType of length __sizeAbstractTimeSlice
        int __sizeAbstractTimeSlice;
        __gml__union_HistoryPropertyType *__union_HistoryPropertyType;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__HistoryPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__HistoryPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__HistoryPropertyType, default initialized and not managed by a soap context
        virtual gml__HistoryPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__HistoryPropertyType); }
      public:
        /// Constructor with default initializations
        gml__HistoryPropertyType() : __sizeAbstractTimeSlice(), __union_HistoryPropertyType(), owns((bool)0) { }
        virtual ~gml__HistoryPropertyType() { }
        /// Friend allocator used by soap_new_gml__HistoryPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__HistoryPropertyType * SOAP_FMAC2 soap_instantiate_gml__HistoryPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:5018 */
#ifndef SOAP_TYPE_plu__gml__union_NodeOrEdgePropertyType
#define SOAP_TYPE_plu__gml__union_NodeOrEdgePropertyType (-904)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_NodeOrEdgePropertyType
{
        #define SOAP_UNION_plu__gml__union_NodeOrEdgePropertyType_Node	(1)	/**< union variant selector value for member Node */
        gml__NodeType *Node;
        #define SOAP_UNION_plu__gml__union_NodeOrEdgePropertyType_Edge	(2)	/**< union variant selector value for member Edge */
        gml__EdgeType *Edge;
};
#endif

/* PlannedLandUse_v3.0.h:464 */
#ifndef SOAP_TYPE_plu_gml__NodeOrEdgePropertyType
#define SOAP_TYPE_plu_gml__NodeOrEdgePropertyType (-109)
/* complex XML schema type 'gml:NodeOrEdgePropertyType': */
class SOAP_CMAC gml__NodeOrEdgePropertyType : public xsd__anyType {
      public:
        /// Union with union _gml__union_NodeOrEdgePropertyType variant selector __union_NodeOrEdgePropertyType set to one of: SOAP_UNION_plu__gml__union_NodeOrEdgePropertyType_Node SOAP_UNION_plu__gml__union_NodeOrEdgePropertyType_Edge
        int __union_NodeOrEdgePropertyType;
        union _gml__union_NodeOrEdgePropertyType union_NodeOrEdgePropertyType;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__NodeOrEdgePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__NodeOrEdgePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__NodeOrEdgePropertyType, default initialized and not managed by a soap context
        virtual gml__NodeOrEdgePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__NodeOrEdgePropertyType); }
      public:
        /// Constructor with default initializations
        gml__NodeOrEdgePropertyType() : __union_NodeOrEdgePropertyType(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__NodeOrEdgePropertyType() { }
        /// Friend allocator used by soap_new_gml__NodeOrEdgePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__NodeOrEdgePropertyType * SOAP_FMAC2 soap_instantiate_gml__NodeOrEdgePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:5081 */
#ifndef SOAP_TYPE_plu__gml__union_NodePropertyType
#define SOAP_TYPE_plu__gml__union_NodePropertyType (-907)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_NodePropertyType
{
        #define SOAP_UNION_plu__gml__union_NodePropertyType_Node	(1)	/**< union variant selector value for member Node */
        gml__NodeType *Node;
};
#endif

/* PlannedLandUse_v3.0.h:467 */
#ifndef SOAP_TYPE_plu_gml__NodePropertyType
#define SOAP_TYPE_plu_gml__NodePropertyType (-110)
/* complex XML schema type 'gml:NodePropertyType': */
class SOAP_CMAC gml__NodePropertyType : public xsd__anyType {
      public:
        /// Union with union _gml__union_NodePropertyType variant selector __union_NodePropertyType set to one of: SOAP_UNION_plu__gml__union_NodePropertyType_Node
        int __union_NodePropertyType;
        union _gml__union_NodePropertyType union_NodePropertyType;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__NodePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__NodePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__NodePropertyType, default initialized and not managed by a soap context
        virtual gml__NodePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__NodePropertyType); }
      public:
        /// Constructor with default initializations
        gml__NodePropertyType() : __union_NodePropertyType(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__NodePropertyType() { }
        /// Friend allocator used by soap_new_gml__NodePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__NodePropertyType * SOAP_FMAC2 soap_instantiate_gml__NodePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:5137 */
#ifndef SOAP_TYPE_plu__gml__union_FaceOrTopoSolidPropertyType
#define SOAP_TYPE_plu__gml__union_FaceOrTopoSolidPropertyType (-908)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_FaceOrTopoSolidPropertyType
{
        #define SOAP_UNION_plu__gml__union_FaceOrTopoSolidPropertyType_Face	(1)	/**< union variant selector value for member Face */
        gml__FaceType *Face;
        #define SOAP_UNION_plu__gml__union_FaceOrTopoSolidPropertyType_TopoSolid	(2)	/**< union variant selector value for member TopoSolid */
        gml__TopoSolidType *TopoSolid;
};
#endif

/* PlannedLandUse_v3.0.h:470 */
#ifndef SOAP_TYPE_plu_gml__FaceOrTopoSolidPropertyType
#define SOAP_TYPE_plu_gml__FaceOrTopoSolidPropertyType (-111)
/* complex XML schema type 'gml:FaceOrTopoSolidPropertyType': */
class SOAP_CMAC gml__FaceOrTopoSolidPropertyType : public xsd__anyType {
      public:
        /// Union with union _gml__union_FaceOrTopoSolidPropertyType variant selector __union_FaceOrTopoSolidPropertyType set to one of: SOAP_UNION_plu__gml__union_FaceOrTopoSolidPropertyType_Face SOAP_UNION_plu__gml__union_FaceOrTopoSolidPropertyType_TopoSolid
        int __union_FaceOrTopoSolidPropertyType;
        union _gml__union_FaceOrTopoSolidPropertyType union_FaceOrTopoSolidPropertyType;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__FaceOrTopoSolidPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__FaceOrTopoSolidPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__FaceOrTopoSolidPropertyType, default initialized and not managed by a soap context
        virtual gml__FaceOrTopoSolidPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__FaceOrTopoSolidPropertyType); }
      public:
        /// Constructor with default initializations
        gml__FaceOrTopoSolidPropertyType() : __union_FaceOrTopoSolidPropertyType(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__FaceOrTopoSolidPropertyType() { }
        /// Friend allocator used by soap_new_gml__FaceOrTopoSolidPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__FaceOrTopoSolidPropertyType * SOAP_FMAC2 soap_instantiate_gml__FaceOrTopoSolidPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:5199 */
#ifndef SOAP_TYPE_plu__gml__union_TopoSolidPropertyType
#define SOAP_TYPE_plu__gml__union_TopoSolidPropertyType (-911)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_TopoSolidPropertyType
{
        #define SOAP_UNION_plu__gml__union_TopoSolidPropertyType_TopoSolid	(1)	/**< union variant selector value for member TopoSolid */
        gml__TopoSolidType *TopoSolid;
};
#endif

/* PlannedLandUse_v3.0.h:473 */
#ifndef SOAP_TYPE_plu_gml__TopoSolidPropertyType
#define SOAP_TYPE_plu_gml__TopoSolidPropertyType (-112)
/* complex XML schema type 'gml:TopoSolidPropertyType': */
class SOAP_CMAC gml__TopoSolidPropertyType : public xsd__anyType {
      public:
        /// Union with union _gml__union_TopoSolidPropertyType variant selector __union_TopoSolidPropertyType set to one of: SOAP_UNION_plu__gml__union_TopoSolidPropertyType_TopoSolid
        int __union_TopoSolidPropertyType;
        union _gml__union_TopoSolidPropertyType union_TopoSolidPropertyType;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TopoSolidPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TopoSolidPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TopoSolidPropertyType, default initialized and not managed by a soap context
        virtual gml__TopoSolidPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TopoSolidPropertyType); }
      public:
        /// Constructor with default initializations
        gml__TopoSolidPropertyType() : __union_TopoSolidPropertyType(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__TopoSolidPropertyType() { }
        /// Friend allocator used by soap_new_gml__TopoSolidPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TopoSolidPropertyType * SOAP_FMAC2 soap_instantiate_gml__TopoSolidPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:5251 */
#ifndef SOAP_TYPE_plu___gml__DirectedNodePropertyType_sequence
#define SOAP_TYPE_plu___gml__DirectedNodePropertyType_sequence (-912)
/* Wrapper: */
class SOAP_CMAC __gml__DirectedNodePropertyType_sequence {
      public:
        /// Required element 'gml:Node' of XML schema type 'gml:NodeType'
        gml__NodeType *Node;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__DirectedNodePropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__DirectedNodePropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__DirectedNodePropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__DirectedNodePropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__DirectedNodePropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__DirectedNodePropertyType_sequence() : Node() { }
        virtual ~__gml__DirectedNodePropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__DirectedNodePropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__DirectedNodePropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__DirectedNodePropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:479 */
#ifndef SOAP_TYPE_plu_gml__DirectedNodePropertyType
#define SOAP_TYPE_plu_gml__DirectedNodePropertyType (-114)
/* complex XML schema type 'gml:DirectedNodePropertyType': */
class SOAP_CMAC gml__DirectedNodePropertyType : public xsd__anyType {
      public:
        __gml__DirectedNodePropertyType_sequence *__DirectedNodePropertyType_sequence;
        /// Optional attribute 'orientation' of XML schema type 'gml:SignType'
        enum gml__SignType orientation;	///< initialized with default value = (enum gml__SignType)1
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DirectedNodePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DirectedNodePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DirectedNodePropertyType, default initialized and not managed by a soap context
        virtual gml__DirectedNodePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DirectedNodePropertyType); }
      public:
        /// Constructor with default initializations
        gml__DirectedNodePropertyType() : __DirectedNodePropertyType_sequence(), orientation((enum gml__SignType)1), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__DirectedNodePropertyType() { }
        /// Friend allocator used by soap_new_gml__DirectedNodePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__DirectedNodePropertyType * SOAP_FMAC2 soap_instantiate_gml__DirectedNodePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:5307 */
#ifndef SOAP_TYPE_plu___gml__DirectedEdgePropertyType_sequence
#define SOAP_TYPE_plu___gml__DirectedEdgePropertyType_sequence (-914)
/* Wrapper: */
class SOAP_CMAC __gml__DirectedEdgePropertyType_sequence {
      public:
        /// Required element 'gml:Edge' of XML schema type 'gml:EdgeType'
        gml__EdgeType *Edge;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__DirectedEdgePropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__DirectedEdgePropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__DirectedEdgePropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__DirectedEdgePropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__DirectedEdgePropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__DirectedEdgePropertyType_sequence() : Edge() { }
        virtual ~__gml__DirectedEdgePropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__DirectedEdgePropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__DirectedEdgePropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__DirectedEdgePropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:485 */
#ifndef SOAP_TYPE_plu_gml__DirectedEdgePropertyType
#define SOAP_TYPE_plu_gml__DirectedEdgePropertyType (-116)
/* complex XML schema type 'gml:DirectedEdgePropertyType': */
class SOAP_CMAC gml__DirectedEdgePropertyType : public xsd__anyType {
      public:
        __gml__DirectedEdgePropertyType_sequence *__DirectedEdgePropertyType_sequence;
        /// Optional attribute 'orientation' of XML schema type 'gml:SignType'
        enum gml__SignType orientation;	///< initialized with default value = (enum gml__SignType)1
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DirectedEdgePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DirectedEdgePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DirectedEdgePropertyType, default initialized and not managed by a soap context
        virtual gml__DirectedEdgePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DirectedEdgePropertyType); }
      public:
        /// Constructor with default initializations
        gml__DirectedEdgePropertyType() : __DirectedEdgePropertyType_sequence(), orientation((enum gml__SignType)1), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__DirectedEdgePropertyType() { }
        /// Friend allocator used by soap_new_gml__DirectedEdgePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__DirectedEdgePropertyType * SOAP_FMAC2 soap_instantiate_gml__DirectedEdgePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:5363 */
#ifndef SOAP_TYPE_plu___gml__DirectedFacePropertyType_sequence
#define SOAP_TYPE_plu___gml__DirectedFacePropertyType_sequence (-916)
/* Wrapper: */
class SOAP_CMAC __gml__DirectedFacePropertyType_sequence {
      public:
        /// Required element 'gml:Face' of XML schema type 'gml:FaceType'
        gml__FaceType *Face;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__DirectedFacePropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__DirectedFacePropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__DirectedFacePropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__DirectedFacePropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__DirectedFacePropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__DirectedFacePropertyType_sequence() : Face() { }
        virtual ~__gml__DirectedFacePropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__DirectedFacePropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__DirectedFacePropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__DirectedFacePropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:491 */
#ifndef SOAP_TYPE_plu_gml__DirectedFacePropertyType
#define SOAP_TYPE_plu_gml__DirectedFacePropertyType (-118)
/* complex XML schema type 'gml:DirectedFacePropertyType': */
class SOAP_CMAC gml__DirectedFacePropertyType : public xsd__anyType {
      public:
        __gml__DirectedFacePropertyType_sequence *__DirectedFacePropertyType_sequence;
        /// Optional attribute 'orientation' of XML schema type 'gml:SignType'
        enum gml__SignType orientation;	///< initialized with default value = (enum gml__SignType)1
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DirectedFacePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DirectedFacePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DirectedFacePropertyType, default initialized and not managed by a soap context
        virtual gml__DirectedFacePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DirectedFacePropertyType); }
      public:
        /// Constructor with default initializations
        gml__DirectedFacePropertyType() : __DirectedFacePropertyType_sequence(), orientation((enum gml__SignType)1), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__DirectedFacePropertyType() { }
        /// Friend allocator used by soap_new_gml__DirectedFacePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__DirectedFacePropertyType * SOAP_FMAC2 soap_instantiate_gml__DirectedFacePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:5419 */
#ifndef SOAP_TYPE_plu___gml__DirectedTopoSolidPropertyType_sequence
#define SOAP_TYPE_plu___gml__DirectedTopoSolidPropertyType_sequence (-918)
/* Wrapper: */
class SOAP_CMAC __gml__DirectedTopoSolidPropertyType_sequence {
      public:
        /// Required element 'gml:TopoSolid' of XML schema type 'gml:TopoSolidType'
        gml__TopoSolidType *TopoSolid;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__DirectedTopoSolidPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__DirectedTopoSolidPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__DirectedTopoSolidPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__DirectedTopoSolidPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__DirectedTopoSolidPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__DirectedTopoSolidPropertyType_sequence() : TopoSolid() { }
        virtual ~__gml__DirectedTopoSolidPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__DirectedTopoSolidPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__DirectedTopoSolidPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__DirectedTopoSolidPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:497 */
#ifndef SOAP_TYPE_plu_gml__DirectedTopoSolidPropertyType
#define SOAP_TYPE_plu_gml__DirectedTopoSolidPropertyType (-120)
/* complex XML schema type 'gml:DirectedTopoSolidPropertyType': */
class SOAP_CMAC gml__DirectedTopoSolidPropertyType : public xsd__anyType {
      public:
        __gml__DirectedTopoSolidPropertyType_sequence *__DirectedTopoSolidPropertyType_sequence;
        /// Optional attribute 'orientation' of XML schema type 'gml:SignType'
        enum gml__SignType orientation;	///< initialized with default value = (enum gml__SignType)1
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DirectedTopoSolidPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DirectedTopoSolidPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DirectedTopoSolidPropertyType, default initialized and not managed by a soap context
        virtual gml__DirectedTopoSolidPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DirectedTopoSolidPropertyType); }
      public:
        /// Constructor with default initializations
        gml__DirectedTopoSolidPropertyType() : __DirectedTopoSolidPropertyType_sequence(), orientation((enum gml__SignType)1), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__DirectedTopoSolidPropertyType() { }
        /// Friend allocator used by soap_new_gml__DirectedTopoSolidPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__DirectedTopoSolidPropertyType * SOAP_FMAC2 soap_instantiate_gml__DirectedTopoSolidPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:503 */
#ifndef SOAP_TYPE_plu_gml__TopoPointPropertyType
#define SOAP_TYPE_plu_gml__TopoPointPropertyType (-122)
/* complex XML schema type 'gml:TopoPointPropertyType': */
class SOAP_CMAC gml__TopoPointPropertyType : public xsd__anyType {
      public:
        /// Required element 'gml:TopoPoint' of XML schema type 'gml:TopoPointType'
        gml__TopoPointType *TopoPoint;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TopoPointPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TopoPointPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TopoPointPropertyType, default initialized and not managed by a soap context
        virtual gml__TopoPointPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TopoPointPropertyType); }
      public:
        /// Constructor with default initializations
        gml__TopoPointPropertyType() : TopoPoint(), owns((bool)0) { }
        virtual ~gml__TopoPointPropertyType() { }
        /// Friend allocator used by soap_new_gml__TopoPointPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TopoPointPropertyType * SOAP_FMAC2 soap_instantiate_gml__TopoPointPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:509 */
#ifndef SOAP_TYPE_plu_gml__TopoCurvePropertyType
#define SOAP_TYPE_plu_gml__TopoCurvePropertyType (-124)
/* complex XML schema type 'gml:TopoCurvePropertyType': */
class SOAP_CMAC gml__TopoCurvePropertyType : public xsd__anyType {
      public:
        /// Required element 'gml:TopoCurve' of XML schema type 'gml:TopoCurveType'
        gml__TopoCurveType *TopoCurve;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TopoCurvePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TopoCurvePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TopoCurvePropertyType, default initialized and not managed by a soap context
        virtual gml__TopoCurvePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TopoCurvePropertyType); }
      public:
        /// Constructor with default initializations
        gml__TopoCurvePropertyType() : TopoCurve(), owns((bool)0) { }
        virtual ~gml__TopoCurvePropertyType() { }
        /// Friend allocator used by soap_new_gml__TopoCurvePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TopoCurvePropertyType * SOAP_FMAC2 soap_instantiate_gml__TopoCurvePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:515 */
#ifndef SOAP_TYPE_plu_gml__TopoSurfacePropertyType
#define SOAP_TYPE_plu_gml__TopoSurfacePropertyType (-126)
/* complex XML schema type 'gml:TopoSurfacePropertyType': */
class SOAP_CMAC gml__TopoSurfacePropertyType : public xsd__anyType {
      public:
        /// Required element 'gml:TopoSurface' of XML schema type 'gml:TopoSurfaceType'
        gml__TopoSurfaceType *TopoSurface;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TopoSurfacePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TopoSurfacePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TopoSurfacePropertyType, default initialized and not managed by a soap context
        virtual gml__TopoSurfacePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TopoSurfacePropertyType); }
      public:
        /// Constructor with default initializations
        gml__TopoSurfacePropertyType() : TopoSurface(), owns((bool)0) { }
        virtual ~gml__TopoSurfacePropertyType() { }
        /// Friend allocator used by soap_new_gml__TopoSurfacePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TopoSurfacePropertyType * SOAP_FMAC2 soap_instantiate_gml__TopoSurfacePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:521 */
#ifndef SOAP_TYPE_plu_gml__TopoVolumePropertyType
#define SOAP_TYPE_plu_gml__TopoVolumePropertyType (-128)
/* complex XML schema type 'gml:TopoVolumePropertyType': */
class SOAP_CMAC gml__TopoVolumePropertyType : public xsd__anyType {
      public:
        /// Required element 'gml:TopoVolume' of XML schema type 'gml:TopoVolumeType'
        gml__TopoVolumeType *TopoVolume;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TopoVolumePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TopoVolumePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TopoVolumePropertyType, default initialized and not managed by a soap context
        virtual gml__TopoVolumePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TopoVolumePropertyType); }
      public:
        /// Constructor with default initializations
        gml__TopoVolumePropertyType() : TopoVolume(), owns((bool)0) { }
        virtual ~gml__TopoVolumePropertyType() { }
        /// Friend allocator used by soap_new_gml__TopoVolumePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TopoVolumePropertyType * SOAP_FMAC2 soap_instantiate_gml__TopoVolumePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:5585 */
#ifndef SOAP_TYPE_plu__gml__union_TopoPrimitiveMemberType
#define SOAP_TYPE_plu__gml__union_TopoPrimitiveMemberType (-925)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_TopoPrimitiveMemberType
{
        #define SOAP_UNION_plu__gml__union_TopoPrimitiveMemberType_Node	(1)	/**< union variant selector value for member Node */
        gml__NodeType *Node;
        #define SOAP_UNION_plu__gml__union_TopoPrimitiveMemberType_Edge	(2)	/**< union variant selector value for member Edge */
        gml__EdgeType *Edge;
        #define SOAP_UNION_plu__gml__union_TopoPrimitiveMemberType_Face	(3)	/**< union variant selector value for member Face */
        gml__FaceType *Face;
        #define SOAP_UNION_plu__gml__union_TopoPrimitiveMemberType_TopoSolid	(4)	/**< union variant selector value for member TopoSolid */
        gml__TopoSolidType *TopoSolid;
};
#endif

/* PlannedLandUse_v3.0.h:5575 */
#ifndef SOAP_TYPE_plu___gml__TopoPrimitiveMemberType_sequence
#define SOAP_TYPE_plu___gml__TopoPrimitiveMemberType_sequence (-924)
/* Wrapper: */
class SOAP_CMAC __gml__TopoPrimitiveMemberType_sequence {
      public:
        /// Union with union _gml__union_TopoPrimitiveMemberType variant selector __unionAbstractTopoPrimitive set to one of: SOAP_UNION_plu__gml__union_TopoPrimitiveMemberType_Node SOAP_UNION_plu__gml__union_TopoPrimitiveMemberType_Edge SOAP_UNION_plu__gml__union_TopoPrimitiveMemberType_Face SOAP_UNION_plu__gml__union_TopoPrimitiveMemberType_TopoSolid
        int __unionAbstractTopoPrimitive;
        union _gml__union_TopoPrimitiveMemberType union_TopoPrimitiveMemberType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__TopoPrimitiveMemberType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__TopoPrimitiveMemberType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__TopoPrimitiveMemberType_sequence, default initialized and not managed by a soap context
        virtual __gml__TopoPrimitiveMemberType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__TopoPrimitiveMemberType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__TopoPrimitiveMemberType_sequence() : __unionAbstractTopoPrimitive() { }
        virtual ~__gml__TopoPrimitiveMemberType_sequence() { }
        /// Friend allocator used by soap_new___gml__TopoPrimitiveMemberType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__TopoPrimitiveMemberType_sequence * SOAP_FMAC2 soap_instantiate___gml__TopoPrimitiveMemberType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:527 */
#ifndef SOAP_TYPE_plu_gml__TopoPrimitiveMemberType
#define SOAP_TYPE_plu_gml__TopoPrimitiveMemberType (-130)
/* complex XML schema type 'gml:TopoPrimitiveMemberType': */
class SOAP_CMAC gml__TopoPrimitiveMemberType : public xsd__anyType {
      public:
        __gml__TopoPrimitiveMemberType_sequence *__TopoPrimitiveMemberType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TopoPrimitiveMemberType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TopoPrimitiveMemberType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TopoPrimitiveMemberType, default initialized and not managed by a soap context
        virtual gml__TopoPrimitiveMemberType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TopoPrimitiveMemberType); }
      public:
        /// Constructor with default initializations
        gml__TopoPrimitiveMemberType() : __TopoPrimitiveMemberType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__TopoPrimitiveMemberType() { }
        /// Friend allocator used by soap_new_gml__TopoPrimitiveMemberType(struct soap*, int)
        friend SOAP_FMAC1 gml__TopoPrimitiveMemberType * SOAP_FMAC2 soap_instantiate_gml__TopoPrimitiveMemberType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:5671 */
#ifndef SOAP_TYPE_plu__gml__union_TopoPrimitiveArrayAssociationType
#define SOAP_TYPE_plu__gml__union_TopoPrimitiveArrayAssociationType (-928)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_TopoPrimitiveArrayAssociationType
{
        #define SOAP_UNION_plu__gml__union_TopoPrimitiveArrayAssociationType_Node	(1)	/**< union variant selector value for member Node */
        gml__NodeType *Node;
        #define SOAP_UNION_plu__gml__union_TopoPrimitiveArrayAssociationType_Edge	(2)	/**< union variant selector value for member Edge */
        gml__EdgeType *Edge;
        #define SOAP_UNION_plu__gml__union_TopoPrimitiveArrayAssociationType_Face	(3)	/**< union variant selector value for member Face */
        gml__FaceType *Face;
        #define SOAP_UNION_plu__gml__union_TopoPrimitiveArrayAssociationType_TopoSolid	(4)	/**< union variant selector value for member TopoSolid */
        gml__TopoSolidType *TopoSolid;
};
#endif

/* PlannedLandUse_v3.0.h:5661 */
#ifndef SOAP_TYPE_plu___gml__TopoPrimitiveArrayAssociationType_sequence
#define SOAP_TYPE_plu___gml__TopoPrimitiveArrayAssociationType_sequence (-927)
/* Wrapper: */
class SOAP_CMAC __gml__TopoPrimitiveArrayAssociationType_sequence {
      public:
        /// Union with union _gml__union_TopoPrimitiveArrayAssociationType variant selector __unionAbstractTopoPrimitive set to one of: SOAP_UNION_plu__gml__union_TopoPrimitiveArrayAssociationType_Node SOAP_UNION_plu__gml__union_TopoPrimitiveArrayAssociationType_Edge SOAP_UNION_plu__gml__union_TopoPrimitiveArrayAssociationType_Face SOAP_UNION_plu__gml__union_TopoPrimitiveArrayAssociationType_TopoSolid
        int __unionAbstractTopoPrimitive;
        union _gml__union_TopoPrimitiveArrayAssociationType union_TopoPrimitiveArrayAssociationType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__TopoPrimitiveArrayAssociationType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__TopoPrimitiveArrayAssociationType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__TopoPrimitiveArrayAssociationType_sequence, default initialized and not managed by a soap context
        virtual __gml__TopoPrimitiveArrayAssociationType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__TopoPrimitiveArrayAssociationType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__TopoPrimitiveArrayAssociationType_sequence() : __unionAbstractTopoPrimitive() { }
        virtual ~__gml__TopoPrimitiveArrayAssociationType_sequence() { }
        /// Friend allocator used by soap_new___gml__TopoPrimitiveArrayAssociationType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__TopoPrimitiveArrayAssociationType_sequence * SOAP_FMAC2 soap_instantiate___gml__TopoPrimitiveArrayAssociationType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:530 */
#ifndef SOAP_TYPE_plu_gml__TopoPrimitiveArrayAssociationType
#define SOAP_TYPE_plu_gml__TopoPrimitiveArrayAssociationType (-131)
/* complex XML schema type 'gml:TopoPrimitiveArrayAssociationType': */
class SOAP_CMAC gml__TopoPrimitiveArrayAssociationType : public xsd__anyType {
      public:
        std::vector<__gml__TopoPrimitiveArrayAssociationType_sequence> __TopoPrimitiveArrayAssociationType_sequence;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TopoPrimitiveArrayAssociationType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TopoPrimitiveArrayAssociationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TopoPrimitiveArrayAssociationType, default initialized and not managed by a soap context
        virtual gml__TopoPrimitiveArrayAssociationType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TopoPrimitiveArrayAssociationType); }
      public:
        /// Constructor with default initializations
        gml__TopoPrimitiveArrayAssociationType() : __TopoPrimitiveArrayAssociationType_sequence(), owns((bool)0) { }
        virtual ~gml__TopoPrimitiveArrayAssociationType() { }
        /// Friend allocator used by soap_new_gml__TopoPrimitiveArrayAssociationType(struct soap*, int)
        friend SOAP_FMAC1 gml__TopoPrimitiveArrayAssociationType * SOAP_FMAC2 soap_instantiate_gml__TopoPrimitiveArrayAssociationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:5724 */
#ifndef SOAP_TYPE_plu___gml__TopoComplexPropertyType_sequence
#define SOAP_TYPE_plu___gml__TopoComplexPropertyType_sequence (-930)
/* Type __gml__TopoComplexPropertyType_sequence is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* Wrapper: */
class SOAP_CMAC __gml__TopoComplexPropertyType_sequence {
      public:
        /// Required element 'gml:TopoComplex' of XML schema type 'gml:TopoComplexType'
        gml__TopoComplexType *TopoComplex;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__TopoComplexPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__TopoComplexPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__TopoComplexPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__TopoComplexPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__TopoComplexPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__TopoComplexPropertyType_sequence() : TopoComplex() { }
        virtual ~__gml__TopoComplexPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__TopoComplexPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__TopoComplexPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__TopoComplexPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:533 */
#ifndef SOAP_TYPE_plu_gml__TopoComplexPropertyType
#define SOAP_TYPE_plu_gml__TopoComplexPropertyType (-132)
/* complex XML schema type 'gml:TopoComplexPropertyType': */
class SOAP_CMAC gml__TopoComplexPropertyType : public xsd__anyType {
      public:
        __gml__TopoComplexPropertyType_sequence *__TopoComplexPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TopoComplexPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TopoComplexPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TopoComplexPropertyType, default initialized and not managed by a soap context
        virtual gml__TopoComplexPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TopoComplexPropertyType); }
      public:
        /// Constructor with default initializations
        gml__TopoComplexPropertyType() : __TopoComplexPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__TopoComplexPropertyType() { }
        /// Friend allocator used by soap_new_gml__TopoComplexPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TopoComplexPropertyType * SOAP_FMAC2 soap_instantiate_gml__TopoComplexPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:5781 */
#ifndef SOAP_TYPE_plu__gml__union_GeometricComplexPropertyType
#define SOAP_TYPE_plu__gml__union_GeometricComplexPropertyType (-934)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_GeometricComplexPropertyType
{
        #define SOAP_UNION_plu__gml__union_GeometricComplexPropertyType_GeometricComplex	(1)	/**< union variant selector value for member GeometricComplex */
        gml__GeometricComplexType *GeometricComplex;
        #define SOAP_UNION_plu__gml__union_GeometricComplexPropertyType_CompositeCurve	(2)	/**< union variant selector value for member CompositeCurve */
        gml__CompositeCurveType *CompositeCurve;
        #define SOAP_UNION_plu__gml__union_GeometricComplexPropertyType_CompositeSurface	(3)	/**< union variant selector value for member CompositeSurface */
        gml__CompositeSurfaceType *CompositeSurface;
        #define SOAP_UNION_plu__gml__union_GeometricComplexPropertyType_CompositeSolid	(4)	/**< union variant selector value for member CompositeSolid */
        gml__CompositeSolidType *CompositeSolid;
};
#endif

/* PlannedLandUse_v3.0.h:5776 */
#ifndef SOAP_TYPE_plu___gml__GeometricComplexPropertyType_sequence
#define SOAP_TYPE_plu___gml__GeometricComplexPropertyType_sequence (-933)
/* Wrapper: */
class SOAP_CMAC __gml__GeometricComplexPropertyType_sequence {
      public:
        /// Union with union _gml__union_GeometricComplexPropertyType variant selector __union_GeometricComplexPropertyType set to one of: SOAP_UNION_plu__gml__union_GeometricComplexPropertyType_GeometricComplex SOAP_UNION_plu__gml__union_GeometricComplexPropertyType_CompositeCurve SOAP_UNION_plu__gml__union_GeometricComplexPropertyType_CompositeSurface SOAP_UNION_plu__gml__union_GeometricComplexPropertyType_CompositeSolid
        int __union_GeometricComplexPropertyType;
        union _gml__union_GeometricComplexPropertyType union_GeometricComplexPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__GeometricComplexPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__GeometricComplexPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__GeometricComplexPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__GeometricComplexPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__GeometricComplexPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__GeometricComplexPropertyType_sequence() : __union_GeometricComplexPropertyType() { }
        virtual ~__gml__GeometricComplexPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__GeometricComplexPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__GeometricComplexPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__GeometricComplexPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:539 */
#ifndef SOAP_TYPE_plu_gml__GeometricComplexPropertyType
#define SOAP_TYPE_plu_gml__GeometricComplexPropertyType (-134)
/* complex XML schema type 'gml:GeometricComplexPropertyType': */
class SOAP_CMAC gml__GeometricComplexPropertyType : public xsd__anyType {
      public:
        __gml__GeometricComplexPropertyType_sequence *__GeometricComplexPropertyType_sequence;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GeometricComplexPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GeometricComplexPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeometricComplexPropertyType, default initialized and not managed by a soap context
        virtual gml__GeometricComplexPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GeometricComplexPropertyType); }
      public:
        /// Constructor with default initializations
        gml__GeometricComplexPropertyType() : __GeometricComplexPropertyType_sequence(), owns((bool)0), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__GeometricComplexPropertyType() { }
        /// Friend allocator used by soap_new_gml__GeometricComplexPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeometricComplexPropertyType * SOAP_FMAC2 soap_instantiate_gml__GeometricComplexPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:5860 */
#ifndef SOAP_TYPE_plu__gml__union_MultiGeometryPropertyType
#define SOAP_TYPE_plu__gml__union_MultiGeometryPropertyType (-941)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_MultiGeometryPropertyType
{
        #define SOAP_UNION_plu__gml__union_MultiGeometryPropertyType_MultiGeometry	(1)	/**< union variant selector value for member MultiGeometry */
        gml__MultiGeometryType *MultiGeometry;
        #define SOAP_UNION_plu__gml__union_MultiGeometryPropertyType_MultiPoint	(2)	/**< union variant selector value for member MultiPoint */
        gml__MultiPointType *MultiPoint;
        #define SOAP_UNION_plu__gml__union_MultiGeometryPropertyType_MultiCurve	(3)	/**< union variant selector value for member MultiCurve */
        gml__MultiCurveType *MultiCurve;
        #define SOAP_UNION_plu__gml__union_MultiGeometryPropertyType_MultiSurface	(4)	/**< union variant selector value for member MultiSurface */
        gml__MultiSurfaceType *MultiSurface;
        #define SOAP_UNION_plu__gml__union_MultiGeometryPropertyType_MultiSolid	(5)	/**< union variant selector value for member MultiSolid */
        gml__MultiSolidType *MultiSolid;
};
#endif

/* PlannedLandUse_v3.0.h:5850 */
#ifndef SOAP_TYPE_plu___gml__MultiGeometryPropertyType_sequence
#define SOAP_TYPE_plu___gml__MultiGeometryPropertyType_sequence (-940)
/* Wrapper: */
class SOAP_CMAC __gml__MultiGeometryPropertyType_sequence {
      public:
        /// Union with union _gml__union_MultiGeometryPropertyType variant selector __unionAbstractGeometricAggregate set to one of: SOAP_UNION_plu__gml__union_MultiGeometryPropertyType_MultiGeometry SOAP_UNION_plu__gml__union_MultiGeometryPropertyType_MultiPoint SOAP_UNION_plu__gml__union_MultiGeometryPropertyType_MultiCurve SOAP_UNION_plu__gml__union_MultiGeometryPropertyType_MultiSurface SOAP_UNION_plu__gml__union_MultiGeometryPropertyType_MultiSolid
        int __unionAbstractGeometricAggregate;
        union _gml__union_MultiGeometryPropertyType union_MultiGeometryPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__MultiGeometryPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__MultiGeometryPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__MultiGeometryPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__MultiGeometryPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__MultiGeometryPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__MultiGeometryPropertyType_sequence() : __unionAbstractGeometricAggregate() { }
        virtual ~__gml__MultiGeometryPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__MultiGeometryPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__MultiGeometryPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__MultiGeometryPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:557 */
#ifndef SOAP_TYPE_plu_gml__MultiGeometryPropertyType
#define SOAP_TYPE_plu_gml__MultiGeometryPropertyType (-140)
/* complex XML schema type 'gml:MultiGeometryPropertyType': */
class SOAP_CMAC gml__MultiGeometryPropertyType : public xsd__anyType {
      public:
        __gml__MultiGeometryPropertyType_sequence *__MultiGeometryPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__MultiGeometryPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__MultiGeometryPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__MultiGeometryPropertyType, default initialized and not managed by a soap context
        virtual gml__MultiGeometryPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__MultiGeometryPropertyType); }
      public:
        /// Constructor with default initializations
        gml__MultiGeometryPropertyType() : __MultiGeometryPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__MultiGeometryPropertyType() { }
        /// Friend allocator used by soap_new_gml__MultiGeometryPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__MultiGeometryPropertyType * SOAP_FMAC2 soap_instantiate_gml__MultiGeometryPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:5940 */
#ifndef SOAP_TYPE_plu___gml__MultiPointPropertyType_sequence
#define SOAP_TYPE_plu___gml__MultiPointPropertyType_sequence (-948)
/* Wrapper: */
class SOAP_CMAC __gml__MultiPointPropertyType_sequence {
      public:
        /// Required element 'gml:MultiPoint' of XML schema type 'gml:MultiPointType'
        gml__MultiPointType *MultiPoint;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__MultiPointPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__MultiPointPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__MultiPointPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__MultiPointPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__MultiPointPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__MultiPointPropertyType_sequence() : MultiPoint() { }
        virtual ~__gml__MultiPointPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__MultiPointPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__MultiPointPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__MultiPointPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:563 */
#ifndef SOAP_TYPE_plu_gml__MultiPointPropertyType
#define SOAP_TYPE_plu_gml__MultiPointPropertyType (-142)
/* complex XML schema type 'gml:MultiPointPropertyType': */
class SOAP_CMAC gml__MultiPointPropertyType : public xsd__anyType {
      public:
        __gml__MultiPointPropertyType_sequence *__MultiPointPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__MultiPointPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__MultiPointPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__MultiPointPropertyType, default initialized and not managed by a soap context
        virtual gml__MultiPointPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__MultiPointPropertyType); }
      public:
        /// Constructor with default initializations
        gml__MultiPointPropertyType() : __MultiPointPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__MultiPointPropertyType() { }
        /// Friend allocator used by soap_new_gml__MultiPointPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__MultiPointPropertyType * SOAP_FMAC2 soap_instantiate_gml__MultiPointPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:5996 */
#ifndef SOAP_TYPE_plu___gml__MultiCurvePropertyType_sequence
#define SOAP_TYPE_plu___gml__MultiCurvePropertyType_sequence (-950)
/* Wrapper: */
class SOAP_CMAC __gml__MultiCurvePropertyType_sequence {
      public:
        /// Required element 'gml:MultiCurve' of XML schema type 'gml:MultiCurveType'
        gml__MultiCurveType *MultiCurve;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__MultiCurvePropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__MultiCurvePropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__MultiCurvePropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__MultiCurvePropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__MultiCurvePropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__MultiCurvePropertyType_sequence() : MultiCurve() { }
        virtual ~__gml__MultiCurvePropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__MultiCurvePropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__MultiCurvePropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__MultiCurvePropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:569 */
#ifndef SOAP_TYPE_plu_gml__MultiCurvePropertyType
#define SOAP_TYPE_plu_gml__MultiCurvePropertyType (-144)
/* complex XML schema type 'gml:MultiCurvePropertyType': */
class SOAP_CMAC gml__MultiCurvePropertyType : public xsd__anyType {
      public:
        __gml__MultiCurvePropertyType_sequence *__MultiCurvePropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__MultiCurvePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__MultiCurvePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__MultiCurvePropertyType, default initialized and not managed by a soap context
        virtual gml__MultiCurvePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__MultiCurvePropertyType); }
      public:
        /// Constructor with default initializations
        gml__MultiCurvePropertyType() : __MultiCurvePropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__MultiCurvePropertyType() { }
        /// Friend allocator used by soap_new_gml__MultiCurvePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__MultiCurvePropertyType * SOAP_FMAC2 soap_instantiate_gml__MultiCurvePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:6052 */
#ifndef SOAP_TYPE_plu___gml__MultiSurfacePropertyType_sequence
#define SOAP_TYPE_plu___gml__MultiSurfacePropertyType_sequence (-952)
/* Wrapper: */
class SOAP_CMAC __gml__MultiSurfacePropertyType_sequence {
      public:
        /// Required element 'gml:MultiSurface' of XML schema type 'gml:MultiSurfaceType'
        gml__MultiSurfaceType *MultiSurface;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__MultiSurfacePropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__MultiSurfacePropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__MultiSurfacePropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__MultiSurfacePropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__MultiSurfacePropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__MultiSurfacePropertyType_sequence() : MultiSurface() { }
        virtual ~__gml__MultiSurfacePropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__MultiSurfacePropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__MultiSurfacePropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__MultiSurfacePropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:575 */
#ifndef SOAP_TYPE_plu_gml__MultiSurfacePropertyType
#define SOAP_TYPE_plu_gml__MultiSurfacePropertyType (-146)
/* complex XML schema type 'gml:MultiSurfacePropertyType': */
class SOAP_CMAC gml__MultiSurfacePropertyType : public xsd__anyType {
      public:
        __gml__MultiSurfacePropertyType_sequence *__MultiSurfacePropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__MultiSurfacePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__MultiSurfacePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__MultiSurfacePropertyType, default initialized and not managed by a soap context
        virtual gml__MultiSurfacePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__MultiSurfacePropertyType); }
      public:
        /// Constructor with default initializations
        gml__MultiSurfacePropertyType() : __MultiSurfacePropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__MultiSurfacePropertyType() { }
        /// Friend allocator used by soap_new_gml__MultiSurfacePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__MultiSurfacePropertyType * SOAP_FMAC2 soap_instantiate_gml__MultiSurfacePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:6108 */
#ifndef SOAP_TYPE_plu___gml__MultiSolidPropertyType_sequence
#define SOAP_TYPE_plu___gml__MultiSolidPropertyType_sequence (-954)
/* Wrapper: */
class SOAP_CMAC __gml__MultiSolidPropertyType_sequence {
      public:
        /// Required element 'gml:MultiSolid' of XML schema type 'gml:MultiSolidType'
        gml__MultiSolidType *MultiSolid;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__MultiSolidPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__MultiSolidPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__MultiSolidPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__MultiSolidPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__MultiSolidPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__MultiSolidPropertyType_sequence() : MultiSolid() { }
        virtual ~__gml__MultiSolidPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__MultiSolidPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__MultiSolidPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__MultiSolidPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:581 */
#ifndef SOAP_TYPE_plu_gml__MultiSolidPropertyType
#define SOAP_TYPE_plu_gml__MultiSolidPropertyType (-148)
/* complex XML schema type 'gml:MultiSolidPropertyType': */
class SOAP_CMAC gml__MultiSolidPropertyType : public xsd__anyType {
      public:
        __gml__MultiSolidPropertyType_sequence *__MultiSolidPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__MultiSolidPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__MultiSolidPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__MultiSolidPropertyType, default initialized and not managed by a soap context
        virtual gml__MultiSolidPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__MultiSolidPropertyType); }
      public:
        /// Constructor with default initializations
        gml__MultiSolidPropertyType() : __MultiSolidPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__MultiSolidPropertyType() { }
        /// Friend allocator used by soap_new_gml__MultiSolidPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__MultiSolidPropertyType * SOAP_FMAC2 soap_instantiate_gml__MultiSolidPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:590 */
#ifndef SOAP_TYPE_plu_gml__AbstractCurveSegmentType
#define SOAP_TYPE_plu_gml__AbstractCurveSegmentType (-151)
/* simple XML schema type 'gml:AbstractCurveSegmentType': */
class SOAP_CMAC gml__AbstractCurveSegmentType : public xsd__anyType {
      public:
        /// Optional attribute 'numDerivativesAtStart' of XML schema type 'xsd:long'
        long numDerivativesAtStart;	///< initialized with default value = 0L
        /// Optional attribute 'numDerivativesAtEnd' of XML schema type 'xsd:long'
        long numDerivativesAtEnd;	///< initialized with default value = 0L
        /// Optional attribute 'numDerivativeInterior' of XML schema type 'xsd:long'
        long numDerivativeInterior;	///< initialized with default value = 0L
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractCurveSegmentType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractCurveSegmentType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractCurveSegmentType, default initialized and not managed by a soap context
        virtual gml__AbstractCurveSegmentType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractCurveSegmentType); }
      public:
        /// Constructor with default initializations
        gml__AbstractCurveSegmentType() : numDerivativesAtStart(0L), numDerivativesAtEnd(0L), numDerivativeInterior(0L) { }
        virtual ~gml__AbstractCurveSegmentType() { }
        /// Friend allocator used by soap_new_gml__AbstractCurveSegmentType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractCurveSegmentType * SOAP_FMAC2 soap_instantiate_gml__AbstractCurveSegmentType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:6200 */
#ifndef SOAP_TYPE_plu__gml__union_CurveSegmentArrayPropertyType
#define SOAP_TYPE_plu__gml__union_CurveSegmentArrayPropertyType (-957)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_CurveSegmentArrayPropertyType
{
        #define SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_LineStringSegment	(1)	/**< union variant selector value for member LineStringSegment */
        gml__LineStringSegmentType *LineStringSegment;
        #define SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_ArcString	(2)	/**< union variant selector value for member ArcString */
        gml__ArcStringType *ArcString;
        #define SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_Arc	(3)	/**< union variant selector value for member Arc */
        gml__ArcType *Arc;
        #define SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_Circle	(4)	/**< union variant selector value for member Circle */
        gml__CircleType *Circle;
        #define SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_ArcStringByBulge	(5)	/**< union variant selector value for member ArcStringByBulge */
        gml__ArcStringByBulgeType *ArcStringByBulge;
        #define SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_ArcByBulge	(6)	/**< union variant selector value for member ArcByBulge */
        gml__ArcByBulgeType *ArcByBulge;
        #define SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_ArcByCenterPoint	(7)	/**< union variant selector value for member ArcByCenterPoint */
        gml__ArcByCenterPointType *ArcByCenterPoint;
        #define SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_CircleByCenterPoint	(8)	/**< union variant selector value for member CircleByCenterPoint */
        gml__CircleByCenterPointType *CircleByCenterPoint;
        #define SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_CubicSpline	(9)	/**< union variant selector value for member CubicSpline */
        gml__CubicSplineType *CubicSpline;
        #define SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_BSpline	(10)	/**< union variant selector value for member BSpline */
        gml__BSplineType *BSpline;
        #define SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_Bezier	(11)	/**< union variant selector value for member Bezier */
        gml__BezierType *Bezier;
        #define SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_OffsetCurve	(12)	/**< union variant selector value for member OffsetCurve */
        gml__OffsetCurveType *OffsetCurve;
        #define SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_Clothoid	(13)	/**< union variant selector value for member Clothoid */
        gml__ClothoidType *Clothoid;
        #define SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_GeodesicString	(14)	/**< union variant selector value for member GeodesicString */
        gml__GeodesicStringType *GeodesicString;
        #define SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_Geodesic	(15)	/**< union variant selector value for member Geodesic */
        gml__GeodesicType *Geodesic;
};
#endif

/* PlannedLandUse_v3.0.h:6187 */
#ifndef SOAP_TYPE_plu___gml__CurveSegmentArrayPropertyType_sequence
#define SOAP_TYPE_plu___gml__CurveSegmentArrayPropertyType_sequence (-956)
/* Wrapper: */
class SOAP_CMAC __gml__CurveSegmentArrayPropertyType_sequence {
      public:
        /// Union with union _gml__union_CurveSegmentArrayPropertyType variant selector __unionAbstractCurveSegment set to one of: SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_LineStringSegment SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_ArcString SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_Arc SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_Circle SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_ArcStringByBulge SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_ArcByBulge SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_ArcByCenterPoint SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_CircleByCenterPoint SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_CubicSpline SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_BSpline SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_Bezier SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_OffsetCurve SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_Clothoid SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_GeodesicString SOAP_UNION_plu__gml__union_CurveSegmentArrayPropertyType_Geodesic
        int __unionAbstractCurveSegment;
        union _gml__union_CurveSegmentArrayPropertyType union_CurveSegmentArrayPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__CurveSegmentArrayPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__CurveSegmentArrayPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__CurveSegmentArrayPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__CurveSegmentArrayPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__CurveSegmentArrayPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__CurveSegmentArrayPropertyType_sequence() : __unionAbstractCurveSegment() { }
        virtual ~__gml__CurveSegmentArrayPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__CurveSegmentArrayPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__CurveSegmentArrayPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__CurveSegmentArrayPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:593 */
#ifndef SOAP_TYPE_plu_gml__CurveSegmentArrayPropertyType
#define SOAP_TYPE_plu_gml__CurveSegmentArrayPropertyType (-152)
/* complex XML schema type 'gml:CurveSegmentArrayPropertyType': */
class SOAP_CMAC gml__CurveSegmentArrayPropertyType : public xsd__anyType {
      public:
        std::vector<__gml__CurveSegmentArrayPropertyType_sequence> __CurveSegmentArrayPropertyType_sequence;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CurveSegmentArrayPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CurveSegmentArrayPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CurveSegmentArrayPropertyType, default initialized and not managed by a soap context
        virtual gml__CurveSegmentArrayPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CurveSegmentArrayPropertyType); }
      public:
        /// Constructor with default initializations
        gml__CurveSegmentArrayPropertyType() : __CurveSegmentArrayPropertyType_sequence() { }
        virtual ~gml__CurveSegmentArrayPropertyType() { }
        /// Friend allocator used by soap_new_gml__CurveSegmentArrayPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__CurveSegmentArrayPropertyType * SOAP_FMAC2 soap_instantiate_gml__CurveSegmentArrayPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:626 */
#ifndef SOAP_TYPE_plu_gml__KnotType
#define SOAP_TYPE_plu_gml__KnotType (-163)
/* complex XML schema type 'gml:KnotType': */
class SOAP_CMAC gml__KnotType : public xsd__anyType {
      public:
        /// Required element 'gml:value' of XML schema type 'xsd:double'
        double value;
        /// Required element 'gml:multiplicity' of XML schema type 'xsd:nonNegativeInteger'
        ULONG64 multiplicity;
        /// Required element 'gml:weight' of XML schema type 'xsd:double'
        double weight;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__KnotType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__KnotType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__KnotType, default initialized and not managed by a soap context
        virtual gml__KnotType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__KnotType); }
      public:
        /// Constructor with default initializations
        gml__KnotType() : value(), multiplicity(), weight() { }
        virtual ~gml__KnotType() { }
        /// Friend allocator used by soap_new_gml__KnotType(struct soap*, int)
        friend SOAP_FMAC1 gml__KnotType * SOAP_FMAC2 soap_instantiate_gml__KnotType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:629 */
#ifndef SOAP_TYPE_plu_gml__KnotPropertyType
#define SOAP_TYPE_plu_gml__KnotPropertyType (-164)
/* complex XML schema type 'gml:KnotPropertyType': */
class SOAP_CMAC gml__KnotPropertyType : public xsd__anyType {
      public:
        /// Required element 'gml:Knot' of XML schema type 'gml:KnotType'
        gml__KnotType *Knot;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__KnotPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__KnotPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__KnotPropertyType, default initialized and not managed by a soap context
        virtual gml__KnotPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__KnotPropertyType); }
      public:
        /// Constructor with default initializations
        gml__KnotPropertyType() : Knot() { }
        virtual ~gml__KnotPropertyType() { }
        /// Friend allocator used by soap_new_gml__KnotPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__KnotPropertyType * SOAP_FMAC2 soap_instantiate_gml__KnotPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:638 */
#ifndef SOAP_TYPE_plu_gml__AffinePlacementType
#define SOAP_TYPE_plu_gml__AffinePlacementType (-167)
/* complex XML schema type 'gml:AffinePlacementType': */
class SOAP_CMAC gml__AffinePlacementType : public xsd__anyType {
      public:
        /// Required element 'gml:location' of XML schema type 'gml:DirectPositionType'
        gml__DirectPositionType *location;
        /// Required element 'gml:refDirection' of XML schema type 'gml:VectorType'
        std::vector<gml__VectorType *> refDirection;
        /// Required element 'gml:inDimension' of XML schema type 'xsd:positiveInteger'
        ULONG64 inDimension;
        /// Required element 'gml:outDimension' of XML schema type 'xsd:positiveInteger'
        ULONG64 outDimension;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AffinePlacementType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AffinePlacementType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AffinePlacementType, default initialized and not managed by a soap context
        virtual gml__AffinePlacementType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AffinePlacementType); }
      public:
        /// Constructor with default initializations
        gml__AffinePlacementType() : location(), refDirection(), inDimension(), outDimension() { }
        virtual ~gml__AffinePlacementType() { }
        /// Friend allocator used by soap_new_gml__AffinePlacementType(struct soap*, int)
        friend SOAP_FMAC1 gml__AffinePlacementType * SOAP_FMAC2 soap_instantiate_gml__AffinePlacementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:656 */
#ifndef SOAP_TYPE_plu_gml__AbstractSurfacePatchType
#define SOAP_TYPE_plu_gml__AbstractSurfacePatchType (-173)
/* simple XML schema type 'gml:AbstractSurfacePatchType': */
class SOAP_CMAC gml__AbstractSurfacePatchType : public xsd__anyType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractSurfacePatchType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractSurfacePatchType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractSurfacePatchType, default initialized and not managed by a soap context
        virtual gml__AbstractSurfacePatchType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractSurfacePatchType); }
      public:
        /// Constructor with default initializations
        gml__AbstractSurfacePatchType() { }
        virtual ~gml__AbstractSurfacePatchType() { }
        /// Friend allocator used by soap_new_gml__AbstractSurfacePatchType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractSurfacePatchType * SOAP_FMAC2 soap_instantiate_gml__AbstractSurfacePatchType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:6477 */
#ifndef SOAP_TYPE_plu__gml__union_SurfacePatchArrayPropertyType
#define SOAP_TYPE_plu__gml__union_SurfacePatchArrayPropertyType (-979)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_SurfacePatchArrayPropertyType
{
        #define SOAP_UNION_plu__gml__union_SurfacePatchArrayPropertyType_PolygonPatch	(1)	/**< union variant selector value for member PolygonPatch */
        gml__PolygonPatchType *PolygonPatch;
        #define SOAP_UNION_plu__gml__union_SurfacePatchArrayPropertyType_Triangle	(2)	/**< union variant selector value for member Triangle */
        gml__TriangleType *Triangle;
        #define SOAP_UNION_plu__gml__union_SurfacePatchArrayPropertyType_Rectangle	(3)	/**< union variant selector value for member Rectangle */
        gml__RectangleType *Rectangle;
};
#endif

/* PlannedLandUse_v3.0.h:6466 */
#ifndef SOAP_TYPE_plu___gml__SurfacePatchArrayPropertyType_sequence
#define SOAP_TYPE_plu___gml__SurfacePatchArrayPropertyType_sequence (-978)
/* Wrapper: */
class SOAP_CMAC __gml__SurfacePatchArrayPropertyType_sequence {
      public:
        /// Union with union _gml__union_SurfacePatchArrayPropertyType variant selector __unionAbstractSurfacePatch set to one of: SOAP_UNION_plu__gml__union_SurfacePatchArrayPropertyType_PolygonPatch SOAP_UNION_plu__gml__union_SurfacePatchArrayPropertyType_Triangle SOAP_UNION_plu__gml__union_SurfacePatchArrayPropertyType_Rectangle
        int __unionAbstractSurfacePatch;
        union _gml__union_SurfacePatchArrayPropertyType union_SurfacePatchArrayPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__SurfacePatchArrayPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__SurfacePatchArrayPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__SurfacePatchArrayPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__SurfacePatchArrayPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__SurfacePatchArrayPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__SurfacePatchArrayPropertyType_sequence() : __unionAbstractSurfacePatch() { }
        virtual ~__gml__SurfacePatchArrayPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__SurfacePatchArrayPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__SurfacePatchArrayPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__SurfacePatchArrayPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:659 */
#ifndef SOAP_TYPE_plu_gml__SurfacePatchArrayPropertyType
#define SOAP_TYPE_plu_gml__SurfacePatchArrayPropertyType (-174)
/* complex XML schema type 'gml:SurfacePatchArrayPropertyType': */
class SOAP_CMAC gml__SurfacePatchArrayPropertyType : public xsd__anyType {
      public:
        std::vector<__gml__SurfacePatchArrayPropertyType_sequence> __SurfacePatchArrayPropertyType_sequence;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__SurfacePatchArrayPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__SurfacePatchArrayPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SurfacePatchArrayPropertyType, default initialized and not managed by a soap context
        virtual gml__SurfacePatchArrayPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__SurfacePatchArrayPropertyType); }
      public:
        /// Constructor with default initializations
        gml__SurfacePatchArrayPropertyType() : __SurfacePatchArrayPropertyType_sequence() { }
        virtual ~gml__SurfacePatchArrayPropertyType() { }
        /// Friend allocator used by soap_new_gml__SurfacePatchArrayPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__SurfacePatchArrayPropertyType * SOAP_FMAC2 soap_instantiate_gml__SurfacePatchArrayPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:674 */
#ifndef SOAP_TYPE_plu_gml__RingPropertyType
#define SOAP_TYPE_plu_gml__RingPropertyType (-179)
/* complex XML schema type 'gml:RingPropertyType': */
class SOAP_CMAC gml__RingPropertyType : public xsd__anyType {
      public:
        /// Required element 'gml:Ring' of XML schema type 'gml:RingType'
        gml__RingType *Ring;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__RingPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__RingPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__RingPropertyType, default initialized and not managed by a soap context
        virtual gml__RingPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__RingPropertyType); }
      public:
        /// Constructor with default initializations
        gml__RingPropertyType() : Ring() { }
        virtual ~gml__RingPropertyType() { }
        /// Friend allocator used by soap_new_gml__RingPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__RingPropertyType * SOAP_FMAC2 soap_instantiate_gml__RingPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:6548 */
#ifndef SOAP_TYPE_plu___gml__LineStringSegmentArrayPropertyType_sequence
#define SOAP_TYPE_plu___gml__LineStringSegmentArrayPropertyType_sequence (-985)
/* Wrapper: */
class SOAP_CMAC __gml__LineStringSegmentArrayPropertyType_sequence {
      public:
        /// Required element 'gml:LineStringSegment' of XML schema type 'gml:LineStringSegmentType'
        gml__LineStringSegmentType *LineStringSegment;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__LineStringSegmentArrayPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__LineStringSegmentArrayPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__LineStringSegmentArrayPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__LineStringSegmentArrayPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__LineStringSegmentArrayPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__LineStringSegmentArrayPropertyType_sequence() : LineStringSegment() { }
        virtual ~__gml__LineStringSegmentArrayPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__LineStringSegmentArrayPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__LineStringSegmentArrayPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__LineStringSegmentArrayPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:695 */
#ifndef SOAP_TYPE_plu_gml__LineStringSegmentArrayPropertyType
#define SOAP_TYPE_plu_gml__LineStringSegmentArrayPropertyType (-186)
/* complex XML schema type 'gml:LineStringSegmentArrayPropertyType': */
class SOAP_CMAC gml__LineStringSegmentArrayPropertyType : public xsd__anyType {
      public:
        std::vector<__gml__LineStringSegmentArrayPropertyType_sequence> __LineStringSegmentArrayPropertyType_sequence;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__LineStringSegmentArrayPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__LineStringSegmentArrayPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__LineStringSegmentArrayPropertyType, default initialized and not managed by a soap context
        virtual gml__LineStringSegmentArrayPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__LineStringSegmentArrayPropertyType); }
      public:
        /// Constructor with default initializations
        gml__LineStringSegmentArrayPropertyType() : __LineStringSegmentArrayPropertyType_sequence() { }
        virtual ~gml__LineStringSegmentArrayPropertyType() { }
        /// Friend allocator used by soap_new_gml__LineStringSegmentArrayPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__LineStringSegmentArrayPropertyType * SOAP_FMAC2 soap_instantiate_gml__LineStringSegmentArrayPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:6588 */
#ifndef SOAP_TYPE_plu__gml__union_SolidPropertyType
#define SOAP_TYPE_plu__gml__union_SolidPropertyType (-988)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_SolidPropertyType
{
        #define SOAP_UNION_plu__gml__union_SolidPropertyType_CompositeSolid	(1)	/**< union variant selector value for member CompositeSolid */
        gml__CompositeSolidType *CompositeSolid;
        #define SOAP_UNION_plu__gml__union_SolidPropertyType_Solid	(2)	/**< union variant selector value for member Solid */
        gml__SolidType *Solid;
};
#endif

/* PlannedLandUse_v3.0.h:6578 */
#ifndef SOAP_TYPE_plu___gml__SolidPropertyType_sequence
#define SOAP_TYPE_plu___gml__SolidPropertyType_sequence (-987)
/* Wrapper: */
class SOAP_CMAC __gml__SolidPropertyType_sequence {
      public:
        /// Union with union _gml__union_SolidPropertyType variant selector __unionAbstractSolid set to one of: SOAP_UNION_plu__gml__union_SolidPropertyType_CompositeSolid SOAP_UNION_plu__gml__union_SolidPropertyType_Solid
        int __unionAbstractSolid;
        union _gml__union_SolidPropertyType union_SolidPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__SolidPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__SolidPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__SolidPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__SolidPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__SolidPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__SolidPropertyType_sequence() : __unionAbstractSolid() { }
        virtual ~__gml__SolidPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__SolidPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__SolidPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__SolidPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:701 */
#ifndef SOAP_TYPE_plu_gml__SolidPropertyType
#define SOAP_TYPE_plu_gml__SolidPropertyType (-188)
/* complex XML schema type 'gml:SolidPropertyType': */
class SOAP_CMAC gml__SolidPropertyType : public xsd__anyType {
      public:
        __gml__SolidPropertyType_sequence *__SolidPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__SolidPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__SolidPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SolidPropertyType, default initialized and not managed by a soap context
        virtual gml__SolidPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__SolidPropertyType); }
      public:
        /// Constructor with default initializations
        gml__SolidPropertyType() : __SolidPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__SolidPropertyType() { }
        /// Friend allocator used by soap_new_gml__SolidPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__SolidPropertyType * SOAP_FMAC2 soap_instantiate_gml__SolidPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:6660 */
#ifndef SOAP_TYPE_plu__gml__union_SolidArrayPropertyType
#define SOAP_TYPE_plu__gml__union_SolidArrayPropertyType (-992)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_SolidArrayPropertyType
{
        #define SOAP_UNION_plu__gml__union_SolidArrayPropertyType_CompositeSolid	(1)	/**< union variant selector value for member CompositeSolid */
        gml__CompositeSolidType *CompositeSolid;
        #define SOAP_UNION_plu__gml__union_SolidArrayPropertyType_Solid	(2)	/**< union variant selector value for member Solid */
        gml__SolidType *Solid;
};
#endif

/* PlannedLandUse_v3.0.h:6650 */
#ifndef SOAP_TYPE_plu___gml__SolidArrayPropertyType_sequence
#define SOAP_TYPE_plu___gml__SolidArrayPropertyType_sequence (-991)
/* Wrapper: */
class SOAP_CMAC __gml__SolidArrayPropertyType_sequence {
      public:
        /// Union with union _gml__union_SolidArrayPropertyType variant selector __unionAbstractSolid set to one of: SOAP_UNION_plu__gml__union_SolidArrayPropertyType_CompositeSolid SOAP_UNION_plu__gml__union_SolidArrayPropertyType_Solid
        int __unionAbstractSolid;
        union _gml__union_SolidArrayPropertyType union_SolidArrayPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__SolidArrayPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__SolidArrayPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__SolidArrayPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__SolidArrayPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__SolidArrayPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__SolidArrayPropertyType_sequence() : __unionAbstractSolid() { }
        virtual ~__gml__SolidArrayPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__SolidArrayPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__SolidArrayPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__SolidArrayPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:704 */
#ifndef SOAP_TYPE_plu_gml__SolidArrayPropertyType
#define SOAP_TYPE_plu_gml__SolidArrayPropertyType (-189)
/* complex XML schema type 'gml:SolidArrayPropertyType': */
class SOAP_CMAC gml__SolidArrayPropertyType : public xsd__anyType {
      public:
        std::vector<__gml__SolidArrayPropertyType_sequence> __SolidArrayPropertyType_sequence;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__SolidArrayPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__SolidArrayPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SolidArrayPropertyType, default initialized and not managed by a soap context
        virtual gml__SolidArrayPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__SolidArrayPropertyType); }
      public:
        /// Constructor with default initializations
        gml__SolidArrayPropertyType() : __SolidArrayPropertyType_sequence(), owns((bool)0) { }
        virtual ~gml__SolidArrayPropertyType() { }
        /// Friend allocator used by soap_new_gml__SolidArrayPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__SolidArrayPropertyType * SOAP_FMAC2 soap_instantiate_gml__SolidArrayPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:713 */
#ifndef SOAP_TYPE_plu_gml__ShellPropertyType
#define SOAP_TYPE_plu_gml__ShellPropertyType (-192)
/* complex XML schema type 'gml:ShellPropertyType': */
class SOAP_CMAC gml__ShellPropertyType : public xsd__anyType {
      public:
        /// Required element 'gml:Shell' of XML schema type 'gml:ShellType'
        gml__ShellType *Shell;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ShellPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ShellPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ShellPropertyType, default initialized and not managed by a soap context
        virtual gml__ShellPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ShellPropertyType); }
      public:
        /// Constructor with default initializations
        gml__ShellPropertyType() : Shell() { }
        virtual ~gml__ShellPropertyType() { }
        /// Friend allocator used by soap_new_gml__ShellPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__ShellPropertyType * SOAP_FMAC2 soap_instantiate_gml__ShellPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:6734 */
#ifndef SOAP_TYPE_plu__gml__union_SurfacePropertyType
#define SOAP_TYPE_plu__gml__union_SurfacePropertyType (-996)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_SurfacePropertyType
{
        #define SOAP_UNION_plu__gml__union_SurfacePropertyType_CompositeSurface	(1)	/**< union variant selector value for member CompositeSurface */
        gml__CompositeSurfaceType *CompositeSurface;
        #define SOAP_UNION_plu__gml__union_SurfacePropertyType_Surface	(2)	/**< union variant selector value for member Surface */
        gml__SurfaceType *Surface;
        #define SOAP_UNION_plu__gml__union_SurfacePropertyType_PolyhedralSurface	(3)	/**< union variant selector value for member PolyhedralSurface */
        gml__SurfaceType *PolyhedralSurface;
        #define SOAP_UNION_plu__gml__union_SurfacePropertyType_TriangulatedSurface	(4)	/**< union variant selector value for member TriangulatedSurface */
        gml__SurfaceType *TriangulatedSurface;
        #define SOAP_UNION_plu__gml__union_SurfacePropertyType_Tin	(5)	/**< union variant selector value for member Tin */
        gml__TinType *Tin;
        #define SOAP_UNION_plu__gml__union_SurfacePropertyType_OrientableSurface	(6)	/**< union variant selector value for member OrientableSurface */
        gml__OrientableSurfaceType *OrientableSurface;
        #define SOAP_UNION_plu__gml__union_SurfacePropertyType_Shell	(7)	/**< union variant selector value for member Shell */
        gml__ShellType *Shell;
        #define SOAP_UNION_plu__gml__union_SurfacePropertyType_Polygon	(8)	/**< union variant selector value for member Polygon */
        gml__PolygonType *Polygon;
};
#endif

/* PlannedLandUse_v3.0.h:6724 */
#ifndef SOAP_TYPE_plu___gml__SurfacePropertyType_sequence
#define SOAP_TYPE_plu___gml__SurfacePropertyType_sequence (-995)
/* Wrapper: */
class SOAP_CMAC __gml__SurfacePropertyType_sequence {
      public:
        /// Union with union _gml__union_SurfacePropertyType variant selector __unionAbstractSurface set to one of: SOAP_UNION_plu__gml__union_SurfacePropertyType_CompositeSurface SOAP_UNION_plu__gml__union_SurfacePropertyType_Surface SOAP_UNION_plu__gml__union_SurfacePropertyType_PolyhedralSurface SOAP_UNION_plu__gml__union_SurfacePropertyType_TriangulatedSurface SOAP_UNION_plu__gml__union_SurfacePropertyType_Tin SOAP_UNION_plu__gml__union_SurfacePropertyType_OrientableSurface SOAP_UNION_plu__gml__union_SurfacePropertyType_Shell SOAP_UNION_plu__gml__union_SurfacePropertyType_Polygon
        int __unionAbstractSurface;
        union _gml__union_SurfacePropertyType union_SurfacePropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__SurfacePropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__SurfacePropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__SurfacePropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__SurfacePropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__SurfacePropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__SurfacePropertyType_sequence() : __unionAbstractSurface() { }
        virtual ~__gml__SurfacePropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__SurfacePropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__SurfacePropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__SurfacePropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:719 */
#ifndef SOAP_TYPE_plu_gml__SurfacePropertyType
#define SOAP_TYPE_plu_gml__SurfacePropertyType (-194)
/* Type gml__SurfacePropertyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gml:SurfacePropertyType': */
class SOAP_CMAC gml__SurfacePropertyType : public xsd__anyType {
      public:
        __gml__SurfacePropertyType_sequence *__SurfacePropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__SurfacePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__SurfacePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SurfacePropertyType, default initialized and not managed by a soap context
        virtual gml__SurfacePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__SurfacePropertyType); }
      public:
        /// Constructor with default initializations
        gml__SurfacePropertyType() : __SurfacePropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__SurfacePropertyType() { }
        /// Friend allocator used by soap_new_gml__SurfacePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__SurfacePropertyType * SOAP_FMAC2 soap_instantiate_gml__SurfacePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:6853 */
#ifndef SOAP_TYPE_plu__gml__union_SurfaceArrayPropertyType
#define SOAP_TYPE_plu__gml__union_SurfaceArrayPropertyType (-1003)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_SurfaceArrayPropertyType
{
        #define SOAP_UNION_plu__gml__union_SurfaceArrayPropertyType_CompositeSurface	(1)	/**< union variant selector value for member CompositeSurface */
        gml__CompositeSurfaceType *CompositeSurface;
        #define SOAP_UNION_plu__gml__union_SurfaceArrayPropertyType_Surface	(2)	/**< union variant selector value for member Surface */
        gml__SurfaceType *Surface;
        #define SOAP_UNION_plu__gml__union_SurfaceArrayPropertyType_PolyhedralSurface	(3)	/**< union variant selector value for member PolyhedralSurface */
        gml__SurfaceType *PolyhedralSurface;
        #define SOAP_UNION_plu__gml__union_SurfaceArrayPropertyType_TriangulatedSurface	(4)	/**< union variant selector value for member TriangulatedSurface */
        gml__SurfaceType *TriangulatedSurface;
        #define SOAP_UNION_plu__gml__union_SurfaceArrayPropertyType_Tin	(5)	/**< union variant selector value for member Tin */
        gml__TinType *Tin;
        #define SOAP_UNION_plu__gml__union_SurfaceArrayPropertyType_OrientableSurface	(6)	/**< union variant selector value for member OrientableSurface */
        gml__OrientableSurfaceType *OrientableSurface;
        #define SOAP_UNION_plu__gml__union_SurfaceArrayPropertyType_Shell	(7)	/**< union variant selector value for member Shell */
        gml__ShellType *Shell;
        #define SOAP_UNION_plu__gml__union_SurfaceArrayPropertyType_Polygon	(8)	/**< union variant selector value for member Polygon */
        gml__PolygonType *Polygon;
};
#endif

/* PlannedLandUse_v3.0.h:6843 */
#ifndef SOAP_TYPE_plu___gml__SurfaceArrayPropertyType_sequence
#define SOAP_TYPE_plu___gml__SurfaceArrayPropertyType_sequence (-1002)
/* Wrapper: */
class SOAP_CMAC __gml__SurfaceArrayPropertyType_sequence {
      public:
        /// Union with union _gml__union_SurfaceArrayPropertyType variant selector __unionAbstractSurface set to one of: SOAP_UNION_plu__gml__union_SurfaceArrayPropertyType_CompositeSurface SOAP_UNION_plu__gml__union_SurfaceArrayPropertyType_Surface SOAP_UNION_plu__gml__union_SurfaceArrayPropertyType_PolyhedralSurface SOAP_UNION_plu__gml__union_SurfaceArrayPropertyType_TriangulatedSurface SOAP_UNION_plu__gml__union_SurfaceArrayPropertyType_Tin SOAP_UNION_plu__gml__union_SurfaceArrayPropertyType_OrientableSurface SOAP_UNION_plu__gml__union_SurfaceArrayPropertyType_Shell SOAP_UNION_plu__gml__union_SurfaceArrayPropertyType_Polygon
        int __unionAbstractSurface;
        union _gml__union_SurfaceArrayPropertyType union_SurfaceArrayPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__SurfaceArrayPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__SurfaceArrayPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__SurfaceArrayPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__SurfaceArrayPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__SurfaceArrayPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__SurfaceArrayPropertyType_sequence() : __unionAbstractSurface() { }
        virtual ~__gml__SurfaceArrayPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__SurfaceArrayPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__SurfaceArrayPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__SurfaceArrayPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:722 */
#ifndef SOAP_TYPE_plu_gml__SurfaceArrayPropertyType
#define SOAP_TYPE_plu_gml__SurfaceArrayPropertyType (-195)
/* complex XML schema type 'gml:SurfaceArrayPropertyType': */
class SOAP_CMAC gml__SurfaceArrayPropertyType : public xsd__anyType {
      public:
        std::vector<__gml__SurfaceArrayPropertyType_sequence> __SurfaceArrayPropertyType_sequence;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__SurfaceArrayPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__SurfaceArrayPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SurfaceArrayPropertyType, default initialized and not managed by a soap context
        virtual gml__SurfaceArrayPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__SurfaceArrayPropertyType); }
      public:
        /// Constructor with default initializations
        gml__SurfaceArrayPropertyType() : __SurfaceArrayPropertyType_sequence(), owns((bool)0) { }
        virtual ~gml__SurfaceArrayPropertyType() { }
        /// Friend allocator used by soap_new_gml__SurfaceArrayPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__SurfaceArrayPropertyType * SOAP_FMAC2 soap_instantiate_gml__SurfaceArrayPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:6947 */
#ifndef SOAP_TYPE_plu__gml__union_AbstractRingPropertyType
#define SOAP_TYPE_plu__gml__union_AbstractRingPropertyType (-1005)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_AbstractRingPropertyType
{
        #define SOAP_UNION_plu__gml__union_AbstractRingPropertyType_Ring	(1)	/**< union variant selector value for member Ring */
        gml__RingType *Ring;
        #define SOAP_UNION_plu__gml__union_AbstractRingPropertyType_LinearRing	(2)	/**< union variant selector value for member LinearRing */
        gml__LinearRingType *LinearRing;
};
#endif

/* PlannedLandUse_v3.0.h:731 */
#ifndef SOAP_TYPE_plu_gml__AbstractRingPropertyType
#define SOAP_TYPE_plu_gml__AbstractRingPropertyType (-198)
/* complex XML schema type 'gml:AbstractRingPropertyType': */
class SOAP_CMAC gml__AbstractRingPropertyType : public xsd__anyType {
      public:
        /// Union with union _gml__union_AbstractRingPropertyType variant selector __unionAbstractRing set to one of: SOAP_UNION_plu__gml__union_AbstractRingPropertyType_Ring SOAP_UNION_plu__gml__union_AbstractRingPropertyType_LinearRing
        int __unionAbstractRing;
        union _gml__union_AbstractRingPropertyType union_AbstractRingPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractRingPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractRingPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractRingPropertyType, default initialized and not managed by a soap context
        virtual gml__AbstractRingPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractRingPropertyType); }
      public:
        /// Constructor with default initializations
        gml__AbstractRingPropertyType() : __unionAbstractRing() { }
        virtual ~gml__AbstractRingPropertyType() { }
        /// Friend allocator used by soap_new_gml__AbstractRingPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractRingPropertyType * SOAP_FMAC2 soap_instantiate_gml__AbstractRingPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:737 */
#ifndef SOAP_TYPE_plu_gml__LinearRingPropertyType
#define SOAP_TYPE_plu_gml__LinearRingPropertyType (-200)
/* complex XML schema type 'gml:LinearRingPropertyType': */
class SOAP_CMAC gml__LinearRingPropertyType : public xsd__anyType {
      public:
        /// Required element 'gml:LinearRing' of XML schema type 'gml:LinearRingType'
        gml__LinearRingType *LinearRing;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__LinearRingPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__LinearRingPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__LinearRingPropertyType, default initialized and not managed by a soap context
        virtual gml__LinearRingPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__LinearRingPropertyType); }
      public:
        /// Constructor with default initializations
        gml__LinearRingPropertyType() : LinearRing() { }
        virtual ~gml__LinearRingPropertyType() { }
        /// Friend allocator used by soap_new_gml__LinearRingPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__LinearRingPropertyType * SOAP_FMAC2 soap_instantiate_gml__LinearRingPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:7017 */
#ifndef SOAP_TYPE_plu__gml__union_GeometryPropertyType
#define SOAP_TYPE_plu__gml__union_GeometryPropertyType (-1008)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_GeometryPropertyType
{
        #define SOAP_UNION_plu__gml__union_GeometryPropertyType_GeometricComplex	(1)	/**< union variant selector value for member GeometricComplex */
        gml__GeometricComplexType *GeometricComplex;
};
#endif

/* PlannedLandUse_v3.0.h:7007 */
#ifndef SOAP_TYPE_plu___gml__GeometryPropertyType_sequence
#define SOAP_TYPE_plu___gml__GeometryPropertyType_sequence (-1007)
/* Wrapper: */
class SOAP_CMAC __gml__GeometryPropertyType_sequence {
      public:
        /// Union with union _gml__union_GeometryPropertyType variant selector __unionAbstractGeometry set to one of: SOAP_UNION_plu__gml__union_GeometryPropertyType_GeometricComplex
        int __unionAbstractGeometry;
        union _gml__union_GeometryPropertyType union_GeometryPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__GeometryPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__GeometryPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__GeometryPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__GeometryPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__GeometryPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__GeometryPropertyType_sequence() : __unionAbstractGeometry() { }
        virtual ~__gml__GeometryPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__GeometryPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__GeometryPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__GeometryPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:743 */
#ifndef SOAP_TYPE_plu_gml__GeometryPropertyType
#define SOAP_TYPE_plu_gml__GeometryPropertyType (-202)
/* complex XML schema type 'gml:GeometryPropertyType': */
class SOAP_CMAC gml__GeometryPropertyType : public xsd__anyType {
      public:
        __gml__GeometryPropertyType_sequence *__GeometryPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GeometryPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GeometryPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeometryPropertyType, default initialized and not managed by a soap context
        virtual gml__GeometryPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GeometryPropertyType); }
      public:
        /// Constructor with default initializations
        gml__GeometryPropertyType() : __GeometryPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__GeometryPropertyType() { }
        /// Friend allocator used by soap_new_gml__GeometryPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeometryPropertyType * SOAP_FMAC2 soap_instantiate_gml__GeometryPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:7081 */
#ifndef SOAP_TYPE_plu__gml__union_GeometryArrayPropertyType
#define SOAP_TYPE_plu__gml__union_GeometryArrayPropertyType (-1011)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_GeometryArrayPropertyType
{
        #define SOAP_UNION_plu__gml__union_GeometryArrayPropertyType_GeometricComplex	(1)	/**< union variant selector value for member GeometricComplex */
        gml__GeometricComplexType *GeometricComplex;
};
#endif

/* PlannedLandUse_v3.0.h:7071 */
#ifndef SOAP_TYPE_plu___gml__GeometryArrayPropertyType_sequence
#define SOAP_TYPE_plu___gml__GeometryArrayPropertyType_sequence (-1010)
/* Wrapper: */
class SOAP_CMAC __gml__GeometryArrayPropertyType_sequence {
      public:
        /// Union with union _gml__union_GeometryArrayPropertyType variant selector __unionAbstractGeometry set to one of: SOAP_UNION_plu__gml__union_GeometryArrayPropertyType_GeometricComplex
        int __unionAbstractGeometry;
        union _gml__union_GeometryArrayPropertyType union_GeometryArrayPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__GeometryArrayPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__GeometryArrayPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__GeometryArrayPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__GeometryArrayPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__GeometryArrayPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__GeometryArrayPropertyType_sequence() : __unionAbstractGeometry() { }
        virtual ~__gml__GeometryArrayPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__GeometryArrayPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__GeometryArrayPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__GeometryArrayPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:746 */
#ifndef SOAP_TYPE_plu_gml__GeometryArrayPropertyType
#define SOAP_TYPE_plu_gml__GeometryArrayPropertyType (-203)
/* complex XML schema type 'gml:GeometryArrayPropertyType': */
class SOAP_CMAC gml__GeometryArrayPropertyType : public xsd__anyType {
      public:
        std::vector<__gml__GeometryArrayPropertyType_sequence> __GeometryArrayPropertyType_sequence;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GeometryArrayPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GeometryArrayPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeometryArrayPropertyType, default initialized and not managed by a soap context
        virtual gml__GeometryArrayPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GeometryArrayPropertyType); }
      public:
        /// Constructor with default initializations
        gml__GeometryArrayPropertyType() : __GeometryArrayPropertyType_sequence(), owns((bool)0) { }
        virtual ~gml__GeometryArrayPropertyType() { }
        /// Friend allocator used by soap_new_gml__GeometryArrayPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeometryArrayPropertyType * SOAP_FMAC2 soap_instantiate_gml__GeometryArrayPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:758 */
#ifndef SOAP_TYPE_plu_gml__EnvelopeType
#define SOAP_TYPE_plu_gml__EnvelopeType (-207)
/* complex XML schema type 'gml:EnvelopeType': */
class SOAP_CMAC gml__EnvelopeType : public xsd__anyType {
      public:
        /// Optional element 'gml:lowerCorner' of XML schema type 'gml:DirectPositionType'
        gml__DirectPositionType *lowerCorner;
        /// Optional element 'gml:upperCorner' of XML schema type 'gml:DirectPositionType'
        gml__DirectPositionType *upperCorner;
        /// Sequence of 0 to 2 elements 'gml:pos' of XML schema type 'gml:DirectPositionType'
        std::vector<gml__DirectPositionType *> pos;
        /// Optional element 'gml:coordinates' of XML schema type 'gml:CoordinatesType'
        gml__CoordinatesType *coordinates;
        /// Optional attribute 'srsName' of XML schema type 'xsd:anyURI'
        char **srsName;
        /// Optional attribute 'srsDimension' of XML schema type 'xsd:positiveInteger'
        ULONG64 *srsDimension;
        /// Optional attribute 'axisLabels' of XML schema type 'gml:NCNameList'
        std::string *axisLabels;
        /// Optional attribute 'uomLabels' of XML schema type 'gml:NCNameList'
        std::string *uomLabels;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__EnvelopeType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__EnvelopeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__EnvelopeType, default initialized and not managed by a soap context
        virtual gml__EnvelopeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__EnvelopeType); }
      public:
        /// Constructor with default initializations
        gml__EnvelopeType() : lowerCorner(), upperCorner(), pos(), coordinates(), srsName(), srsDimension(), axisLabels(), uomLabels() { }
        virtual ~gml__EnvelopeType() { }
        /// Friend allocator used by soap_new_gml__EnvelopeType(struct soap*, int)
        friend SOAP_FMAC1 gml__EnvelopeType * SOAP_FMAC2 soap_instantiate_gml__EnvelopeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:7163 */
#ifndef SOAP_TYPE_plu__gml__union_GeometricPrimitivePropertyType
#define SOAP_TYPE_plu__gml__union_GeometricPrimitivePropertyType (-1018)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_GeometricPrimitivePropertyType
{
        #define SOAP_UNION_plu__gml__union_GeometricPrimitivePropertyType_Point	(1)	/**< union variant selector value for member Point */
        gml__PointType *Point;
};
#endif

/* PlannedLandUse_v3.0.h:7153 */
#ifndef SOAP_TYPE_plu___gml__GeometricPrimitivePropertyType_sequence
#define SOAP_TYPE_plu___gml__GeometricPrimitivePropertyType_sequence (-1017)
/* Wrapper: */
class SOAP_CMAC __gml__GeometricPrimitivePropertyType_sequence {
      public:
        /// Union with union _gml__union_GeometricPrimitivePropertyType variant selector __unionAbstractGeometricPrimitive set to one of: SOAP_UNION_plu__gml__union_GeometricPrimitivePropertyType_Point
        int __unionAbstractGeometricPrimitive;
        union _gml__union_GeometricPrimitivePropertyType union_GeometricPrimitivePropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__GeometricPrimitivePropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__GeometricPrimitivePropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__GeometricPrimitivePropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__GeometricPrimitivePropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__GeometricPrimitivePropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__GeometricPrimitivePropertyType_sequence() : __unionAbstractGeometricPrimitive() { }
        virtual ~__gml__GeometricPrimitivePropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__GeometricPrimitivePropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__GeometricPrimitivePropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__GeometricPrimitivePropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:764 */
#ifndef SOAP_TYPE_plu_gml__GeometricPrimitivePropertyType
#define SOAP_TYPE_plu_gml__GeometricPrimitivePropertyType (-209)
/* complex XML schema type 'gml:GeometricPrimitivePropertyType': */
class SOAP_CMAC gml__GeometricPrimitivePropertyType : public xsd__anyType {
      public:
        __gml__GeometricPrimitivePropertyType_sequence *__GeometricPrimitivePropertyType_sequence;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GeometricPrimitivePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GeometricPrimitivePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeometricPrimitivePropertyType, default initialized and not managed by a soap context
        virtual gml__GeometricPrimitivePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GeometricPrimitivePropertyType); }
      public:
        /// Constructor with default initializations
        gml__GeometricPrimitivePropertyType() : __GeometricPrimitivePropertyType_sequence(), owns((bool)0), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__GeometricPrimitivePropertyType() { }
        /// Friend allocator used by soap_new_gml__GeometricPrimitivePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeometricPrimitivePropertyType * SOAP_FMAC2 soap_instantiate_gml__GeometricPrimitivePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:7219 */
#ifndef SOAP_TYPE_plu___gml__PointPropertyType_sequence
#define SOAP_TYPE_plu___gml__PointPropertyType_sequence (-1021)
/* Wrapper: */
class SOAP_CMAC __gml__PointPropertyType_sequence {
      public:
        /// Required element 'gml:Point' of XML schema type 'gml:PointType'
        gml__PointType *Point;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__PointPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__PointPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__PointPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__PointPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__PointPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__PointPropertyType_sequence() : Point() { }
        virtual ~__gml__PointPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__PointPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__PointPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__PointPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:770 */
#ifndef SOAP_TYPE_plu_gml__PointPropertyType
#define SOAP_TYPE_plu_gml__PointPropertyType (-211)
/* complex XML schema type 'gml:PointPropertyType': */
class SOAP_CMAC gml__PointPropertyType : public xsd__anyType {
      public:
        __gml__PointPropertyType_sequence *__PointPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__PointPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__PointPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__PointPropertyType, default initialized and not managed by a soap context
        virtual gml__PointPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__PointPropertyType); }
      public:
        /// Constructor with default initializations
        gml__PointPropertyType() : __PointPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__PointPropertyType() { }
        /// Friend allocator used by soap_new_gml__PointPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__PointPropertyType * SOAP_FMAC2 soap_instantiate_gml__PointPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:7275 */
#ifndef SOAP_TYPE_plu___gml__PointArrayPropertyType_sequence
#define SOAP_TYPE_plu___gml__PointArrayPropertyType_sequence (-1023)
/* Wrapper: */
class SOAP_CMAC __gml__PointArrayPropertyType_sequence {
      public:
        /// Required element 'gml:Point' of XML schema type 'gml:PointType'
        gml__PointType *Point;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__PointArrayPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__PointArrayPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__PointArrayPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__PointArrayPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__PointArrayPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__PointArrayPropertyType_sequence() : Point() { }
        virtual ~__gml__PointArrayPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__PointArrayPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__PointArrayPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__PointArrayPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:773 */
#ifndef SOAP_TYPE_plu_gml__PointArrayPropertyType
#define SOAP_TYPE_plu_gml__PointArrayPropertyType (-212)
/* complex XML schema type 'gml:PointArrayPropertyType': */
class SOAP_CMAC gml__PointArrayPropertyType : public xsd__anyType {
      public:
        std::vector<__gml__PointArrayPropertyType_sequence> __PointArrayPropertyType_sequence;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__PointArrayPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__PointArrayPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__PointArrayPropertyType, default initialized and not managed by a soap context
        virtual gml__PointArrayPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__PointArrayPropertyType); }
      public:
        /// Constructor with default initializations
        gml__PointArrayPropertyType() : __PointArrayPropertyType_sequence(), owns((bool)0) { }
        virtual ~gml__PointArrayPropertyType() { }
        /// Friend allocator used by soap_new_gml__PointArrayPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__PointArrayPropertyType * SOAP_FMAC2 soap_instantiate_gml__PointArrayPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:7318 */
#ifndef SOAP_TYPE_plu__gml__union_CurvePropertyType
#define SOAP_TYPE_plu__gml__union_CurvePropertyType (-1026)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_CurvePropertyType
{
        #define SOAP_UNION_plu__gml__union_CurvePropertyType_CompositeCurve	(1)	/**< union variant selector value for member CompositeCurve */
        gml__CompositeCurveType *CompositeCurve;
        #define SOAP_UNION_plu__gml__union_CurvePropertyType_Curve	(2)	/**< union variant selector value for member Curve */
        gml__CurveType *Curve;
        #define SOAP_UNION_plu__gml__union_CurvePropertyType_OrientableCurve	(3)	/**< union variant selector value for member OrientableCurve */
        gml__OrientableCurveType *OrientableCurve;
        #define SOAP_UNION_plu__gml__union_CurvePropertyType_LineString	(4)	/**< union variant selector value for member LineString */
        gml__LineStringType *LineString;
};
#endif

/* PlannedLandUse_v3.0.h:7308 */
#ifndef SOAP_TYPE_plu___gml__CurvePropertyType_sequence
#define SOAP_TYPE_plu___gml__CurvePropertyType_sequence (-1025)
/* Wrapper: */
class SOAP_CMAC __gml__CurvePropertyType_sequence {
      public:
        /// Union with union _gml__union_CurvePropertyType variant selector __unionAbstractCurve set to one of: SOAP_UNION_plu__gml__union_CurvePropertyType_CompositeCurve SOAP_UNION_plu__gml__union_CurvePropertyType_Curve SOAP_UNION_plu__gml__union_CurvePropertyType_OrientableCurve SOAP_UNION_plu__gml__union_CurvePropertyType_LineString
        int __unionAbstractCurve;
        union _gml__union_CurvePropertyType union_CurvePropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__CurvePropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__CurvePropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__CurvePropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__CurvePropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__CurvePropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__CurvePropertyType_sequence() : __unionAbstractCurve() { }
        virtual ~__gml__CurvePropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__CurvePropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__CurvePropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__CurvePropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:779 */
#ifndef SOAP_TYPE_plu_gml__CurvePropertyType
#define SOAP_TYPE_plu_gml__CurvePropertyType (-214)
/* Type gml__CurvePropertyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gml:CurvePropertyType': */
class SOAP_CMAC gml__CurvePropertyType : public xsd__anyType {
      public:
        __gml__CurvePropertyType_sequence *__CurvePropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CurvePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CurvePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CurvePropertyType, default initialized and not managed by a soap context
        virtual gml__CurvePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CurvePropertyType); }
      public:
        /// Constructor with default initializations
        gml__CurvePropertyType() : __CurvePropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__CurvePropertyType() { }
        /// Friend allocator used by soap_new_gml__CurvePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__CurvePropertyType * SOAP_FMAC2 soap_instantiate_gml__CurvePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:7402 */
#ifndef SOAP_TYPE_plu__gml__union_CurveArrayPropertyType
#define SOAP_TYPE_plu__gml__union_CurveArrayPropertyType (-1032)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_CurveArrayPropertyType
{
        #define SOAP_UNION_plu__gml__union_CurveArrayPropertyType_CompositeCurve	(1)	/**< union variant selector value for member CompositeCurve */
        gml__CompositeCurveType *CompositeCurve;
        #define SOAP_UNION_plu__gml__union_CurveArrayPropertyType_Curve	(2)	/**< union variant selector value for member Curve */
        gml__CurveType *Curve;
        #define SOAP_UNION_plu__gml__union_CurveArrayPropertyType_OrientableCurve	(3)	/**< union variant selector value for member OrientableCurve */
        gml__OrientableCurveType *OrientableCurve;
        #define SOAP_UNION_plu__gml__union_CurveArrayPropertyType_LineString	(4)	/**< union variant selector value for member LineString */
        gml__LineStringType *LineString;
};
#endif

/* PlannedLandUse_v3.0.h:7392 */
#ifndef SOAP_TYPE_plu___gml__CurveArrayPropertyType_sequence
#define SOAP_TYPE_plu___gml__CurveArrayPropertyType_sequence (-1031)
/* Wrapper: */
class SOAP_CMAC __gml__CurveArrayPropertyType_sequence {
      public:
        /// Union with union _gml__union_CurveArrayPropertyType variant selector __unionAbstractCurve set to one of: SOAP_UNION_plu__gml__union_CurveArrayPropertyType_CompositeCurve SOAP_UNION_plu__gml__union_CurveArrayPropertyType_Curve SOAP_UNION_plu__gml__union_CurveArrayPropertyType_OrientableCurve SOAP_UNION_plu__gml__union_CurveArrayPropertyType_LineString
        int __unionAbstractCurve;
        union _gml__union_CurveArrayPropertyType union_CurveArrayPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__CurveArrayPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__CurveArrayPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__CurveArrayPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__CurveArrayPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__CurveArrayPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__CurveArrayPropertyType_sequence() : __unionAbstractCurve() { }
        virtual ~__gml__CurveArrayPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__CurveArrayPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__CurveArrayPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__CurveArrayPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:782 */
#ifndef SOAP_TYPE_plu_gml__CurveArrayPropertyType
#define SOAP_TYPE_plu_gml__CurveArrayPropertyType (-215)
/* complex XML schema type 'gml:CurveArrayPropertyType': */
class SOAP_CMAC gml__CurveArrayPropertyType : public xsd__anyType {
      public:
        std::vector<__gml__CurveArrayPropertyType_sequence> __CurveArrayPropertyType_sequence;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CurveArrayPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CurveArrayPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CurveArrayPropertyType, default initialized and not managed by a soap context
        virtual gml__CurveArrayPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CurveArrayPropertyType); }
      public:
        /// Constructor with default initializations
        gml__CurveArrayPropertyType() : __CurveArrayPropertyType_sequence(), owns((bool)0) { }
        virtual ~gml__CurveArrayPropertyType() { }
        /// Friend allocator used by soap_new_gml__CurveArrayPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__CurveArrayPropertyType * SOAP_FMAC2 soap_instantiate_gml__CurveArrayPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:812 */
#ifndef SOAP_TYPE_plu_gml__UnitOfMeasureType
#define SOAP_TYPE_plu_gml__UnitOfMeasureType (-225)
/* simple XML schema type 'gml:UnitOfMeasureType': */
class SOAP_CMAC gml__UnitOfMeasureType : public xsd__anyType {
      public:
        /// Required attribute 'uom' of XML schema type 'gml:UomIdentifier'
        std::string uom;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__UnitOfMeasureType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__UnitOfMeasureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__UnitOfMeasureType, default initialized and not managed by a soap context
        virtual gml__UnitOfMeasureType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__UnitOfMeasureType); }
      public:
        /// Constructor with default initializations
        gml__UnitOfMeasureType() : uom() { }
        virtual ~gml__UnitOfMeasureType() { }
        /// Friend allocator used by soap_new_gml__UnitOfMeasureType(struct soap*, int)
        friend SOAP_FMAC1 gml__UnitOfMeasureType * SOAP_FMAC2 soap_instantiate_gml__UnitOfMeasureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:833 */
#ifndef SOAP_TYPE_plu_gml__FormulaType
#define SOAP_TYPE_plu_gml__FormulaType (-232)
/* complex XML schema type 'gml:FormulaType': */
class SOAP_CMAC gml__FormulaType : public xsd__anyType {
      public:
        /// Optional element 'gml:a' of XML schema type 'xsd:double'
        double *a;
        /// Required element 'gml:b' of XML schema type 'xsd:double'
        double b;
        /// Required element 'gml:c' of XML schema type 'xsd:double'
        double c;
        /// Optional element 'gml:d' of XML schema type 'xsd:double'
        double *d;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__FormulaType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__FormulaType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__FormulaType, default initialized and not managed by a soap context
        virtual gml__FormulaType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__FormulaType); }
      public:
        /// Constructor with default initializations
        gml__FormulaType() : a(), b(), c(), d() { }
        virtual ~gml__FormulaType() { }
        /// Friend allocator used by soap_new_gml__FormulaType(struct soap*, int)
        friend SOAP_FMAC1 gml__FormulaType * SOAP_FMAC2 soap_instantiate_gml__FormulaType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:848 */
#ifndef SOAP_TYPE_plu_gml__AbstractGMLType
#define SOAP_TYPE_plu_gml__AbstractGMLType (-237)
/* complex XML schema type 'gml:AbstractGMLType': */
class SOAP_CMAC gml__AbstractGMLType : public xsd__anyType {
      public:
        /// Optional element 'gml:metaDataProperty' of XML schema type 'gml:MetaDataPropertyType'
        std::vector<gml__MetaDataPropertyType *> metaDataProperty;
        /// Optional element 'gml:description' of XML schema type 'gml:StringOrRefType'
        gml__StringOrRefType *description;
        /// Optional element 'gml:descriptionReference' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *descriptionReference;
        /// Optional element 'gml:identifier' of XML schema type 'gml:CodeWithAuthorityType'
        gml__CodeWithAuthorityType *identifier;
        /// Optional element 'gml:name' of XML schema type 'gml:CodeType'
        std::vector<gml__CodeType *> name;
        /// Optional attribute 'gml:id' of XML schema type 'xsd:ID'
        char **gml__id;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractGMLType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractGMLType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractGMLType, default initialized and not managed by a soap context
        virtual gml__AbstractGMLType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractGMLType); }
      public:
        /// Constructor with default initializations
        gml__AbstractGMLType() : metaDataProperty(), description(), descriptionReference(), identifier(), name(), gml__id() { }
        virtual ~gml__AbstractGMLType() { }
        /// Friend allocator used by soap_new_gml__AbstractGMLType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractGMLType * SOAP_FMAC2 soap_instantiate_gml__AbstractGMLType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:7537 */
#ifndef SOAP_TYPE_plu___gml__AssociationRoleType_sequence
#define SOAP_TYPE_plu___gml__AssociationRoleType_sequence (-1042)
/* Wrapper: */
class SOAP_CMAC __gml__AssociationRoleType_sequence {
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__AssociationRoleType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__AssociationRoleType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__AssociationRoleType_sequence, default initialized and not managed by a soap context
        virtual __gml__AssociationRoleType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__AssociationRoleType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__AssociationRoleType_sequence() { }
        virtual ~__gml__AssociationRoleType_sequence() { }
        /// Friend allocator used by soap_new___gml__AssociationRoleType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__AssociationRoleType_sequence * SOAP_FMAC2 soap_instantiate___gml__AssociationRoleType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:851 */
#ifndef SOAP_TYPE_plu_gml__AssociationRoleType
#define SOAP_TYPE_plu_gml__AssociationRoleType (-238)
/* complex XML schema type 'gml:AssociationRoleType': */
class SOAP_CMAC gml__AssociationRoleType : public xsd__anyType {
      public:
        __gml__AssociationRoleType_sequence *__AssociationRoleType_sequence;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AssociationRoleType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AssociationRoleType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AssociationRoleType, default initialized and not managed by a soap context
        virtual gml__AssociationRoleType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AssociationRoleType); }
      public:
        /// Constructor with default initializations
        gml__AssociationRoleType() : __AssociationRoleType_sequence(), owns((bool)0), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__AssociationRoleType() { }
        /// Friend allocator used by soap_new_gml__AssociationRoleType(struct soap*, int)
        friend SOAP_FMAC1 gml__AssociationRoleType * SOAP_FMAC2 soap_instantiate_gml__AssociationRoleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:854 */
#ifndef SOAP_TYPE_plu_gml__ReferenceType
#define SOAP_TYPE_plu_gml__ReferenceType (-239)
/* simple XML schema type 'gml:ReferenceType': */
class SOAP_CMAC gml__ReferenceType : public xsd__anyType {
      public:
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ReferenceType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ReferenceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ReferenceType, default initialized and not managed by a soap context
        virtual gml__ReferenceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ReferenceType); }
      public:
        /// Constructor with default initializations
        gml__ReferenceType() : owns((bool)0), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__ReferenceType() { }
        /// Friend allocator used by soap_new_gml__ReferenceType(struct soap*, int)
        friend SOAP_FMAC1 gml__ReferenceType * SOAP_FMAC2 soap_instantiate_gml__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:857 */
#ifndef SOAP_TYPE_plu_gml__InlinePropertyType
#define SOAP_TYPE_plu_gml__InlinePropertyType (-240)
/* simple XML schema type 'gml:InlinePropertyType': */
class SOAP_CMAC gml__InlinePropertyType : public xsd__anyType {
      public:
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__InlinePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__InlinePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__InlinePropertyType, default initialized and not managed by a soap context
        virtual gml__InlinePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__InlinePropertyType); }
      public:
        /// Constructor with default initializations
        gml__InlinePropertyType() : owns((bool)0) { }
        virtual ~gml__InlinePropertyType() { }
        /// Friend allocator used by soap_new_gml__InlinePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__InlinePropertyType * SOAP_FMAC2 soap_instantiate_gml__InlinePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:860 */
#ifndef SOAP_TYPE_plu_gml__AbstractMemberType
#define SOAP_TYPE_plu_gml__AbstractMemberType (-241)
/* simple XML schema type 'gml:AbstractMemberType': */
class SOAP_CMAC gml__AbstractMemberType : public xsd__anyType {
      public:
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractMemberType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractMemberType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractMemberType, default initialized and not managed by a soap context
        virtual gml__AbstractMemberType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractMemberType); }
      public:
        /// Constructor with default initializations
        gml__AbstractMemberType() : owns((bool)0) { }
        virtual ~gml__AbstractMemberType() { }
        /// Friend allocator used by soap_new_gml__AbstractMemberType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractMemberType * SOAP_FMAC2 soap_instantiate_gml__AbstractMemberType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:863 */
#ifndef SOAP_TYPE_plu_gml__AbstractMetadataPropertyType
#define SOAP_TYPE_plu_gml__AbstractMetadataPropertyType (-242)
/* simple XML schema type 'gml:AbstractMetadataPropertyType': */
class SOAP_CMAC gml__AbstractMetadataPropertyType : public xsd__anyType {
      public:
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractMetadataPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractMetadataPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractMetadataPropertyType, default initialized and not managed by a soap context
        virtual gml__AbstractMetadataPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractMetadataPropertyType); }
      public:
        /// Constructor with default initializations
        gml__AbstractMetadataPropertyType() : owns((bool)0) { }
        virtual ~gml__AbstractMetadataPropertyType() { }
        /// Friend allocator used by soap_new_gml__AbstractMetadataPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractMetadataPropertyType * SOAP_FMAC2 soap_instantiate_gml__AbstractMetadataPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:7715 */
#ifndef SOAP_TYPE_plu__gml__union_DomainSetType
#define SOAP_TYPE_plu__gml__union_DomainSetType (-1045)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_DomainSetType
{
        #define SOAP_UNION_plu__gml__union_DomainSetType_GeometricComplex	(1)	/**< union variant selector value for member GeometricComplex */
        gml__GeometricComplexType *GeometricComplex;
};
#endif

/* PlannedLandUse_v3.0.h:7710 */
#ifndef SOAP_TYPE_plu___gml__DomainSetType_sequence
#define SOAP_TYPE_plu___gml__DomainSetType_sequence (-1044)
/* Wrapper: */
class SOAP_CMAC __gml__DomainSetType_sequence {
      public:
        /// Union with union _gml__union_DomainSetType variant selector __union_DomainSetType set to one of: SOAP_UNION_plu__gml__union_DomainSetType_GeometricComplex
        int __union_DomainSetType;
        union _gml__union_DomainSetType union_DomainSetType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__DomainSetType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__DomainSetType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__DomainSetType_sequence, default initialized and not managed by a soap context
        virtual __gml__DomainSetType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__DomainSetType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__DomainSetType_sequence() : __union_DomainSetType() { }
        virtual ~__gml__DomainSetType_sequence() { }
        /// Friend allocator used by soap_new___gml__DomainSetType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__DomainSetType_sequence * SOAP_FMAC2 soap_instantiate___gml__DomainSetType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:899 */
#ifndef SOAP_TYPE_plu_gml__DomainSetType
#define SOAP_TYPE_plu_gml__DomainSetType (-254)
/* complex XML schema type 'gml:DomainSetType': */
class SOAP_CMAC gml__DomainSetType : public xsd__anyType {
      public:
        __gml__DomainSetType_sequence *__DomainSetType_sequence;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DomainSetType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DomainSetType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DomainSetType, default initialized and not managed by a soap context
        virtual gml__DomainSetType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DomainSetType); }
      public:
        /// Constructor with default initializations
        gml__DomainSetType() : __DomainSetType_sequence(), owns((bool)0), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__DomainSetType() { }
        /// Friend allocator used by soap_new_gml__DomainSetType(struct soap*, int)
        friend SOAP_FMAC1 gml__DomainSetType * SOAP_FMAC2 soap_instantiate_gml__DomainSetType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:7800 */
#ifndef SOAP_TYPE_plu__gml__union_RangeSetType_
#define SOAP_TYPE_plu__gml__union_RangeSetType_ (-1053)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_RangeSetType_
{
        #define SOAP_UNION_plu__gml__union_RangeSetType__BooleanList	(1)	/**< union variant selector value for member BooleanList */
        std::string *BooleanList;
        #define SOAP_UNION_plu__gml__union_RangeSetType__CategoryList	(2)	/**< union variant selector value for member CategoryList */
        gml__CodeOrNilReasonListType *CategoryList;
        #define SOAP_UNION_plu__gml__union_RangeSetType__CountList	(3)	/**< union variant selector value for member CountList */
        std::string *CountList;
        #define SOAP_UNION_plu__gml__union_RangeSetType__QuantityList	(4)	/**< union variant selector value for member QuantityList */
        gml__MeasureOrNilReasonListType *QuantityList;
};
#endif

/* PlannedLandUse_v3.0.h:7795 */
#ifndef SOAP_TYPE_plu___gml__union_RangeSetType_
#define SOAP_TYPE_plu___gml__union_RangeSetType_ (-1052)
/* Wrapper: */
class SOAP_CMAC __gml__union_RangeSetType_ {
      public:
        /// Union with union _gml__union_RangeSetType_ variant selector __unionAbstractScalarValueList set to one of: SOAP_UNION_plu__gml__union_RangeSetType__BooleanList SOAP_UNION_plu__gml__union_RangeSetType__CategoryList SOAP_UNION_plu__gml__union_RangeSetType__CountList SOAP_UNION_plu__gml__union_RangeSetType__QuantityList
        int __unionAbstractScalarValueList;
        union _gml__union_RangeSetType_ union_RangeSetType_;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_RangeSetType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_RangeSetType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_RangeSetType_, default initialized and not managed by a soap context
        virtual __gml__union_RangeSetType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_RangeSetType_); }
      public:
        /// Constructor with default initializations
        __gml__union_RangeSetType_() : __unionAbstractScalarValueList() { }
        virtual ~__gml__union_RangeSetType_() { }
        /// Friend allocator used by soap_new___gml__union_RangeSetType_(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_RangeSetType_ * SOAP_FMAC2 soap_instantiate___gml__union_RangeSetType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:7793 */
#ifndef SOAP_TYPE_plu____gml__union_RangeSetType_
#define SOAP_TYPE_plu____gml__union_RangeSetType_ (-1051)
/* Wrapper: */
struct SOAP_CMAC ___gml__union_RangeSetType_ {
      public:
        /** Sequence of elements '-union-RangeSetType' of XML schema type '-gml:union-RangeSetType' stored in dynamic array __union_RangeSetType_ of length __sizeAbstractScalarValueList */
        int __sizeAbstractScalarValueList;
        __gml__union_RangeSetType_ *__union_RangeSetType_;
      public:
        /** Return unique type id SOAP_TYPE_plu____gml__union_RangeSetType_ */
        long soap_type() const { return SOAP_TYPE_plu____gml__union_RangeSetType_; }
        /** Friend allocator */
        friend SOAP_FMAC1 ___gml__union_RangeSetType_ * SOAP_FMAC2 soap_instantiate____gml__union_RangeSetType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:7780 */
#ifndef SOAP_TYPE_plu__gml__union_RangeSetType
#define SOAP_TYPE_plu__gml__union_RangeSetType (-1047)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_RangeSetType
{
        #define SOAP_UNION_plu__gml__union_RangeSetType_ValueArray	(1)	/**< union variant selector value for member ValueArray */
        std::vector<gml__ValueArrayType *> *ValueArray;
        #define SOAP_UNION_plu__gml__union_RangeSetType___union_RangeSetType_	(2)	/**< union variant selector value for member __union_RangeSetType_ */
        struct ___gml__union_RangeSetType_ __union_RangeSetType_;
        #define SOAP_UNION_plu__gml__union_RangeSetType_DataBlock	(3)	/**< union variant selector value for member DataBlock */
        gml__DataBlockType *DataBlock;
        #define SOAP_UNION_plu__gml__union_RangeSetType_File	(4)	/**< union variant selector value for member File */
        gml__FileType *File;
};
#endif

/* PlannedLandUse_v3.0.h:902 */
#ifndef SOAP_TYPE_plu_gml__RangeSetType
#define SOAP_TYPE_plu_gml__RangeSetType (-255)
/* complex XML schema type 'gml:RangeSetType': */
class SOAP_CMAC gml__RangeSetType : public xsd__anyType {
      public:
        /// Union with union _gml__union_RangeSetType variant selector __union_RangeSetType set to one of: SOAP_UNION_plu__gml__union_RangeSetType_ValueArray SOAP_UNION_plu__gml__union_RangeSetType___union_RangeSetType_ SOAP_UNION_plu__gml__union_RangeSetType_DataBlock SOAP_UNION_plu__gml__union_RangeSetType_File
        int __union_RangeSetType;
        union _gml__union_RangeSetType union_RangeSetType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__RangeSetType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__RangeSetType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__RangeSetType, default initialized and not managed by a soap context
        virtual gml__RangeSetType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__RangeSetType); }
      public:
        /// Constructor with default initializations
        gml__RangeSetType() : __union_RangeSetType() { }
        virtual ~gml__RangeSetType() { }
        /// Friend allocator used by soap_new_gml__RangeSetType(struct soap*, int)
        friend SOAP_FMAC1 gml__RangeSetType * SOAP_FMAC2 soap_instantiate_gml__RangeSetType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:7853 */
#ifndef SOAP_TYPE_plu__gml__union_DataBlockType
#define SOAP_TYPE_plu__gml__union_DataBlockType (-1062)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_DataBlockType
{
        #define SOAP_UNION_plu__gml__union_DataBlockType_tupleList	(1)	/**< union variant selector value for member tupleList */
        gml__CoordinatesType *tupleList;
        #define SOAP_UNION_plu__gml__union_DataBlockType_doubleOrNilReasonTupleList	(2)	/**< union variant selector value for member doubleOrNilReasonTupleList */
        std::string *doubleOrNilReasonTupleList;
};
#endif

/* PlannedLandUse_v3.0.h:905 */
#ifndef SOAP_TYPE_plu_gml__DataBlockType
#define SOAP_TYPE_plu_gml__DataBlockType (-256)
/* complex XML schema type 'gml:DataBlockType': */
class SOAP_CMAC gml__DataBlockType : public xsd__anyType {
      public:
        /// Required element 'gml:rangeParameters' of XML schema type 'gml:AssociationRoleType'
        gml__AssociationRoleType *rangeParameters;
        /// Union with union _gml__union_DataBlockType variant selector __union_DataBlockType set to one of: SOAP_UNION_plu__gml__union_DataBlockType_tupleList SOAP_UNION_plu__gml__union_DataBlockType_doubleOrNilReasonTupleList
        int __union_DataBlockType;
        union _gml__union_DataBlockType union_DataBlockType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DataBlockType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DataBlockType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DataBlockType, default initialized and not managed by a soap context
        virtual gml__DataBlockType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DataBlockType); }
      public:
        /// Constructor with default initializations
        gml__DataBlockType() : rangeParameters(), __union_DataBlockType() { }
        virtual ~gml__DataBlockType() { }
        /// Friend allocator used by soap_new_gml__DataBlockType(struct soap*, int)
        friend SOAP_FMAC1 gml__DataBlockType * SOAP_FMAC2 soap_instantiate_gml__DataBlockType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:7888 */
#ifndef SOAP_TYPE_plu__gml__union_FileType
#define SOAP_TYPE_plu__gml__union_FileType (-1064)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_FileType
{
        #define SOAP_UNION_plu__gml__union_FileType_fileName	(1)	/**< union variant selector value for member fileName */
        char **fileName;
        #define SOAP_UNION_plu__gml__union_FileType_fileReference	(2)	/**< union variant selector value for member fileReference */
        char **fileReference;
};
#endif

/* PlannedLandUse_v3.0.h:908 */
#ifndef SOAP_TYPE_plu_gml__FileType
#define SOAP_TYPE_plu_gml__FileType (-257)
/* complex XML schema type 'gml:FileType': */
class SOAP_CMAC gml__FileType : public xsd__anyType {
      public:
        /// Required element 'gml:rangeParameters' of XML schema type 'gml:AssociationRoleType'
        gml__AssociationRoleType *rangeParameters;
        /// Union with union _gml__union_FileType variant selector __union_FileType set to one of: SOAP_UNION_plu__gml__union_FileType_fileName SOAP_UNION_plu__gml__union_FileType_fileReference
        int __union_FileType;
        union _gml__union_FileType union_FileType;
        /// Required element 'gml:fileStructure' of XML schema type 'gml:CodeType'
        gml__CodeType *fileStructure;
        /// Optional element 'gml:mimeType' of XML schema type 'xsd:anyURI'
        char **mimeType;
        /// Optional element 'gml:compression' of XML schema type 'xsd:anyURI'
        char **compression;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__FileType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__FileType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__FileType, default initialized and not managed by a soap context
        virtual gml__FileType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__FileType); }
      public:
        /// Constructor with default initializations
        gml__FileType() : rangeParameters(), __union_FileType(), fileStructure(), mimeType(), compression() { }
        virtual ~gml__FileType() { }
        /// Friend allocator used by soap_new_gml__FileType(struct soap*, int)
        friend SOAP_FMAC1 gml__FileType * SOAP_FMAC2 soap_instantiate_gml__FileType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:7921 */
#ifndef SOAP_TYPE_plu__gml__union_CoverageFunctionType
#define SOAP_TYPE_plu__gml__union_CoverageFunctionType (-1065)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_CoverageFunctionType
{
        #define SOAP_UNION_plu__gml__union_CoverageFunctionType_MappingRule	(1)	/**< union variant selector value for member MappingRule */
        gml__StringOrRefType *MappingRule;
        #define SOAP_UNION_plu__gml__union_CoverageFunctionType_CoverageMappingRule	(2)	/**< union variant selector value for member CoverageMappingRule */
        gml__MappingRuleType *CoverageMappingRule;
        #define SOAP_UNION_plu__gml__union_CoverageFunctionType_GridFunction	(3)	/**< union variant selector value for member GridFunction */
        gml__GridFunctionType *GridFunction;
};
#endif

/* PlannedLandUse_v3.0.h:911 */
#ifndef SOAP_TYPE_plu_gml__CoverageFunctionType
#define SOAP_TYPE_plu_gml__CoverageFunctionType (-258)
/* complex XML schema type 'gml:CoverageFunctionType': */
class SOAP_CMAC gml__CoverageFunctionType : public xsd__anyType {
      public:
        /// Union with union _gml__union_CoverageFunctionType variant selector __union_CoverageFunctionType set to one of: SOAP_UNION_plu__gml__union_CoverageFunctionType_MappingRule SOAP_UNION_plu__gml__union_CoverageFunctionType_CoverageMappingRule SOAP_UNION_plu__gml__union_CoverageFunctionType_GridFunction
        int __union_CoverageFunctionType;
        union _gml__union_CoverageFunctionType union_CoverageFunctionType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CoverageFunctionType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CoverageFunctionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CoverageFunctionType, default initialized and not managed by a soap context
        virtual gml__CoverageFunctionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CoverageFunctionType); }
      public:
        /// Constructor with default initializations
        gml__CoverageFunctionType() : __union_CoverageFunctionType() { }
        virtual ~gml__CoverageFunctionType() { }
        /// Friend allocator used by soap_new_gml__CoverageFunctionType(struct soap*, int)
        friend SOAP_FMAC1 gml__CoverageFunctionType * SOAP_FMAC2 soap_instantiate_gml__CoverageFunctionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:7958 */
#ifndef SOAP_TYPE_plu__gml__union_MappingRuleType
#define SOAP_TYPE_plu__gml__union_MappingRuleType (-1068)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_MappingRuleType
{
        #define SOAP_UNION_plu__gml__union_MappingRuleType_ruleDefinition	(1)	/**< union variant selector value for member ruleDefinition */
        std::string *ruleDefinition;
        #define SOAP_UNION_plu__gml__union_MappingRuleType_ruleReference	(2)	/**< union variant selector value for member ruleReference */
        gml__ReferenceType *ruleReference;
};
#endif

/* PlannedLandUse_v3.0.h:914 */
#ifndef SOAP_TYPE_plu_gml__MappingRuleType
#define SOAP_TYPE_plu_gml__MappingRuleType (-259)
/* complex XML schema type 'gml:MappingRuleType': */
class SOAP_CMAC gml__MappingRuleType : public xsd__anyType {
      public:
        /// Union with union _gml__union_MappingRuleType variant selector __union_MappingRuleType set to one of: SOAP_UNION_plu__gml__union_MappingRuleType_ruleDefinition SOAP_UNION_plu__gml__union_MappingRuleType_ruleReference
        int __union_MappingRuleType;
        union _gml__union_MappingRuleType union_MappingRuleType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__MappingRuleType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__MappingRuleType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__MappingRuleType, default initialized and not managed by a soap context
        virtual gml__MappingRuleType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__MappingRuleType); }
      public:
        /// Constructor with default initializations
        gml__MappingRuleType() : __union_MappingRuleType() { }
        virtual ~gml__MappingRuleType() { }
        /// Friend allocator used by soap_new_gml__MappingRuleType(struct soap*, int)
        friend SOAP_FMAC1 gml__MappingRuleType * SOAP_FMAC2 soap_instantiate_gml__MappingRuleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:917 */
#ifndef SOAP_TYPE_plu_gml__GridFunctionType
#define SOAP_TYPE_plu_gml__GridFunctionType (-260)
/* complex XML schema type 'gml:GridFunctionType': */
class SOAP_CMAC gml__GridFunctionType : public xsd__anyType {
      public:
        /// Optional element 'gml:sequenceRule' of XML schema type 'gml:SequenceRuleType'
        gml__SequenceRuleType *sequenceRule;
        /// Optional element 'gml:startPoint' of XML schema type 'gml:integerList'
        std::string *startPoint;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GridFunctionType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GridFunctionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GridFunctionType, default initialized and not managed by a soap context
        virtual gml__GridFunctionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GridFunctionType); }
      public:
        /// Constructor with default initializations
        gml__GridFunctionType() : sequenceRule(), startPoint() { }
        virtual ~gml__GridFunctionType() { }
        /// Friend allocator used by soap_new_gml__GridFunctionType(struct soap*, int)
        friend SOAP_FMAC1 gml__GridFunctionType * SOAP_FMAC2 soap_instantiate_gml__GridFunctionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:8012 */
#ifndef SOAP_TYPE_plu__gml__union_FeaturePropertyType
#define SOAP_TYPE_plu__gml__union_FeaturePropertyType (-1072)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_FeaturePropertyType
{
        #define SOAP_UNION_plu__gml__union_FeaturePropertyType_DynamicFeature	(1)	/**< union variant selector value for member DynamicFeature */
        gml__DynamicFeatureType *DynamicFeature;
        #define SOAP_UNION_plu__gml__union_FeaturePropertyType_DynamicFeatureCollection	(2)	/**< union variant selector value for member DynamicFeatureCollection */
        gml__DynamicFeatureCollectionType *DynamicFeatureCollection;
        #define SOAP_UNION_plu__gml__union_FeaturePropertyType_Observation	(3)	/**< union variant selector value for member Observation */
        gml__ObservationType *Observation;
        #define SOAP_UNION_plu__gml__union_FeaturePropertyType_DirectedObservation	(4)	/**< union variant selector value for member DirectedObservation */
        gml__DirectedObservationType *DirectedObservation;
        #define SOAP_UNION_plu__gml__union_FeaturePropertyType_DirectedObservationAtDistance	(5)	/**< union variant selector value for member DirectedObservationAtDistance */
        gml__DirectedObservationAtDistanceType *DirectedObservationAtDistance;
        #define SOAP_UNION_plu__gml__union_FeaturePropertyType_FeatureCollection	(6)	/**< union variant selector value for member FeatureCollection */
        gml__FeatureCollectionType *FeatureCollection;
        #define SOAP_UNION_plu__gml__union_FeaturePropertyType_base__SpatialDataSet	(7)	/**< union variant selector value for member base__SpatialDataSet */
        base__SpatialDataSetType *base__SpatialDataSet;
        #define SOAP_UNION_plu__gml__union_FeaturePropertyType_plu__ZoningElement	(8)	/**< union variant selector value for member plu__ZoningElement */
        plu__ZoningElementType *plu__ZoningElement;
        #define SOAP_UNION_plu__gml__union_FeaturePropertyType_plu__OfficialDocumentation	(9)	/**< union variant selector value for member plu__OfficialDocumentation */
        plu__OfficialDocumentationType *plu__OfficialDocumentation;
        #define SOAP_UNION_plu__gml__union_FeaturePropertyType_plu__SupplementaryRegulation	(10)	/**< union variant selector value for member plu__SupplementaryRegulation */
        plu__SupplementaryRegulationType *plu__SupplementaryRegulation;
        #define SOAP_UNION_plu__gml__union_FeaturePropertyType_plu__SpatialPlan	(11)	/**< union variant selector value for member plu__SpatialPlan */
        plu__SpatialPlanType *plu__SpatialPlan;
};
#endif

/* PlannedLandUse_v3.0.h:8002 */
#ifndef SOAP_TYPE_plu___gml__FeaturePropertyType_sequence
#define SOAP_TYPE_plu___gml__FeaturePropertyType_sequence (-1071)
/* Wrapper: */
class SOAP_CMAC __gml__FeaturePropertyType_sequence {
      public:
        /// Union with union _gml__union_FeaturePropertyType variant selector __unionAbstractFeature set to one of: SOAP_UNION_plu__gml__union_FeaturePropertyType_DynamicFeature SOAP_UNION_plu__gml__union_FeaturePropertyType_DynamicFeatureCollection SOAP_UNION_plu__gml__union_FeaturePropertyType_Observation SOAP_UNION_plu__gml__union_FeaturePropertyType_DirectedObservation SOAP_UNION_plu__gml__union_FeaturePropertyType_DirectedObservationAtDistance SOAP_UNION_plu__gml__union_FeaturePropertyType_FeatureCollection SOAP_UNION_plu__gml__union_FeaturePropertyType_base__SpatialDataSet SOAP_UNION_plu__gml__union_FeaturePropertyType_plu__ZoningElement SOAP_UNION_plu__gml__union_FeaturePropertyType_plu__OfficialDocumentation SOAP_UNION_plu__gml__union_FeaturePropertyType_plu__SupplementaryRegulation SOAP_UNION_plu__gml__union_FeaturePropertyType_plu__SpatialPlan
        int __unionAbstractFeature;
        union _gml__union_FeaturePropertyType union_FeaturePropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__FeaturePropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__FeaturePropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__FeaturePropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__FeaturePropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__FeaturePropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__FeaturePropertyType_sequence() : __unionAbstractFeature() { }
        virtual ~__gml__FeaturePropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__FeaturePropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__FeaturePropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__FeaturePropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:926 */
#ifndef SOAP_TYPE_plu_gml__FeaturePropertyType
#define SOAP_TYPE_plu_gml__FeaturePropertyType (-263)
/* Type gml__FeaturePropertyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gml:FeaturePropertyType': */
class SOAP_CMAC gml__FeaturePropertyType : public xsd__anyType {
      public:
        __gml__FeaturePropertyType_sequence *__FeaturePropertyType_sequence;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__FeaturePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__FeaturePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__FeaturePropertyType, default initialized and not managed by a soap context
        virtual gml__FeaturePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__FeaturePropertyType); }
      public:
        /// Constructor with default initializations
        gml__FeaturePropertyType() : __FeaturePropertyType_sequence(), owns((bool)0), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__FeaturePropertyType() { }
        /// Friend allocator used by soap_new_gml__FeaturePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__FeaturePropertyType * SOAP_FMAC2 soap_instantiate_gml__FeaturePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:8211 */
#ifndef SOAP_TYPE_plu__gml__union_BoundingShapeType
#define SOAP_TYPE_plu__gml__union_BoundingShapeType (-1080)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_BoundingShapeType
{
        #define SOAP_UNION_plu__gml__union_BoundingShapeType_Envelope	(1)	/**< union variant selector value for member Envelope */
        gml__EnvelopeType *Envelope;
        #define SOAP_UNION_plu__gml__union_BoundingShapeType_EnvelopeWithTimePeriod	(2)	/**< union variant selector value for member EnvelopeWithTimePeriod */
        gml__EnvelopeWithTimePeriodType *EnvelopeWithTimePeriod;
        #define SOAP_UNION_plu__gml__union_BoundingShapeType_Null	(3)	/**< union variant selector value for member Null */
        std::string *Null;
};
#endif

/* PlannedLandUse_v3.0.h:929 */
#ifndef SOAP_TYPE_plu_gml__BoundingShapeType
#define SOAP_TYPE_plu_gml__BoundingShapeType (-264)
/* complex XML schema type 'gml:BoundingShapeType': */
class SOAP_CMAC gml__BoundingShapeType : public xsd__anyType {
      public:
        /// Union with union _gml__union_BoundingShapeType variant selector __union_BoundingShapeType set to one of: SOAP_UNION_plu__gml__union_BoundingShapeType_Envelope SOAP_UNION_plu__gml__union_BoundingShapeType_EnvelopeWithTimePeriod SOAP_UNION_plu__gml__union_BoundingShapeType_Null
        int __union_BoundingShapeType;
        union _gml__union_BoundingShapeType union_BoundingShapeType;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__BoundingShapeType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__BoundingShapeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__BoundingShapeType, default initialized and not managed by a soap context
        virtual gml__BoundingShapeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__BoundingShapeType); }
      public:
        /// Constructor with default initializations
        gml__BoundingShapeType() : __union_BoundingShapeType(), nilReason() { }
        virtual ~gml__BoundingShapeType() { }
        /// Friend allocator used by soap_new_gml__BoundingShapeType(struct soap*, int)
        friend SOAP_FMAC1 gml__BoundingShapeType * SOAP_FMAC2 soap_instantiate_gml__BoundingShapeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:935 */
#ifndef SOAP_TYPE_plu_gml__AbstractFeatureMemberType
#define SOAP_TYPE_plu_gml__AbstractFeatureMemberType (-266)
/* simple XML schema type 'gml:AbstractFeatureMemberType': */
class SOAP_CMAC gml__AbstractFeatureMemberType : public xsd__anyType {
      public:
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractFeatureMemberType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractFeatureMemberType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractFeatureMemberType, default initialized and not managed by a soap context
        virtual gml__AbstractFeatureMemberType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractFeatureMemberType); }
      public:
        /// Constructor with default initializations
        gml__AbstractFeatureMemberType() : owns((bool)0) { }
        virtual ~gml__AbstractFeatureMemberType() { }
        /// Friend allocator used by soap_new_gml__AbstractFeatureMemberType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractFeatureMemberType * SOAP_FMAC2 soap_instantiate_gml__AbstractFeatureMemberType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:8289 */
#ifndef SOAP_TYPE_plu__gml__union_TimePrimitivePropertyType
#define SOAP_TYPE_plu__gml__union_TimePrimitivePropertyType (-1084)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_TimePrimitivePropertyType
{
};
#endif

/* PlannedLandUse_v3.0.h:8279 */
#ifndef SOAP_TYPE_plu___gml__TimePrimitivePropertyType_sequence
#define SOAP_TYPE_plu___gml__TimePrimitivePropertyType_sequence (-1083)
/* Wrapper: */
class SOAP_CMAC __gml__TimePrimitivePropertyType_sequence {
      public:
        /// Union with union _gml__union_TimePrimitivePropertyType variant selector __unionAbstractTimePrimitive set to one of:
        int __unionAbstractTimePrimitive;
        union _gml__union_TimePrimitivePropertyType union_TimePrimitivePropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__TimePrimitivePropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__TimePrimitivePropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__TimePrimitivePropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__TimePrimitivePropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__TimePrimitivePropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__TimePrimitivePropertyType_sequence() : __unionAbstractTimePrimitive() { }
        virtual ~__gml__TimePrimitivePropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__TimePrimitivePropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__TimePrimitivePropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__TimePrimitivePropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:944 */
#ifndef SOAP_TYPE_plu_gml__TimePrimitivePropertyType
#define SOAP_TYPE_plu_gml__TimePrimitivePropertyType (-269)
/* complex XML schema type 'gml:TimePrimitivePropertyType': */
class SOAP_CMAC gml__TimePrimitivePropertyType : public xsd__anyType {
      public:
        __gml__TimePrimitivePropertyType_sequence *__TimePrimitivePropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimePrimitivePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimePrimitivePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimePrimitivePropertyType, default initialized and not managed by a soap context
        virtual gml__TimePrimitivePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimePrimitivePropertyType); }
      public:
        /// Constructor with default initializations
        gml__TimePrimitivePropertyType() : __TimePrimitivePropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__TimePrimitivePropertyType() { }
        /// Friend allocator used by soap_new_gml__TimePrimitivePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimePrimitivePropertyType * SOAP_FMAC2 soap_instantiate_gml__TimePrimitivePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:8340 */
#ifndef SOAP_TYPE_plu___gml__TimeInstantPropertyType_sequence
#define SOAP_TYPE_plu___gml__TimeInstantPropertyType_sequence (-1086)
/* Wrapper: */
class SOAP_CMAC __gml__TimeInstantPropertyType_sequence {
      public:
        /// Required element 'gml:TimeInstant' of XML schema type 'gml:TimeInstantType'
        gml__TimeInstantType *TimeInstant;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__TimeInstantPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__TimeInstantPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__TimeInstantPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__TimeInstantPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__TimeInstantPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__TimeInstantPropertyType_sequence() : TimeInstant() { }
        virtual ~__gml__TimeInstantPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__TimeInstantPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__TimeInstantPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__TimeInstantPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:959 */
#ifndef SOAP_TYPE_plu_gml__TimeInstantPropertyType
#define SOAP_TYPE_plu_gml__TimeInstantPropertyType (-274)
/* complex XML schema type 'gml:TimeInstantPropertyType': */
class SOAP_CMAC gml__TimeInstantPropertyType : public xsd__anyType {
      public:
        __gml__TimeInstantPropertyType_sequence *__TimeInstantPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeInstantPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeInstantPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeInstantPropertyType, default initialized and not managed by a soap context
        virtual gml__TimeInstantPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeInstantPropertyType); }
      public:
        /// Constructor with default initializations
        gml__TimeInstantPropertyType() : __TimeInstantPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__TimeInstantPropertyType() { }
        /// Friend allocator used by soap_new_gml__TimeInstantPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeInstantPropertyType * SOAP_FMAC2 soap_instantiate_gml__TimeInstantPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:8395 */
#ifndef SOAP_TYPE_plu___gml__TimePeriodPropertyType_sequence
#define SOAP_TYPE_plu___gml__TimePeriodPropertyType_sequence (-1089)
/* Wrapper: */
class SOAP_CMAC __gml__TimePeriodPropertyType_sequence {
      public:
        /// Required element 'gml:TimePeriod' of XML schema type 'gml:TimePeriodType'
        gml__TimePeriodType *TimePeriod;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__TimePeriodPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__TimePeriodPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__TimePeriodPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__TimePeriodPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__TimePeriodPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__TimePeriodPropertyType_sequence() : TimePeriod() { }
        virtual ~__gml__TimePeriodPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__TimePeriodPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__TimePeriodPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__TimePeriodPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:965 */
#ifndef SOAP_TYPE_plu_gml__TimePeriodPropertyType
#define SOAP_TYPE_plu_gml__TimePeriodPropertyType (-276)
/* complex XML schema type 'gml:TimePeriodPropertyType': */
class SOAP_CMAC gml__TimePeriodPropertyType : public xsd__anyType {
      public:
        __gml__TimePeriodPropertyType_sequence *__TimePeriodPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimePeriodPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimePeriodPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimePeriodPropertyType, default initialized and not managed by a soap context
        virtual gml__TimePeriodPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimePeriodPropertyType); }
      public:
        /// Constructor with default initializations
        gml__TimePeriodPropertyType() : __TimePeriodPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__TimePeriodPropertyType() { }
        /// Friend allocator used by soap_new_gml__TimePeriodPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimePeriodPropertyType * SOAP_FMAC2 soap_instantiate_gml__TimePeriodPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:8458 */
#ifndef SOAP_TYPE_plu__gml__union_ValuePropertyType
#define SOAP_TYPE_plu__gml__union_ValuePropertyType (-1093)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ValuePropertyType
{
        #define SOAP_UNION_plu__gml__union_ValuePropertyType_CompositeValue	(1)	/**< union variant selector value for member CompositeValue */
        gml__CompositeValueType *CompositeValue;
        #define SOAP_UNION_plu__gml__union_ValuePropertyType_ValueArray	(2)	/**< union variant selector value for member ValueArray */
        gml__ValueArrayType *ValueArray;
        #define SOAP_UNION_plu__gml__union_ValuePropertyType_CategoryExtent	(3)	/**< union variant selector value for member CategoryExtent */
        gml__CategoryExtentType *CategoryExtent;
        #define SOAP_UNION_plu__gml__union_ValuePropertyType_CountExtent	(4)	/**< union variant selector value for member CountExtent */
        std::string *CountExtent;
        #define SOAP_UNION_plu__gml__union_ValuePropertyType_QuantityExtent	(5)	/**< union variant selector value for member QuantityExtent */
        gml__QuantityExtentType *QuantityExtent;
        #define SOAP_UNION_plu__gml__union_ValuePropertyType_GeometricComplex	(6)	/**< union variant selector value for member GeometricComplex */
        gml__GeometricComplexType *GeometricComplex;
        #define SOAP_UNION_plu__gml__union_ValuePropertyType_Null	(7)	/**< union variant selector value for member Null */
        std::string *Null;
};
#endif

/* PlannedLandUse_v3.0.h:8449 */
#ifndef SOAP_TYPE_plu___gml__ValuePropertyType_sequence
#define SOAP_TYPE_plu___gml__ValuePropertyType_sequence (-1092)
/* Wrapper: */
class SOAP_CMAC __gml__ValuePropertyType_sequence {
      public:
        /// Union with union _gml__union_ValuePropertyType variant selector __union_ValuePropertyType set to one of: SOAP_UNION_plu__gml__union_ValuePropertyType_CompositeValue SOAP_UNION_plu__gml__union_ValuePropertyType_ValueArray SOAP_UNION_plu__gml__union_ValuePropertyType_CategoryExtent SOAP_UNION_plu__gml__union_ValuePropertyType_CountExtent SOAP_UNION_plu__gml__union_ValuePropertyType_QuantityExtent SOAP_UNION_plu__gml__union_ValuePropertyType_GeometricComplex SOAP_UNION_plu__gml__union_ValuePropertyType_Null
        int __union_ValuePropertyType;
        union _gml__union_ValuePropertyType union_ValuePropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__ValuePropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__ValuePropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__ValuePropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__ValuePropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__ValuePropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__ValuePropertyType_sequence() : __union_ValuePropertyType() { }
        virtual ~__gml__ValuePropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__ValuePropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__ValuePropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__ValuePropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:974 */
#ifndef SOAP_TYPE_plu_gml__ValuePropertyType
#define SOAP_TYPE_plu_gml__ValuePropertyType (-279)
/* complex XML schema type 'gml:ValuePropertyType': */
class SOAP_CMAC gml__ValuePropertyType : public xsd__anyType {
      public:
        __gml__ValuePropertyType_sequence *__ValuePropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ValuePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ValuePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ValuePropertyType, default initialized and not managed by a soap context
        virtual gml__ValuePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ValuePropertyType); }
      public:
        /// Constructor with default initializations
        gml__ValuePropertyType() : __ValuePropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__ValuePropertyType() { }
        /// Friend allocator used by soap_new_gml__ValuePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__ValuePropertyType * SOAP_FMAC2 soap_instantiate_gml__ValuePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:8562 */
#ifndef SOAP_TYPE_plu__gml__union_ValueArrayPropertyType
#define SOAP_TYPE_plu__gml__union_ValueArrayPropertyType (-1100)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ValueArrayPropertyType
{
        #define SOAP_UNION_plu__gml__union_ValueArrayPropertyType_CompositeValue	(1)	/**< union variant selector value for member CompositeValue */
        gml__CompositeValueType *CompositeValue;
        #define SOAP_UNION_plu__gml__union_ValueArrayPropertyType_ValueArray	(2)	/**< union variant selector value for member ValueArray */
        gml__ValueArrayType *ValueArray;
        #define SOAP_UNION_plu__gml__union_ValueArrayPropertyType_CategoryExtent	(3)	/**< union variant selector value for member CategoryExtent */
        gml__CategoryExtentType *CategoryExtent;
        #define SOAP_UNION_plu__gml__union_ValueArrayPropertyType_CountExtent	(4)	/**< union variant selector value for member CountExtent */
        std::string *CountExtent;
        #define SOAP_UNION_plu__gml__union_ValueArrayPropertyType_QuantityExtent	(5)	/**< union variant selector value for member QuantityExtent */
        gml__QuantityExtentType *QuantityExtent;
        #define SOAP_UNION_plu__gml__union_ValueArrayPropertyType_GeometricComplex	(6)	/**< union variant selector value for member GeometricComplex */
        gml__GeometricComplexType *GeometricComplex;
        #define SOAP_UNION_plu__gml__union_ValueArrayPropertyType_Null	(7)	/**< union variant selector value for member Null */
        std::string *Null;
};
#endif

/* PlannedLandUse_v3.0.h:8553 */
#ifndef SOAP_TYPE_plu___gml__ValueArrayPropertyType_sequence
#define SOAP_TYPE_plu___gml__ValueArrayPropertyType_sequence (-1099)
/* Type __gml__ValueArrayPropertyType_sequence is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* Wrapper: */
class SOAP_CMAC __gml__ValueArrayPropertyType_sequence {
      public:
        /// Union with union _gml__union_ValueArrayPropertyType variant selector __union_ValueArrayPropertyType set to one of: SOAP_UNION_plu__gml__union_ValueArrayPropertyType_CompositeValue SOAP_UNION_plu__gml__union_ValueArrayPropertyType_ValueArray SOAP_UNION_plu__gml__union_ValueArrayPropertyType_CategoryExtent SOAP_UNION_plu__gml__union_ValueArrayPropertyType_CountExtent SOAP_UNION_plu__gml__union_ValueArrayPropertyType_QuantityExtent SOAP_UNION_plu__gml__union_ValueArrayPropertyType_GeometricComplex SOAP_UNION_plu__gml__union_ValueArrayPropertyType_Null
        int __union_ValueArrayPropertyType;
        union _gml__union_ValueArrayPropertyType union_ValueArrayPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__ValueArrayPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__ValueArrayPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__ValueArrayPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__ValueArrayPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__ValueArrayPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__ValueArrayPropertyType_sequence() : __union_ValueArrayPropertyType() { }
        virtual ~__gml__ValueArrayPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__ValueArrayPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__ValueArrayPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__ValueArrayPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:977 */
#ifndef SOAP_TYPE_plu_gml__ValueArrayPropertyType
#define SOAP_TYPE_plu_gml__ValueArrayPropertyType (-280)
/* complex XML schema type 'gml:ValueArrayPropertyType': */
class SOAP_CMAC gml__ValueArrayPropertyType : public xsd__anyType {
      public:
        std::vector<__gml__ValueArrayPropertyType_sequence> __ValueArrayPropertyType_sequence;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ValueArrayPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ValueArrayPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ValueArrayPropertyType, default initialized and not managed by a soap context
        virtual gml__ValueArrayPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ValueArrayPropertyType); }
      public:
        /// Constructor with default initializations
        gml__ValueArrayPropertyType() : __ValueArrayPropertyType_sequence(), owns((bool)0) { }
        virtual ~gml__ValueArrayPropertyType() { }
        /// Friend allocator used by soap_new_gml__ValueArrayPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__ValueArrayPropertyType * SOAP_FMAC2 soap_instantiate_gml__ValueArrayPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:8634 */
#ifndef SOAP_TYPE_plu___gml__BooleanPropertyType_sequence
#define SOAP_TYPE_plu___gml__BooleanPropertyType_sequence (-1102)
/* Wrapper: */
class SOAP_CMAC __gml__BooleanPropertyType_sequence {
      public:
        /// Required element 'gml:Boolean' of XML schema type 'gml:Boolean'
        _gml__Boolean *Boolean;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__BooleanPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__BooleanPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__BooleanPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__BooleanPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__BooleanPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__BooleanPropertyType_sequence() : Boolean() { }
        virtual ~__gml__BooleanPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__BooleanPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__BooleanPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__BooleanPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:992 */
#ifndef SOAP_TYPE_plu_gml__BooleanPropertyType
#define SOAP_TYPE_plu_gml__BooleanPropertyType (-285)
/* complex XML schema type 'gml:BooleanPropertyType': */
class SOAP_CMAC gml__BooleanPropertyType : public xsd__anyType {
      public:
        __gml__BooleanPropertyType_sequence *__BooleanPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__BooleanPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__BooleanPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__BooleanPropertyType, default initialized and not managed by a soap context
        virtual gml__BooleanPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__BooleanPropertyType); }
      public:
        /// Constructor with default initializations
        gml__BooleanPropertyType() : __BooleanPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__BooleanPropertyType() { }
        /// Friend allocator used by soap_new_gml__BooleanPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__BooleanPropertyType * SOAP_FMAC2 soap_instantiate_gml__BooleanPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:8679 */
#ifndef SOAP_TYPE_plu___gml__CategoryPropertyType_sequence
#define SOAP_TYPE_plu___gml__CategoryPropertyType_sequence (-1105)
/* Wrapper: */
class SOAP_CMAC __gml__CategoryPropertyType_sequence {
      public:
        /// Required element 'gml:Category' of XML schema type 'gml:Category'
        _gml__Category *Category;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__CategoryPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__CategoryPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__CategoryPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__CategoryPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__CategoryPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__CategoryPropertyType_sequence() : Category() { }
        virtual ~__gml__CategoryPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__CategoryPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__CategoryPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__CategoryPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:995 */
#ifndef SOAP_TYPE_plu_gml__CategoryPropertyType
#define SOAP_TYPE_plu_gml__CategoryPropertyType (-286)
/* complex XML schema type 'gml:CategoryPropertyType': */
class SOAP_CMAC gml__CategoryPropertyType : public xsd__anyType {
      public:
        __gml__CategoryPropertyType_sequence *__CategoryPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CategoryPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CategoryPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CategoryPropertyType, default initialized and not managed by a soap context
        virtual gml__CategoryPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CategoryPropertyType); }
      public:
        /// Constructor with default initializations
        gml__CategoryPropertyType() : __CategoryPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__CategoryPropertyType() { }
        /// Friend allocator used by soap_new_gml__CategoryPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__CategoryPropertyType * SOAP_FMAC2 soap_instantiate_gml__CategoryPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:8727 */
#ifndef SOAP_TYPE_plu___gml__QuantityPropertyType_sequence
#define SOAP_TYPE_plu___gml__QuantityPropertyType_sequence (-1108)
/* Wrapper: */
class SOAP_CMAC __gml__QuantityPropertyType_sequence {
      public:
        /// Required element 'gml:Quantity' of XML schema type 'gml:Quantity'
        _gml__Quantity *Quantity;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__QuantityPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__QuantityPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__QuantityPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__QuantityPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__QuantityPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__QuantityPropertyType_sequence() : Quantity() { }
        virtual ~__gml__QuantityPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__QuantityPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__QuantityPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__QuantityPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:998 */
#ifndef SOAP_TYPE_plu_gml__QuantityPropertyType
#define SOAP_TYPE_plu_gml__QuantityPropertyType (-287)
/* complex XML schema type 'gml:QuantityPropertyType': */
class SOAP_CMAC gml__QuantityPropertyType : public xsd__anyType {
      public:
        __gml__QuantityPropertyType_sequence *__QuantityPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__QuantityPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__QuantityPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__QuantityPropertyType, default initialized and not managed by a soap context
        virtual gml__QuantityPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__QuantityPropertyType); }
      public:
        /// Constructor with default initializations
        gml__QuantityPropertyType() : __QuantityPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__QuantityPropertyType() { }
        /// Friend allocator used by soap_new_gml__QuantityPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__QuantityPropertyType * SOAP_FMAC2 soap_instantiate_gml__QuantityPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:8775 */
#ifndef SOAP_TYPE_plu___gml__CountPropertyType_sequence
#define SOAP_TYPE_plu___gml__CountPropertyType_sequence (-1111)
/* Wrapper: */
class SOAP_CMAC __gml__CountPropertyType_sequence {
      public:
        /// Required element 'gml:Count' of XML schema type 'gml:Count'
        _gml__Count *Count;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__CountPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__CountPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__CountPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__CountPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__CountPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__CountPropertyType_sequence() : Count() { }
        virtual ~__gml__CountPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__CountPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__CountPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__CountPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1001 */
#ifndef SOAP_TYPE_plu_gml__CountPropertyType
#define SOAP_TYPE_plu_gml__CountPropertyType (-288)
/* complex XML schema type 'gml:CountPropertyType': */
class SOAP_CMAC gml__CountPropertyType : public xsd__anyType {
      public:
        __gml__CountPropertyType_sequence *__CountPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CountPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CountPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CountPropertyType, default initialized and not managed by a soap context
        virtual gml__CountPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CountPropertyType); }
      public:
        /// Constructor with default initializations
        gml__CountPropertyType() : __CountPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__CountPropertyType() { }
        /// Friend allocator used by soap_new_gml__CountPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__CountPropertyType * SOAP_FMAC2 soap_instantiate_gml__CountPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1007 */
#ifndef SOAP_TYPE_plu_gml__GridLimitsType
#define SOAP_TYPE_plu_gml__GridLimitsType (-290)
/* complex XML schema type 'gml:GridLimitsType': */
class SOAP_CMAC gml__GridLimitsType : public xsd__anyType {
      public:
        /// Required element 'gml:GridEnvelope' of XML schema type 'gml:GridEnvelopeType'
        gml__GridEnvelopeType *GridEnvelope;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GridLimitsType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GridLimitsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GridLimitsType, default initialized and not managed by a soap context
        virtual gml__GridLimitsType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GridLimitsType); }
      public:
        /// Constructor with default initializations
        gml__GridLimitsType() : GridEnvelope() { }
        virtual ~gml__GridLimitsType() { }
        /// Friend allocator used by soap_new_gml__GridLimitsType(struct soap*, int)
        friend SOAP_FMAC1 gml__GridLimitsType * SOAP_FMAC2 soap_instantiate_gml__GridLimitsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1010 */
#ifndef SOAP_TYPE_plu_gml__GridEnvelopeType
#define SOAP_TYPE_plu_gml__GridEnvelopeType (-291)
/* complex XML schema type 'gml:GridEnvelopeType': */
class SOAP_CMAC gml__GridEnvelopeType : public xsd__anyType {
      public:
        /// Required element 'gml:low' of XML schema type 'gml:integerList'
        std::string low;
        /// Required element 'gml:high' of XML schema type 'gml:integerList'
        std::string high;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GridEnvelopeType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GridEnvelopeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GridEnvelopeType, default initialized and not managed by a soap context
        virtual gml__GridEnvelopeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GridEnvelopeType); }
      public:
        /// Constructor with default initializations
        gml__GridEnvelopeType() : low(), high() { }
        virtual ~gml__GridEnvelopeType() { }
        /// Friend allocator used by soap_new_gml__GridEnvelopeType(struct soap*, int)
        friend SOAP_FMAC1 gml__GridEnvelopeType * SOAP_FMAC2 soap_instantiate_gml__GridEnvelopeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:8871 */
#ifndef SOAP_TYPE_plu__gml__union_SingleCRSPropertyType
#define SOAP_TYPE_plu__gml__union_SingleCRSPropertyType (-1116)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_SingleCRSPropertyType
{
        #define SOAP_UNION_plu__gml__union_SingleCRSPropertyType_GeodeticCRS	(1)	/**< union variant selector value for member GeodeticCRS */
        gml__GeodeticCRSType *GeodeticCRS;
        #define SOAP_UNION_plu__gml__union_SingleCRSPropertyType_VerticalCRS	(2)	/**< union variant selector value for member VerticalCRS */
        gml__VerticalCRSType *VerticalCRS;
        #define SOAP_UNION_plu__gml__union_SingleCRSPropertyType_EngineeringCRS	(3)	/**< union variant selector value for member EngineeringCRS */
        gml__EngineeringCRSType *EngineeringCRS;
        #define SOAP_UNION_plu__gml__union_SingleCRSPropertyType_ImageCRS	(4)	/**< union variant selector value for member ImageCRS */
        gml__ImageCRSType *ImageCRS;
        #define SOAP_UNION_plu__gml__union_SingleCRSPropertyType_TemporalCRS	(5)	/**< union variant selector value for member TemporalCRS */
        gml__TemporalCRSType *TemporalCRS;
        #define SOAP_UNION_plu__gml__union_SingleCRSPropertyType_GeographicCRS	(6)	/**< union variant selector value for member GeographicCRS */
        gml__GeographicCRSType *GeographicCRS;
        #define SOAP_UNION_plu__gml__union_SingleCRSPropertyType_GeocentricCRS	(7)	/**< union variant selector value for member GeocentricCRS */
        gml__GeocentricCRSType *GeocentricCRS;
};
#endif

/* PlannedLandUse_v3.0.h:8861 */
#ifndef SOAP_TYPE_plu___gml__SingleCRSPropertyType_sequence
#define SOAP_TYPE_plu___gml__SingleCRSPropertyType_sequence (-1115)
/* Wrapper: */
class SOAP_CMAC __gml__SingleCRSPropertyType_sequence {
      public:
        /// Union with union _gml__union_SingleCRSPropertyType variant selector __unionAbstractSingleCRS set to one of: SOAP_UNION_plu__gml__union_SingleCRSPropertyType_GeodeticCRS SOAP_UNION_plu__gml__union_SingleCRSPropertyType_VerticalCRS SOAP_UNION_plu__gml__union_SingleCRSPropertyType_EngineeringCRS SOAP_UNION_plu__gml__union_SingleCRSPropertyType_ImageCRS SOAP_UNION_plu__gml__union_SingleCRSPropertyType_TemporalCRS SOAP_UNION_plu__gml__union_SingleCRSPropertyType_GeographicCRS SOAP_UNION_plu__gml__union_SingleCRSPropertyType_GeocentricCRS
        int __unionAbstractSingleCRS;
        union _gml__union_SingleCRSPropertyType union_SingleCRSPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__SingleCRSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__SingleCRSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__SingleCRSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__SingleCRSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__SingleCRSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__SingleCRSPropertyType_sequence() : __unionAbstractSingleCRS() { }
        virtual ~__gml__SingleCRSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__SingleCRSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__SingleCRSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__SingleCRSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1016 */
#ifndef SOAP_TYPE_plu_gml__SingleCRSPropertyType
#define SOAP_TYPE_plu_gml__SingleCRSPropertyType (-293)
/* complex XML schema type 'gml:SingleCRSPropertyType': */
class SOAP_CMAC gml__SingleCRSPropertyType : public xsd__anyType {
      public:
        __gml__SingleCRSPropertyType_sequence *__SingleCRSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__SingleCRSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__SingleCRSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SingleCRSPropertyType, default initialized and not managed by a soap context
        virtual gml__SingleCRSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__SingleCRSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__SingleCRSPropertyType() : __SingleCRSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__SingleCRSPropertyType() { }
        /// Friend allocator used by soap_new_gml__SingleCRSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__SingleCRSPropertyType * SOAP_FMAC2 soap_instantiate_gml__SingleCRSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:8946 */
#ifndef SOAP_TYPE_plu___gml__CompoundCRSPropertyType_sequence
#define SOAP_TYPE_plu___gml__CompoundCRSPropertyType_sequence (-1125)
/* Wrapper: */
class SOAP_CMAC __gml__CompoundCRSPropertyType_sequence {
      public:
        /// Required element 'gml:CompoundCRS' of XML schema type 'gml:CompoundCRSType'
        gml__CompoundCRSType *CompoundCRS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__CompoundCRSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__CompoundCRSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__CompoundCRSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__CompoundCRSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__CompoundCRSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__CompoundCRSPropertyType_sequence() : CompoundCRS() { }
        virtual ~__gml__CompoundCRSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__CompoundCRSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__CompoundCRSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__CompoundCRSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1025 */
#ifndef SOAP_TYPE_plu_gml__CompoundCRSPropertyType
#define SOAP_TYPE_plu_gml__CompoundCRSPropertyType (-296)
/* complex XML schema type 'gml:CompoundCRSPropertyType': */
class SOAP_CMAC gml__CompoundCRSPropertyType : public xsd__anyType {
      public:
        __gml__CompoundCRSPropertyType_sequence *__CompoundCRSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CompoundCRSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CompoundCRSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CompoundCRSPropertyType, default initialized and not managed by a soap context
        virtual gml__CompoundCRSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CompoundCRSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__CompoundCRSPropertyType() : __CompoundCRSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__CompoundCRSPropertyType() { }
        /// Friend allocator used by soap_new_gml__CompoundCRSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__CompoundCRSPropertyType * SOAP_FMAC2 soap_instantiate_gml__CompoundCRSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:8997 */
#ifndef SOAP_TYPE_plu___gml__GeodeticCRSPropertyType_sequence
#define SOAP_TYPE_plu___gml__GeodeticCRSPropertyType_sequence (-1128)
/* Wrapper: */
class SOAP_CMAC __gml__GeodeticCRSPropertyType_sequence {
      public:
        /// Required element 'gml:GeodeticCRS' of XML schema type 'gml:GeodeticCRSType'
        gml__GeodeticCRSType *GeodeticCRS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__GeodeticCRSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__GeodeticCRSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__GeodeticCRSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__GeodeticCRSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__GeodeticCRSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__GeodeticCRSPropertyType_sequence() : GeodeticCRS() { }
        virtual ~__gml__GeodeticCRSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__GeodeticCRSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__GeodeticCRSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__GeodeticCRSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1031 */
#ifndef SOAP_TYPE_plu_gml__GeodeticCRSPropertyType
#define SOAP_TYPE_plu_gml__GeodeticCRSPropertyType (-298)
/* complex XML schema type 'gml:GeodeticCRSPropertyType': */
class SOAP_CMAC gml__GeodeticCRSPropertyType : public xsd__anyType {
      public:
        __gml__GeodeticCRSPropertyType_sequence *__GeodeticCRSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GeodeticCRSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GeodeticCRSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeodeticCRSPropertyType, default initialized and not managed by a soap context
        virtual gml__GeodeticCRSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GeodeticCRSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__GeodeticCRSPropertyType() : __GeodeticCRSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__GeodeticCRSPropertyType() { }
        /// Friend allocator used by soap_new_gml__GeodeticCRSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeodeticCRSPropertyType * SOAP_FMAC2 soap_instantiate_gml__GeodeticCRSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:9045 */
#ifndef SOAP_TYPE_plu___gml__VerticalCRSPropertyType_sequence
#define SOAP_TYPE_plu___gml__VerticalCRSPropertyType_sequence (-1130)
/* Wrapper: */
class SOAP_CMAC __gml__VerticalCRSPropertyType_sequence {
      public:
        /// Required element 'gml:VerticalCRS' of XML schema type 'gml:VerticalCRSType'
        gml__VerticalCRSType *VerticalCRS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__VerticalCRSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__VerticalCRSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__VerticalCRSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__VerticalCRSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__VerticalCRSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__VerticalCRSPropertyType_sequence() : VerticalCRS() { }
        virtual ~__gml__VerticalCRSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__VerticalCRSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__VerticalCRSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__VerticalCRSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1037 */
#ifndef SOAP_TYPE_plu_gml__VerticalCRSPropertyType
#define SOAP_TYPE_plu_gml__VerticalCRSPropertyType (-300)
/* complex XML schema type 'gml:VerticalCRSPropertyType': */
class SOAP_CMAC gml__VerticalCRSPropertyType : public xsd__anyType {
      public:
        __gml__VerticalCRSPropertyType_sequence *__VerticalCRSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__VerticalCRSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__VerticalCRSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__VerticalCRSPropertyType, default initialized and not managed by a soap context
        virtual gml__VerticalCRSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__VerticalCRSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__VerticalCRSPropertyType() : __VerticalCRSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__VerticalCRSPropertyType() { }
        /// Friend allocator used by soap_new_gml__VerticalCRSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__VerticalCRSPropertyType * SOAP_FMAC2 soap_instantiate_gml__VerticalCRSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:9096 */
#ifndef SOAP_TYPE_plu___gml__ProjectedCRSPropertyType_sequence
#define SOAP_TYPE_plu___gml__ProjectedCRSPropertyType_sequence (-1132)
/* Wrapper: */
class SOAP_CMAC __gml__ProjectedCRSPropertyType_sequence {
      public:
        /// Required element 'gml:ProjectedCRS' of XML schema type 'gml:ProjectedCRSType'
        gml__ProjectedCRSType *ProjectedCRS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__ProjectedCRSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__ProjectedCRSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__ProjectedCRSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__ProjectedCRSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__ProjectedCRSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__ProjectedCRSPropertyType_sequence() : ProjectedCRS() { }
        virtual ~__gml__ProjectedCRSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__ProjectedCRSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__ProjectedCRSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__ProjectedCRSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1043 */
#ifndef SOAP_TYPE_plu_gml__ProjectedCRSPropertyType
#define SOAP_TYPE_plu_gml__ProjectedCRSPropertyType (-302)
/* complex XML schema type 'gml:ProjectedCRSPropertyType': */
class SOAP_CMAC gml__ProjectedCRSPropertyType : public xsd__anyType {
      public:
        __gml__ProjectedCRSPropertyType_sequence *__ProjectedCRSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ProjectedCRSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ProjectedCRSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ProjectedCRSPropertyType, default initialized and not managed by a soap context
        virtual gml__ProjectedCRSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ProjectedCRSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__ProjectedCRSPropertyType() : __ProjectedCRSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__ProjectedCRSPropertyType() { }
        /// Friend allocator used by soap_new_gml__ProjectedCRSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__ProjectedCRSPropertyType * SOAP_FMAC2 soap_instantiate_gml__ProjectedCRSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:9147 */
#ifndef SOAP_TYPE_plu___gml__DerivedCRSPropertyType_sequence
#define SOAP_TYPE_plu___gml__DerivedCRSPropertyType_sequence (-1135)
/* Wrapper: */
class SOAP_CMAC __gml__DerivedCRSPropertyType_sequence {
      public:
        /// Required element 'gml:DerivedCRS' of XML schema type 'gml:DerivedCRSType'
        gml__DerivedCRSType *DerivedCRS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__DerivedCRSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__DerivedCRSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__DerivedCRSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__DerivedCRSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__DerivedCRSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__DerivedCRSPropertyType_sequence() : DerivedCRS() { }
        virtual ~__gml__DerivedCRSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__DerivedCRSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__DerivedCRSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__DerivedCRSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1049 */
#ifndef SOAP_TYPE_plu_gml__DerivedCRSPropertyType
#define SOAP_TYPE_plu_gml__DerivedCRSPropertyType (-304)
/* complex XML schema type 'gml:DerivedCRSPropertyType': */
class SOAP_CMAC gml__DerivedCRSPropertyType : public xsd__anyType {
      public:
        __gml__DerivedCRSPropertyType_sequence *__DerivedCRSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DerivedCRSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DerivedCRSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DerivedCRSPropertyType, default initialized and not managed by a soap context
        virtual gml__DerivedCRSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DerivedCRSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__DerivedCRSPropertyType() : __DerivedCRSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__DerivedCRSPropertyType() { }
        /// Friend allocator used by soap_new_gml__DerivedCRSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__DerivedCRSPropertyType * SOAP_FMAC2 soap_instantiate_gml__DerivedCRSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:9198 */
#ifndef SOAP_TYPE_plu___gml__EngineeringCRSPropertyType_sequence
#define SOAP_TYPE_plu___gml__EngineeringCRSPropertyType_sequence (-1138)
/* Wrapper: */
class SOAP_CMAC __gml__EngineeringCRSPropertyType_sequence {
      public:
        /// Required element 'gml:EngineeringCRS' of XML schema type 'gml:EngineeringCRSType'
        gml__EngineeringCRSType *EngineeringCRS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__EngineeringCRSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__EngineeringCRSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__EngineeringCRSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__EngineeringCRSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__EngineeringCRSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__EngineeringCRSPropertyType_sequence() : EngineeringCRS() { }
        virtual ~__gml__EngineeringCRSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__EngineeringCRSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__EngineeringCRSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__EngineeringCRSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1055 */
#ifndef SOAP_TYPE_plu_gml__EngineeringCRSPropertyType
#define SOAP_TYPE_plu_gml__EngineeringCRSPropertyType (-306)
/* complex XML schema type 'gml:EngineeringCRSPropertyType': */
class SOAP_CMAC gml__EngineeringCRSPropertyType : public xsd__anyType {
      public:
        __gml__EngineeringCRSPropertyType_sequence *__EngineeringCRSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__EngineeringCRSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__EngineeringCRSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__EngineeringCRSPropertyType, default initialized and not managed by a soap context
        virtual gml__EngineeringCRSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__EngineeringCRSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__EngineeringCRSPropertyType() : __EngineeringCRSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__EngineeringCRSPropertyType() { }
        /// Friend allocator used by soap_new_gml__EngineeringCRSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__EngineeringCRSPropertyType * SOAP_FMAC2 soap_instantiate_gml__EngineeringCRSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:9251 */
#ifndef SOAP_TYPE_plu___gml__ImageCRSPropertyType_sequence
#define SOAP_TYPE_plu___gml__ImageCRSPropertyType_sequence (-1140)
/* Wrapper: */
class SOAP_CMAC __gml__ImageCRSPropertyType_sequence {
      public:
        /// Required element 'gml:ImageCRS' of XML schema type 'gml:ImageCRSType'
        gml__ImageCRSType *ImageCRS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__ImageCRSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__ImageCRSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__ImageCRSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__ImageCRSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__ImageCRSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__ImageCRSPropertyType_sequence() : ImageCRS() { }
        virtual ~__gml__ImageCRSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__ImageCRSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__ImageCRSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__ImageCRSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1061 */
#ifndef SOAP_TYPE_plu_gml__ImageCRSPropertyType
#define SOAP_TYPE_plu_gml__ImageCRSPropertyType (-308)
/* complex XML schema type 'gml:ImageCRSPropertyType': */
class SOAP_CMAC gml__ImageCRSPropertyType : public xsd__anyType {
      public:
        __gml__ImageCRSPropertyType_sequence *__ImageCRSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ImageCRSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ImageCRSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ImageCRSPropertyType, default initialized and not managed by a soap context
        virtual gml__ImageCRSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ImageCRSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__ImageCRSPropertyType() : __ImageCRSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__ImageCRSPropertyType() { }
        /// Friend allocator used by soap_new_gml__ImageCRSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__ImageCRSPropertyType * SOAP_FMAC2 soap_instantiate_gml__ImageCRSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:9302 */
#ifndef SOAP_TYPE_plu___gml__TemporalCRSPropertyType_sequence
#define SOAP_TYPE_plu___gml__TemporalCRSPropertyType_sequence (-1142)
/* Wrapper: */
class SOAP_CMAC __gml__TemporalCRSPropertyType_sequence {
      public:
        /// Required element 'gml:TemporalCRS' of XML schema type 'gml:TemporalCRSType'
        gml__TemporalCRSType *TemporalCRS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__TemporalCRSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__TemporalCRSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__TemporalCRSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__TemporalCRSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__TemporalCRSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__TemporalCRSPropertyType_sequence() : TemporalCRS() { }
        virtual ~__gml__TemporalCRSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__TemporalCRSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__TemporalCRSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__TemporalCRSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1067 */
#ifndef SOAP_TYPE_plu_gml__TemporalCRSPropertyType
#define SOAP_TYPE_plu_gml__TemporalCRSPropertyType (-310)
/* complex XML schema type 'gml:TemporalCRSPropertyType': */
class SOAP_CMAC gml__TemporalCRSPropertyType : public xsd__anyType {
      public:
        __gml__TemporalCRSPropertyType_sequence *__TemporalCRSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TemporalCRSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TemporalCRSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TemporalCRSPropertyType, default initialized and not managed by a soap context
        virtual gml__TemporalCRSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TemporalCRSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__TemporalCRSPropertyType() : __TemporalCRSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__TemporalCRSPropertyType() { }
        /// Friend allocator used by soap_new_gml__TemporalCRSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TemporalCRSPropertyType * SOAP_FMAC2 soap_instantiate_gml__TemporalCRSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:9353 */
#ifndef SOAP_TYPE_plu___gml__CoordinateSystemAxisPropertyType_sequence
#define SOAP_TYPE_plu___gml__CoordinateSystemAxisPropertyType_sequence (-1144)
/* Wrapper: */
class SOAP_CMAC __gml__CoordinateSystemAxisPropertyType_sequence {
      public:
        /// Required element 'gml:CoordinateSystemAxis' of XML schema type 'gml:CoordinateSystemAxisType'
        gml__CoordinateSystemAxisType *CoordinateSystemAxis;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__CoordinateSystemAxisPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__CoordinateSystemAxisPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__CoordinateSystemAxisPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__CoordinateSystemAxisPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__CoordinateSystemAxisPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__CoordinateSystemAxisPropertyType_sequence() : CoordinateSystemAxis() { }
        virtual ~__gml__CoordinateSystemAxisPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__CoordinateSystemAxisPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__CoordinateSystemAxisPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__CoordinateSystemAxisPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1073 */
#ifndef SOAP_TYPE_plu_gml__CoordinateSystemAxisPropertyType
#define SOAP_TYPE_plu_gml__CoordinateSystemAxisPropertyType (-312)
/* complex XML schema type 'gml:CoordinateSystemAxisPropertyType': */
class SOAP_CMAC gml__CoordinateSystemAxisPropertyType : public xsd__anyType {
      public:
        __gml__CoordinateSystemAxisPropertyType_sequence *__CoordinateSystemAxisPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CoordinateSystemAxisPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CoordinateSystemAxisPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CoordinateSystemAxisPropertyType, default initialized and not managed by a soap context
        virtual gml__CoordinateSystemAxisPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CoordinateSystemAxisPropertyType); }
      public:
        /// Constructor with default initializations
        gml__CoordinateSystemAxisPropertyType() : __CoordinateSystemAxisPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__CoordinateSystemAxisPropertyType() { }
        /// Friend allocator used by soap_new_gml__CoordinateSystemAxisPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__CoordinateSystemAxisPropertyType * SOAP_FMAC2 soap_instantiate_gml__CoordinateSystemAxisPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:9414 */
#ifndef SOAP_TYPE_plu__gml__union_CoordinateSystemPropertyType
#define SOAP_TYPE_plu__gml__union_CoordinateSystemPropertyType (-1148)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_CoordinateSystemPropertyType
{
        #define SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_EllipsoidalCS	(1)	/**< union variant selector value for member EllipsoidalCS */
        gml__EllipsoidalCSType *EllipsoidalCS;
        #define SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_CartesianCS	(2)	/**< union variant selector value for member CartesianCS */
        gml__CartesianCSType *CartesianCS;
        #define SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_VerticalCS	(3)	/**< union variant selector value for member VerticalCS */
        gml__VerticalCSType *VerticalCS;
        #define SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_TimeCS	(4)	/**< union variant selector value for member TimeCS */
        gml__TimeCSType *TimeCS;
        #define SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_LinearCS	(5)	/**< union variant selector value for member LinearCS */
        gml__LinearCSType *LinearCS;
        #define SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_UserDefinedCS	(6)	/**< union variant selector value for member UserDefinedCS */
        gml__UserDefinedCSType *UserDefinedCS;
        #define SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_SphericalCS	(7)	/**< union variant selector value for member SphericalCS */
        gml__SphericalCSType *SphericalCS;
        #define SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_PolarCS	(8)	/**< union variant selector value for member PolarCS */
        gml__PolarCSType *PolarCS;
        #define SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_CylindricalCS	(9)	/**< union variant selector value for member CylindricalCS */
        gml__CylindricalCSType *CylindricalCS;
        #define SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_AffineCS	(10)	/**< union variant selector value for member AffineCS */
        gml__AffineCSType *AffineCS;
        #define SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_TemporalCS	(11)	/**< union variant selector value for member TemporalCS */
        gml__TemporalCSType *TemporalCS;
        #define SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_ObliqueCartesianCS	(12)	/**< union variant selector value for member ObliqueCartesianCS */
        gml__ObliqueCartesianCSType *ObliqueCartesianCS;
};
#endif

/* PlannedLandUse_v3.0.h:9404 */
#ifndef SOAP_TYPE_plu___gml__CoordinateSystemPropertyType_sequence
#define SOAP_TYPE_plu___gml__CoordinateSystemPropertyType_sequence (-1147)
/* Wrapper: */
class SOAP_CMAC __gml__CoordinateSystemPropertyType_sequence {
      public:
        /// Union with union _gml__union_CoordinateSystemPropertyType variant selector __unionAbstractCoordinateSystem set to one of: SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_EllipsoidalCS SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_CartesianCS SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_VerticalCS SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_TimeCS SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_LinearCS SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_UserDefinedCS SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_SphericalCS SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_PolarCS SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_CylindricalCS SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_AffineCS SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_TemporalCS SOAP_UNION_plu__gml__union_CoordinateSystemPropertyType_ObliqueCartesianCS
        int __unionAbstractCoordinateSystem;
        union _gml__union_CoordinateSystemPropertyType union_CoordinateSystemPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__CoordinateSystemPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__CoordinateSystemPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__CoordinateSystemPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__CoordinateSystemPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__CoordinateSystemPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__CoordinateSystemPropertyType_sequence() : __unionAbstractCoordinateSystem() { }
        virtual ~__gml__CoordinateSystemPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__CoordinateSystemPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__CoordinateSystemPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__CoordinateSystemPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1079 */
#ifndef SOAP_TYPE_plu_gml__CoordinateSystemPropertyType
#define SOAP_TYPE_plu_gml__CoordinateSystemPropertyType (-314)
/* complex XML schema type 'gml:CoordinateSystemPropertyType': */
class SOAP_CMAC gml__CoordinateSystemPropertyType : public xsd__anyType {
      public:
        __gml__CoordinateSystemPropertyType_sequence *__CoordinateSystemPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CoordinateSystemPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CoordinateSystemPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CoordinateSystemPropertyType, default initialized and not managed by a soap context
        virtual gml__CoordinateSystemPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CoordinateSystemPropertyType); }
      public:
        /// Constructor with default initializations
        gml__CoordinateSystemPropertyType() : __CoordinateSystemPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__CoordinateSystemPropertyType() { }
        /// Friend allocator used by soap_new_gml__CoordinateSystemPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__CoordinateSystemPropertyType * SOAP_FMAC2 soap_instantiate_gml__CoordinateSystemPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:9515 */
#ifndef SOAP_TYPE_plu___gml__EllipsoidalCSPropertyType_sequence
#define SOAP_TYPE_plu___gml__EllipsoidalCSPropertyType_sequence (-1162)
/* Wrapper: */
class SOAP_CMAC __gml__EllipsoidalCSPropertyType_sequence {
      public:
        /// Required element 'gml:EllipsoidalCS' of XML schema type 'gml:EllipsoidalCSType'
        gml__EllipsoidalCSType *EllipsoidalCS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__EllipsoidalCSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__EllipsoidalCSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__EllipsoidalCSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__EllipsoidalCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__EllipsoidalCSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__EllipsoidalCSPropertyType_sequence() : EllipsoidalCS() { }
        virtual ~__gml__EllipsoidalCSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__EllipsoidalCSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__EllipsoidalCSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__EllipsoidalCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1085 */
#ifndef SOAP_TYPE_plu_gml__EllipsoidalCSPropertyType
#define SOAP_TYPE_plu_gml__EllipsoidalCSPropertyType (-316)
/* complex XML schema type 'gml:EllipsoidalCSPropertyType': */
class SOAP_CMAC gml__EllipsoidalCSPropertyType : public xsd__anyType {
      public:
        __gml__EllipsoidalCSPropertyType_sequence *__EllipsoidalCSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__EllipsoidalCSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__EllipsoidalCSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__EllipsoidalCSPropertyType, default initialized and not managed by a soap context
        virtual gml__EllipsoidalCSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__EllipsoidalCSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__EllipsoidalCSPropertyType() : __EllipsoidalCSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__EllipsoidalCSPropertyType() { }
        /// Friend allocator used by soap_new_gml__EllipsoidalCSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__EllipsoidalCSPropertyType * SOAP_FMAC2 soap_instantiate_gml__EllipsoidalCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:9566 */
#ifndef SOAP_TYPE_plu___gml__CartesianCSPropertyType_sequence
#define SOAP_TYPE_plu___gml__CartesianCSPropertyType_sequence (-1164)
/* Wrapper: */
class SOAP_CMAC __gml__CartesianCSPropertyType_sequence {
      public:
        /// Required element 'gml:CartesianCS' of XML schema type 'gml:CartesianCSType'
        gml__CartesianCSType *CartesianCS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__CartesianCSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__CartesianCSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__CartesianCSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__CartesianCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__CartesianCSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__CartesianCSPropertyType_sequence() : CartesianCS() { }
        virtual ~__gml__CartesianCSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__CartesianCSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__CartesianCSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__CartesianCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1091 */
#ifndef SOAP_TYPE_plu_gml__CartesianCSPropertyType
#define SOAP_TYPE_plu_gml__CartesianCSPropertyType (-318)
/* complex XML schema type 'gml:CartesianCSPropertyType': */
class SOAP_CMAC gml__CartesianCSPropertyType : public xsd__anyType {
      public:
        __gml__CartesianCSPropertyType_sequence *__CartesianCSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CartesianCSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CartesianCSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CartesianCSPropertyType, default initialized and not managed by a soap context
        virtual gml__CartesianCSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CartesianCSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__CartesianCSPropertyType() : __CartesianCSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__CartesianCSPropertyType() { }
        /// Friend allocator used by soap_new_gml__CartesianCSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__CartesianCSPropertyType * SOAP_FMAC2 soap_instantiate_gml__CartesianCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:9617 */
#ifndef SOAP_TYPE_plu___gml__VerticalCSPropertyType_sequence
#define SOAP_TYPE_plu___gml__VerticalCSPropertyType_sequence (-1166)
/* Wrapper: */
class SOAP_CMAC __gml__VerticalCSPropertyType_sequence {
      public:
        /// Required element 'gml:VerticalCS' of XML schema type 'gml:VerticalCSType'
        gml__VerticalCSType *VerticalCS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__VerticalCSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__VerticalCSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__VerticalCSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__VerticalCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__VerticalCSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__VerticalCSPropertyType_sequence() : VerticalCS() { }
        virtual ~__gml__VerticalCSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__VerticalCSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__VerticalCSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__VerticalCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1097 */
#ifndef SOAP_TYPE_plu_gml__VerticalCSPropertyType
#define SOAP_TYPE_plu_gml__VerticalCSPropertyType (-320)
/* complex XML schema type 'gml:VerticalCSPropertyType': */
class SOAP_CMAC gml__VerticalCSPropertyType : public xsd__anyType {
      public:
        __gml__VerticalCSPropertyType_sequence *__VerticalCSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__VerticalCSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__VerticalCSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__VerticalCSPropertyType, default initialized and not managed by a soap context
        virtual gml__VerticalCSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__VerticalCSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__VerticalCSPropertyType() : __VerticalCSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__VerticalCSPropertyType() { }
        /// Friend allocator used by soap_new_gml__VerticalCSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__VerticalCSPropertyType * SOAP_FMAC2 soap_instantiate_gml__VerticalCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:9668 */
#ifndef SOAP_TYPE_plu___gml__TimeCSPropertyType_sequence
#define SOAP_TYPE_plu___gml__TimeCSPropertyType_sequence (-1168)
/* Wrapper: */
class SOAP_CMAC __gml__TimeCSPropertyType_sequence {
      public:
        /// Required element 'gml:TimeCS' of XML schema type 'gml:TimeCSType'
        gml__TimeCSType *TimeCS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__TimeCSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__TimeCSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__TimeCSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__TimeCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__TimeCSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__TimeCSPropertyType_sequence() : TimeCS() { }
        virtual ~__gml__TimeCSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__TimeCSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__TimeCSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__TimeCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1103 */
#ifndef SOAP_TYPE_plu_gml__TimeCSPropertyType
#define SOAP_TYPE_plu_gml__TimeCSPropertyType (-322)
/* complex XML schema type 'gml:TimeCSPropertyType': */
class SOAP_CMAC gml__TimeCSPropertyType : public xsd__anyType {
      public:
        __gml__TimeCSPropertyType_sequence *__TimeCSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeCSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeCSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeCSPropertyType, default initialized and not managed by a soap context
        virtual gml__TimeCSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeCSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__TimeCSPropertyType() : __TimeCSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__TimeCSPropertyType() { }
        /// Friend allocator used by soap_new_gml__TimeCSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeCSPropertyType * SOAP_FMAC2 soap_instantiate_gml__TimeCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:9719 */
#ifndef SOAP_TYPE_plu___gml__LinearCSPropertyType_sequence
#define SOAP_TYPE_plu___gml__LinearCSPropertyType_sequence (-1170)
/* Wrapper: */
class SOAP_CMAC __gml__LinearCSPropertyType_sequence {
      public:
        /// Required element 'gml:LinearCS' of XML schema type 'gml:LinearCSType'
        gml__LinearCSType *LinearCS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__LinearCSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__LinearCSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__LinearCSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__LinearCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__LinearCSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__LinearCSPropertyType_sequence() : LinearCS() { }
        virtual ~__gml__LinearCSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__LinearCSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__LinearCSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__LinearCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1109 */
#ifndef SOAP_TYPE_plu_gml__LinearCSPropertyType
#define SOAP_TYPE_plu_gml__LinearCSPropertyType (-324)
/* complex XML schema type 'gml:LinearCSPropertyType': */
class SOAP_CMAC gml__LinearCSPropertyType : public xsd__anyType {
      public:
        __gml__LinearCSPropertyType_sequence *__LinearCSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__LinearCSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__LinearCSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__LinearCSPropertyType, default initialized and not managed by a soap context
        virtual gml__LinearCSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__LinearCSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__LinearCSPropertyType() : __LinearCSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__LinearCSPropertyType() { }
        /// Friend allocator used by soap_new_gml__LinearCSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__LinearCSPropertyType * SOAP_FMAC2 soap_instantiate_gml__LinearCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:9770 */
#ifndef SOAP_TYPE_plu___gml__UserDefinedCSPropertyType_sequence
#define SOAP_TYPE_plu___gml__UserDefinedCSPropertyType_sequence (-1172)
/* Wrapper: */
class SOAP_CMAC __gml__UserDefinedCSPropertyType_sequence {
      public:
        /// Required element 'gml:UserDefinedCS' of XML schema type 'gml:UserDefinedCSType'
        gml__UserDefinedCSType *UserDefinedCS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__UserDefinedCSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__UserDefinedCSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__UserDefinedCSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__UserDefinedCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__UserDefinedCSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__UserDefinedCSPropertyType_sequence() : UserDefinedCS() { }
        virtual ~__gml__UserDefinedCSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__UserDefinedCSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__UserDefinedCSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__UserDefinedCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1115 */
#ifndef SOAP_TYPE_plu_gml__UserDefinedCSPropertyType
#define SOAP_TYPE_plu_gml__UserDefinedCSPropertyType (-326)
/* complex XML schema type 'gml:UserDefinedCSPropertyType': */
class SOAP_CMAC gml__UserDefinedCSPropertyType : public xsd__anyType {
      public:
        __gml__UserDefinedCSPropertyType_sequence *__UserDefinedCSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__UserDefinedCSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__UserDefinedCSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__UserDefinedCSPropertyType, default initialized and not managed by a soap context
        virtual gml__UserDefinedCSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__UserDefinedCSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__UserDefinedCSPropertyType() : __UserDefinedCSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__UserDefinedCSPropertyType() { }
        /// Friend allocator used by soap_new_gml__UserDefinedCSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__UserDefinedCSPropertyType * SOAP_FMAC2 soap_instantiate_gml__UserDefinedCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:9821 */
#ifndef SOAP_TYPE_plu___gml__SphericalCSPropertyType_sequence
#define SOAP_TYPE_plu___gml__SphericalCSPropertyType_sequence (-1174)
/* Wrapper: */
class SOAP_CMAC __gml__SphericalCSPropertyType_sequence {
      public:
        /// Required element 'gml:SphericalCS' of XML schema type 'gml:SphericalCSType'
        gml__SphericalCSType *SphericalCS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__SphericalCSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__SphericalCSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__SphericalCSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__SphericalCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__SphericalCSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__SphericalCSPropertyType_sequence() : SphericalCS() { }
        virtual ~__gml__SphericalCSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__SphericalCSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__SphericalCSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__SphericalCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1121 */
#ifndef SOAP_TYPE_plu_gml__SphericalCSPropertyType
#define SOAP_TYPE_plu_gml__SphericalCSPropertyType (-328)
/* complex XML schema type 'gml:SphericalCSPropertyType': */
class SOAP_CMAC gml__SphericalCSPropertyType : public xsd__anyType {
      public:
        __gml__SphericalCSPropertyType_sequence *__SphericalCSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__SphericalCSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__SphericalCSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SphericalCSPropertyType, default initialized and not managed by a soap context
        virtual gml__SphericalCSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__SphericalCSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__SphericalCSPropertyType() : __SphericalCSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__SphericalCSPropertyType() { }
        /// Friend allocator used by soap_new_gml__SphericalCSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__SphericalCSPropertyType * SOAP_FMAC2 soap_instantiate_gml__SphericalCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:9872 */
#ifndef SOAP_TYPE_plu___gml__PolarCSPropertyType_sequence
#define SOAP_TYPE_plu___gml__PolarCSPropertyType_sequence (-1176)
/* Wrapper: */
class SOAP_CMAC __gml__PolarCSPropertyType_sequence {
      public:
        /// Required element 'gml:PolarCS' of XML schema type 'gml:PolarCSType'
        gml__PolarCSType *PolarCS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__PolarCSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__PolarCSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__PolarCSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__PolarCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__PolarCSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__PolarCSPropertyType_sequence() : PolarCS() { }
        virtual ~__gml__PolarCSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__PolarCSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__PolarCSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__PolarCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1127 */
#ifndef SOAP_TYPE_plu_gml__PolarCSPropertyType
#define SOAP_TYPE_plu_gml__PolarCSPropertyType (-330)
/* complex XML schema type 'gml:PolarCSPropertyType': */
class SOAP_CMAC gml__PolarCSPropertyType : public xsd__anyType {
      public:
        __gml__PolarCSPropertyType_sequence *__PolarCSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__PolarCSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__PolarCSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__PolarCSPropertyType, default initialized and not managed by a soap context
        virtual gml__PolarCSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__PolarCSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__PolarCSPropertyType() : __PolarCSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__PolarCSPropertyType() { }
        /// Friend allocator used by soap_new_gml__PolarCSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__PolarCSPropertyType * SOAP_FMAC2 soap_instantiate_gml__PolarCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:9923 */
#ifndef SOAP_TYPE_plu___gml__CylindricalCSPropertyType_sequence
#define SOAP_TYPE_plu___gml__CylindricalCSPropertyType_sequence (-1178)
/* Wrapper: */
class SOAP_CMAC __gml__CylindricalCSPropertyType_sequence {
      public:
        /// Required element 'gml:CylindricalCS' of XML schema type 'gml:CylindricalCSType'
        gml__CylindricalCSType *CylindricalCS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__CylindricalCSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__CylindricalCSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__CylindricalCSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__CylindricalCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__CylindricalCSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__CylindricalCSPropertyType_sequence() : CylindricalCS() { }
        virtual ~__gml__CylindricalCSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__CylindricalCSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__CylindricalCSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__CylindricalCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1133 */
#ifndef SOAP_TYPE_plu_gml__CylindricalCSPropertyType
#define SOAP_TYPE_plu_gml__CylindricalCSPropertyType (-332)
/* complex XML schema type 'gml:CylindricalCSPropertyType': */
class SOAP_CMAC gml__CylindricalCSPropertyType : public xsd__anyType {
      public:
        __gml__CylindricalCSPropertyType_sequence *__CylindricalCSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CylindricalCSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CylindricalCSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CylindricalCSPropertyType, default initialized and not managed by a soap context
        virtual gml__CylindricalCSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CylindricalCSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__CylindricalCSPropertyType() : __CylindricalCSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__CylindricalCSPropertyType() { }
        /// Friend allocator used by soap_new_gml__CylindricalCSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__CylindricalCSPropertyType * SOAP_FMAC2 soap_instantiate_gml__CylindricalCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:9974 */
#ifndef SOAP_TYPE_plu___gml__AffineCSPropertyType_sequence
#define SOAP_TYPE_plu___gml__AffineCSPropertyType_sequence (-1180)
/* Wrapper: */
class SOAP_CMAC __gml__AffineCSPropertyType_sequence {
      public:
        /// Required element 'gml:AffineCS' of XML schema type 'gml:AffineCSType'
        gml__AffineCSType *AffineCS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__AffineCSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__AffineCSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__AffineCSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__AffineCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__AffineCSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__AffineCSPropertyType_sequence() : AffineCS() { }
        virtual ~__gml__AffineCSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__AffineCSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__AffineCSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__AffineCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1139 */
#ifndef SOAP_TYPE_plu_gml__AffineCSPropertyType
#define SOAP_TYPE_plu_gml__AffineCSPropertyType (-334)
/* complex XML schema type 'gml:AffineCSPropertyType': */
class SOAP_CMAC gml__AffineCSPropertyType : public xsd__anyType {
      public:
        __gml__AffineCSPropertyType_sequence *__AffineCSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AffineCSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AffineCSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AffineCSPropertyType, default initialized and not managed by a soap context
        virtual gml__AffineCSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AffineCSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__AffineCSPropertyType() : __AffineCSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__AffineCSPropertyType() { }
        /// Friend allocator used by soap_new_gml__AffineCSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__AffineCSPropertyType * SOAP_FMAC2 soap_instantiate_gml__AffineCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:10035 */
#ifndef SOAP_TYPE_plu__gml__union_CRSPropertyType
#define SOAP_TYPE_plu__gml__union_CRSPropertyType (-1183)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_CRSPropertyType
{
        #define SOAP_UNION_plu__gml__union_CRSPropertyType_CompoundCRS	(1)	/**< union variant selector value for member CompoundCRS */
        gml__CompoundCRSType *CompoundCRS;
};
#endif

/* PlannedLandUse_v3.0.h:10025 */
#ifndef SOAP_TYPE_plu___gml__CRSPropertyType_sequence
#define SOAP_TYPE_plu___gml__CRSPropertyType_sequence (-1182)
/* Wrapper: */
class SOAP_CMAC __gml__CRSPropertyType_sequence {
      public:
        /// Union with union _gml__union_CRSPropertyType variant selector __unionAbstractCRS set to one of: SOAP_UNION_plu__gml__union_CRSPropertyType_CompoundCRS
        int __unionAbstractCRS;
        union _gml__union_CRSPropertyType union_CRSPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__CRSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__CRSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__CRSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__CRSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__CRSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__CRSPropertyType_sequence() : __unionAbstractCRS() { }
        virtual ~__gml__CRSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__CRSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__CRSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__CRSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1148 */
#ifndef SOAP_TYPE_plu_gml__CRSPropertyType
#define SOAP_TYPE_plu_gml__CRSPropertyType (-337)
/* complex XML schema type 'gml:CRSPropertyType': */
class SOAP_CMAC gml__CRSPropertyType : public xsd__anyType {
      public:
        __gml__CRSPropertyType_sequence *__CRSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CRSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CRSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CRSPropertyType, default initialized and not managed by a soap context
        virtual gml__CRSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CRSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__CRSPropertyType() : __CRSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__CRSPropertyType() { }
        /// Friend allocator used by soap_new_gml__CRSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__CRSPropertyType * SOAP_FMAC2 soap_instantiate_gml__CRSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:10097 */
#ifndef SOAP_TYPE_plu__gml__union_DatumPropertyType
#define SOAP_TYPE_plu__gml__union_DatumPropertyType (-1186)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_DatumPropertyType
{
        #define SOAP_UNION_plu__gml__union_DatumPropertyType_GeodeticDatum	(1)	/**< union variant selector value for member GeodeticDatum */
        gml__GeodeticDatumType *GeodeticDatum;
        #define SOAP_UNION_plu__gml__union_DatumPropertyType_EngineeringDatum	(2)	/**< union variant selector value for member EngineeringDatum */
        gml__EngineeringDatumType *EngineeringDatum;
        #define SOAP_UNION_plu__gml__union_DatumPropertyType_ImageDatum	(3)	/**< union variant selector value for member ImageDatum */
        gml__ImageDatumType *ImageDatum;
        #define SOAP_UNION_plu__gml__union_DatumPropertyType_VerticalDatum	(4)	/**< union variant selector value for member VerticalDatum */
        gml__VerticalDatumType *VerticalDatum;
        #define SOAP_UNION_plu__gml__union_DatumPropertyType_TemporalDatum	(5)	/**< union variant selector value for member TemporalDatum */
        gml__TemporalDatumType *TemporalDatum;
};
#endif

/* PlannedLandUse_v3.0.h:10087 */
#ifndef SOAP_TYPE_plu___gml__DatumPropertyType_sequence
#define SOAP_TYPE_plu___gml__DatumPropertyType_sequence (-1185)
/* Wrapper: */
class SOAP_CMAC __gml__DatumPropertyType_sequence {
      public:
        /// Union with union _gml__union_DatumPropertyType variant selector __unionAbstractDatum set to one of: SOAP_UNION_plu__gml__union_DatumPropertyType_GeodeticDatum SOAP_UNION_plu__gml__union_DatumPropertyType_EngineeringDatum SOAP_UNION_plu__gml__union_DatumPropertyType_ImageDatum SOAP_UNION_plu__gml__union_DatumPropertyType_VerticalDatum SOAP_UNION_plu__gml__union_DatumPropertyType_TemporalDatum
        int __unionAbstractDatum;
        union _gml__union_DatumPropertyType union_DatumPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__DatumPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__DatumPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__DatumPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__DatumPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__DatumPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__DatumPropertyType_sequence() : __unionAbstractDatum() { }
        virtual ~__gml__DatumPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__DatumPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__DatumPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__DatumPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1154 */
#ifndef SOAP_TYPE_plu_gml__DatumPropertyType
#define SOAP_TYPE_plu_gml__DatumPropertyType (-339)
/* complex XML schema type 'gml:DatumPropertyType': */
class SOAP_CMAC gml__DatumPropertyType : public xsd__anyType {
      public:
        __gml__DatumPropertyType_sequence *__DatumPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DatumPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DatumPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DatumPropertyType, default initialized and not managed by a soap context
        virtual gml__DatumPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DatumPropertyType); }
      public:
        /// Constructor with default initializations
        gml__DatumPropertyType() : __DatumPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__DatumPropertyType() { }
        /// Friend allocator used by soap_new_gml__DatumPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__DatumPropertyType * SOAP_FMAC2 soap_instantiate_gml__DatumPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:10169 */
#ifndef SOAP_TYPE_plu___gml__GeodeticDatumPropertyType_sequence
#define SOAP_TYPE_plu___gml__GeodeticDatumPropertyType_sequence (-1193)
/* Wrapper: */
class SOAP_CMAC __gml__GeodeticDatumPropertyType_sequence {
      public:
        /// Required element 'gml:GeodeticDatum' of XML schema type 'gml:GeodeticDatumType'
        gml__GeodeticDatumType *GeodeticDatum;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__GeodeticDatumPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__GeodeticDatumPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__GeodeticDatumPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__GeodeticDatumPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__GeodeticDatumPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__GeodeticDatumPropertyType_sequence() : GeodeticDatum() { }
        virtual ~__gml__GeodeticDatumPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__GeodeticDatumPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__GeodeticDatumPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__GeodeticDatumPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1160 */
#ifndef SOAP_TYPE_plu_gml__GeodeticDatumPropertyType
#define SOAP_TYPE_plu_gml__GeodeticDatumPropertyType (-341)
/* complex XML schema type 'gml:GeodeticDatumPropertyType': */
class SOAP_CMAC gml__GeodeticDatumPropertyType : public xsd__anyType {
      public:
        __gml__GeodeticDatumPropertyType_sequence *__GeodeticDatumPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GeodeticDatumPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GeodeticDatumPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeodeticDatumPropertyType, default initialized and not managed by a soap context
        virtual gml__GeodeticDatumPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GeodeticDatumPropertyType); }
      public:
        /// Constructor with default initializations
        gml__GeodeticDatumPropertyType() : __GeodeticDatumPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__GeodeticDatumPropertyType() { }
        /// Friend allocator used by soap_new_gml__GeodeticDatumPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeodeticDatumPropertyType * SOAP_FMAC2 soap_instantiate_gml__GeodeticDatumPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:10220 */
#ifndef SOAP_TYPE_plu___gml__EllipsoidPropertyType_sequence
#define SOAP_TYPE_plu___gml__EllipsoidPropertyType_sequence (-1195)
/* Wrapper: */
class SOAP_CMAC __gml__EllipsoidPropertyType_sequence {
      public:
        /// Required element 'gml:Ellipsoid' of XML schema type 'gml:EllipsoidType'
        gml__EllipsoidType *Ellipsoid;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__EllipsoidPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__EllipsoidPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__EllipsoidPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__EllipsoidPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__EllipsoidPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__EllipsoidPropertyType_sequence() : Ellipsoid() { }
        virtual ~__gml__EllipsoidPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__EllipsoidPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__EllipsoidPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__EllipsoidPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1166 */
#ifndef SOAP_TYPE_plu_gml__EllipsoidPropertyType
#define SOAP_TYPE_plu_gml__EllipsoidPropertyType (-343)
/* complex XML schema type 'gml:EllipsoidPropertyType': */
class SOAP_CMAC gml__EllipsoidPropertyType : public xsd__anyType {
      public:
        __gml__EllipsoidPropertyType_sequence *__EllipsoidPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__EllipsoidPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__EllipsoidPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__EllipsoidPropertyType, default initialized and not managed by a soap context
        virtual gml__EllipsoidPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__EllipsoidPropertyType); }
      public:
        /// Constructor with default initializations
        gml__EllipsoidPropertyType() : __EllipsoidPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__EllipsoidPropertyType() { }
        /// Friend allocator used by soap_new_gml__EllipsoidPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__EllipsoidPropertyType * SOAP_FMAC2 soap_instantiate_gml__EllipsoidPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:10271 */
#ifndef SOAP_TYPE_plu___gml__PrimeMeridianPropertyType_sequence
#define SOAP_TYPE_plu___gml__PrimeMeridianPropertyType_sequence (-1198)
/* Wrapper: */
class SOAP_CMAC __gml__PrimeMeridianPropertyType_sequence {
      public:
        /// Required element 'gml:PrimeMeridian' of XML schema type 'gml:PrimeMeridianType'
        gml__PrimeMeridianType *PrimeMeridian;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__PrimeMeridianPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__PrimeMeridianPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__PrimeMeridianPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__PrimeMeridianPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__PrimeMeridianPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__PrimeMeridianPropertyType_sequence() : PrimeMeridian() { }
        virtual ~__gml__PrimeMeridianPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__PrimeMeridianPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__PrimeMeridianPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__PrimeMeridianPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1172 */
#ifndef SOAP_TYPE_plu_gml__PrimeMeridianPropertyType
#define SOAP_TYPE_plu_gml__PrimeMeridianPropertyType (-345)
/* complex XML schema type 'gml:PrimeMeridianPropertyType': */
class SOAP_CMAC gml__PrimeMeridianPropertyType : public xsd__anyType {
      public:
        __gml__PrimeMeridianPropertyType_sequence *__PrimeMeridianPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__PrimeMeridianPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__PrimeMeridianPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__PrimeMeridianPropertyType, default initialized and not managed by a soap context
        virtual gml__PrimeMeridianPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__PrimeMeridianPropertyType); }
      public:
        /// Constructor with default initializations
        gml__PrimeMeridianPropertyType() : __PrimeMeridianPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__PrimeMeridianPropertyType() { }
        /// Friend allocator used by soap_new_gml__PrimeMeridianPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__PrimeMeridianPropertyType * SOAP_FMAC2 soap_instantiate_gml__PrimeMeridianPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:10322 */
#ifndef SOAP_TYPE_plu___gml__EngineeringDatumPropertyType_sequence
#define SOAP_TYPE_plu___gml__EngineeringDatumPropertyType_sequence (-1201)
/* Wrapper: */
class SOAP_CMAC __gml__EngineeringDatumPropertyType_sequence {
      public:
        /// Required element 'gml:EngineeringDatum' of XML schema type 'gml:EngineeringDatumType'
        gml__EngineeringDatumType *EngineeringDatum;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__EngineeringDatumPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__EngineeringDatumPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__EngineeringDatumPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__EngineeringDatumPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__EngineeringDatumPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__EngineeringDatumPropertyType_sequence() : EngineeringDatum() { }
        virtual ~__gml__EngineeringDatumPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__EngineeringDatumPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__EngineeringDatumPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__EngineeringDatumPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1178 */
#ifndef SOAP_TYPE_plu_gml__EngineeringDatumPropertyType
#define SOAP_TYPE_plu_gml__EngineeringDatumPropertyType (-347)
/* complex XML schema type 'gml:EngineeringDatumPropertyType': */
class SOAP_CMAC gml__EngineeringDatumPropertyType : public xsd__anyType {
      public:
        __gml__EngineeringDatumPropertyType_sequence *__EngineeringDatumPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__EngineeringDatumPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__EngineeringDatumPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__EngineeringDatumPropertyType, default initialized and not managed by a soap context
        virtual gml__EngineeringDatumPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__EngineeringDatumPropertyType); }
      public:
        /// Constructor with default initializations
        gml__EngineeringDatumPropertyType() : __EngineeringDatumPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__EngineeringDatumPropertyType() { }
        /// Friend allocator used by soap_new_gml__EngineeringDatumPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__EngineeringDatumPropertyType * SOAP_FMAC2 soap_instantiate_gml__EngineeringDatumPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:10373 */
#ifndef SOAP_TYPE_plu___gml__ImageDatumPropertyType_sequence
#define SOAP_TYPE_plu___gml__ImageDatumPropertyType_sequence (-1203)
/* Wrapper: */
class SOAP_CMAC __gml__ImageDatumPropertyType_sequence {
      public:
        /// Required element 'gml:ImageDatum' of XML schema type 'gml:ImageDatumType'
        gml__ImageDatumType *ImageDatum;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__ImageDatumPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__ImageDatumPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__ImageDatumPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__ImageDatumPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__ImageDatumPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__ImageDatumPropertyType_sequence() : ImageDatum() { }
        virtual ~__gml__ImageDatumPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__ImageDatumPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__ImageDatumPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__ImageDatumPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1184 */
#ifndef SOAP_TYPE_plu_gml__ImageDatumPropertyType
#define SOAP_TYPE_plu_gml__ImageDatumPropertyType (-349)
/* complex XML schema type 'gml:ImageDatumPropertyType': */
class SOAP_CMAC gml__ImageDatumPropertyType : public xsd__anyType {
      public:
        __gml__ImageDatumPropertyType_sequence *__ImageDatumPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ImageDatumPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ImageDatumPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ImageDatumPropertyType, default initialized and not managed by a soap context
        virtual gml__ImageDatumPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ImageDatumPropertyType); }
      public:
        /// Constructor with default initializations
        gml__ImageDatumPropertyType() : __ImageDatumPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__ImageDatumPropertyType() { }
        /// Friend allocator used by soap_new_gml__ImageDatumPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__ImageDatumPropertyType * SOAP_FMAC2 soap_instantiate_gml__ImageDatumPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:10424 */
#ifndef SOAP_TYPE_plu___gml__VerticalDatumPropertyType_sequence
#define SOAP_TYPE_plu___gml__VerticalDatumPropertyType_sequence (-1205)
/* Wrapper: */
class SOAP_CMAC __gml__VerticalDatumPropertyType_sequence {
      public:
        /// Required element 'gml:VerticalDatum' of XML schema type 'gml:VerticalDatumType'
        gml__VerticalDatumType *VerticalDatum;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__VerticalDatumPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__VerticalDatumPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__VerticalDatumPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__VerticalDatumPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__VerticalDatumPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__VerticalDatumPropertyType_sequence() : VerticalDatum() { }
        virtual ~__gml__VerticalDatumPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__VerticalDatumPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__VerticalDatumPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__VerticalDatumPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1190 */
#ifndef SOAP_TYPE_plu_gml__VerticalDatumPropertyType
#define SOAP_TYPE_plu_gml__VerticalDatumPropertyType (-351)
/* complex XML schema type 'gml:VerticalDatumPropertyType': */
class SOAP_CMAC gml__VerticalDatumPropertyType : public xsd__anyType {
      public:
        __gml__VerticalDatumPropertyType_sequence *__VerticalDatumPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__VerticalDatumPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__VerticalDatumPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__VerticalDatumPropertyType, default initialized and not managed by a soap context
        virtual gml__VerticalDatumPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__VerticalDatumPropertyType); }
      public:
        /// Constructor with default initializations
        gml__VerticalDatumPropertyType() : __VerticalDatumPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__VerticalDatumPropertyType() { }
        /// Friend allocator used by soap_new_gml__VerticalDatumPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__VerticalDatumPropertyType * SOAP_FMAC2 soap_instantiate_gml__VerticalDatumPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:10475 */
#ifndef SOAP_TYPE_plu___gml__TemporalDatumPropertyType_sequence
#define SOAP_TYPE_plu___gml__TemporalDatumPropertyType_sequence (-1207)
/* Wrapper: */
class SOAP_CMAC __gml__TemporalDatumPropertyType_sequence {
      public:
        /// Required element 'gml:TemporalDatum' of XML schema type 'gml:TemporalDatumType'
        gml__TemporalDatumType *TemporalDatum;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__TemporalDatumPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__TemporalDatumPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__TemporalDatumPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__TemporalDatumPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__TemporalDatumPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__TemporalDatumPropertyType_sequence() : TemporalDatum() { }
        virtual ~__gml__TemporalDatumPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__TemporalDatumPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__TemporalDatumPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__TemporalDatumPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1199 */
#ifndef SOAP_TYPE_plu_gml__TemporalDatumPropertyType
#define SOAP_TYPE_plu_gml__TemporalDatumPropertyType (-354)
/* complex XML schema type 'gml:TemporalDatumPropertyType': */
class SOAP_CMAC gml__TemporalDatumPropertyType : public xsd__anyType {
      public:
        __gml__TemporalDatumPropertyType_sequence *__TemporalDatumPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TemporalDatumPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TemporalDatumPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TemporalDatumPropertyType, default initialized and not managed by a soap context
        virtual gml__TemporalDatumPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TemporalDatumPropertyType); }
      public:
        /// Constructor with default initializations
        gml__TemporalDatumPropertyType() : __TemporalDatumPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__TemporalDatumPropertyType() { }
        /// Friend allocator used by soap_new_gml__TemporalDatumPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TemporalDatumPropertyType * SOAP_FMAC2 soap_instantiate_gml__TemporalDatumPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:10537 */
#ifndef SOAP_TYPE_plu__gml__union_CoordinateOperationPropertyType
#define SOAP_TYPE_plu__gml__union_CoordinateOperationPropertyType (-1210)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_CoordinateOperationPropertyType
{
        #define SOAP_UNION_plu__gml__union_CoordinateOperationPropertyType_ConcatenatedOperation	(1)	/**< union variant selector value for member ConcatenatedOperation */
        gml__ConcatenatedOperationType *ConcatenatedOperation;
};
#endif

/* PlannedLandUse_v3.0.h:10526 */
#ifndef SOAP_TYPE_plu___gml__CoordinateOperationPropertyType_sequence
#define SOAP_TYPE_plu___gml__CoordinateOperationPropertyType_sequence (-1209)
/* Wrapper: */
class SOAP_CMAC __gml__CoordinateOperationPropertyType_sequence {
      public:
        /// Union with union _gml__union_CoordinateOperationPropertyType variant selector __unionAbstractCoordinateOperation set to one of: SOAP_UNION_plu__gml__union_CoordinateOperationPropertyType_ConcatenatedOperation
        int __unionAbstractCoordinateOperation;
        union _gml__union_CoordinateOperationPropertyType union_CoordinateOperationPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__CoordinateOperationPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__CoordinateOperationPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__CoordinateOperationPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__CoordinateOperationPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__CoordinateOperationPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__CoordinateOperationPropertyType_sequence() : __unionAbstractCoordinateOperation() { }
        virtual ~__gml__CoordinateOperationPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__CoordinateOperationPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__CoordinateOperationPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__CoordinateOperationPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1205 */
#ifndef SOAP_TYPE_plu_gml__CoordinateOperationPropertyType
#define SOAP_TYPE_plu_gml__CoordinateOperationPropertyType (-356)
/* complex XML schema type 'gml:CoordinateOperationPropertyType': */
class SOAP_CMAC gml__CoordinateOperationPropertyType : public xsd__anyType {
      public:
        __gml__CoordinateOperationPropertyType_sequence *__CoordinateOperationPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CoordinateOperationPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CoordinateOperationPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CoordinateOperationPropertyType, default initialized and not managed by a soap context
        virtual gml__CoordinateOperationPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CoordinateOperationPropertyType); }
      public:
        /// Constructor with default initializations
        gml__CoordinateOperationPropertyType() : __CoordinateOperationPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__CoordinateOperationPropertyType() { }
        /// Friend allocator used by soap_new_gml__CoordinateOperationPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__CoordinateOperationPropertyType * SOAP_FMAC2 soap_instantiate_gml__CoordinateOperationPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:10596 */
#ifndef SOAP_TYPE_plu__gml__union_SingleOperationPropertyType
#define SOAP_TYPE_plu__gml__union_SingleOperationPropertyType (-1214)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_SingleOperationPropertyType
{
        #define SOAP_UNION_plu__gml__union_SingleOperationPropertyType_PassThroughOperation	(1)	/**< union variant selector value for member PassThroughOperation */
        gml__PassThroughOperationType *PassThroughOperation;
};
#endif

/* PlannedLandUse_v3.0.h:10586 */
#ifndef SOAP_TYPE_plu___gml__SingleOperationPropertyType_sequence
#define SOAP_TYPE_plu___gml__SingleOperationPropertyType_sequence (-1213)
/* Wrapper: */
class SOAP_CMAC __gml__SingleOperationPropertyType_sequence {
      public:
        /// Union with union _gml__union_SingleOperationPropertyType variant selector __unionAbstractSingleOperation set to one of: SOAP_UNION_plu__gml__union_SingleOperationPropertyType_PassThroughOperation
        int __unionAbstractSingleOperation;
        union _gml__union_SingleOperationPropertyType union_SingleOperationPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__SingleOperationPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__SingleOperationPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__SingleOperationPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__SingleOperationPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__SingleOperationPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__SingleOperationPropertyType_sequence() : __unionAbstractSingleOperation() { }
        virtual ~__gml__SingleOperationPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__SingleOperationPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__SingleOperationPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__SingleOperationPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1208 */
#ifndef SOAP_TYPE_plu_gml__SingleOperationPropertyType
#define SOAP_TYPE_plu_gml__SingleOperationPropertyType (-357)
/* complex XML schema type 'gml:SingleOperationPropertyType': */
class SOAP_CMAC gml__SingleOperationPropertyType : public xsd__anyType {
      public:
        __gml__SingleOperationPropertyType_sequence *__SingleOperationPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__SingleOperationPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__SingleOperationPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SingleOperationPropertyType, default initialized and not managed by a soap context
        virtual gml__SingleOperationPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__SingleOperationPropertyType); }
      public:
        /// Constructor with default initializations
        gml__SingleOperationPropertyType() : __SingleOperationPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__SingleOperationPropertyType() { }
        /// Friend allocator used by soap_new_gml__SingleOperationPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__SingleOperationPropertyType * SOAP_FMAC2 soap_instantiate_gml__SingleOperationPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:10660 */
#ifndef SOAP_TYPE_plu__gml__union_GeneralConversionPropertyType
#define SOAP_TYPE_plu__gml__union_GeneralConversionPropertyType (-1218)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_GeneralConversionPropertyType
{
        #define SOAP_UNION_plu__gml__union_GeneralConversionPropertyType_Conversion	(1)	/**< union variant selector value for member Conversion */
        gml__ConversionType *Conversion;
};
#endif

/* PlannedLandUse_v3.0.h:10649 */
#ifndef SOAP_TYPE_plu___gml__GeneralConversionPropertyType_sequence
#define SOAP_TYPE_plu___gml__GeneralConversionPropertyType_sequence (-1217)
/* Wrapper: */
class SOAP_CMAC __gml__GeneralConversionPropertyType_sequence {
      public:
        /// Union with union _gml__union_GeneralConversionPropertyType variant selector __unionAbstractGeneralConversion set to one of: SOAP_UNION_plu__gml__union_GeneralConversionPropertyType_Conversion
        int __unionAbstractGeneralConversion;
        union _gml__union_GeneralConversionPropertyType union_GeneralConversionPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__GeneralConversionPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__GeneralConversionPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__GeneralConversionPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__GeneralConversionPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__GeneralConversionPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__GeneralConversionPropertyType_sequence() : __unionAbstractGeneralConversion() { }
        virtual ~__gml__GeneralConversionPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__GeneralConversionPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__GeneralConversionPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__GeneralConversionPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1214 */
#ifndef SOAP_TYPE_plu_gml__GeneralConversionPropertyType
#define SOAP_TYPE_plu_gml__GeneralConversionPropertyType (-359)
/* complex XML schema type 'gml:GeneralConversionPropertyType': */
class SOAP_CMAC gml__GeneralConversionPropertyType : public xsd__anyType {
      public:
        __gml__GeneralConversionPropertyType_sequence *__GeneralConversionPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GeneralConversionPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GeneralConversionPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeneralConversionPropertyType, default initialized and not managed by a soap context
        virtual gml__GeneralConversionPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GeneralConversionPropertyType); }
      public:
        /// Constructor with default initializations
        gml__GeneralConversionPropertyType() : __GeneralConversionPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__GeneralConversionPropertyType() { }
        /// Friend allocator used by soap_new_gml__GeneralConversionPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeneralConversionPropertyType * SOAP_FMAC2 soap_instantiate_gml__GeneralConversionPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:10725 */
#ifndef SOAP_TYPE_plu__gml__union_GeneralTransformationPropertyType
#define SOAP_TYPE_plu__gml__union_GeneralTransformationPropertyType (-1222)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_GeneralTransformationPropertyType
{
        #define SOAP_UNION_plu__gml__union_GeneralTransformationPropertyType_Transformation	(1)	/**< union variant selector value for member Transformation */
        gml__TransformationType *Transformation;
};
#endif

/* PlannedLandUse_v3.0.h:10714 */
#ifndef SOAP_TYPE_plu___gml__GeneralTransformationPropertyType_sequence
#define SOAP_TYPE_plu___gml__GeneralTransformationPropertyType_sequence (-1221)
/* Wrapper: */
class SOAP_CMAC __gml__GeneralTransformationPropertyType_sequence {
      public:
        /// Union with union _gml__union_GeneralTransformationPropertyType variant selector __unionAbstractGeneralTransformation set to one of: SOAP_UNION_plu__gml__union_GeneralTransformationPropertyType_Transformation
        int __unionAbstractGeneralTransformation;
        union _gml__union_GeneralTransformationPropertyType union_GeneralTransformationPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__GeneralTransformationPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__GeneralTransformationPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__GeneralTransformationPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__GeneralTransformationPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__GeneralTransformationPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__GeneralTransformationPropertyType_sequence() : __unionAbstractGeneralTransformation() { }
        virtual ~__gml__GeneralTransformationPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__GeneralTransformationPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__GeneralTransformationPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__GeneralTransformationPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1220 */
#ifndef SOAP_TYPE_plu_gml__GeneralTransformationPropertyType
#define SOAP_TYPE_plu_gml__GeneralTransformationPropertyType (-361)
/* complex XML schema type 'gml:GeneralTransformationPropertyType': */
class SOAP_CMAC gml__GeneralTransformationPropertyType : public xsd__anyType {
      public:
        __gml__GeneralTransformationPropertyType_sequence *__GeneralTransformationPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GeneralTransformationPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GeneralTransformationPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeneralTransformationPropertyType, default initialized and not managed by a soap context
        virtual gml__GeneralTransformationPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GeneralTransformationPropertyType); }
      public:
        /// Constructor with default initializations
        gml__GeneralTransformationPropertyType() : __GeneralTransformationPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__GeneralTransformationPropertyType() { }
        /// Friend allocator used by soap_new_gml__GeneralTransformationPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeneralTransformationPropertyType * SOAP_FMAC2 soap_instantiate_gml__GeneralTransformationPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:10779 */
#ifndef SOAP_TYPE_plu___gml__ConcatenatedOperationPropertyType_sequence
#define SOAP_TYPE_plu___gml__ConcatenatedOperationPropertyType_sequence (-1225)
/* Wrapper: */
class SOAP_CMAC __gml__ConcatenatedOperationPropertyType_sequence {
      public:
        /// Required element 'gml:ConcatenatedOperation' of XML schema type 'gml:ConcatenatedOperationType'
        gml__ConcatenatedOperationType *ConcatenatedOperation;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__ConcatenatedOperationPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__ConcatenatedOperationPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__ConcatenatedOperationPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__ConcatenatedOperationPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__ConcatenatedOperationPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__ConcatenatedOperationPropertyType_sequence() : ConcatenatedOperation() { }
        virtual ~__gml__ConcatenatedOperationPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__ConcatenatedOperationPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__ConcatenatedOperationPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__ConcatenatedOperationPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1226 */
#ifndef SOAP_TYPE_plu_gml__ConcatenatedOperationPropertyType
#define SOAP_TYPE_plu_gml__ConcatenatedOperationPropertyType (-363)
/* complex XML schema type 'gml:ConcatenatedOperationPropertyType': */
class SOAP_CMAC gml__ConcatenatedOperationPropertyType : public xsd__anyType {
      public:
        __gml__ConcatenatedOperationPropertyType_sequence *__ConcatenatedOperationPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ConcatenatedOperationPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ConcatenatedOperationPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ConcatenatedOperationPropertyType, default initialized and not managed by a soap context
        virtual gml__ConcatenatedOperationPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ConcatenatedOperationPropertyType); }
      public:
        /// Constructor with default initializations
        gml__ConcatenatedOperationPropertyType() : __ConcatenatedOperationPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__ConcatenatedOperationPropertyType() { }
        /// Friend allocator used by soap_new_gml__ConcatenatedOperationPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__ConcatenatedOperationPropertyType * SOAP_FMAC2 soap_instantiate_gml__ConcatenatedOperationPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:10827 */
#ifndef SOAP_TYPE_plu___gml__PassThroughOperationPropertyType_sequence
#define SOAP_TYPE_plu___gml__PassThroughOperationPropertyType_sequence (-1227)
/* Wrapper: */
class SOAP_CMAC __gml__PassThroughOperationPropertyType_sequence {
      public:
        /// Required element 'gml:PassThroughOperation' of XML schema type 'gml:PassThroughOperationType'
        gml__PassThroughOperationType *PassThroughOperation;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__PassThroughOperationPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__PassThroughOperationPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__PassThroughOperationPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__PassThroughOperationPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__PassThroughOperationPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__PassThroughOperationPropertyType_sequence() : PassThroughOperation() { }
        virtual ~__gml__PassThroughOperationPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__PassThroughOperationPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__PassThroughOperationPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__PassThroughOperationPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1232 */
#ifndef SOAP_TYPE_plu_gml__PassThroughOperationPropertyType
#define SOAP_TYPE_plu_gml__PassThroughOperationPropertyType (-365)
/* complex XML schema type 'gml:PassThroughOperationPropertyType': */
class SOAP_CMAC gml__PassThroughOperationPropertyType : public xsd__anyType {
      public:
        __gml__PassThroughOperationPropertyType_sequence *__PassThroughOperationPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__PassThroughOperationPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__PassThroughOperationPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__PassThroughOperationPropertyType, default initialized and not managed by a soap context
        virtual gml__PassThroughOperationPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__PassThroughOperationPropertyType); }
      public:
        /// Constructor with default initializations
        gml__PassThroughOperationPropertyType() : __PassThroughOperationPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__PassThroughOperationPropertyType() { }
        /// Friend allocator used by soap_new_gml__PassThroughOperationPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__PassThroughOperationPropertyType * SOAP_FMAC2 soap_instantiate_gml__PassThroughOperationPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:10879 */
#ifndef SOAP_TYPE_plu___gml__ConversionPropertyType_sequence
#define SOAP_TYPE_plu___gml__ConversionPropertyType_sequence (-1229)
/* Wrapper: */
class SOAP_CMAC __gml__ConversionPropertyType_sequence {
      public:
        /// Required element 'gml:Conversion' of XML schema type 'gml:ConversionType'
        gml__ConversionType *Conversion;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__ConversionPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__ConversionPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__ConversionPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__ConversionPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__ConversionPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__ConversionPropertyType_sequence() : Conversion() { }
        virtual ~__gml__ConversionPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__ConversionPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__ConversionPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__ConversionPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1238 */
#ifndef SOAP_TYPE_plu_gml__ConversionPropertyType
#define SOAP_TYPE_plu_gml__ConversionPropertyType (-367)
/* complex XML schema type 'gml:ConversionPropertyType': */
class SOAP_CMAC gml__ConversionPropertyType : public xsd__anyType {
      public:
        __gml__ConversionPropertyType_sequence *__ConversionPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ConversionPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ConversionPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ConversionPropertyType, default initialized and not managed by a soap context
        virtual gml__ConversionPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ConversionPropertyType); }
      public:
        /// Constructor with default initializations
        gml__ConversionPropertyType() : __ConversionPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__ConversionPropertyType() { }
        /// Friend allocator used by soap_new_gml__ConversionPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__ConversionPropertyType * SOAP_FMAC2 soap_instantiate_gml__ConversionPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:10932 */
#ifndef SOAP_TYPE_plu___gml__TransformationPropertyType_sequence
#define SOAP_TYPE_plu___gml__TransformationPropertyType_sequence (-1231)
/* Wrapper: */
class SOAP_CMAC __gml__TransformationPropertyType_sequence {
      public:
        /// Required element 'gml:Transformation' of XML schema type 'gml:TransformationType'
        gml__TransformationType *Transformation;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__TransformationPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__TransformationPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__TransformationPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__TransformationPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__TransformationPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__TransformationPropertyType_sequence() : Transformation() { }
        virtual ~__gml__TransformationPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__TransformationPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__TransformationPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__TransformationPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1244 */
#ifndef SOAP_TYPE_plu_gml__TransformationPropertyType
#define SOAP_TYPE_plu_gml__TransformationPropertyType (-369)
/* complex XML schema type 'gml:TransformationPropertyType': */
class SOAP_CMAC gml__TransformationPropertyType : public xsd__anyType {
      public:
        __gml__TransformationPropertyType_sequence *__TransformationPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TransformationPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TransformationPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TransformationPropertyType, default initialized and not managed by a soap context
        virtual gml__TransformationPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TransformationPropertyType); }
      public:
        /// Constructor with default initializations
        gml__TransformationPropertyType() : __TransformationPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__TransformationPropertyType() { }
        /// Friend allocator used by soap_new_gml__TransformationPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TransformationPropertyType * SOAP_FMAC2 soap_instantiate_gml__TransformationPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1247 */
#ifndef SOAP_TYPE_plu_gml__AbstractGeneralParameterValueType
#define SOAP_TYPE_plu_gml__AbstractGeneralParameterValueType (-370)
/* simple XML schema type 'gml:AbstractGeneralParameterValueType': */
class SOAP_CMAC gml__AbstractGeneralParameterValueType : public xsd__anyType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractGeneralParameterValueType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractGeneralParameterValueType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractGeneralParameterValueType, default initialized and not managed by a soap context
        virtual gml__AbstractGeneralParameterValueType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractGeneralParameterValueType); }
      public:
        /// Constructor with default initializations
        gml__AbstractGeneralParameterValueType() { }
        virtual ~gml__AbstractGeneralParameterValueType() { }
        /// Friend allocator used by soap_new_gml__AbstractGeneralParameterValueType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractGeneralParameterValueType * SOAP_FMAC2 soap_instantiate_gml__AbstractGeneralParameterValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:11009 */
#ifndef SOAP_TYPE_plu__gml__union_AbstractGeneralParameterValuePropertyType
#define SOAP_TYPE_plu__gml__union_AbstractGeneralParameterValuePropertyType (-1233)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_AbstractGeneralParameterValuePropertyType
{
        #define SOAP_UNION_plu__gml__union_AbstractGeneralParameterValuePropertyType_ParameterValue	(1)	/**< union variant selector value for member ParameterValue */
        gml__ParameterValueType *ParameterValue;
        #define SOAP_UNION_plu__gml__union_AbstractGeneralParameterValuePropertyType_ParameterValueGroup	(2)	/**< union variant selector value for member ParameterValueGroup */
        gml__ParameterValueGroupType *ParameterValueGroup;
};
#endif

/* PlannedLandUse_v3.0.h:1250 */
#ifndef SOAP_TYPE_plu_gml__AbstractGeneralParameterValuePropertyType
#define SOAP_TYPE_plu_gml__AbstractGeneralParameterValuePropertyType (-371)
/* Type gml__AbstractGeneralParameterValuePropertyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gml:AbstractGeneralParameterValuePropertyType': */
class SOAP_CMAC gml__AbstractGeneralParameterValuePropertyType : public xsd__anyType {
      public:
        /// Union with union _gml__union_AbstractGeneralParameterValuePropertyType variant selector __unionAbstractGeneralParameterValue set to one of: SOAP_UNION_plu__gml__union_AbstractGeneralParameterValuePropertyType_ParameterValue SOAP_UNION_plu__gml__union_AbstractGeneralParameterValuePropertyType_ParameterValueGroup
        int __unionAbstractGeneralParameterValue;
        union _gml__union_AbstractGeneralParameterValuePropertyType union_AbstractGeneralParameterValuePropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractGeneralParameterValuePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractGeneralParameterValuePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractGeneralParameterValuePropertyType, default initialized and not managed by a soap context
        virtual gml__AbstractGeneralParameterValuePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractGeneralParameterValuePropertyType); }
      public:
        /// Constructor with default initializations
        gml__AbstractGeneralParameterValuePropertyType() : __unionAbstractGeneralParameterValue() { }
        virtual ~gml__AbstractGeneralParameterValuePropertyType() { }
        /// Friend allocator used by soap_new_gml__AbstractGeneralParameterValuePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractGeneralParameterValuePropertyType * SOAP_FMAC2 soap_instantiate_gml__AbstractGeneralParameterValuePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:11043 */
#ifndef SOAP_TYPE_plu___gml__OperationMethodPropertyType_sequence
#define SOAP_TYPE_plu___gml__OperationMethodPropertyType_sequence (-1236)
/* Wrapper: */
class SOAP_CMAC __gml__OperationMethodPropertyType_sequence {
      public:
        /// Required element 'gml:OperationMethod' of XML schema type 'gml:OperationMethodType'
        gml__OperationMethodType *OperationMethod;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__OperationMethodPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__OperationMethodPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__OperationMethodPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__OperationMethodPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__OperationMethodPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__OperationMethodPropertyType_sequence() : OperationMethod() { }
        virtual ~__gml__OperationMethodPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__OperationMethodPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__OperationMethodPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__OperationMethodPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1262 */
#ifndef SOAP_TYPE_plu_gml__OperationMethodPropertyType
#define SOAP_TYPE_plu_gml__OperationMethodPropertyType (-375)
/* complex XML schema type 'gml:OperationMethodPropertyType': */
class SOAP_CMAC gml__OperationMethodPropertyType : public xsd__anyType {
      public:
        __gml__OperationMethodPropertyType_sequence *__OperationMethodPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__OperationMethodPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__OperationMethodPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__OperationMethodPropertyType, default initialized and not managed by a soap context
        virtual gml__OperationMethodPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__OperationMethodPropertyType); }
      public:
        /// Constructor with default initializations
        gml__OperationMethodPropertyType() : __OperationMethodPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__OperationMethodPropertyType() { }
        /// Friend allocator used by soap_new_gml__OperationMethodPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__OperationMethodPropertyType * SOAP_FMAC2 soap_instantiate_gml__OperationMethodPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:11105 */
#ifndef SOAP_TYPE_plu__gml__union_AbstractGeneralOperationParameterPropertyType
#define SOAP_TYPE_plu__gml__union_AbstractGeneralOperationParameterPropertyType (-1240)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_AbstractGeneralOperationParameterPropertyType
{
        #define SOAP_UNION_plu__gml__union_AbstractGeneralOperationParameterPropertyType_OperationParameter	(1)	/**< union variant selector value for member OperationParameter */
        gml__OperationParameterType *OperationParameter;
        #define SOAP_UNION_plu__gml__union_AbstractGeneralOperationParameterPropertyType_OperationParameterGroup	(2)	/**< union variant selector value for member OperationParameterGroup */
        gml__OperationParameterGroupType *OperationParameterGroup;
};
#endif

/* PlannedLandUse_v3.0.h:11095 */
#ifndef SOAP_TYPE_plu___gml__AbstractGeneralOperationParameterPropertyType_sequence
#define SOAP_TYPE_plu___gml__AbstractGeneralOperationParameterPropertyType_sequence (-1239)
/* Wrapper: */
class SOAP_CMAC __gml__AbstractGeneralOperationParameterPropertyType_sequence {
      public:
        /// Union with union _gml__union_AbstractGeneralOperationParameterPropertyType variant selector __unionAbstractGeneralOperationParameter set to one of: SOAP_UNION_plu__gml__union_AbstractGeneralOperationParameterPropertyType_OperationParameter SOAP_UNION_plu__gml__union_AbstractGeneralOperationParameterPropertyType_OperationParameterGroup
        int __unionAbstractGeneralOperationParameter;
        union _gml__union_AbstractGeneralOperationParameterPropertyType union_AbstractGeneralOperationParameterPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__AbstractGeneralOperationParameterPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__AbstractGeneralOperationParameterPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__AbstractGeneralOperationParameterPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__AbstractGeneralOperationParameterPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__AbstractGeneralOperationParameterPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__AbstractGeneralOperationParameterPropertyType_sequence() : __unionAbstractGeneralOperationParameter() { }
        virtual ~__gml__AbstractGeneralOperationParameterPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__AbstractGeneralOperationParameterPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__AbstractGeneralOperationParameterPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__AbstractGeneralOperationParameterPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1268 */
#ifndef SOAP_TYPE_plu_gml__AbstractGeneralOperationParameterPropertyType
#define SOAP_TYPE_plu_gml__AbstractGeneralOperationParameterPropertyType (-377)
/* complex XML schema type 'gml:AbstractGeneralOperationParameterPropertyType': */
class SOAP_CMAC gml__AbstractGeneralOperationParameterPropertyType : public xsd__anyType {
      public:
        __gml__AbstractGeneralOperationParameterPropertyType_sequence *__AbstractGeneralOperationParameterPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractGeneralOperationParameterPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractGeneralOperationParameterPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractGeneralOperationParameterPropertyType, default initialized and not managed by a soap context
        virtual gml__AbstractGeneralOperationParameterPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractGeneralOperationParameterPropertyType); }
      public:
        /// Constructor with default initializations
        gml__AbstractGeneralOperationParameterPropertyType() : __AbstractGeneralOperationParameterPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__AbstractGeneralOperationParameterPropertyType() { }
        /// Friend allocator used by soap_new_gml__AbstractGeneralOperationParameterPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractGeneralOperationParameterPropertyType * SOAP_FMAC2 soap_instantiate_gml__AbstractGeneralOperationParameterPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:11163 */
#ifndef SOAP_TYPE_plu___gml__OperationParameterPropertyType_sequence
#define SOAP_TYPE_plu___gml__OperationParameterPropertyType_sequence (-1244)
/* Wrapper: */
class SOAP_CMAC __gml__OperationParameterPropertyType_sequence {
      public:
        /// Required element 'gml:OperationParameter' of XML schema type 'gml:OperationParameterType'
        gml__OperationParameterType *OperationParameter;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__OperationParameterPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__OperationParameterPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__OperationParameterPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__OperationParameterPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__OperationParameterPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__OperationParameterPropertyType_sequence() : OperationParameter() { }
        virtual ~__gml__OperationParameterPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__OperationParameterPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__OperationParameterPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__OperationParameterPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1274 */
#ifndef SOAP_TYPE_plu_gml__OperationParameterPropertyType
#define SOAP_TYPE_plu_gml__OperationParameterPropertyType (-379)
/* complex XML schema type 'gml:OperationParameterPropertyType': */
class SOAP_CMAC gml__OperationParameterPropertyType : public xsd__anyType {
      public:
        __gml__OperationParameterPropertyType_sequence *__OperationParameterPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__OperationParameterPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__OperationParameterPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__OperationParameterPropertyType, default initialized and not managed by a soap context
        virtual gml__OperationParameterPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__OperationParameterPropertyType); }
      public:
        /// Constructor with default initializations
        gml__OperationParameterPropertyType() : __OperationParameterPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__OperationParameterPropertyType() { }
        /// Friend allocator used by soap_new_gml__OperationParameterPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__OperationParameterPropertyType * SOAP_FMAC2 soap_instantiate_gml__OperationParameterPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:11214 */
#ifndef SOAP_TYPE_plu___gml__OperationParameterGroupPropertyType_sequence
#define SOAP_TYPE_plu___gml__OperationParameterGroupPropertyType_sequence (-1246)
/* Wrapper: */
class SOAP_CMAC __gml__OperationParameterGroupPropertyType_sequence {
      public:
        /// Required element 'gml:OperationParameterGroup' of XML schema type 'gml:OperationParameterGroupType'
        gml__OperationParameterGroupType *OperationParameterGroup;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__OperationParameterGroupPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__OperationParameterGroupPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__OperationParameterGroupPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__OperationParameterGroupPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__OperationParameterGroupPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__OperationParameterGroupPropertyType_sequence() : OperationParameterGroup() { }
        virtual ~__gml__OperationParameterGroupPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__OperationParameterGroupPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__OperationParameterGroupPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__OperationParameterGroupPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1280 */
#ifndef SOAP_TYPE_plu_gml__OperationParameterGroupPropertyType
#define SOAP_TYPE_plu_gml__OperationParameterGroupPropertyType (-381)
/* complex XML schema type 'gml:OperationParameterGroupPropertyType': */
class SOAP_CMAC gml__OperationParameterGroupPropertyType : public xsd__anyType {
      public:
        __gml__OperationParameterGroupPropertyType_sequence *__OperationParameterGroupPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__OperationParameterGroupPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__OperationParameterGroupPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__OperationParameterGroupPropertyType, default initialized and not managed by a soap context
        virtual gml__OperationParameterGroupPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__OperationParameterGroupPropertyType); }
      public:
        /// Constructor with default initializations
        gml__OperationParameterGroupPropertyType() : __OperationParameterGroupPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__OperationParameterGroupPropertyType() { }
        /// Friend allocator used by soap_new_gml__OperationParameterGroupPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__OperationParameterGroupPropertyType * SOAP_FMAC2 soap_instantiate_gml__OperationParameterGroupPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:11273 */
#ifndef SOAP_TYPE_plu__gml__union_ProcedurePropertyType
#define SOAP_TYPE_plu__gml__union_ProcedurePropertyType (-1249)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ProcedurePropertyType
{
        #define SOAP_UNION_plu__gml__union_ProcedurePropertyType_DynamicFeature	(1)	/**< union variant selector value for member DynamicFeature */
        gml__DynamicFeatureType *DynamicFeature;
        #define SOAP_UNION_plu__gml__union_ProcedurePropertyType_DynamicFeatureCollection	(2)	/**< union variant selector value for member DynamicFeatureCollection */
        gml__DynamicFeatureCollectionType *DynamicFeatureCollection;
        #define SOAP_UNION_plu__gml__union_ProcedurePropertyType_Observation	(3)	/**< union variant selector value for member Observation */
        gml__ObservationType *Observation;
        #define SOAP_UNION_plu__gml__union_ProcedurePropertyType_DirectedObservation	(4)	/**< union variant selector value for member DirectedObservation */
        gml__DirectedObservationType *DirectedObservation;
        #define SOAP_UNION_plu__gml__union_ProcedurePropertyType_DirectedObservationAtDistance	(5)	/**< union variant selector value for member DirectedObservationAtDistance */
        gml__DirectedObservationAtDistanceType *DirectedObservationAtDistance;
        #define SOAP_UNION_plu__gml__union_ProcedurePropertyType_FeatureCollection	(6)	/**< union variant selector value for member FeatureCollection */
        gml__FeatureCollectionType *FeatureCollection;
        #define SOAP_UNION_plu__gml__union_ProcedurePropertyType_base__SpatialDataSet	(7)	/**< union variant selector value for member base__SpatialDataSet */
        base__SpatialDataSetType *base__SpatialDataSet;
        #define SOAP_UNION_plu__gml__union_ProcedurePropertyType_plu__ZoningElement	(8)	/**< union variant selector value for member plu__ZoningElement */
        plu__ZoningElementType *plu__ZoningElement;
        #define SOAP_UNION_plu__gml__union_ProcedurePropertyType_plu__OfficialDocumentation	(9)	/**< union variant selector value for member plu__OfficialDocumentation */
        plu__OfficialDocumentationType *plu__OfficialDocumentation;
        #define SOAP_UNION_plu__gml__union_ProcedurePropertyType_plu__SupplementaryRegulation	(10)	/**< union variant selector value for member plu__SupplementaryRegulation */
        plu__SupplementaryRegulationType *plu__SupplementaryRegulation;
        #define SOAP_UNION_plu__gml__union_ProcedurePropertyType_plu__SpatialPlan	(11)	/**< union variant selector value for member plu__SpatialPlan */
        plu__SpatialPlanType *plu__SpatialPlan;
};
#endif

/* PlannedLandUse_v3.0.h:11263 */
#ifndef SOAP_TYPE_plu___gml__ProcedurePropertyType_sequence
#define SOAP_TYPE_plu___gml__ProcedurePropertyType_sequence (-1248)
/* Wrapper: */
class SOAP_CMAC __gml__ProcedurePropertyType_sequence {
      public:
        /// Union with union _gml__union_ProcedurePropertyType variant selector __unionAbstractFeature set to one of: SOAP_UNION_plu__gml__union_ProcedurePropertyType_DynamicFeature SOAP_UNION_plu__gml__union_ProcedurePropertyType_DynamicFeatureCollection SOAP_UNION_plu__gml__union_ProcedurePropertyType_Observation SOAP_UNION_plu__gml__union_ProcedurePropertyType_DirectedObservation SOAP_UNION_plu__gml__union_ProcedurePropertyType_DirectedObservationAtDistance SOAP_UNION_plu__gml__union_ProcedurePropertyType_FeatureCollection SOAP_UNION_plu__gml__union_ProcedurePropertyType_base__SpatialDataSet SOAP_UNION_plu__gml__union_ProcedurePropertyType_plu__ZoningElement SOAP_UNION_plu__gml__union_ProcedurePropertyType_plu__OfficialDocumentation SOAP_UNION_plu__gml__union_ProcedurePropertyType_plu__SupplementaryRegulation SOAP_UNION_plu__gml__union_ProcedurePropertyType_plu__SpatialPlan
        int __unionAbstractFeature;
        union _gml__union_ProcedurePropertyType union_ProcedurePropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__ProcedurePropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__ProcedurePropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__ProcedurePropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__ProcedurePropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__ProcedurePropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__ProcedurePropertyType_sequence() : __unionAbstractFeature() { }
        virtual ~__gml__ProcedurePropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__ProcedurePropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__ProcedurePropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__ProcedurePropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1286 */
#ifndef SOAP_TYPE_plu_gml__ProcedurePropertyType
#define SOAP_TYPE_plu_gml__ProcedurePropertyType (-383)
/* complex XML schema type 'gml:ProcedurePropertyType': */
class SOAP_CMAC gml__ProcedurePropertyType : public xsd__anyType {
      public:
        __gml__ProcedurePropertyType_sequence *__ProcedurePropertyType_sequence;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ProcedurePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ProcedurePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ProcedurePropertyType, default initialized and not managed by a soap context
        virtual gml__ProcedurePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ProcedurePropertyType); }
      public:
        /// Constructor with default initializations
        gml__ProcedurePropertyType() : __ProcedurePropertyType_sequence(), owns((bool)0), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__ProcedurePropertyType() { }
        /// Friend allocator used by soap_new_gml__ProcedurePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__ProcedurePropertyType * SOAP_FMAC2 soap_instantiate_gml__ProcedurePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:11473 */
#ifndef SOAP_TYPE_plu__gml__union_TargetPropertyType
#define SOAP_TYPE_plu__gml__union_TargetPropertyType (-1251)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_TargetPropertyType
{
        #define SOAP_UNION_plu__gml__union_TargetPropertyType_DynamicFeature	(1)	/**< union variant selector value for member DynamicFeature */
        gml__DynamicFeatureType *DynamicFeature;
        #define SOAP_UNION_plu__gml__union_TargetPropertyType_DynamicFeatureCollection	(2)	/**< union variant selector value for member DynamicFeatureCollection */
        gml__DynamicFeatureCollectionType *DynamicFeatureCollection;
        #define SOAP_UNION_plu__gml__union_TargetPropertyType_Observation	(3)	/**< union variant selector value for member Observation */
        gml__ObservationType *Observation;
        #define SOAP_UNION_plu__gml__union_TargetPropertyType_DirectedObservation	(4)	/**< union variant selector value for member DirectedObservation */
        gml__DirectedObservationType *DirectedObservation;
        #define SOAP_UNION_plu__gml__union_TargetPropertyType_DirectedObservationAtDistance	(5)	/**< union variant selector value for member DirectedObservationAtDistance */
        gml__DirectedObservationAtDistanceType *DirectedObservationAtDistance;
        #define SOAP_UNION_plu__gml__union_TargetPropertyType_FeatureCollection	(6)	/**< union variant selector value for member FeatureCollection */
        gml__FeatureCollectionType *FeatureCollection;
        #define SOAP_UNION_plu__gml__union_TargetPropertyType_base__SpatialDataSet	(7)	/**< union variant selector value for member base__SpatialDataSet */
        base__SpatialDataSetType *base__SpatialDataSet;
        #define SOAP_UNION_plu__gml__union_TargetPropertyType_plu__ZoningElement	(8)	/**< union variant selector value for member plu__ZoningElement */
        plu__ZoningElementType *plu__ZoningElement;
        #define SOAP_UNION_plu__gml__union_TargetPropertyType_plu__OfficialDocumentation	(9)	/**< union variant selector value for member plu__OfficialDocumentation */
        plu__OfficialDocumentationType *plu__OfficialDocumentation;
        #define SOAP_UNION_plu__gml__union_TargetPropertyType_plu__SupplementaryRegulation	(10)	/**< union variant selector value for member plu__SupplementaryRegulation */
        plu__SupplementaryRegulationType *plu__SupplementaryRegulation;
        #define SOAP_UNION_plu__gml__union_TargetPropertyType_plu__SpatialPlan	(11)	/**< union variant selector value for member plu__SpatialPlan */
        plu__SpatialPlanType *plu__SpatialPlan;
        #define SOAP_UNION_plu__gml__union_TargetPropertyType_GeometricComplex	(12)	/**< union variant selector value for member GeometricComplex */
        gml__GeometricComplexType *GeometricComplex;
};
#endif

/* PlannedLandUse_v3.0.h:1289 */
#ifndef SOAP_TYPE_plu_gml__TargetPropertyType
#define SOAP_TYPE_plu_gml__TargetPropertyType (-384)
/* complex XML schema type 'gml:TargetPropertyType': */
class SOAP_CMAC gml__TargetPropertyType : public xsd__anyType {
      public:
        /// Union with union _gml__union_TargetPropertyType variant selector __union_TargetPropertyType set to one of: SOAP_UNION_plu__gml__union_TargetPropertyType_DynamicFeature SOAP_UNION_plu__gml__union_TargetPropertyType_DynamicFeatureCollection SOAP_UNION_plu__gml__union_TargetPropertyType_Observation SOAP_UNION_plu__gml__union_TargetPropertyType_DirectedObservation SOAP_UNION_plu__gml__union_TargetPropertyType_DirectedObservationAtDistance SOAP_UNION_plu__gml__union_TargetPropertyType_FeatureCollection SOAP_UNION_plu__gml__union_TargetPropertyType_base__SpatialDataSet SOAP_UNION_plu__gml__union_TargetPropertyType_plu__ZoningElement SOAP_UNION_plu__gml__union_TargetPropertyType_plu__OfficialDocumentation SOAP_UNION_plu__gml__union_TargetPropertyType_plu__SupplementaryRegulation SOAP_UNION_plu__gml__union_TargetPropertyType_plu__SpatialPlan SOAP_UNION_plu__gml__union_TargetPropertyType_GeometricComplex
        int __union_TargetPropertyType;
        union _gml__union_TargetPropertyType union_TargetPropertyType;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TargetPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TargetPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TargetPropertyType, default initialized and not managed by a soap context
        virtual gml__TargetPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TargetPropertyType); }
      public:
        /// Constructor with default initializations
        gml__TargetPropertyType() : __union_TargetPropertyType(), owns((bool)0), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__TargetPropertyType() { }
        /// Friend allocator used by soap_new_gml__TargetPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TargetPropertyType * SOAP_FMAC2 soap_instantiate_gml__TargetPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:11682 */
#ifndef SOAP_TYPE_plu___gml__ResultType_sequence
#define SOAP_TYPE_plu___gml__ResultType_sequence (-1252)
/* Wrapper: */
class SOAP_CMAC __gml__ResultType_sequence {
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__ResultType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__ResultType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__ResultType_sequence, default initialized and not managed by a soap context
        virtual __gml__ResultType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__ResultType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__ResultType_sequence() { }
        virtual ~__gml__ResultType_sequence() { }
        /// Friend allocator used by soap_new___gml__ResultType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__ResultType_sequence * SOAP_FMAC2 soap_instantiate___gml__ResultType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1292 */
#ifndef SOAP_TYPE_plu_gml__ResultType
#define SOAP_TYPE_plu_gml__ResultType (-385)
/* complex XML schema type 'gml:ResultType': */
class SOAP_CMAC gml__ResultType : public xsd__anyType {
      public:
        __gml__ResultType_sequence *__ResultType_sequence;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ResultType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ResultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ResultType, default initialized and not managed by a soap context
        virtual gml__ResultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ResultType); }
      public:
        /// Constructor with default initializations
        gml__ResultType() : __ResultType_sequence(), owns((bool)0), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__ResultType() { }
        /// Friend allocator used by soap_new_gml__ResultType(struct soap*, int)
        friend SOAP_FMAC1 gml__ResultType * SOAP_FMAC2 soap_instantiate_gml__ResultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:11738 */
#ifndef SOAP_TYPE_plu__gml__union_DirectionPropertyType
#define SOAP_TYPE_plu__gml__union_DirectionPropertyType (-1254)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_DirectionPropertyType
{
        #define SOAP_UNION_plu__gml__union_DirectionPropertyType_DirectionVector	(1)	/**< union variant selector value for member DirectionVector */
        gml__DirectionVectorType *DirectionVector;
        #define SOAP_UNION_plu__gml__union_DirectionPropertyType_DirectionDescription	(2)	/**< union variant selector value for member DirectionDescription */
        gml__DirectionDescriptionType *DirectionDescription;
        #define SOAP_UNION_plu__gml__union_DirectionPropertyType_CompassPoint	(3)	/**< union variant selector value for member CompassPoint */
        enum gml__CompassPointEnumeration CompassPoint;
        #define SOAP_UNION_plu__gml__union_DirectionPropertyType_DirectionKeyword	(4)	/**< union variant selector value for member DirectionKeyword */
        gml__CodeType *DirectionKeyword;
        #define SOAP_UNION_plu__gml__union_DirectionPropertyType_DirectionString	(5)	/**< union variant selector value for member DirectionString */
        gml__StringOrRefType *DirectionString;
};
#endif

/* PlannedLandUse_v3.0.h:1301 */
#ifndef SOAP_TYPE_plu_gml__DirectionPropertyType
#define SOAP_TYPE_plu_gml__DirectionPropertyType (-388)
/* complex XML schema type 'gml:DirectionPropertyType': */
class SOAP_CMAC gml__DirectionPropertyType : public xsd__anyType {
      public:
        /// Union with union _gml__union_DirectionPropertyType variant selector __union_DirectionPropertyType set to one of: SOAP_UNION_plu__gml__union_DirectionPropertyType_DirectionVector SOAP_UNION_plu__gml__union_DirectionPropertyType_DirectionDescription SOAP_UNION_plu__gml__union_DirectionPropertyType_CompassPoint SOAP_UNION_plu__gml__union_DirectionPropertyType_DirectionKeyword SOAP_UNION_plu__gml__union_DirectionPropertyType_DirectionString
        int __union_DirectionPropertyType;
        union _gml__union_DirectionPropertyType union_DirectionPropertyType;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DirectionPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DirectionPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DirectionPropertyType, default initialized and not managed by a soap context
        virtual gml__DirectionPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DirectionPropertyType); }
      public:
        /// Constructor with default initializations
        gml__DirectionPropertyType() : __union_DirectionPropertyType(), owns((bool)0), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__DirectionPropertyType() { }
        /// Friend allocator used by soap_new_gml__DirectionPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__DirectionPropertyType * SOAP_FMAC2 soap_instantiate_gml__DirectionPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1304 */
#ifndef SOAP_TYPE_plu_gml__DirectionVectorType
#define SOAP_TYPE_plu_gml__DirectionVectorType (-389)
/* complex XML schema type 'gml:DirectionVectorType': */
class SOAP_CMAC gml__DirectionVectorType : public xsd__anyType {
      public:
        /// Optional element 'gml:vector' of XML schema type 'gml:VectorType'
        gml__VectorType *vector;
        /// Optional element 'gml:horizontalAngle' of XML schema type 'gml:AngleType'
        gml__AngleType *horizontalAngle;
        /// Optional element 'gml:verticalAngle' of XML schema type 'gml:AngleType'
        gml__AngleType *verticalAngle;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DirectionVectorType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DirectionVectorType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DirectionVectorType, default initialized and not managed by a soap context
        virtual gml__DirectionVectorType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DirectionVectorType); }
      public:
        /// Constructor with default initializations
        gml__DirectionVectorType() : vector(), horizontalAngle(), verticalAngle() { }
        virtual ~gml__DirectionVectorType() { }
        /// Friend allocator used by soap_new_gml__DirectionVectorType(struct soap*, int)
        friend SOAP_FMAC1 gml__DirectionVectorType * SOAP_FMAC2 soap_instantiate_gml__DirectionVectorType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:11831 */
#ifndef SOAP_TYPE_plu__gml__union_DirectionDescriptionType
#define SOAP_TYPE_plu__gml__union_DirectionDescriptionType (-1258)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_DirectionDescriptionType
{
        #define SOAP_UNION_plu__gml__union_DirectionDescriptionType_compassPoint	(1)	/**< union variant selector value for member compassPoint */
        enum gml__CompassPointEnumeration compassPoint;
        #define SOAP_UNION_plu__gml__union_DirectionDescriptionType_keyword	(2)	/**< union variant selector value for member keyword */
        gml__CodeType *keyword;
        #define SOAP_UNION_plu__gml__union_DirectionDescriptionType_description	(3)	/**< union variant selector value for member description */
        std::string *description;
        #define SOAP_UNION_plu__gml__union_DirectionDescriptionType_reference	(4)	/**< union variant selector value for member reference */
        gml__ReferenceType *reference;
};
#endif

/* PlannedLandUse_v3.0.h:1307 */
#ifndef SOAP_TYPE_plu_gml__DirectionDescriptionType
#define SOAP_TYPE_plu_gml__DirectionDescriptionType (-390)
/* complex XML schema type 'gml:DirectionDescriptionType': */
class SOAP_CMAC gml__DirectionDescriptionType : public xsd__anyType {
      public:
        /// Union with union _gml__union_DirectionDescriptionType variant selector __union_DirectionDescriptionType set to one of: SOAP_UNION_plu__gml__union_DirectionDescriptionType_compassPoint SOAP_UNION_plu__gml__union_DirectionDescriptionType_keyword SOAP_UNION_plu__gml__union_DirectionDescriptionType_description SOAP_UNION_plu__gml__union_DirectionDescriptionType_reference
        int __union_DirectionDescriptionType;
        union _gml__union_DirectionDescriptionType union_DirectionDescriptionType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DirectionDescriptionType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DirectionDescriptionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DirectionDescriptionType, default initialized and not managed by a soap context
        virtual gml__DirectionDescriptionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DirectionDescriptionType); }
      public:
        /// Constructor with default initializations
        gml__DirectionDescriptionType() : __union_DirectionDescriptionType() { }
        virtual ~gml__DirectionDescriptionType() { }
        /// Friend allocator used by soap_new_gml__DirectionDescriptionType(struct soap*, int)
        friend SOAP_FMAC1 gml__DirectionDescriptionType * SOAP_FMAC2 soap_instantiate_gml__DirectionDescriptionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:11862 */
#ifndef SOAP_TYPE_plu___gml__TimeCalendarPropertyType_sequence
#define SOAP_TYPE_plu___gml__TimeCalendarPropertyType_sequence (-1259)
/* Wrapper: */
class SOAP_CMAC __gml__TimeCalendarPropertyType_sequence {
      public:
        /// Required element 'gml:TimeCalendar' of XML schema type 'gml:TimeCalendarType'
        gml__TimeCalendarType *TimeCalendar;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__TimeCalendarPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__TimeCalendarPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__TimeCalendarPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__TimeCalendarPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__TimeCalendarPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__TimeCalendarPropertyType_sequence() : TimeCalendar() { }
        virtual ~__gml__TimeCalendarPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__TimeCalendarPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__TimeCalendarPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__TimeCalendarPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1322 */
#ifndef SOAP_TYPE_plu_gml__TimeCalendarPropertyType
#define SOAP_TYPE_plu_gml__TimeCalendarPropertyType (-395)
/* complex XML schema type 'gml:TimeCalendarPropertyType': */
class SOAP_CMAC gml__TimeCalendarPropertyType : public xsd__anyType {
      public:
        __gml__TimeCalendarPropertyType_sequence *__TimeCalendarPropertyType_sequence;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeCalendarPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeCalendarPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeCalendarPropertyType, default initialized and not managed by a soap context
        virtual gml__TimeCalendarPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeCalendarPropertyType); }
      public:
        /// Constructor with default initializations
        gml__TimeCalendarPropertyType() : __TimeCalendarPropertyType_sequence(), owns((bool)0), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__TimeCalendarPropertyType() { }
        /// Friend allocator used by soap_new_gml__TimeCalendarPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeCalendarPropertyType * SOAP_FMAC2 soap_instantiate_gml__TimeCalendarPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:11918 */
#ifndef SOAP_TYPE_plu___gml__TimeCalendarEraPropertyType_sequence
#define SOAP_TYPE_plu___gml__TimeCalendarEraPropertyType_sequence (-1262)
/* Wrapper: */
class SOAP_CMAC __gml__TimeCalendarEraPropertyType_sequence {
      public:
        /// Required element 'gml:TimeCalendarEra' of XML schema type 'gml:TimeCalendarEraType'
        gml__TimeCalendarEraType *TimeCalendarEra;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__TimeCalendarEraPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__TimeCalendarEraPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__TimeCalendarEraPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__TimeCalendarEraPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__TimeCalendarEraPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__TimeCalendarEraPropertyType_sequence() : TimeCalendarEra() { }
        virtual ~__gml__TimeCalendarEraPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__TimeCalendarEraPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__TimeCalendarEraPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__TimeCalendarEraPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1325 */
#ifndef SOAP_TYPE_plu_gml__TimeCalendarEraPropertyType
#define SOAP_TYPE_plu_gml__TimeCalendarEraPropertyType (-396)
/* complex XML schema type 'gml:TimeCalendarEraPropertyType': */
class SOAP_CMAC gml__TimeCalendarEraPropertyType : public xsd__anyType {
      public:
        __gml__TimeCalendarEraPropertyType_sequence *__TimeCalendarEraPropertyType_sequence;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeCalendarEraPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeCalendarEraPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeCalendarEraPropertyType, default initialized and not managed by a soap context
        virtual gml__TimeCalendarEraPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeCalendarEraPropertyType); }
      public:
        /// Constructor with default initializations
        gml__TimeCalendarEraPropertyType() : __TimeCalendarEraPropertyType_sequence(), owns((bool)0), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__TimeCalendarEraPropertyType() { }
        /// Friend allocator used by soap_new_gml__TimeCalendarEraPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeCalendarEraPropertyType * SOAP_FMAC2 soap_instantiate_gml__TimeCalendarEraPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:11977 */
#ifndef SOAP_TYPE_plu___gml__TimeClockPropertyType_sequence
#define SOAP_TYPE_plu___gml__TimeClockPropertyType_sequence (-1265)
/* Wrapper: */
class SOAP_CMAC __gml__TimeClockPropertyType_sequence {
      public:
        /// Required element 'gml:TimeClock' of XML schema type 'gml:TimeClockType'
        gml__TimeClockType *TimeClock;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__TimeClockPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__TimeClockPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__TimeClockPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__TimeClockPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__TimeClockPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__TimeClockPropertyType_sequence() : TimeClock() { }
        virtual ~__gml__TimeClockPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__TimeClockPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__TimeClockPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__TimeClockPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1331 */
#ifndef SOAP_TYPE_plu_gml__TimeClockPropertyType
#define SOAP_TYPE_plu_gml__TimeClockPropertyType (-398)
/* complex XML schema type 'gml:TimeClockPropertyType': */
class SOAP_CMAC gml__TimeClockPropertyType : public xsd__anyType {
      public:
        __gml__TimeClockPropertyType_sequence *__TimeClockPropertyType_sequence;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeClockPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeClockPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeClockPropertyType, default initialized and not managed by a soap context
        virtual gml__TimeClockPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeClockPropertyType); }
      public:
        /// Constructor with default initializations
        gml__TimeClockPropertyType() : __TimeClockPropertyType_sequence(), owns((bool)0), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__TimeClockPropertyType() { }
        /// Friend allocator used by soap_new_gml__TimeClockPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeClockPropertyType * SOAP_FMAC2 soap_instantiate_gml__TimeClockPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:12036 */
#ifndef SOAP_TYPE_plu___gml__TimeOrdinalEraPropertyType_sequence
#define SOAP_TYPE_plu___gml__TimeOrdinalEraPropertyType_sequence (-1268)
/* Wrapper: */
class SOAP_CMAC __gml__TimeOrdinalEraPropertyType_sequence {
      public:
        /// Required element 'gml:TimeOrdinalEra' of XML schema type 'gml:TimeOrdinalEraType'
        gml__TimeOrdinalEraType *TimeOrdinalEra;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__TimeOrdinalEraPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__TimeOrdinalEraPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__TimeOrdinalEraPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__TimeOrdinalEraPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__TimeOrdinalEraPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__TimeOrdinalEraPropertyType_sequence() : TimeOrdinalEra() { }
        virtual ~__gml__TimeOrdinalEraPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__TimeOrdinalEraPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__TimeOrdinalEraPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__TimeOrdinalEraPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1340 */
#ifndef SOAP_TYPE_plu_gml__TimeOrdinalEraPropertyType
#define SOAP_TYPE_plu_gml__TimeOrdinalEraPropertyType (-401)
/* Type gml__TimeOrdinalEraPropertyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gml:TimeOrdinalEraPropertyType': */
class SOAP_CMAC gml__TimeOrdinalEraPropertyType : public xsd__anyType {
      public:
        __gml__TimeOrdinalEraPropertyType_sequence *__TimeOrdinalEraPropertyType_sequence;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeOrdinalEraPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeOrdinalEraPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeOrdinalEraPropertyType, default initialized and not managed by a soap context
        virtual gml__TimeOrdinalEraPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeOrdinalEraPropertyType); }
      public:
        /// Constructor with default initializations
        gml__TimeOrdinalEraPropertyType() : __TimeOrdinalEraPropertyType_sequence(), owns((bool)0), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__TimeOrdinalEraPropertyType() { }
        /// Friend allocator used by soap_new_gml__TimeOrdinalEraPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeOrdinalEraPropertyType * SOAP_FMAC2 soap_instantiate_gml__TimeOrdinalEraPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:12104 */
#ifndef SOAP_TYPE_plu__gml__union_TimeTopologyPrimitivePropertyType
#define SOAP_TYPE_plu__gml__union_TimeTopologyPrimitivePropertyType (-1272)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_TimeTopologyPrimitivePropertyType
{
        #define SOAP_UNION_plu__gml__union_TimeTopologyPrimitivePropertyType_TimeNode	(1)	/**< union variant selector value for member TimeNode */
        gml__TimeNodeType *TimeNode;
        #define SOAP_UNION_plu__gml__union_TimeTopologyPrimitivePropertyType_TimeEdge	(2)	/**< union variant selector value for member TimeEdge */
        gml__TimeEdgeType *TimeEdge;
};
#endif

/* PlannedLandUse_v3.0.h:12092 */
#ifndef SOAP_TYPE_plu___gml__TimeTopologyPrimitivePropertyType_sequence
#define SOAP_TYPE_plu___gml__TimeTopologyPrimitivePropertyType_sequence (-1271)
/* Wrapper: */
class SOAP_CMAC __gml__TimeTopologyPrimitivePropertyType_sequence {
      public:
        /// Union with union _gml__union_TimeTopologyPrimitivePropertyType variant selector __unionAbstractTimeTopologyPrimitive set to one of: SOAP_UNION_plu__gml__union_TimeTopologyPrimitivePropertyType_TimeNode SOAP_UNION_plu__gml__union_TimeTopologyPrimitivePropertyType_TimeEdge
        int __unionAbstractTimeTopologyPrimitive;
        union _gml__union_TimeTopologyPrimitivePropertyType union_TimeTopologyPrimitivePropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__TimeTopologyPrimitivePropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__TimeTopologyPrimitivePropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__TimeTopologyPrimitivePropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__TimeTopologyPrimitivePropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__TimeTopologyPrimitivePropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__TimeTopologyPrimitivePropertyType_sequence() : __unionAbstractTimeTopologyPrimitive() { }
        virtual ~__gml__TimeTopologyPrimitivePropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__TimeTopologyPrimitivePropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__TimeTopologyPrimitivePropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__TimeTopologyPrimitivePropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1346 */
#ifndef SOAP_TYPE_plu_gml__TimeTopologyPrimitivePropertyType
#define SOAP_TYPE_plu_gml__TimeTopologyPrimitivePropertyType (-403)
/* complex XML schema type 'gml:TimeTopologyPrimitivePropertyType': */
class SOAP_CMAC gml__TimeTopologyPrimitivePropertyType : public xsd__anyType {
      public:
        __gml__TimeTopologyPrimitivePropertyType_sequence *__TimeTopologyPrimitivePropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeTopologyPrimitivePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeTopologyPrimitivePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeTopologyPrimitivePropertyType, default initialized and not managed by a soap context
        virtual gml__TimeTopologyPrimitivePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeTopologyPrimitivePropertyType); }
      public:
        /// Constructor with default initializations
        gml__TimeTopologyPrimitivePropertyType() : __TimeTopologyPrimitivePropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__TimeTopologyPrimitivePropertyType() { }
        /// Friend allocator used by soap_new_gml__TimeTopologyPrimitivePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeTopologyPrimitivePropertyType * SOAP_FMAC2 soap_instantiate_gml__TimeTopologyPrimitivePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:12165 */
#ifndef SOAP_TYPE_plu___gml__TimeTopologyComplexPropertyType_sequence
#define SOAP_TYPE_plu___gml__TimeTopologyComplexPropertyType_sequence (-1276)
/* Wrapper: */
class SOAP_CMAC __gml__TimeTopologyComplexPropertyType_sequence {
      public:
        /// Required element 'gml:TimeTopologyComplex' of XML schema type 'gml:TimeTopologyComplexType'
        gml__TimeTopologyComplexType *TimeTopologyComplex;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__TimeTopologyComplexPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__TimeTopologyComplexPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__TimeTopologyComplexPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__TimeTopologyComplexPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__TimeTopologyComplexPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__TimeTopologyComplexPropertyType_sequence() : TimeTopologyComplex() { }
        virtual ~__gml__TimeTopologyComplexPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__TimeTopologyComplexPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__TimeTopologyComplexPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__TimeTopologyComplexPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1352 */
#ifndef SOAP_TYPE_plu_gml__TimeTopologyComplexPropertyType
#define SOAP_TYPE_plu_gml__TimeTopologyComplexPropertyType (-405)
/* complex XML schema type 'gml:TimeTopologyComplexPropertyType': */
class SOAP_CMAC gml__TimeTopologyComplexPropertyType : public xsd__anyType {
      public:
        __gml__TimeTopologyComplexPropertyType_sequence *__TimeTopologyComplexPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeTopologyComplexPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeTopologyComplexPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeTopologyComplexPropertyType, default initialized and not managed by a soap context
        virtual gml__TimeTopologyComplexPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeTopologyComplexPropertyType); }
      public:
        /// Constructor with default initializations
        gml__TimeTopologyComplexPropertyType() : __TimeTopologyComplexPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__TimeTopologyComplexPropertyType() { }
        /// Friend allocator used by soap_new_gml__TimeTopologyComplexPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeTopologyComplexPropertyType * SOAP_FMAC2 soap_instantiate_gml__TimeTopologyComplexPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:12222 */
#ifndef SOAP_TYPE_plu___gml__TimeNodePropertyType_sequence
#define SOAP_TYPE_plu___gml__TimeNodePropertyType_sequence (-1279)
/* Wrapper: */
class SOAP_CMAC __gml__TimeNodePropertyType_sequence {
      public:
        /// Required element 'gml:TimeNode' of XML schema type 'gml:TimeNodeType'
        gml__TimeNodeType *TimeNode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__TimeNodePropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__TimeNodePropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__TimeNodePropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__TimeNodePropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__TimeNodePropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__TimeNodePropertyType_sequence() : TimeNode() { }
        virtual ~__gml__TimeNodePropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__TimeNodePropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__TimeNodePropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__TimeNodePropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1358 */
#ifndef SOAP_TYPE_plu_gml__TimeNodePropertyType
#define SOAP_TYPE_plu_gml__TimeNodePropertyType (-407)
/* Type gml__TimeNodePropertyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gml:TimeNodePropertyType': */
class SOAP_CMAC gml__TimeNodePropertyType : public xsd__anyType {
      public:
        __gml__TimeNodePropertyType_sequence *__TimeNodePropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeNodePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeNodePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeNodePropertyType, default initialized and not managed by a soap context
        virtual gml__TimeNodePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeNodePropertyType); }
      public:
        /// Constructor with default initializations
        gml__TimeNodePropertyType() : __TimeNodePropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__TimeNodePropertyType() { }
        /// Friend allocator used by soap_new_gml__TimeNodePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeNodePropertyType * SOAP_FMAC2 soap_instantiate_gml__TimeNodePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:12277 */
#ifndef SOAP_TYPE_plu___gml__TimeEdgePropertyType_sequence
#define SOAP_TYPE_plu___gml__TimeEdgePropertyType_sequence (-1281)
/* Wrapper: */
class SOAP_CMAC __gml__TimeEdgePropertyType_sequence {
      public:
        /// Required element 'gml:TimeEdge' of XML schema type 'gml:TimeEdgeType'
        gml__TimeEdgeType *TimeEdge;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__TimeEdgePropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__TimeEdgePropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__TimeEdgePropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__TimeEdgePropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__TimeEdgePropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__TimeEdgePropertyType_sequence() : TimeEdge() { }
        virtual ~__gml__TimeEdgePropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__TimeEdgePropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__TimeEdgePropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__TimeEdgePropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1364 */
#ifndef SOAP_TYPE_plu_gml__TimeEdgePropertyType
#define SOAP_TYPE_plu_gml__TimeEdgePropertyType (-409)
/* complex XML schema type 'gml:TimeEdgePropertyType': */
class SOAP_CMAC gml__TimeEdgePropertyType : public xsd__anyType {
      public:
        __gml__TimeEdgePropertyType_sequence *__TimeEdgePropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeEdgePropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeEdgePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeEdgePropertyType, default initialized and not managed by a soap context
        virtual gml__TimeEdgePropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeEdgePropertyType); }
      public:
        /// Constructor with default initializations
        gml__TimeEdgePropertyType() : __TimeEdgePropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0) { }
        virtual ~gml__TimeEdgePropertyType() { }
        /// Friend allocator used by soap_new_gml__TimeEdgePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeEdgePropertyType * SOAP_FMAC2 soap_instantiate_gml__TimeEdgePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:12336 */
#ifndef SOAP_TYPE_plu__gml__union_OperationPropertyType
#define SOAP_TYPE_plu__gml__union_OperationPropertyType (-1284)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_OperationPropertyType
{
};
#endif

/* PlannedLandUse_v3.0.h:12329 */
#ifndef SOAP_TYPE_plu___gml__OperationPropertyType_sequence
#define SOAP_TYPE_plu___gml__OperationPropertyType_sequence (-1283)
/* Wrapper: */
class SOAP_CMAC __gml__OperationPropertyType_sequence {
      public:
        /// Union with union _gml__union_OperationPropertyType variant selector __unionAbstractOperation set to one of:
        int __unionAbstractOperation;
        union _gml__union_OperationPropertyType union_OperationPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__OperationPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__OperationPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__OperationPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__OperationPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__OperationPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__OperationPropertyType_sequence() : __unionAbstractOperation() { }
        virtual ~__gml__OperationPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__OperationPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__OperationPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__OperationPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1367 */
#ifndef SOAP_TYPE_plu_gml__OperationPropertyType
#define SOAP_TYPE_plu_gml__OperationPropertyType (-410)
/* complex XML schema type 'gml:OperationPropertyType': */
class SOAP_CMAC gml__OperationPropertyType : public xsd__anyType {
      public:
        __gml__OperationPropertyType_sequence *__OperationPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__OperationPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__OperationPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__OperationPropertyType, default initialized and not managed by a soap context
        virtual gml__OperationPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__OperationPropertyType); }
      public:
        /// Constructor with default initializations
        gml__OperationPropertyType() : __OperationPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__OperationPropertyType() { }
        /// Friend allocator used by soap_new_gml__OperationPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__OperationPropertyType * SOAP_FMAC2 soap_instantiate_gml__OperationPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:12380 */
#ifndef SOAP_TYPE_plu___gml__TemporalCSPropertyType_sequence
#define SOAP_TYPE_plu___gml__TemporalCSPropertyType_sequence (-1286)
/* Wrapper: */
class SOAP_CMAC __gml__TemporalCSPropertyType_sequence {
      public:
        /// Required element 'gml:TemporalCS' of XML schema type 'gml:TemporalCSType'
        gml__TemporalCSType *TemporalCS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__TemporalCSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__TemporalCSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__TemporalCSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__TemporalCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__TemporalCSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__TemporalCSPropertyType_sequence() : TemporalCS() { }
        virtual ~__gml__TemporalCSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__TemporalCSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__TemporalCSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__TemporalCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1373 */
#ifndef SOAP_TYPE_plu_gml__TemporalCSPropertyType
#define SOAP_TYPE_plu_gml__TemporalCSPropertyType (-412)
/* complex XML schema type 'gml:TemporalCSPropertyType': */
class SOAP_CMAC gml__TemporalCSPropertyType : public xsd__anyType {
      public:
        __gml__TemporalCSPropertyType_sequence *__TemporalCSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TemporalCSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TemporalCSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TemporalCSPropertyType, default initialized and not managed by a soap context
        virtual gml__TemporalCSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TemporalCSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__TemporalCSPropertyType() : __TemporalCSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__TemporalCSPropertyType() { }
        /// Friend allocator used by soap_new_gml__TemporalCSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TemporalCSPropertyType * SOAP_FMAC2 soap_instantiate_gml__TemporalCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:12425 */
#ifndef SOAP_TYPE_plu___gml__ObliqueCartesianCSPropertyType_sequence
#define SOAP_TYPE_plu___gml__ObliqueCartesianCSPropertyType_sequence (-1288)
/* Wrapper: */
class SOAP_CMAC __gml__ObliqueCartesianCSPropertyType_sequence {
      public:
        /// Required element 'gml:ObliqueCartesianCS' of XML schema type 'gml:ObliqueCartesianCSType'
        gml__ObliqueCartesianCSType *ObliqueCartesianCS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__ObliqueCartesianCSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__ObliqueCartesianCSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__ObliqueCartesianCSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__ObliqueCartesianCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__ObliqueCartesianCSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__ObliqueCartesianCSPropertyType_sequence() : ObliqueCartesianCS() { }
        virtual ~__gml__ObliqueCartesianCSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__ObliqueCartesianCSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__ObliqueCartesianCSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__ObliqueCartesianCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1379 */
#ifndef SOAP_TYPE_plu_gml__ObliqueCartesianCSPropertyType
#define SOAP_TYPE_plu_gml__ObliqueCartesianCSPropertyType (-414)
/* complex XML schema type 'gml:ObliqueCartesianCSPropertyType': */
class SOAP_CMAC gml__ObliqueCartesianCSPropertyType : public xsd__anyType {
      public:
        __gml__ObliqueCartesianCSPropertyType_sequence *__ObliqueCartesianCSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ObliqueCartesianCSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ObliqueCartesianCSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ObliqueCartesianCSPropertyType, default initialized and not managed by a soap context
        virtual gml__ObliqueCartesianCSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ObliqueCartesianCSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__ObliqueCartesianCSPropertyType() : __ObliqueCartesianCSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__ObliqueCartesianCSPropertyType() { }
        /// Friend allocator used by soap_new_gml__ObliqueCartesianCSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__ObliqueCartesianCSPropertyType * SOAP_FMAC2 soap_instantiate_gml__ObliqueCartesianCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:12470 */
#ifndef SOAP_TYPE_plu___gml__GeographicCRSPropertyType_sequence
#define SOAP_TYPE_plu___gml__GeographicCRSPropertyType_sequence (-1290)
/* Wrapper: */
class SOAP_CMAC __gml__GeographicCRSPropertyType_sequence {
      public:
        /// Required element 'gml:GeographicCRS' of XML schema type 'gml:GeographicCRSType'
        gml__GeographicCRSType *GeographicCRS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__GeographicCRSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__GeographicCRSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__GeographicCRSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__GeographicCRSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__GeographicCRSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__GeographicCRSPropertyType_sequence() : GeographicCRS() { }
        virtual ~__gml__GeographicCRSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__GeographicCRSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__GeographicCRSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__GeographicCRSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1385 */
#ifndef SOAP_TYPE_plu_gml__GeographicCRSPropertyType
#define SOAP_TYPE_plu_gml__GeographicCRSPropertyType (-416)
/* complex XML schema type 'gml:GeographicCRSPropertyType': */
class SOAP_CMAC gml__GeographicCRSPropertyType : public xsd__anyType {
      public:
        __gml__GeographicCRSPropertyType_sequence *__GeographicCRSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GeographicCRSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GeographicCRSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeographicCRSPropertyType, default initialized and not managed by a soap context
        virtual gml__GeographicCRSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GeographicCRSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__GeographicCRSPropertyType() : __GeographicCRSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__GeographicCRSPropertyType() { }
        /// Friend allocator used by soap_new_gml__GeographicCRSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeographicCRSPropertyType * SOAP_FMAC2 soap_instantiate_gml__GeographicCRSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:12515 */
#ifndef SOAP_TYPE_plu___gml__GeocentricCRSPropertyType_sequence
#define SOAP_TYPE_plu___gml__GeocentricCRSPropertyType_sequence (-1292)
/* Wrapper: */
class SOAP_CMAC __gml__GeocentricCRSPropertyType_sequence {
      public:
        /// Required element 'gml:GeocentricCRS' of XML schema type 'gml:GeocentricCRSType'
        gml__GeocentricCRSType *GeocentricCRS;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__GeocentricCRSPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__GeocentricCRSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__GeocentricCRSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__GeocentricCRSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__GeocentricCRSPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__GeocentricCRSPropertyType_sequence() : GeocentricCRS() { }
        virtual ~__gml__GeocentricCRSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__GeocentricCRSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__GeocentricCRSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__GeocentricCRSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1391 */
#ifndef SOAP_TYPE_plu_gml__GeocentricCRSPropertyType
#define SOAP_TYPE_plu_gml__GeocentricCRSPropertyType (-418)
/* complex XML schema type 'gml:GeocentricCRSPropertyType': */
class SOAP_CMAC gml__GeocentricCRSPropertyType : public xsd__anyType {
      public:
        __gml__GeocentricCRSPropertyType_sequence *__GeocentricCRSPropertyType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GeocentricCRSPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GeocentricCRSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeocentricCRSPropertyType, default initialized and not managed by a soap context
        virtual gml__GeocentricCRSPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GeocentricCRSPropertyType); }
      public:
        /// Constructor with default initializations
        gml__GeocentricCRSPropertyType() : __GeocentricCRSPropertyType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__GeocentricCRSPropertyType() { }
        /// Friend allocator used by soap_new_gml__GeocentricCRSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeocentricCRSPropertyType * SOAP_FMAC2 soap_instantiate_gml__GeocentricCRSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1394 */
#ifndef SOAP_TYPE_plu_gml__DMSAngleType
#define SOAP_TYPE_plu_gml__DMSAngleType (-419)
/* complex XML schema type 'gml:DMSAngleType': */
class SOAP_CMAC gml__DMSAngleType : public xsd__anyType {
      public:
        /// Required element 'gml:degrees' of XML schema type 'gml:DegreesType'
        gml__DegreesType *degrees;
        /// Optional element 'gml:decimalMinutes' of XML schema type 'gml:DecimalMinutesType'
        double *decimalMinutes;
        /// Optional element 'gml:minutes' of XML schema type 'gml:ArcMinutesType'
        ULONG64 *minutes;
        /// Optional element 'gml:seconds' of XML schema type 'gml:ArcSecondsType'
        double *seconds;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DMSAngleType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DMSAngleType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DMSAngleType, default initialized and not managed by a soap context
        virtual gml__DMSAngleType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DMSAngleType); }
      public:
        /// Constructor with default initializations
        gml__DMSAngleType() : degrees(), decimalMinutes(), minutes(), seconds() { }
        virtual ~gml__DMSAngleType() { }
        /// Friend allocator used by soap_new_gml__DMSAngleType(struct soap*, int)
        friend SOAP_FMAC1 gml__DMSAngleType * SOAP_FMAC2 soap_instantiate_gml__DMSAngleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:12592 */
#ifndef SOAP_TYPE_plu__gml__union_AngleChoiceType
#define SOAP_TYPE_plu__gml__union_AngleChoiceType (-1298)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_AngleChoiceType
{
        #define SOAP_UNION_plu__gml__union_AngleChoiceType_angle	(1)	/**< union variant selector value for member angle */
        gml__AngleType *angle;
        #define SOAP_UNION_plu__gml__union_AngleChoiceType_dmsAngle	(2)	/**< union variant selector value for member dmsAngle */
        gml__DMSAngleType *dmsAngle;
};
#endif

/* PlannedLandUse_v3.0.h:1400 */
#ifndef SOAP_TYPE_plu_gml__AngleChoiceType
#define SOAP_TYPE_plu_gml__AngleChoiceType (-421)
/* complex XML schema type 'gml:AngleChoiceType': */
class SOAP_CMAC gml__AngleChoiceType : public xsd__anyType {
      public:
        /// Union with union _gml__union_AngleChoiceType variant selector __union_AngleChoiceType set to one of: SOAP_UNION_plu__gml__union_AngleChoiceType_angle SOAP_UNION_plu__gml__union_AngleChoiceType_dmsAngle
        int __union_AngleChoiceType;
        union _gml__union_AngleChoiceType union_AngleChoiceType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AngleChoiceType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AngleChoiceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AngleChoiceType, default initialized and not managed by a soap context
        virtual gml__AngleChoiceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AngleChoiceType); }
      public:
        /// Constructor with default initializations
        gml__AngleChoiceType() : __union_AngleChoiceType() { }
        virtual ~gml__AngleChoiceType() { }
        /// Friend allocator used by soap_new_gml__AngleChoiceType(struct soap*, int)
        friend SOAP_FMAC1 gml__AngleChoiceType * SOAP_FMAC2 soap_instantiate_gml__AngleChoiceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:12629 */
#ifndef SOAP_TYPE_plu__gml__union_ArrayAssociationType
#define SOAP_TYPE_plu__gml__union_ArrayAssociationType (-1301)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ArrayAssociationType
{
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_lunom__HILUCSPresence	(1)	/**< union variant selector value for member lunom__HILUCSPresence */
        lunom__HILUCSPresenceType *lunom__HILUCSPresence;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_lunom__SpecificPercentage	(2)	/**< union variant selector value for member lunom__SpecificPercentage */
        lunom__SpecificPercentageType *lunom__SpecificPercentage;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_lunom__SpecificPresence	(3)	/**< union variant selector value for member lunom__SpecificPresence */
        lunom__SpecificPresenceType *lunom__SpecificPresence;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_lunom__HILUCSPercentage	(4)	/**< union variant selector value for member lunom__HILUCSPercentage */
        lunom__HILUCSPercentageType *lunom__HILUCSPercentage;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_base2__OfficialJournalInformation	(5)	/**< union variant selector value for member base2__OfficialJournalInformation */
        base2__OfficialJournalInformationType *base2__OfficialJournalInformation;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_base2__Contact	(6)	/**< union variant selector value for member base2__Contact */
        base2__ContactType *base2__Contact;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_base2__RelatedParty	(7)	/**< union variant selector value for member base2__RelatedParty */
        base2__RelatedPartyType *base2__RelatedParty;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_base2__ThematicIdentifier	(8)	/**< union variant selector value for member base2__ThematicIdentifier */
        base2__ThematicIdentifierType *base2__ThematicIdentifier;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_AffinePlacement	(9)	/**< union variant selector value for member AffinePlacement */
        gml__AffinePlacementType *AffinePlacement;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_Envelope	(10)	/**< union variant selector value for member Envelope */
        gml__EnvelopeType *Envelope;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_EnvelopeWithTimePeriod	(11)	/**< union variant selector value for member EnvelopeWithTimePeriod */
        gml__EnvelopeWithTimePeriodType *EnvelopeWithTimePeriod;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_DataBlock	(12)	/**< union variant selector value for member DataBlock */
        gml__DataBlockType *DataBlock;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_File	(13)	/**< union variant selector value for member File */
        gml__FileType *File;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_coverageFunction	(14)	/**< union variant selector value for member coverageFunction */
        gml__CoverageFunctionType *coverageFunction;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_CoverageMappingRule	(15)	/**< union variant selector value for member CoverageMappingRule */
        gml__MappingRuleType *CoverageMappingRule;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_GridFunction	(16)	/**< union variant selector value for member GridFunction */
        gml__GridFunctionType *GridFunction;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_base__Identifier	(17)	/**< union variant selector value for member base__Identifier */
        base__IdentifierType *base__Identifier;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_plu__DimensioningIndicationValue	(18)	/**< union variant selector value for member plu__DimensioningIndicationValue */
        plu__DimensioningIndicationValueType *plu__DimensioningIndicationValue;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_plu__DimensioningIndicationIntegerValue	(19)	/**< union variant selector value for member plu__DimensioningIndicationIntegerValue */
        plu__DimensioningIndicationIntegerValueType *plu__DimensioningIndicationIntegerValue;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_plu__DimensioningIndicationRealValue	(20)	/**< union variant selector value for member plu__DimensioningIndicationRealValue */
        plu__DimensioningIndicationRealValueType *plu__DimensioningIndicationRealValue;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_plu__DimensioningIndicationMeasureValue	(21)	/**< union variant selector value for member plu__DimensioningIndicationMeasureValue */
        plu__DimensioningIndicationMeasureValueType *plu__DimensioningIndicationMeasureValue;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_plu__DimensioningIndicationCharacterValue	(22)	/**< union variant selector value for member plu__DimensioningIndicationCharacterValue */
        plu__DimensioningIndicationCharacterValueType *plu__DimensioningIndicationCharacterValue;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_plu__OrdinanceValue	(23)	/**< union variant selector value for member plu__OrdinanceValue */
        plu__OrdinanceValueType *plu__OrdinanceValue;
        #define SOAP_UNION_plu__gml__union_ArrayAssociationType_plu__BackgroundMapValue	(24)	/**< union variant selector value for member plu__BackgroundMapValue */
        plu__BackgroundMapValueType *plu__BackgroundMapValue;
};
#endif

/* PlannedLandUse_v3.0.h:12624 */
#ifndef SOAP_TYPE_plu___gml__union_ArrayAssociationType
#define SOAP_TYPE_plu___gml__union_ArrayAssociationType (-1300)
/* Wrapper: */
class SOAP_CMAC __gml__union_ArrayAssociationType {
      public:
        /// Union with union _gml__union_ArrayAssociationType variant selector __unionAbstractObject set to one of: SOAP_UNION_plu__gml__union_ArrayAssociationType_lunom__HILUCSPresence SOAP_UNION_plu__gml__union_ArrayAssociationType_lunom__SpecificPercentage SOAP_UNION_plu__gml__union_ArrayAssociationType_lunom__SpecificPresence SOAP_UNION_plu__gml__union_ArrayAssociationType_lunom__HILUCSPercentage SOAP_UNION_plu__gml__union_ArrayAssociationType_base2__OfficialJournalInformation SOAP_UNION_plu__gml__union_ArrayAssociationType_base2__Contact SOAP_UNION_plu__gml__union_ArrayAssociationType_base2__RelatedParty SOAP_UNION_plu__gml__union_ArrayAssociationType_base2__ThematicIdentifier SOAP_UNION_plu__gml__union_ArrayAssociationType_AffinePlacement SOAP_UNION_plu__gml__union_ArrayAssociationType_Envelope SOAP_UNION_plu__gml__union_ArrayAssociationType_EnvelopeWithTimePeriod SOAP_UNION_plu__gml__union_ArrayAssociationType_DataBlock SOAP_UNION_plu__gml__union_ArrayAssociationType_File SOAP_UNION_plu__gml__union_ArrayAssociationType_coverageFunction SOAP_UNION_plu__gml__union_ArrayAssociationType_CoverageMappingRule SOAP_UNION_plu__gml__union_ArrayAssociationType_GridFunction SOAP_UNION_plu__gml__union_ArrayAssociationType_base__Identifier SOAP_UNION_plu__gml__union_ArrayAssociationType_plu__DimensioningIndicationValue SOAP_UNION_plu__gml__union_ArrayAssociationType_plu__DimensioningIndicationIntegerValue SOAP_UNION_plu__gml__union_ArrayAssociationType_plu__DimensioningIndicationRealValue SOAP_UNION_plu__gml__union_ArrayAssociationType_plu__DimensioningIndicationMeasureValue SOAP_UNION_plu__gml__union_ArrayAssociationType_plu__DimensioningIndicationCharacterValue SOAP_UNION_plu__gml__union_ArrayAssociationType_plu__OrdinanceValue SOAP_UNION_plu__gml__union_ArrayAssociationType_plu__BackgroundMapValue
        int __unionAbstractObject;
        union _gml__union_ArrayAssociationType union_ArrayAssociationType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_ArrayAssociationType
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_ArrayAssociationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_ArrayAssociationType, default initialized and not managed by a soap context
        virtual __gml__union_ArrayAssociationType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_ArrayAssociationType); }
      public:
        /// Constructor with default initializations
        __gml__union_ArrayAssociationType() : __unionAbstractObject() { }
        virtual ~__gml__union_ArrayAssociationType() { }
        /// Friend allocator used by soap_new___gml__union_ArrayAssociationType(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_ArrayAssociationType * SOAP_FMAC2 soap_instantiate___gml__union_ArrayAssociationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1403 */
#ifndef SOAP_TYPE_plu_gml__ArrayAssociationType
#define SOAP_TYPE_plu_gml__ArrayAssociationType (-422)
/* complex XML schema type 'gml:ArrayAssociationType': */
class SOAP_CMAC gml__ArrayAssociationType : public xsd__anyType {
      public:
        /// Sequence of elements '-union-ArrayAssociationType' of XML schema type '-gml:union-ArrayAssociationType' stored in dynamic array __union_ArrayAssociationType of length __sizeAbstractObject
        int __sizeAbstractObject;
        __gml__union_ArrayAssociationType *__union_ArrayAssociationType;
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ArrayAssociationType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ArrayAssociationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ArrayAssociationType, default initialized and not managed by a soap context
        virtual gml__ArrayAssociationType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ArrayAssociationType); }
      public:
        /// Constructor with default initializations
        gml__ArrayAssociationType() : __sizeAbstractObject(), __union_ArrayAssociationType(), owns((bool)0) { }
        virtual ~gml__ArrayAssociationType() { }
        /// Friend allocator used by soap_new_gml__ArrayAssociationType(struct soap*, int)
        friend SOAP_FMAC1 gml__ArrayAssociationType * SOAP_FMAC2 soap_instantiate_gml__ArrayAssociationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:12938 */
#ifndef SOAP_TYPE_plu__gml__union_MetaDataPropertyType
#define SOAP_TYPE_plu__gml__union_MetaDataPropertyType (-1306)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_MetaDataPropertyType
{
        #define SOAP_UNION_plu__gml__union_MetaDataPropertyType_GenericMetaData	(1)	/**< union variant selector value for member GenericMetaData */
        gml__GenericMetaDataType *GenericMetaData;
};
#endif

/* PlannedLandUse_v3.0.h:12931 */
#ifndef SOAP_TYPE_plu___gml__MetaDataPropertyType_sequence
#define SOAP_TYPE_plu___gml__MetaDataPropertyType_sequence (-1305)
/* Wrapper: */
class SOAP_CMAC __gml__MetaDataPropertyType_sequence {
      public:
        /// Union with union _gml__union_MetaDataPropertyType variant selector __unionAbstractMetaData set to one of: SOAP_UNION_plu__gml__union_MetaDataPropertyType_GenericMetaData
        int __unionAbstractMetaData;
        union _gml__union_MetaDataPropertyType union_MetaDataPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__MetaDataPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__MetaDataPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__MetaDataPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__MetaDataPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__MetaDataPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__MetaDataPropertyType_sequence() : __unionAbstractMetaData() { }
        virtual ~__gml__MetaDataPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__MetaDataPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__MetaDataPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__MetaDataPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1415 */
#ifndef SOAP_TYPE_plu_gml__MetaDataPropertyType
#define SOAP_TYPE_plu_gml__MetaDataPropertyType (-426)
/* complex XML schema type 'gml:MetaDataPropertyType': */
class SOAP_CMAC gml__MetaDataPropertyType : public xsd__anyType {
      public:
        __gml__MetaDataPropertyType_sequence *__MetaDataPropertyType_sequence;
        /// Optional attribute 'about' of XML schema type 'xsd:anyURI'
        char **about;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__MetaDataPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__MetaDataPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__MetaDataPropertyType, default initialized and not managed by a soap context
        virtual gml__MetaDataPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__MetaDataPropertyType); }
      public:
        /// Constructor with default initializations
        gml__MetaDataPropertyType() : __MetaDataPropertyType_sequence(), about(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__MetaDataPropertyType() { }
        /// Friend allocator used by soap_new_gml__MetaDataPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__MetaDataPropertyType * SOAP_FMAC2 soap_instantiate_gml__MetaDataPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1418 */
#ifndef SOAP_TYPE_plu_gml__AbstractMetaDataType
#define SOAP_TYPE_plu_gml__AbstractMetaDataType (-427)
/* complex XML schema type 'gml:AbstractMetaDataType': */
class SOAP_CMAC gml__AbstractMetaDataType : public xsd__anyType {
      public:
        /// Optional attribute 'gml:id' of XML schema type 'xsd:ID'
        char **gml__id;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractMetaDataType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractMetaDataType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractMetaDataType, default initialized and not managed by a soap context
        virtual gml__AbstractMetaDataType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractMetaDataType); }
      public:
        /// Constructor with default initializations
        gml__AbstractMetaDataType() : gml__id(), __mixed() { }
        virtual ~gml__AbstractMetaDataType() { }
        /// Friend allocator used by soap_new_gml__AbstractMetaDataType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractMetaDataType * SOAP_FMAC2 soap_instantiate_gml__AbstractMetaDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:13013 */
#ifndef SOAP_TYPE_plu__gml__union_LocationPropertyType
#define SOAP_TYPE_plu__gml__union_LocationPropertyType (-1309)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_LocationPropertyType
{
        #define SOAP_UNION_plu__gml__union_LocationPropertyType_GeometricComplex	(1)	/**< union variant selector value for member GeometricComplex */
        gml__GeometricComplexType *GeometricComplex;
        #define SOAP_UNION_plu__gml__union_LocationPropertyType_LocationKeyWord	(2)	/**< union variant selector value for member LocationKeyWord */
        gml__CodeType *LocationKeyWord;
        #define SOAP_UNION_plu__gml__union_LocationPropertyType_LocationString	(3)	/**< union variant selector value for member LocationString */
        gml__StringOrRefType *LocationString;
        #define SOAP_UNION_plu__gml__union_LocationPropertyType_Null	(4)	/**< union variant selector value for member Null */
        std::string *Null;
};
#endif

/* PlannedLandUse_v3.0.h:1424 */
#ifndef SOAP_TYPE_plu_gml__LocationPropertyType
#define SOAP_TYPE_plu_gml__LocationPropertyType (-429)
/* complex XML schema type 'gml:LocationPropertyType': */
class SOAP_CMAC gml__LocationPropertyType : public xsd__anyType {
      public:
        /// Union with union _gml__union_LocationPropertyType variant selector __union_LocationPropertyType set to one of: SOAP_UNION_plu__gml__union_LocationPropertyType_GeometricComplex SOAP_UNION_plu__gml__union_LocationPropertyType_LocationKeyWord SOAP_UNION_plu__gml__union_LocationPropertyType_LocationString SOAP_UNION_plu__gml__union_LocationPropertyType_Null
        int __union_LocationPropertyType;
        union _gml__union_LocationPropertyType union_LocationPropertyType;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__LocationPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__LocationPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__LocationPropertyType, default initialized and not managed by a soap context
        virtual gml__LocationPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__LocationPropertyType); }
      public:
        /// Constructor with default initializations
        gml__LocationPropertyType() : __union_LocationPropertyType(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__LocationPropertyType() { }
        /// Friend allocator used by soap_new_gml__LocationPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__LocationPropertyType * SOAP_FMAC2 soap_instantiate_gml__LocationPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:13080 */
#ifndef SOAP_TYPE_plu__gml__union_FeatureArrayPropertyType
#define SOAP_TYPE_plu__gml__union_FeatureArrayPropertyType (-1311)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_FeatureArrayPropertyType
{
        #define SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_DynamicFeature	(1)	/**< union variant selector value for member DynamicFeature */
        gml__DynamicFeatureType *DynamicFeature;
        #define SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_DynamicFeatureCollection	(2)	/**< union variant selector value for member DynamicFeatureCollection */
        gml__DynamicFeatureCollectionType *DynamicFeatureCollection;
        #define SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_Observation	(3)	/**< union variant selector value for member Observation */
        gml__ObservationType *Observation;
        #define SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_DirectedObservation	(4)	/**< union variant selector value for member DirectedObservation */
        gml__DirectedObservationType *DirectedObservation;
        #define SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_DirectedObservationAtDistance	(5)	/**< union variant selector value for member DirectedObservationAtDistance */
        gml__DirectedObservationAtDistanceType *DirectedObservationAtDistance;
        #define SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_FeatureCollection	(6)	/**< union variant selector value for member FeatureCollection */
        gml__FeatureCollectionType *FeatureCollection;
        #define SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_base__SpatialDataSet	(7)	/**< union variant selector value for member base__SpatialDataSet */
        base__SpatialDataSetType *base__SpatialDataSet;
        #define SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_plu__ZoningElement	(8)	/**< union variant selector value for member plu__ZoningElement */
        plu__ZoningElementType *plu__ZoningElement;
        #define SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_plu__OfficialDocumentation	(9)	/**< union variant selector value for member plu__OfficialDocumentation */
        plu__OfficialDocumentationType *plu__OfficialDocumentation;
        #define SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_plu__SupplementaryRegulation	(10)	/**< union variant selector value for member plu__SupplementaryRegulation */
        plu__SupplementaryRegulationType *plu__SupplementaryRegulation;
        #define SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_plu__SpatialPlan	(11)	/**< union variant selector value for member plu__SpatialPlan */
        plu__SpatialPlanType *plu__SpatialPlan;
};
#endif

/* PlannedLandUse_v3.0.h:13070 */
#ifndef SOAP_TYPE_plu___gml__FeatureArrayPropertyType_sequence
#define SOAP_TYPE_plu___gml__FeatureArrayPropertyType_sequence (-1310)
/* Type __gml__FeatureArrayPropertyType_sequence is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* Wrapper: */
class SOAP_CMAC __gml__FeatureArrayPropertyType_sequence {
      public:
        /// Union with union _gml__union_FeatureArrayPropertyType variant selector __unionAbstractFeature set to one of: SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_DynamicFeature SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_DynamicFeatureCollection SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_Observation SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_DirectedObservation SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_DirectedObservationAtDistance SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_FeatureCollection SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_base__SpatialDataSet SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_plu__ZoningElement SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_plu__OfficialDocumentation SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_plu__SupplementaryRegulation SOAP_UNION_plu__gml__union_FeatureArrayPropertyType_plu__SpatialPlan
        int __unionAbstractFeature;
        union _gml__union_FeatureArrayPropertyType union_FeatureArrayPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__FeatureArrayPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__FeatureArrayPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__FeatureArrayPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__FeatureArrayPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__FeatureArrayPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__FeatureArrayPropertyType_sequence() : __unionAbstractFeature() { }
        virtual ~__gml__FeatureArrayPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__FeatureArrayPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__FeatureArrayPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__FeatureArrayPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1430 */
#ifndef SOAP_TYPE_plu_gml__FeatureArrayPropertyType
#define SOAP_TYPE_plu_gml__FeatureArrayPropertyType (-431)
/* complex XML schema type 'gml:FeatureArrayPropertyType': */
class SOAP_CMAC gml__FeatureArrayPropertyType : public xsd__anyType {
      public:
        std::vector<__gml__FeatureArrayPropertyType_sequence> __FeatureArrayPropertyType_sequence;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__FeatureArrayPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__FeatureArrayPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__FeatureArrayPropertyType, default initialized and not managed by a soap context
        virtual gml__FeatureArrayPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__FeatureArrayPropertyType); }
      public:
        /// Constructor with default initializations
        gml__FeatureArrayPropertyType() : __FeatureArrayPropertyType_sequence() { }
        virtual ~gml__FeatureArrayPropertyType() { }
        /// Friend allocator used by soap_new_gml__FeatureArrayPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__FeatureArrayPropertyType * SOAP_FMAC2 soap_instantiate_gml__FeatureArrayPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1442 */
#ifndef SOAP_TYPE_plu_gml__IndirectEntryType
#define SOAP_TYPE_plu_gml__IndirectEntryType (-435)
/* complex XML schema type 'gml:IndirectEntryType': */
class SOAP_CMAC gml__IndirectEntryType : public xsd__anyType {
      public:
        /// Required element 'gml:DefinitionProxy' of XML schema type 'gml:DefinitionProxyType'
        gml__DefinitionProxyType *DefinitionProxy;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__IndirectEntryType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__IndirectEntryType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__IndirectEntryType, default initialized and not managed by a soap context
        virtual gml__IndirectEntryType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__IndirectEntryType); }
      public:
        /// Constructor with default initializations
        gml__IndirectEntryType() : DefinitionProxy() { }
        virtual ~gml__IndirectEntryType() { }
        /// Friend allocator used by soap_new_gml__IndirectEntryType(struct soap*, int)
        friend SOAP_FMAC1 gml__IndirectEntryType * SOAP_FMAC2 soap_instantiate_gml__IndirectEntryType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:13273 */
#ifndef SOAP_TYPE_plu___gml__domainOfValidity_sequence
#define SOAP_TYPE_plu___gml__domainOfValidity_sequence (-1314)
/* Wrapper: */
class SOAP_CMAC __gml__domainOfValidity_sequence {
      public:
        /// Required element 'gmd:EX_Extent' of XML schema type 'gmd:EX_Extent_Type'
        gmd__EX_x005fExtent_x005fType *gmd__EX_x005fExtent;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__domainOfValidity_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__domainOfValidity_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__domainOfValidity_sequence, default initialized and not managed by a soap context
        virtual __gml__domainOfValidity_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__domainOfValidity_sequence); }
      public:
        /// Constructor with default initializations
        __gml__domainOfValidity_sequence() : gmd__EX_x005fExtent() { }
        virtual ~__gml__domainOfValidity_sequence() { }
        /// Friend allocator used by soap_new___gml__domainOfValidity_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__domainOfValidity_sequence * SOAP_FMAC2 soap_instantiate___gml__domainOfValidity_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1463 */
#ifndef SOAP_TYPE_plu__gml__domainOfValidity
#define SOAP_TYPE_plu__gml__domainOfValidity (-442)
/* Type _gml__domainOfValidity is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gml:domainOfValidity': */
class SOAP_CMAC _gml__domainOfValidity {
      public:
        __gml__domainOfValidity_sequence *__domainOfValidity_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_plu__gml__domainOfValidity
        virtual long soap_type(void) const { return SOAP_TYPE_plu__gml__domainOfValidity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _gml__domainOfValidity, default initialized and not managed by a soap context
        virtual _gml__domainOfValidity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_gml__domainOfValidity); }
      public:
        /// Constructor with default initializations
        _gml__domainOfValidity() : __domainOfValidity_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~_gml__domainOfValidity() { }
        /// Friend allocator used by soap_new__gml__domainOfValidity(struct soap*, int)
        friend SOAP_FMAC1 _gml__domainOfValidity * SOAP_FMAC2 soap_instantiate__gml__domainOfValidity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1466 */
#ifndef SOAP_TYPE_plu__gml__secondDefiningParameter
#define SOAP_TYPE_plu__gml__secondDefiningParameter (-443)
/* complex XML schema type 'gml:secondDefiningParameter': */
class SOAP_CMAC _gml__secondDefiningParameter {
      public:
        /// Required element 'gml:SecondDefiningParameter' of XML schema type 'gml:SecondDefiningParameter'
        _gml__SecondDefiningParameter *SecondDefiningParameter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_plu__gml__secondDefiningParameter
        virtual long soap_type(void) const { return SOAP_TYPE_plu__gml__secondDefiningParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _gml__secondDefiningParameter, default initialized and not managed by a soap context
        virtual _gml__secondDefiningParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_gml__secondDefiningParameter); }
      public:
        /// Constructor with default initializations
        _gml__secondDefiningParameter() : SecondDefiningParameter(), soap() { }
        virtual ~_gml__secondDefiningParameter() { }
        /// Friend allocator used by soap_new__gml__secondDefiningParameter(struct soap*, int)
        friend SOAP_FMAC1 _gml__secondDefiningParameter * SOAP_FMAC2 soap_instantiate__gml__secondDefiningParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:13350 */
#ifndef SOAP_TYPE_plu__gml__union_SecondDefiningParameter
#define SOAP_TYPE_plu__gml__union_SecondDefiningParameter (-1318)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_SecondDefiningParameter
{
        #define SOAP_UNION_plu__gml__union_SecondDefiningParameter_inverseFlattening	(1)	/**< union variant selector value for member inverseFlattening */
        gml__MeasureType *inverseFlattening;
        #define SOAP_UNION_plu__gml__union_SecondDefiningParameter_semiMinorAxis	(2)	/**< union variant selector value for member semiMinorAxis */
        gml__LengthType *semiMinorAxis;
        #define SOAP_UNION_plu__gml__union_SecondDefiningParameter_isSphere	(3)	/**< union variant selector value for member isSphere */
        bool isSphere;
};
#endif

/* PlannedLandUse_v3.0.h:1469 */
#ifndef SOAP_TYPE_plu__gml__SecondDefiningParameter
#define SOAP_TYPE_plu__gml__SecondDefiningParameter (-444)
/* Choice: */
class SOAP_CMAC _gml__SecondDefiningParameter {
      public:
        /// Union with union _gml__union_SecondDefiningParameter variant selector __union_SecondDefiningParameter set to one of: SOAP_UNION_plu__gml__union_SecondDefiningParameter_inverseFlattening SOAP_UNION_plu__gml__union_SecondDefiningParameter_semiMinorAxis SOAP_UNION_plu__gml__union_SecondDefiningParameter_isSphere
        int __union_SecondDefiningParameter;
        union _gml__union_SecondDefiningParameter union_SecondDefiningParameter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_plu__gml__SecondDefiningParameter
        virtual long soap_type(void) const { return SOAP_TYPE_plu__gml__SecondDefiningParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _gml__SecondDefiningParameter, default initialized and not managed by a soap context
        virtual _gml__SecondDefiningParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_gml__SecondDefiningParameter); }
      public:
        /// Constructor with default initializations
        _gml__SecondDefiningParameter() : __union_SecondDefiningParameter(), soap() { }
        virtual ~_gml__SecondDefiningParameter() { }
        /// Friend allocator used by soap_new__gml__SecondDefiningParameter(struct soap*, int)
        friend SOAP_FMAC1 _gml__SecondDefiningParameter * SOAP_FMAC2 soap_instantiate__gml__SecondDefiningParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:13389 */
#ifndef SOAP_TYPE_plu__gml__union_coordinateOperationAccuracy
#define SOAP_TYPE_plu__gml__union_coordinateOperationAccuracy (-1322)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_coordinateOperationAccuracy
{
        #define SOAP_UNION_plu__gml__union_coordinateOperationAccuracy_gmd__DQ_x005fRelativeInternalPositionalAccuracy	(1)	/**< union variant selector value for member gmd__DQ_x005fRelativeInternalPositionalAccuracy */
        gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType *gmd__DQ_x005fRelativeInternalPositionalAccuracy;
        #define SOAP_UNION_plu__gml__union_coordinateOperationAccuracy_gmd__DQ_x005fGriddedDataPositionalAccuracy	(2)	/**< union variant selector value for member gmd__DQ_x005fGriddedDataPositionalAccuracy */
        gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType *gmd__DQ_x005fGriddedDataPositionalAccuracy;
        #define SOAP_UNION_plu__gml__union_coordinateOperationAccuracy_gmd__DQ_x005fAbsoluteExternalPositionalAccuracy	(3)	/**< union variant selector value for member gmd__DQ_x005fAbsoluteExternalPositionalAccuracy */
        gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType *gmd__DQ_x005fAbsoluteExternalPositionalAccuracy;
};
#endif

/* PlannedLandUse_v3.0.h:13382 */
#ifndef SOAP_TYPE_plu___gml__coordinateOperationAccuracy_sequence
#define SOAP_TYPE_plu___gml__coordinateOperationAccuracy_sequence (-1321)
/* Wrapper: */
class SOAP_CMAC __gml__coordinateOperationAccuracy_sequence {
      public:
        /// Union with union _gml__union_coordinateOperationAccuracy variant selector __unionAbstractDQ_x005fPositionalAccuracy set to one of: SOAP_UNION_plu__gml__union_coordinateOperationAccuracy_gmd__DQ_x005fRelativeInternalPositionalAccuracy SOAP_UNION_plu__gml__union_coordinateOperationAccuracy_gmd__DQ_x005fGriddedDataPositionalAccuracy SOAP_UNION_plu__gml__union_coordinateOperationAccuracy_gmd__DQ_x005fAbsoluteExternalPositionalAccuracy
        int __unionAbstractDQ_x005fPositionalAccuracy;
        union _gml__union_coordinateOperationAccuracy union_coordinateOperationAccuracy;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__coordinateOperationAccuracy_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__coordinateOperationAccuracy_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__coordinateOperationAccuracy_sequence, default initialized and not managed by a soap context
        virtual __gml__coordinateOperationAccuracy_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__coordinateOperationAccuracy_sequence); }
      public:
        /// Constructor with default initializations
        __gml__coordinateOperationAccuracy_sequence() : __unionAbstractDQ_x005fPositionalAccuracy() { }
        virtual ~__gml__coordinateOperationAccuracy_sequence() { }
        /// Friend allocator used by soap_new___gml__coordinateOperationAccuracy_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__coordinateOperationAccuracy_sequence * SOAP_FMAC2 soap_instantiate___gml__coordinateOperationAccuracy_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1472 */
#ifndef SOAP_TYPE_plu__gml__coordinateOperationAccuracy
#define SOAP_TYPE_plu__gml__coordinateOperationAccuracy (-445)
/* complex XML schema type 'gml:coordinateOperationAccuracy': */
class SOAP_CMAC _gml__coordinateOperationAccuracy {
      public:
        __gml__coordinateOperationAccuracy_sequence *__coordinateOperationAccuracy_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_plu__gml__coordinateOperationAccuracy
        virtual long soap_type(void) const { return SOAP_TYPE_plu__gml__coordinateOperationAccuracy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _gml__coordinateOperationAccuracy, default initialized and not managed by a soap context
        virtual _gml__coordinateOperationAccuracy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_gml__coordinateOperationAccuracy); }
      public:
        /// Constructor with default initializations
        _gml__coordinateOperationAccuracy() : __coordinateOperationAccuracy_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~_gml__coordinateOperationAccuracy() { }
        /// Friend allocator used by soap_new__gml__coordinateOperationAccuracy(struct soap*, int)
        friend SOAP_FMAC1 _gml__coordinateOperationAccuracy * SOAP_FMAC2 soap_instantiate__gml__coordinateOperationAccuracy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:13445 */
#ifndef SOAP_TYPE_plu___gml__formulaCitation_sequence
#define SOAP_TYPE_plu___gml__formulaCitation_sequence (-1327)
/* Wrapper: */
class SOAP_CMAC __gml__formulaCitation_sequence {
      public:
        /// Required element 'gmd:CI_Citation' of XML schema type 'gmd:CI_Citation_Type'
        gmd__CI_x005fCitation_x005fType *gmd__CI_x005fCitation;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__formulaCitation_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__formulaCitation_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__formulaCitation_sequence, default initialized and not managed by a soap context
        virtual __gml__formulaCitation_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__formulaCitation_sequence); }
      public:
        /// Constructor with default initializations
        __gml__formulaCitation_sequence() : gmd__CI_x005fCitation() { }
        virtual ~__gml__formulaCitation_sequence() { }
        /// Friend allocator used by soap_new___gml__formulaCitation_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__formulaCitation_sequence * SOAP_FMAC2 soap_instantiate___gml__formulaCitation_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1475 */
#ifndef SOAP_TYPE_plu__gml__formulaCitation
#define SOAP_TYPE_plu__gml__formulaCitation (-446)
/* complex XML schema type 'gml:formulaCitation': */
class SOAP_CMAC _gml__formulaCitation {
      public:
        __gml__formulaCitation_sequence *__formulaCitation_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_plu__gml__formulaCitation
        virtual long soap_type(void) const { return SOAP_TYPE_plu__gml__formulaCitation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _gml__formulaCitation, default initialized and not managed by a soap context
        virtual _gml__formulaCitation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_gml__formulaCitation); }
      public:
        /// Constructor with default initializations
        _gml__formulaCitation() : __formulaCitation_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~_gml__formulaCitation() { }
        /// Friend allocator used by soap_new__gml__formulaCitation(struct soap*, int)
        friend SOAP_FMAC1 _gml__formulaCitation * SOAP_FMAC2 soap_instantiate__gml__formulaCitation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:13507 */
#ifndef SOAP_TYPE_plu__gmd__union_DS_x005fAggregate_x005fPropertyType
#define SOAP_TYPE_plu__gmd__union_DS_x005fAggregate_x005fPropertyType (-1331)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_DS_x005fAggregate_x005fPropertyType
{
        #define SOAP_UNION_plu__gmd__union_DS_x005fAggregate_x005fPropertyType_DS_x005fOtherAggregate	(1)	/**< union variant selector value for member DS_x005fOtherAggregate */
        gmd__DS_x005fOtherAggregate_x005fType *DS_x005fOtherAggregate;
        #define SOAP_UNION_plu__gmd__union_DS_x005fAggregate_x005fPropertyType_DS_x005fStereoMate	(2)	/**< union variant selector value for member DS_x005fStereoMate */
        gmd__DS_x005fStereoMate_x005fType *DS_x005fStereoMate;
        #define SOAP_UNION_plu__gmd__union_DS_x005fAggregate_x005fPropertyType_DS_x005fSeries	(3)	/**< union variant selector value for member DS_x005fSeries */
        gmd__DS_x005fSeries_x005fType *DS_x005fSeries;
        #define SOAP_UNION_plu__gmd__union_DS_x005fAggregate_x005fPropertyType_DS_x005fPlatform	(4)	/**< union variant selector value for member DS_x005fPlatform */
        gmd__DS_x005fPlatform_x005fType *DS_x005fPlatform;
        #define SOAP_UNION_plu__gmd__union_DS_x005fAggregate_x005fPropertyType_DS_x005fSensor	(5)	/**< union variant selector value for member DS_x005fSensor */
        gmd__DS_x005fSensor_x005fType *DS_x005fSensor;
        #define SOAP_UNION_plu__gmd__union_DS_x005fAggregate_x005fPropertyType_DS_x005fProductionSeries	(6)	/**< union variant selector value for member DS_x005fProductionSeries */
        gmd__DS_x005fProductionSeries_x005fType *DS_x005fProductionSeries;
        #define SOAP_UNION_plu__gmd__union_DS_x005fAggregate_x005fPropertyType_DS_x005fInitiative	(7)	/**< union variant selector value for member DS_x005fInitiative */
        gmd__DS_x005fInitiative_x005fType *DS_x005fInitiative;
};
#endif

/* PlannedLandUse_v3.0.h:13500 */
#ifndef SOAP_TYPE_plu___gmd__DS_x005fAggregate_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DS_x005fAggregate_x005fPropertyType_sequence (-1330)
/* Wrapper: */
class SOAP_CMAC __gmd__DS_x005fAggregate_x005fPropertyType_sequence {
      public:
        /// Union with union _gmd__union_DS_x005fAggregate_x005fPropertyType variant selector __unionAbstractDS_x005fAggregate set to one of: SOAP_UNION_plu__gmd__union_DS_x005fAggregate_x005fPropertyType_DS_x005fOtherAggregate SOAP_UNION_plu__gmd__union_DS_x005fAggregate_x005fPropertyType_DS_x005fStereoMate SOAP_UNION_plu__gmd__union_DS_x005fAggregate_x005fPropertyType_DS_x005fSeries SOAP_UNION_plu__gmd__union_DS_x005fAggregate_x005fPropertyType_DS_x005fPlatform SOAP_UNION_plu__gmd__union_DS_x005fAggregate_x005fPropertyType_DS_x005fSensor SOAP_UNION_plu__gmd__union_DS_x005fAggregate_x005fPropertyType_DS_x005fProductionSeries SOAP_UNION_plu__gmd__union_DS_x005fAggregate_x005fPropertyType_DS_x005fInitiative
        int __unionAbstractDS_x005fAggregate;
        union _gmd__union_DS_x005fAggregate_x005fPropertyType union_DS_x005fAggregate_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DS_x005fAggregate_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DS_x005fAggregate_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DS_x005fAggregate_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DS_x005fAggregate_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DS_x005fAggregate_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DS_x005fAggregate_x005fPropertyType_sequence() : __unionAbstractDS_x005fAggregate() { }
        virtual ~__gmd__DS_x005fAggregate_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DS_x005fAggregate_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DS_x005fAggregate_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DS_x005fAggregate_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1481 */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fAggregate_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fAggregate_x005fPropertyType (-448)
/* Type gmd__DS_x005fAggregate_x005fPropertyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gmd:DS_Aggregate_PropertyType': */
class SOAP_CMAC gmd__DS_x005fAggregate_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DS_x005fAggregate_x005fPropertyType_sequence *__DS_x005fAggregate_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DS_x005fAggregate_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DS_x005fAggregate_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DS_x005fAggregate_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DS_x005fAggregate_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DS_x005fAggregate_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DS_x005fAggregate_x005fPropertyType() : __DS_x005fAggregate_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DS_x005fAggregate_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DS_x005fAggregate_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DS_x005fAggregate_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DS_x005fAggregate_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:13569 */
#ifndef SOAP_TYPE_plu___gmd__DS_x005fDataSet_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DS_x005fDataSet_x005fPropertyType_sequence (-1340)
/* Wrapper: */
class SOAP_CMAC __gmd__DS_x005fDataSet_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DS_DataSet' of XML schema type 'gmd:DS_DataSet_Type'
        gmd__DS_x005fDataSet_x005fType *DS_x005fDataSet;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DS_x005fDataSet_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DS_x005fDataSet_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DS_x005fDataSet_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DS_x005fDataSet_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DS_x005fDataSet_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DS_x005fDataSet_x005fPropertyType_sequence() : DS_x005fDataSet() { }
        virtual ~__gmd__DS_x005fDataSet_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DS_x005fDataSet_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DS_x005fDataSet_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DS_x005fDataSet_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1487 */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fDataSet_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fDataSet_x005fPropertyType (-450)
/* complex XML schema type 'gmd:DS_DataSet_PropertyType': */
class SOAP_CMAC gmd__DS_x005fDataSet_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DS_x005fDataSet_x005fPropertyType_sequence *__DS_x005fDataSet_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DS_x005fDataSet_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DS_x005fDataSet_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DS_x005fDataSet_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DS_x005fDataSet_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DS_x005fDataSet_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DS_x005fDataSet_x005fPropertyType() : __DS_x005fDataSet_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DS_x005fDataSet_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DS_x005fDataSet_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DS_x005fDataSet_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DS_x005fDataSet_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:13620 */
#ifndef SOAP_TYPE_plu__gmd__union_DS_x005fOtherAggregate_x005fPropertyType
#define SOAP_TYPE_plu__gmd__union_DS_x005fOtherAggregate_x005fPropertyType (-1344)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_DS_x005fOtherAggregate_x005fPropertyType
{
        #define SOAP_UNION_plu__gmd__union_DS_x005fOtherAggregate_x005fPropertyType_DS_x005fOtherAggregate	(1)	/**< union variant selector value for member DS_x005fOtherAggregate */
        gmd__DS_x005fOtherAggregate_x005fType *DS_x005fOtherAggregate;
        #define SOAP_UNION_plu__gmd__union_DS_x005fOtherAggregate_x005fPropertyType_DS_x005fStereoMate	(2)	/**< union variant selector value for member DS_x005fStereoMate */
        gmd__DS_x005fStereoMate_x005fType *DS_x005fStereoMate;
};
#endif

/* PlannedLandUse_v3.0.h:13614 */
#ifndef SOAP_TYPE_plu___gmd__DS_x005fOtherAggregate_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DS_x005fOtherAggregate_x005fPropertyType_sequence (-1343)
/* Wrapper: */
class SOAP_CMAC __gmd__DS_x005fOtherAggregate_x005fPropertyType_sequence {
      public:
        /// Union with union _gmd__union_DS_x005fOtherAggregate_x005fPropertyType variant selector __unionDS_x005fOtherAggregate set to one of: SOAP_UNION_plu__gmd__union_DS_x005fOtherAggregate_x005fPropertyType_DS_x005fOtherAggregate SOAP_UNION_plu__gmd__union_DS_x005fOtherAggregate_x005fPropertyType_DS_x005fStereoMate
        int __unionDS_x005fOtherAggregate;
        union _gmd__union_DS_x005fOtherAggregate_x005fPropertyType union_DS_x005fOtherAggregate_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DS_x005fOtherAggregate_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DS_x005fOtherAggregate_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DS_x005fOtherAggregate_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DS_x005fOtherAggregate_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DS_x005fOtherAggregate_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DS_x005fOtherAggregate_x005fPropertyType_sequence() : __unionDS_x005fOtherAggregate() { }
        virtual ~__gmd__DS_x005fOtherAggregate_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DS_x005fOtherAggregate_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DS_x005fOtherAggregate_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DS_x005fOtherAggregate_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1493 */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fOtherAggregate_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fOtherAggregate_x005fPropertyType (-452)
/* complex XML schema type 'gmd:DS_OtherAggregate_PropertyType': */
class SOAP_CMAC gmd__DS_x005fOtherAggregate_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DS_x005fOtherAggregate_x005fPropertyType_sequence *__DS_x005fOtherAggregate_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DS_x005fOtherAggregate_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DS_x005fOtherAggregate_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DS_x005fOtherAggregate_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DS_x005fOtherAggregate_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DS_x005fOtherAggregate_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DS_x005fOtherAggregate_x005fPropertyType() : __DS_x005fOtherAggregate_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DS_x005fOtherAggregate_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DS_x005fOtherAggregate_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DS_x005fOtherAggregate_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DS_x005fOtherAggregate_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:13674 */
#ifndef SOAP_TYPE_plu__gmd__union_DS_x005fSeries_x005fPropertyType
#define SOAP_TYPE_plu__gmd__union_DS_x005fSeries_x005fPropertyType (-1347)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_DS_x005fSeries_x005fPropertyType
{
        #define SOAP_UNION_plu__gmd__union_DS_x005fSeries_x005fPropertyType_DS_x005fSeries	(1)	/**< union variant selector value for member DS_x005fSeries */
        gmd__DS_x005fSeries_x005fType *DS_x005fSeries;
        #define SOAP_UNION_plu__gmd__union_DS_x005fSeries_x005fPropertyType_DS_x005fPlatform	(2)	/**< union variant selector value for member DS_x005fPlatform */
        gmd__DS_x005fPlatform_x005fType *DS_x005fPlatform;
        #define SOAP_UNION_plu__gmd__union_DS_x005fSeries_x005fPropertyType_DS_x005fSensor	(3)	/**< union variant selector value for member DS_x005fSensor */
        gmd__DS_x005fSensor_x005fType *DS_x005fSensor;
        #define SOAP_UNION_plu__gmd__union_DS_x005fSeries_x005fPropertyType_DS_x005fProductionSeries	(4)	/**< union variant selector value for member DS_x005fProductionSeries */
        gmd__DS_x005fProductionSeries_x005fType *DS_x005fProductionSeries;
};
#endif

/* PlannedLandUse_v3.0.h:13668 */
#ifndef SOAP_TYPE_plu___gmd__DS_x005fSeries_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DS_x005fSeries_x005fPropertyType_sequence (-1346)
/* Wrapper: */
class SOAP_CMAC __gmd__DS_x005fSeries_x005fPropertyType_sequence {
      public:
        /// Union with union _gmd__union_DS_x005fSeries_x005fPropertyType variant selector __unionDS_x005fSeries set to one of: SOAP_UNION_plu__gmd__union_DS_x005fSeries_x005fPropertyType_DS_x005fSeries SOAP_UNION_plu__gmd__union_DS_x005fSeries_x005fPropertyType_DS_x005fPlatform SOAP_UNION_plu__gmd__union_DS_x005fSeries_x005fPropertyType_DS_x005fSensor SOAP_UNION_plu__gmd__union_DS_x005fSeries_x005fPropertyType_DS_x005fProductionSeries
        int __unionDS_x005fSeries;
        union _gmd__union_DS_x005fSeries_x005fPropertyType union_DS_x005fSeries_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DS_x005fSeries_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DS_x005fSeries_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DS_x005fSeries_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DS_x005fSeries_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DS_x005fSeries_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DS_x005fSeries_x005fPropertyType_sequence() : __unionDS_x005fSeries() { }
        virtual ~__gmd__DS_x005fSeries_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DS_x005fSeries_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DS_x005fSeries_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DS_x005fSeries_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1499 */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fSeries_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fSeries_x005fPropertyType (-454)
/* complex XML schema type 'gmd:DS_Series_PropertyType': */
class SOAP_CMAC gmd__DS_x005fSeries_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DS_x005fSeries_x005fPropertyType_sequence *__DS_x005fSeries_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DS_x005fSeries_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DS_x005fSeries_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DS_x005fSeries_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DS_x005fSeries_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DS_x005fSeries_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DS_x005fSeries_x005fPropertyType() : __DS_x005fSeries_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DS_x005fSeries_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DS_x005fSeries_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DS_x005fSeries_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DS_x005fSeries_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:13726 */
#ifndef SOAP_TYPE_plu___gmd__DS_x005fInitiative_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DS_x005fInitiative_x005fPropertyType_sequence (-1349)
/* Wrapper: */
class SOAP_CMAC __gmd__DS_x005fInitiative_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DS_Initiative' of XML schema type 'gmd:DS_Initiative_Type'
        gmd__DS_x005fInitiative_x005fType *DS_x005fInitiative;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DS_x005fInitiative_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DS_x005fInitiative_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DS_x005fInitiative_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DS_x005fInitiative_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DS_x005fInitiative_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DS_x005fInitiative_x005fPropertyType_sequence() : DS_x005fInitiative() { }
        virtual ~__gmd__DS_x005fInitiative_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DS_x005fInitiative_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DS_x005fInitiative_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DS_x005fInitiative_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1505 */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fInitiative_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fInitiative_x005fPropertyType (-456)
/* complex XML schema type 'gmd:DS_Initiative_PropertyType': */
class SOAP_CMAC gmd__DS_x005fInitiative_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DS_x005fInitiative_x005fPropertyType_sequence *__DS_x005fInitiative_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DS_x005fInitiative_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DS_x005fInitiative_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DS_x005fInitiative_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DS_x005fInitiative_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DS_x005fInitiative_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DS_x005fInitiative_x005fPropertyType() : __DS_x005fInitiative_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DS_x005fInitiative_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DS_x005fInitiative_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DS_x005fInitiative_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DS_x005fInitiative_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:13771 */
#ifndef SOAP_TYPE_plu___gmd__DS_x005fPlatform_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DS_x005fPlatform_x005fPropertyType_sequence (-1351)
/* Wrapper: */
class SOAP_CMAC __gmd__DS_x005fPlatform_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DS_Platform' of XML schema type 'gmd:DS_Platform_Type'
        gmd__DS_x005fPlatform_x005fType *DS_x005fPlatform;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DS_x005fPlatform_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DS_x005fPlatform_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DS_x005fPlatform_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DS_x005fPlatform_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DS_x005fPlatform_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DS_x005fPlatform_x005fPropertyType_sequence() : DS_x005fPlatform() { }
        virtual ~__gmd__DS_x005fPlatform_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DS_x005fPlatform_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DS_x005fPlatform_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DS_x005fPlatform_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1511 */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fPlatform_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fPlatform_x005fPropertyType (-458)
/* complex XML schema type 'gmd:DS_Platform_PropertyType': */
class SOAP_CMAC gmd__DS_x005fPlatform_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DS_x005fPlatform_x005fPropertyType_sequence *__DS_x005fPlatform_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DS_x005fPlatform_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DS_x005fPlatform_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DS_x005fPlatform_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DS_x005fPlatform_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DS_x005fPlatform_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DS_x005fPlatform_x005fPropertyType() : __DS_x005fPlatform_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DS_x005fPlatform_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DS_x005fPlatform_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DS_x005fPlatform_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DS_x005fPlatform_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:13816 */
#ifndef SOAP_TYPE_plu___gmd__DS_x005fSensor_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DS_x005fSensor_x005fPropertyType_sequence (-1353)
/* Wrapper: */
class SOAP_CMAC __gmd__DS_x005fSensor_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DS_Sensor' of XML schema type 'gmd:DS_Sensor_Type'
        gmd__DS_x005fSensor_x005fType *DS_x005fSensor;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DS_x005fSensor_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DS_x005fSensor_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DS_x005fSensor_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DS_x005fSensor_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DS_x005fSensor_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DS_x005fSensor_x005fPropertyType_sequence() : DS_x005fSensor() { }
        virtual ~__gmd__DS_x005fSensor_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DS_x005fSensor_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DS_x005fSensor_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DS_x005fSensor_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1517 */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fSensor_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fSensor_x005fPropertyType (-460)
/* complex XML schema type 'gmd:DS_Sensor_PropertyType': */
class SOAP_CMAC gmd__DS_x005fSensor_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DS_x005fSensor_x005fPropertyType_sequence *__DS_x005fSensor_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DS_x005fSensor_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DS_x005fSensor_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DS_x005fSensor_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DS_x005fSensor_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DS_x005fSensor_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DS_x005fSensor_x005fPropertyType() : __DS_x005fSensor_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DS_x005fSensor_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DS_x005fSensor_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DS_x005fSensor_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DS_x005fSensor_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:13861 */
#ifndef SOAP_TYPE_plu___gmd__DS_x005fProductionSeries_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DS_x005fProductionSeries_x005fPropertyType_sequence (-1355)
/* Wrapper: */
class SOAP_CMAC __gmd__DS_x005fProductionSeries_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DS_ProductionSeries' of XML schema type 'gmd:DS_ProductionSeries_Type'
        gmd__DS_x005fProductionSeries_x005fType *DS_x005fProductionSeries;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DS_x005fProductionSeries_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DS_x005fProductionSeries_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DS_x005fProductionSeries_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DS_x005fProductionSeries_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DS_x005fProductionSeries_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DS_x005fProductionSeries_x005fPropertyType_sequence() : DS_x005fProductionSeries() { }
        virtual ~__gmd__DS_x005fProductionSeries_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DS_x005fProductionSeries_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DS_x005fProductionSeries_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DS_x005fProductionSeries_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1523 */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fProductionSeries_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fProductionSeries_x005fPropertyType (-462)
/* complex XML schema type 'gmd:DS_ProductionSeries_PropertyType': */
class SOAP_CMAC gmd__DS_x005fProductionSeries_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DS_x005fProductionSeries_x005fPropertyType_sequence *__DS_x005fProductionSeries_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DS_x005fProductionSeries_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DS_x005fProductionSeries_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DS_x005fProductionSeries_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DS_x005fProductionSeries_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DS_x005fProductionSeries_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DS_x005fProductionSeries_x005fPropertyType() : __DS_x005fProductionSeries_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DS_x005fProductionSeries_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DS_x005fProductionSeries_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DS_x005fProductionSeries_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DS_x005fProductionSeries_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:13906 */
#ifndef SOAP_TYPE_plu___gmd__DS_x005fStereoMate_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DS_x005fStereoMate_x005fPropertyType_sequence (-1357)
/* Wrapper: */
class SOAP_CMAC __gmd__DS_x005fStereoMate_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DS_StereoMate' of XML schema type 'gmd:DS_StereoMate_Type'
        gmd__DS_x005fStereoMate_x005fType *DS_x005fStereoMate;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DS_x005fStereoMate_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DS_x005fStereoMate_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DS_x005fStereoMate_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DS_x005fStereoMate_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DS_x005fStereoMate_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DS_x005fStereoMate_x005fPropertyType_sequence() : DS_x005fStereoMate() { }
        virtual ~__gmd__DS_x005fStereoMate_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DS_x005fStereoMate_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DS_x005fStereoMate_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DS_x005fStereoMate_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1529 */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fStereoMate_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fStereoMate_x005fPropertyType (-464)
/* complex XML schema type 'gmd:DS_StereoMate_PropertyType': */
class SOAP_CMAC gmd__DS_x005fStereoMate_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DS_x005fStereoMate_x005fPropertyType_sequence *__DS_x005fStereoMate_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DS_x005fStereoMate_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DS_x005fStereoMate_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DS_x005fStereoMate_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DS_x005fStereoMate_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DS_x005fStereoMate_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DS_x005fStereoMate_x005fPropertyType() : __DS_x005fStereoMate_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DS_x005fStereoMate_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DS_x005fStereoMate_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DS_x005fStereoMate_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DS_x005fStereoMate_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:13951 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fMetadata_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fMetadata_x005fPropertyType_sequence (-1359)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fMetadata_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_Metadata' of XML schema type 'gmd:MD_Metadata_Type'
        gmd__MD_x005fMetadata_x005fType *MD_x005fMetadata;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fMetadata_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fMetadata_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fMetadata_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fMetadata_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fMetadata_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fMetadata_x005fPropertyType_sequence() : MD_x005fMetadata() { }
        virtual ~__gmd__MD_x005fMetadata_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fMetadata_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fMetadata_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fMetadata_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1535 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMetadata_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fMetadata_x005fPropertyType (-466)
/* complex XML schema type 'gmd:MD_Metadata_PropertyType': */
class SOAP_CMAC gmd__MD_x005fMetadata_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fMetadata_x005fPropertyType_sequence *__MD_x005fMetadata_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fMetadata_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fMetadata_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fMetadata_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fMetadata_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fMetadata_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fMetadata_x005fPropertyType() : __MD_x005fMetadata_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fMetadata_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fMetadata_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fMetadata_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fMetadata_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14002 */
#ifndef SOAP_TYPE_plu__gmd__union_MD_x005fGridSpatialRepresentation_x005fPropertyType
#define SOAP_TYPE_plu__gmd__union_MD_x005fGridSpatialRepresentation_x005fPropertyType (-1363)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_MD_x005fGridSpatialRepresentation_x005fPropertyType
{
        #define SOAP_UNION_plu__gmd__union_MD_x005fGridSpatialRepresentation_x005fPropertyType_MD_x005fGridSpatialRepresentation	(1)	/**< union variant selector value for member MD_x005fGridSpatialRepresentation */
        gmd__MD_x005fGridSpatialRepresentation_x005fType *MD_x005fGridSpatialRepresentation;
        #define SOAP_UNION_plu__gmd__union_MD_x005fGridSpatialRepresentation_x005fPropertyType_MD_x005fGeoreferenceable	(2)	/**< union variant selector value for member MD_x005fGeoreferenceable */
        gmd__MD_x005fGeoreferenceable_x005fType *MD_x005fGeoreferenceable;
        #define SOAP_UNION_plu__gmd__union_MD_x005fGridSpatialRepresentation_x005fPropertyType_MD_x005fGeorectified	(3)	/**< union variant selector value for member MD_x005fGeorectified */
        gmd__MD_x005fGeorectified_x005fType *MD_x005fGeorectified;
};
#endif

/* PlannedLandUse_v3.0.h:13996 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType_sequence (-1362)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType_sequence {
      public:
        /// Union with union _gmd__union_MD_x005fGridSpatialRepresentation_x005fPropertyType variant selector __unionMD_x005fGridSpatialRepresentation set to one of: SOAP_UNION_plu__gmd__union_MD_x005fGridSpatialRepresentation_x005fPropertyType_MD_x005fGridSpatialRepresentation SOAP_UNION_plu__gmd__union_MD_x005fGridSpatialRepresentation_x005fPropertyType_MD_x005fGeoreferenceable SOAP_UNION_plu__gmd__union_MD_x005fGridSpatialRepresentation_x005fPropertyType_MD_x005fGeorectified
        int __unionMD_x005fGridSpatialRepresentation;
        union _gmd__union_MD_x005fGridSpatialRepresentation_x005fPropertyType union_MD_x005fGridSpatialRepresentation_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType_sequence() : __unionMD_x005fGridSpatialRepresentation() { }
        virtual ~__gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1541 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType (-468)
/* complex XML schema type 'gmd:MD_GridSpatialRepresentation_PropertyType': */
class SOAP_CMAC gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType_sequence *__MD_x005fGridSpatialRepresentation_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType() : __MD_x005fGridSpatialRepresentation_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14052 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType_sequence (-1368)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_VectorSpatialRepresentation' of XML schema type 'gmd:MD_VectorSpatialRepresentation_Type'
        gmd__MD_x005fVectorSpatialRepresentation_x005fType *MD_x005fVectorSpatialRepresentation;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType_sequence() : MD_x005fVectorSpatialRepresentation() { }
        virtual ~__gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1547 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType (-470)
/* complex XML schema type 'gmd:MD_VectorSpatialRepresentation_PropertyType': */
class SOAP_CMAC gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType_sequence *__MD_x005fVectorSpatialRepresentation_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType() : __MD_x005fVectorSpatialRepresentation_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14104 */
#ifndef SOAP_TYPE_plu__gmd__union_MD_x005fSpatialRepresentation_x005fPropertyType
#define SOAP_TYPE_plu__gmd__union_MD_x005fSpatialRepresentation_x005fPropertyType (-1372)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_MD_x005fSpatialRepresentation_x005fPropertyType
{
        #define SOAP_UNION_plu__gmd__union_MD_x005fSpatialRepresentation_x005fPropertyType_MD_x005fGridSpatialRepresentation	(1)	/**< union variant selector value for member MD_x005fGridSpatialRepresentation */
        gmd__MD_x005fGridSpatialRepresentation_x005fType *MD_x005fGridSpatialRepresentation;
        #define SOAP_UNION_plu__gmd__union_MD_x005fSpatialRepresentation_x005fPropertyType_MD_x005fGeoreferenceable	(2)	/**< union variant selector value for member MD_x005fGeoreferenceable */
        gmd__MD_x005fGeoreferenceable_x005fType *MD_x005fGeoreferenceable;
        #define SOAP_UNION_plu__gmd__union_MD_x005fSpatialRepresentation_x005fPropertyType_MD_x005fGeorectified	(3)	/**< union variant selector value for member MD_x005fGeorectified */
        gmd__MD_x005fGeorectified_x005fType *MD_x005fGeorectified;
        #define SOAP_UNION_plu__gmd__union_MD_x005fSpatialRepresentation_x005fPropertyType_MD_x005fVectorSpatialRepresentation	(4)	/**< union variant selector value for member MD_x005fVectorSpatialRepresentation */
        gmd__MD_x005fVectorSpatialRepresentation_x005fType *MD_x005fVectorSpatialRepresentation;
};
#endif

/* PlannedLandUse_v3.0.h:14097 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fSpatialRepresentation_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fSpatialRepresentation_x005fPropertyType_sequence (-1371)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fSpatialRepresentation_x005fPropertyType_sequence {
      public:
        /// Union with union _gmd__union_MD_x005fSpatialRepresentation_x005fPropertyType variant selector __unionAbstractMD_x005fSpatialRepresentation set to one of: SOAP_UNION_plu__gmd__union_MD_x005fSpatialRepresentation_x005fPropertyType_MD_x005fGridSpatialRepresentation SOAP_UNION_plu__gmd__union_MD_x005fSpatialRepresentation_x005fPropertyType_MD_x005fGeoreferenceable SOAP_UNION_plu__gmd__union_MD_x005fSpatialRepresentation_x005fPropertyType_MD_x005fGeorectified SOAP_UNION_plu__gmd__union_MD_x005fSpatialRepresentation_x005fPropertyType_MD_x005fVectorSpatialRepresentation
        int __unionAbstractMD_x005fSpatialRepresentation;
        union _gmd__union_MD_x005fSpatialRepresentation_x005fPropertyType union_MD_x005fSpatialRepresentation_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fSpatialRepresentation_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fSpatialRepresentation_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fSpatialRepresentation_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fSpatialRepresentation_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fSpatialRepresentation_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fSpatialRepresentation_x005fPropertyType_sequence() : __unionAbstractMD_x005fSpatialRepresentation() { }
        virtual ~__gmd__MD_x005fSpatialRepresentation_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fSpatialRepresentation_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fSpatialRepresentation_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fSpatialRepresentation_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1553 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fSpatialRepresentation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fSpatialRepresentation_x005fPropertyType (-472)
/* complex XML schema type 'gmd:MD_SpatialRepresentation_PropertyType': */
class SOAP_CMAC gmd__MD_x005fSpatialRepresentation_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fSpatialRepresentation_x005fPropertyType_sequence *__MD_x005fSpatialRepresentation_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fSpatialRepresentation_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fSpatialRepresentation_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fSpatialRepresentation_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fSpatialRepresentation_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fSpatialRepresentation_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fSpatialRepresentation_x005fPropertyType() : __MD_x005fSpatialRepresentation_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fSpatialRepresentation_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fSpatialRepresentation_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fSpatialRepresentation_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fSpatialRepresentation_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14158 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fGeoreferenceable_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fGeoreferenceable_x005fPropertyType_sequence (-1374)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fGeoreferenceable_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_Georeferenceable' of XML schema type 'gmd:MD_Georeferenceable_Type'
        gmd__MD_x005fGeoreferenceable_x005fType *MD_x005fGeoreferenceable;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fGeoreferenceable_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fGeoreferenceable_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fGeoreferenceable_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fGeoreferenceable_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fGeoreferenceable_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fGeoreferenceable_x005fPropertyType_sequence() : MD_x005fGeoreferenceable() { }
        virtual ~__gmd__MD_x005fGeoreferenceable_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fGeoreferenceable_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fGeoreferenceable_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fGeoreferenceable_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1559 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fGeoreferenceable_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fGeoreferenceable_x005fPropertyType (-474)
/* complex XML schema type 'gmd:MD_Georeferenceable_PropertyType': */
class SOAP_CMAC gmd__MD_x005fGeoreferenceable_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fGeoreferenceable_x005fPropertyType_sequence *__MD_x005fGeoreferenceable_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fGeoreferenceable_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fGeoreferenceable_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fGeoreferenceable_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fGeoreferenceable_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fGeoreferenceable_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fGeoreferenceable_x005fPropertyType() : __MD_x005fGeoreferenceable_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fGeoreferenceable_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fGeoreferenceable_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fGeoreferenceable_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fGeoreferenceable_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14203 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fDimension_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fDimension_x005fPropertyType_sequence (-1376)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fDimension_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_Dimension' of XML schema type 'gmd:MD_Dimension_Type'
        gmd__MD_x005fDimension_x005fType *MD_x005fDimension;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fDimension_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fDimension_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fDimension_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fDimension_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fDimension_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fDimension_x005fPropertyType_sequence() : MD_x005fDimension() { }
        virtual ~__gmd__MD_x005fDimension_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fDimension_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fDimension_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fDimension_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1565 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDimension_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fDimension_x005fPropertyType (-476)
/* complex XML schema type 'gmd:MD_Dimension_PropertyType': */
class SOAP_CMAC gmd__MD_x005fDimension_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fDimension_x005fPropertyType_sequence *__MD_x005fDimension_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fDimension_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fDimension_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fDimension_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fDimension_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fDimension_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fDimension_x005fPropertyType() : __MD_x005fDimension_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fDimension_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fDimension_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fDimension_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fDimension_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14248 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fGeorectified_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fGeorectified_x005fPropertyType_sequence (-1379)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fGeorectified_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_Georectified' of XML schema type 'gmd:MD_Georectified_Type'
        gmd__MD_x005fGeorectified_x005fType *MD_x005fGeorectified;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fGeorectified_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fGeorectified_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fGeorectified_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fGeorectified_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fGeorectified_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fGeorectified_x005fPropertyType_sequence() : MD_x005fGeorectified() { }
        virtual ~__gmd__MD_x005fGeorectified_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fGeorectified_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fGeorectified_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fGeorectified_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1571 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fGeorectified_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fGeorectified_x005fPropertyType (-478)
/* complex XML schema type 'gmd:MD_Georectified_PropertyType': */
class SOAP_CMAC gmd__MD_x005fGeorectified_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fGeorectified_x005fPropertyType_sequence *__MD_x005fGeorectified_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fGeorectified_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fGeorectified_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fGeorectified_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fGeorectified_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fGeorectified_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fGeorectified_x005fPropertyType() : __MD_x005fGeorectified_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fGeorectified_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fGeorectified_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fGeorectified_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fGeorectified_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14293 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fGeometricObjects_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fGeometricObjects_x005fPropertyType_sequence (-1381)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fGeometricObjects_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_GeometricObjects' of XML schema type 'gmd:MD_GeometricObjects_Type'
        gmd__MD_x005fGeometricObjects_x005fType *MD_x005fGeometricObjects;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fGeometricObjects_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fGeometricObjects_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fGeometricObjects_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fGeometricObjects_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fGeometricObjects_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fGeometricObjects_x005fPropertyType_sequence() : MD_x005fGeometricObjects() { }
        virtual ~__gmd__MD_x005fGeometricObjects_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fGeometricObjects_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fGeometricObjects_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fGeometricObjects_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1577 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fGeometricObjects_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fGeometricObjects_x005fPropertyType (-480)
/* complex XML schema type 'gmd:MD_GeometricObjects_PropertyType': */
class SOAP_CMAC gmd__MD_x005fGeometricObjects_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fGeometricObjects_x005fPropertyType_sequence *__MD_x005fGeometricObjects_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fGeometricObjects_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fGeometricObjects_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fGeometricObjects_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fGeometricObjects_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fGeometricObjects_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fGeometricObjects_x005fPropertyType() : __MD_x005fGeometricObjects_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fGeometricObjects_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fGeometricObjects_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fGeometricObjects_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fGeometricObjects_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14338 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fPixelOrientationCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fPixelOrientationCode_x005fPropertyType_sequence (-1384)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fPixelOrientationCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_PixelOrientationCode' of XML schema type 'gmd:MD_PixelOrientationCode_Type'
        enum gmd__MD_x005fPixelOrientationCode_x005fType MD_x005fPixelOrientationCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fPixelOrientationCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fPixelOrientationCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fPixelOrientationCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fPixelOrientationCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fPixelOrientationCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fPixelOrientationCode_x005fPropertyType_sequence() : MD_x005fPixelOrientationCode() { }
        virtual ~__gmd__MD_x005fPixelOrientationCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fPixelOrientationCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fPixelOrientationCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fPixelOrientationCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1580 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fPixelOrientationCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fPixelOrientationCode_x005fPropertyType (-481)
/* complex XML schema type 'gmd:MD_PixelOrientationCode_PropertyType': */
class SOAP_CMAC gmd__MD_x005fPixelOrientationCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fPixelOrientationCode_x005fPropertyType_sequence *__MD_x005fPixelOrientationCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fPixelOrientationCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fPixelOrientationCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fPixelOrientationCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fPixelOrientationCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fPixelOrientationCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fPixelOrientationCode_x005fPropertyType() : __MD_x005fPixelOrientationCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fPixelOrientationCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fPixelOrientationCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fPixelOrientationCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fPixelOrientationCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14363 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fTopologyLevelCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fTopologyLevelCode_x005fPropertyType_sequence (-1386)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fTopologyLevelCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_TopologyLevelCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *MD_x005fTopologyLevelCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fTopologyLevelCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fTopologyLevelCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fTopologyLevelCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fTopologyLevelCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fTopologyLevelCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fTopologyLevelCode_x005fPropertyType_sequence() : MD_x005fTopologyLevelCode() { }
        virtual ~__gmd__MD_x005fTopologyLevelCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fTopologyLevelCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fTopologyLevelCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fTopologyLevelCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1583 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fTopologyLevelCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fTopologyLevelCode_x005fPropertyType (-482)
/* complex XML schema type 'gmd:MD_TopologyLevelCode_PropertyType': */
class SOAP_CMAC gmd__MD_x005fTopologyLevelCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fTopologyLevelCode_x005fPropertyType_sequence *__MD_x005fTopologyLevelCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fTopologyLevelCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fTopologyLevelCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fTopologyLevelCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fTopologyLevelCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fTopologyLevelCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fTopologyLevelCode_x005fPropertyType() : __MD_x005fTopologyLevelCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fTopologyLevelCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fTopologyLevelCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fTopologyLevelCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fTopologyLevelCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14388 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType_sequence (-1389)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_GeometricObjectTypeCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *MD_x005fGeometricObjectTypeCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType_sequence() : MD_x005fGeometricObjectTypeCode() { }
        virtual ~__gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1586 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType (-483)
/* complex XML schema type 'gmd:MD_GeometricObjectTypeCode_PropertyType': */
class SOAP_CMAC gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType_sequence *__MD_x005fGeometricObjectTypeCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType() : __MD_x005fGeometricObjectTypeCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14413 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fCellGeometryCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fCellGeometryCode_x005fPropertyType_sequence (-1391)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fCellGeometryCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_CellGeometryCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *MD_x005fCellGeometryCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fCellGeometryCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fCellGeometryCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fCellGeometryCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fCellGeometryCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fCellGeometryCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fCellGeometryCode_x005fPropertyType_sequence() : MD_x005fCellGeometryCode() { }
        virtual ~__gmd__MD_x005fCellGeometryCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fCellGeometryCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fCellGeometryCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fCellGeometryCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1589 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fCellGeometryCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fCellGeometryCode_x005fPropertyType (-484)
/* complex XML schema type 'gmd:MD_CellGeometryCode_PropertyType': */
class SOAP_CMAC gmd__MD_x005fCellGeometryCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fCellGeometryCode_x005fPropertyType_sequence *__MD_x005fCellGeometryCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fCellGeometryCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fCellGeometryCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fCellGeometryCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fCellGeometryCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fCellGeometryCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fCellGeometryCode_x005fPropertyType() : __MD_x005fCellGeometryCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fCellGeometryCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fCellGeometryCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fCellGeometryCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fCellGeometryCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14438 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType_sequence (-1393)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_DimensionNameTypeCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *MD_x005fDimensionNameTypeCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType_sequence() : MD_x005fDimensionNameTypeCode() { }
        virtual ~__gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1592 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType (-485)
/* complex XML schema type 'gmd:MD_DimensionNameTypeCode_PropertyType': */
class SOAP_CMAC gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType_sequence *__MD_x005fDimensionNameTypeCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType() : __MD_x005fDimensionNameTypeCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14463 */
#ifndef SOAP_TYPE_plu___gmd__CI_x005fResponsibleParty_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__CI_x005fResponsibleParty_x005fPropertyType_sequence (-1395)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_x005fResponsibleParty_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_ResponsibleParty' of XML schema type 'gmd:CI_ResponsibleParty_Type'
        gmd__CI_x005fResponsibleParty_x005fType *CI_x005fResponsibleParty;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__CI_x005fResponsibleParty_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__CI_x005fResponsibleParty_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_x005fResponsibleParty_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_x005fResponsibleParty_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__CI_x005fResponsibleParty_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__CI_x005fResponsibleParty_x005fPropertyType_sequence() : CI_x005fResponsibleParty() { }
        virtual ~__gmd__CI_x005fResponsibleParty_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_x005fResponsibleParty_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_x005fResponsibleParty_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_x005fResponsibleParty_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1598 */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fResponsibleParty_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fResponsibleParty_x005fPropertyType (-487)
/* complex XML schema type 'gmd:CI_ResponsibleParty_PropertyType': */
class SOAP_CMAC gmd__CI_x005fResponsibleParty_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__CI_x005fResponsibleParty_x005fPropertyType_sequence *__CI_x005fResponsibleParty_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__CI_x005fResponsibleParty_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__CI_x005fResponsibleParty_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_x005fResponsibleParty_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_x005fResponsibleParty_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__CI_x005fResponsibleParty_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__CI_x005fResponsibleParty_x005fPropertyType() : __CI_x005fResponsibleParty_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__CI_x005fResponsibleParty_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_x005fResponsibleParty_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_x005fResponsibleParty_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_x005fResponsibleParty_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14508 */
#ifndef SOAP_TYPE_plu___gmd__CI_x005fCitation_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__CI_x005fCitation_x005fPropertyType_sequence (-1398)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_x005fCitation_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_Citation' of XML schema type 'gmd:CI_Citation_Type'
        gmd__CI_x005fCitation_x005fType *CI_x005fCitation;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__CI_x005fCitation_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__CI_x005fCitation_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_x005fCitation_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_x005fCitation_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__CI_x005fCitation_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__CI_x005fCitation_x005fPropertyType_sequence() : CI_x005fCitation() { }
        virtual ~__gmd__CI_x005fCitation_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_x005fCitation_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_x005fCitation_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_x005fCitation_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1604 */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fCitation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fCitation_x005fPropertyType (-489)
/* complex XML schema type 'gmd:CI_Citation_PropertyType': */
class SOAP_CMAC gmd__CI_x005fCitation_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__CI_x005fCitation_x005fPropertyType_sequence *__CI_x005fCitation_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__CI_x005fCitation_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__CI_x005fCitation_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_x005fCitation_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_x005fCitation_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__CI_x005fCitation_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__CI_x005fCitation_x005fPropertyType() : __CI_x005fCitation_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__CI_x005fCitation_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_x005fCitation_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_x005fCitation_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_x005fCitation_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14553 */
#ifndef SOAP_TYPE_plu___gmd__CI_x005fAddress_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__CI_x005fAddress_x005fPropertyType_sequence (-1400)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_x005fAddress_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_Address' of XML schema type 'gmd:CI_Address_Type'
        gmd__CI_x005fAddress_x005fType *CI_x005fAddress;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__CI_x005fAddress_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__CI_x005fAddress_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_x005fAddress_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_x005fAddress_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__CI_x005fAddress_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__CI_x005fAddress_x005fPropertyType_sequence() : CI_x005fAddress() { }
        virtual ~__gmd__CI_x005fAddress_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_x005fAddress_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_x005fAddress_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_x005fAddress_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1610 */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fAddress_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fAddress_x005fPropertyType (-491)
/* complex XML schema type 'gmd:CI_Address_PropertyType': */
class SOAP_CMAC gmd__CI_x005fAddress_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__CI_x005fAddress_x005fPropertyType_sequence *__CI_x005fAddress_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__CI_x005fAddress_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__CI_x005fAddress_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_x005fAddress_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_x005fAddress_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__CI_x005fAddress_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__CI_x005fAddress_x005fPropertyType() : __CI_x005fAddress_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__CI_x005fAddress_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_x005fAddress_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_x005fAddress_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_x005fAddress_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14598 */
#ifndef SOAP_TYPE_plu___gmd__CI_x005fOnlineResource_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__CI_x005fOnlineResource_x005fPropertyType_sequence (-1403)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_x005fOnlineResource_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_OnlineResource' of XML schema type 'gmd:CI_OnlineResource_Type'
        gmd__CI_x005fOnlineResource_x005fType *CI_x005fOnlineResource;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__CI_x005fOnlineResource_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__CI_x005fOnlineResource_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_x005fOnlineResource_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_x005fOnlineResource_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__CI_x005fOnlineResource_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__CI_x005fOnlineResource_x005fPropertyType_sequence() : CI_x005fOnlineResource() { }
        virtual ~__gmd__CI_x005fOnlineResource_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_x005fOnlineResource_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_x005fOnlineResource_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_x005fOnlineResource_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1616 */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fOnlineResource_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fOnlineResource_x005fPropertyType (-493)
/* complex XML schema type 'gmd:CI_OnlineResource_PropertyType': */
class SOAP_CMAC gmd__CI_x005fOnlineResource_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__CI_x005fOnlineResource_x005fPropertyType_sequence *__CI_x005fOnlineResource_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__CI_x005fOnlineResource_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__CI_x005fOnlineResource_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_x005fOnlineResource_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_x005fOnlineResource_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__CI_x005fOnlineResource_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__CI_x005fOnlineResource_x005fPropertyType() : __CI_x005fOnlineResource_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__CI_x005fOnlineResource_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_x005fOnlineResource_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_x005fOnlineResource_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_x005fOnlineResource_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14643 */
#ifndef SOAP_TYPE_plu___gmd__CI_x005fContact_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__CI_x005fContact_x005fPropertyType_sequence (-1406)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_x005fContact_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_Contact' of XML schema type 'gmd:CI_Contact_Type'
        gmd__CI_x005fContact_x005fType *CI_x005fContact;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__CI_x005fContact_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__CI_x005fContact_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_x005fContact_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_x005fContact_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__CI_x005fContact_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__CI_x005fContact_x005fPropertyType_sequence() : CI_x005fContact() { }
        virtual ~__gmd__CI_x005fContact_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_x005fContact_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_x005fContact_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_x005fContact_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1622 */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fContact_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fContact_x005fPropertyType (-495)
/* complex XML schema type 'gmd:CI_Contact_PropertyType': */
class SOAP_CMAC gmd__CI_x005fContact_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__CI_x005fContact_x005fPropertyType_sequence *__CI_x005fContact_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__CI_x005fContact_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__CI_x005fContact_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_x005fContact_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_x005fContact_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__CI_x005fContact_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__CI_x005fContact_x005fPropertyType() : __CI_x005fContact_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__CI_x005fContact_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_x005fContact_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_x005fContact_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_x005fContact_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14688 */
#ifndef SOAP_TYPE_plu___gmd__CI_x005fTelephone_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__CI_x005fTelephone_x005fPropertyType_sequence (-1409)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_x005fTelephone_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_Telephone' of XML schema type 'gmd:CI_Telephone_Type'
        gmd__CI_x005fTelephone_x005fType *CI_x005fTelephone;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__CI_x005fTelephone_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__CI_x005fTelephone_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_x005fTelephone_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_x005fTelephone_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__CI_x005fTelephone_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__CI_x005fTelephone_x005fPropertyType_sequence() : CI_x005fTelephone() { }
        virtual ~__gmd__CI_x005fTelephone_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_x005fTelephone_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_x005fTelephone_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_x005fTelephone_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1628 */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fTelephone_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fTelephone_x005fPropertyType (-497)
/* complex XML schema type 'gmd:CI_Telephone_PropertyType': */
class SOAP_CMAC gmd__CI_x005fTelephone_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__CI_x005fTelephone_x005fPropertyType_sequence *__CI_x005fTelephone_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__CI_x005fTelephone_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__CI_x005fTelephone_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_x005fTelephone_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_x005fTelephone_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__CI_x005fTelephone_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__CI_x005fTelephone_x005fPropertyType() : __CI_x005fTelephone_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__CI_x005fTelephone_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_x005fTelephone_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_x005fTelephone_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_x005fTelephone_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14733 */
#ifndef SOAP_TYPE_plu___gmd__CI_x005fDate_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__CI_x005fDate_x005fPropertyType_sequence (-1412)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_x005fDate_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_Date' of XML schema type 'gmd:CI_Date_Type'
        gmd__CI_x005fDate_x005fType *CI_x005fDate;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__CI_x005fDate_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__CI_x005fDate_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_x005fDate_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_x005fDate_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__CI_x005fDate_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__CI_x005fDate_x005fPropertyType_sequence() : CI_x005fDate() { }
        virtual ~__gmd__CI_x005fDate_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_x005fDate_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_x005fDate_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_x005fDate_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1634 */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fDate_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fDate_x005fPropertyType (-499)
/* complex XML schema type 'gmd:CI_Date_PropertyType': */
class SOAP_CMAC gmd__CI_x005fDate_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__CI_x005fDate_x005fPropertyType_sequence *__CI_x005fDate_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__CI_x005fDate_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__CI_x005fDate_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_x005fDate_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_x005fDate_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__CI_x005fDate_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__CI_x005fDate_x005fPropertyType() : __CI_x005fDate_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__CI_x005fDate_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_x005fDate_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_x005fDate_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_x005fDate_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14778 */
#ifndef SOAP_TYPE_plu___gmd__CI_x005fSeries_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__CI_x005fSeries_x005fPropertyType_sequence (-1415)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_x005fSeries_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_Series' of XML schema type 'gmd:CI_Series_Type'
        gmd__CI_x005fSeries_x005fType *CI_x005fSeries;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__CI_x005fSeries_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__CI_x005fSeries_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_x005fSeries_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_x005fSeries_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__CI_x005fSeries_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__CI_x005fSeries_x005fPropertyType_sequence() : CI_x005fSeries() { }
        virtual ~__gmd__CI_x005fSeries_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_x005fSeries_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_x005fSeries_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_x005fSeries_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1640 */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fSeries_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fSeries_x005fPropertyType (-501)
/* complex XML schema type 'gmd:CI_Series_PropertyType': */
class SOAP_CMAC gmd__CI_x005fSeries_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__CI_x005fSeries_x005fPropertyType_sequence *__CI_x005fSeries_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__CI_x005fSeries_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__CI_x005fSeries_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_x005fSeries_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_x005fSeries_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__CI_x005fSeries_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__CI_x005fSeries_x005fPropertyType() : __CI_x005fSeries_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__CI_x005fSeries_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_x005fSeries_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_x005fSeries_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_x005fSeries_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14823 */
#ifndef SOAP_TYPE_plu___gmd__URL_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__URL_x005fPropertyType_sequence (-1418)
/* Wrapper: */
class SOAP_CMAC __gmd__URL_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:URL' of XML schema type 'xsd:anyURI'
        char *URL;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__URL_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__URL_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__URL_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__URL_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__URL_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__URL_x005fPropertyType_sequence() : URL() { }
        virtual ~__gmd__URL_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__URL_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__URL_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__URL_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1643 */
#ifndef SOAP_TYPE_plu_gmd__URL_x005fPropertyType
#define SOAP_TYPE_plu_gmd__URL_x005fPropertyType (-502)
/* complex XML schema type 'gmd:URL_PropertyType': */
class SOAP_CMAC gmd__URL_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__URL_x005fPropertyType_sequence *__URL_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__URL_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__URL_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__URL_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__URL_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__URL_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__URL_x005fPropertyType() : __URL_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__URL_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__URL_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__URL_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__URL_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14848 */
#ifndef SOAP_TYPE_plu___gmd__CI_x005fRoleCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__CI_x005fRoleCode_x005fPropertyType_sequence (-1420)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_x005fRoleCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_RoleCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *CI_x005fRoleCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__CI_x005fRoleCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__CI_x005fRoleCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_x005fRoleCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_x005fRoleCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__CI_x005fRoleCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__CI_x005fRoleCode_x005fPropertyType_sequence() : CI_x005fRoleCode() { }
        virtual ~__gmd__CI_x005fRoleCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_x005fRoleCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_x005fRoleCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_x005fRoleCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1646 */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fRoleCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fRoleCode_x005fPropertyType (-503)
/* complex XML schema type 'gmd:CI_RoleCode_PropertyType': */
class SOAP_CMAC gmd__CI_x005fRoleCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__CI_x005fRoleCode_x005fPropertyType_sequence *__CI_x005fRoleCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__CI_x005fRoleCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__CI_x005fRoleCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_x005fRoleCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_x005fRoleCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__CI_x005fRoleCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__CI_x005fRoleCode_x005fPropertyType() : __CI_x005fRoleCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__CI_x005fRoleCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_x005fRoleCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_x005fRoleCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_x005fRoleCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14873 */
#ifndef SOAP_TYPE_plu___gmd__CI_x005fPresentationFormCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__CI_x005fPresentationFormCode_x005fPropertyType_sequence (-1422)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_x005fPresentationFormCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_PresentationFormCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *CI_x005fPresentationFormCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__CI_x005fPresentationFormCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__CI_x005fPresentationFormCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_x005fPresentationFormCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_x005fPresentationFormCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__CI_x005fPresentationFormCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__CI_x005fPresentationFormCode_x005fPropertyType_sequence() : CI_x005fPresentationFormCode() { }
        virtual ~__gmd__CI_x005fPresentationFormCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_x005fPresentationFormCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_x005fPresentationFormCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_x005fPresentationFormCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1649 */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fPresentationFormCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fPresentationFormCode_x005fPropertyType (-504)
/* complex XML schema type 'gmd:CI_PresentationFormCode_PropertyType': */
class SOAP_CMAC gmd__CI_x005fPresentationFormCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__CI_x005fPresentationFormCode_x005fPropertyType_sequence *__CI_x005fPresentationFormCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__CI_x005fPresentationFormCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__CI_x005fPresentationFormCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_x005fPresentationFormCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_x005fPresentationFormCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__CI_x005fPresentationFormCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__CI_x005fPresentationFormCode_x005fPropertyType() : __CI_x005fPresentationFormCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__CI_x005fPresentationFormCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_x005fPresentationFormCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_x005fPresentationFormCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_x005fPresentationFormCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14898 */
#ifndef SOAP_TYPE_plu___gmd__CI_x005fOnLineFunctionCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__CI_x005fOnLineFunctionCode_x005fPropertyType_sequence (-1424)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_x005fOnLineFunctionCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_OnLineFunctionCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *CI_x005fOnLineFunctionCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__CI_x005fOnLineFunctionCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__CI_x005fOnLineFunctionCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_x005fOnLineFunctionCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_x005fOnLineFunctionCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__CI_x005fOnLineFunctionCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__CI_x005fOnLineFunctionCode_x005fPropertyType_sequence() : CI_x005fOnLineFunctionCode() { }
        virtual ~__gmd__CI_x005fOnLineFunctionCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_x005fOnLineFunctionCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_x005fOnLineFunctionCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_x005fOnLineFunctionCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1652 */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fOnLineFunctionCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fOnLineFunctionCode_x005fPropertyType (-505)
/* complex XML schema type 'gmd:CI_OnLineFunctionCode_PropertyType': */
class SOAP_CMAC gmd__CI_x005fOnLineFunctionCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__CI_x005fOnLineFunctionCode_x005fPropertyType_sequence *__CI_x005fOnLineFunctionCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__CI_x005fOnLineFunctionCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__CI_x005fOnLineFunctionCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_x005fOnLineFunctionCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_x005fOnLineFunctionCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__CI_x005fOnLineFunctionCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__CI_x005fOnLineFunctionCode_x005fPropertyType() : __CI_x005fOnLineFunctionCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__CI_x005fOnLineFunctionCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_x005fOnLineFunctionCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_x005fOnLineFunctionCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_x005fOnLineFunctionCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14923 */
#ifndef SOAP_TYPE_plu___gmd__CI_x005fDateTypeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__CI_x005fDateTypeCode_x005fPropertyType_sequence (-1426)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_x005fDateTypeCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_DateTypeCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *CI_x005fDateTypeCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__CI_x005fDateTypeCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__CI_x005fDateTypeCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_x005fDateTypeCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_x005fDateTypeCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__CI_x005fDateTypeCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__CI_x005fDateTypeCode_x005fPropertyType_sequence() : CI_x005fDateTypeCode() { }
        virtual ~__gmd__CI_x005fDateTypeCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_x005fDateTypeCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_x005fDateTypeCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_x005fDateTypeCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1655 */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fDateTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fDateTypeCode_x005fPropertyType (-506)
/* complex XML schema type 'gmd:CI_DateTypeCode_PropertyType': */
class SOAP_CMAC gmd__CI_x005fDateTypeCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__CI_x005fDateTypeCode_x005fPropertyType_sequence *__CI_x005fDateTypeCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__CI_x005fDateTypeCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__CI_x005fDateTypeCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_x005fDateTypeCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_x005fDateTypeCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__CI_x005fDateTypeCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__CI_x005fDateTypeCode_x005fPropertyType() : __CI_x005fDateTypeCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__CI_x005fDateTypeCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_x005fDateTypeCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_x005fDateTypeCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_x005fDateTypeCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14948 */
#ifndef SOAP_TYPE_plu___gmd__RS_x005fIdentifier_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__RS_x005fIdentifier_x005fPropertyType_sequence (-1428)
/* Wrapper: */
class SOAP_CMAC __gmd__RS_x005fIdentifier_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:RS_Identifier' of XML schema type 'gmd:RS_Identifier_Type'
        gmd__RS_x005fIdentifier_x005fType *RS_x005fIdentifier;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__RS_x005fIdentifier_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__RS_x005fIdentifier_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__RS_x005fIdentifier_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__RS_x005fIdentifier_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__RS_x005fIdentifier_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__RS_x005fIdentifier_x005fPropertyType_sequence() : RS_x005fIdentifier() { }
        virtual ~__gmd__RS_x005fIdentifier_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__RS_x005fIdentifier_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__RS_x005fIdentifier_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__RS_x005fIdentifier_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1661 */
#ifndef SOAP_TYPE_plu_gmd__RS_x005fIdentifier_x005fPropertyType
#define SOAP_TYPE_plu_gmd__RS_x005fIdentifier_x005fPropertyType (-508)
/* complex XML schema type 'gmd:RS_Identifier_PropertyType': */
class SOAP_CMAC gmd__RS_x005fIdentifier_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__RS_x005fIdentifier_x005fPropertyType_sequence *__RS_x005fIdentifier_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__RS_x005fIdentifier_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__RS_x005fIdentifier_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__RS_x005fIdentifier_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__RS_x005fIdentifier_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__RS_x005fIdentifier_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__RS_x005fIdentifier_x005fPropertyType() : __RS_x005fIdentifier_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__RS_x005fIdentifier_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__RS_x005fIdentifier_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__RS_x005fIdentifier_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__RS_x005fIdentifier_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:14993 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fReferenceSystem_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fReferenceSystem_x005fPropertyType_sequence (-1431)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fReferenceSystem_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_ReferenceSystem' of XML schema type 'gmd:MD_ReferenceSystem_Type'
        gmd__MD_x005fReferenceSystem_x005fType *MD_x005fReferenceSystem;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fReferenceSystem_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fReferenceSystem_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fReferenceSystem_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fReferenceSystem_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fReferenceSystem_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fReferenceSystem_x005fPropertyType_sequence() : MD_x005fReferenceSystem() { }
        virtual ~__gmd__MD_x005fReferenceSystem_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fReferenceSystem_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fReferenceSystem_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fReferenceSystem_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1667 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fReferenceSystem_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fReferenceSystem_x005fPropertyType (-510)
/* complex XML schema type 'gmd:MD_ReferenceSystem_PropertyType': */
class SOAP_CMAC gmd__MD_x005fReferenceSystem_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fReferenceSystem_x005fPropertyType_sequence *__MD_x005fReferenceSystem_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fReferenceSystem_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fReferenceSystem_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fReferenceSystem_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fReferenceSystem_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fReferenceSystem_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fReferenceSystem_x005fPropertyType() : __MD_x005fReferenceSystem_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fReferenceSystem_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fReferenceSystem_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fReferenceSystem_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fReferenceSystem_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15044 */
#ifndef SOAP_TYPE_plu__gmd__union_MD_x005fIdentifier_x005fPropertyType
#define SOAP_TYPE_plu__gmd__union_MD_x005fIdentifier_x005fPropertyType (-1435)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_MD_x005fIdentifier_x005fPropertyType
{
        #define SOAP_UNION_plu__gmd__union_MD_x005fIdentifier_x005fPropertyType_MD_x005fIdentifier	(1)	/**< union variant selector value for member MD_x005fIdentifier */
        gmd__MD_x005fIdentifier_x005fType *MD_x005fIdentifier;
        #define SOAP_UNION_plu__gmd__union_MD_x005fIdentifier_x005fPropertyType_RS_x005fIdentifier	(2)	/**< union variant selector value for member RS_x005fIdentifier */
        gmd__RS_x005fIdentifier_x005fType *RS_x005fIdentifier;
};
#endif

/* PlannedLandUse_v3.0.h:15038 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fIdentifier_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fIdentifier_x005fPropertyType_sequence (-1434)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fIdentifier_x005fPropertyType_sequence {
      public:
        /// Union with union _gmd__union_MD_x005fIdentifier_x005fPropertyType variant selector __unionMD_x005fIdentifier set to one of: SOAP_UNION_plu__gmd__union_MD_x005fIdentifier_x005fPropertyType_MD_x005fIdentifier SOAP_UNION_plu__gmd__union_MD_x005fIdentifier_x005fPropertyType_RS_x005fIdentifier
        int __unionMD_x005fIdentifier;
        union _gmd__union_MD_x005fIdentifier_x005fPropertyType union_MD_x005fIdentifier_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fIdentifier_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fIdentifier_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fIdentifier_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fIdentifier_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fIdentifier_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fIdentifier_x005fPropertyType_sequence() : __unionMD_x005fIdentifier() { }
        virtual ~__gmd__MD_x005fIdentifier_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fIdentifier_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fIdentifier_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fIdentifier_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1673 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fIdentifier_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fIdentifier_x005fPropertyType (-512)
/* Type gmd__MD_x005fIdentifier_x005fPropertyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gmd:MD_Identifier_PropertyType': */
class SOAP_CMAC gmd__MD_x005fIdentifier_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fIdentifier_x005fPropertyType_sequence *__MD_x005fIdentifier_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fIdentifier_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fIdentifier_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fIdentifier_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fIdentifier_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fIdentifier_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fIdentifier_x005fPropertyType() : __MD_x005fIdentifier_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fIdentifier_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fIdentifier_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fIdentifier_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fIdentifier_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15099 */
#ifndef SOAP_TYPE_plu__gmd__union_RS_x005fReferenceSystem_x005fPropertyType
#define SOAP_TYPE_plu__gmd__union_RS_x005fReferenceSystem_x005fPropertyType (-1439)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_RS_x005fReferenceSystem_x005fPropertyType
{
};
#endif

/* PlannedLandUse_v3.0.h:15092 */
#ifndef SOAP_TYPE_plu___gmd__RS_x005fReferenceSystem_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__RS_x005fReferenceSystem_x005fPropertyType_sequence (-1438)
/* Wrapper: */
class SOAP_CMAC __gmd__RS_x005fReferenceSystem_x005fPropertyType_sequence {
      public:
        /// Union with union _gmd__union_RS_x005fReferenceSystem_x005fPropertyType variant selector __unionAbstractRS_x005fReferenceSystem set to one of:
        int __unionAbstractRS_x005fReferenceSystem;
        union _gmd__union_RS_x005fReferenceSystem_x005fPropertyType union_RS_x005fReferenceSystem_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__RS_x005fReferenceSystem_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__RS_x005fReferenceSystem_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__RS_x005fReferenceSystem_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__RS_x005fReferenceSystem_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__RS_x005fReferenceSystem_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__RS_x005fReferenceSystem_x005fPropertyType_sequence() : __unionAbstractRS_x005fReferenceSystem() { }
        virtual ~__gmd__RS_x005fReferenceSystem_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__RS_x005fReferenceSystem_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__RS_x005fReferenceSystem_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__RS_x005fReferenceSystem_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1679 */
#ifndef SOAP_TYPE_plu_gmd__RS_x005fReferenceSystem_x005fPropertyType
#define SOAP_TYPE_plu_gmd__RS_x005fReferenceSystem_x005fPropertyType (-514)
/* complex XML schema type 'gmd:RS_ReferenceSystem_PropertyType': */
class SOAP_CMAC gmd__RS_x005fReferenceSystem_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__RS_x005fReferenceSystem_x005fPropertyType_sequence *__RS_x005fReferenceSystem_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__RS_x005fReferenceSystem_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__RS_x005fReferenceSystem_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__RS_x005fReferenceSystem_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__RS_x005fReferenceSystem_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__RS_x005fReferenceSystem_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__RS_x005fReferenceSystem_x005fPropertyType() : __RS_x005fReferenceSystem_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__RS_x005fReferenceSystem_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__RS_x005fReferenceSystem_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__RS_x005fReferenceSystem_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__RS_x005fReferenceSystem_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15149 */
#ifndef SOAP_TYPE_plu__gmd__union_EX_x005fTemporalExtent_x005fPropertyType
#define SOAP_TYPE_plu__gmd__union_EX_x005fTemporalExtent_x005fPropertyType (-1442)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_EX_x005fTemporalExtent_x005fPropertyType
{
        #define SOAP_UNION_plu__gmd__union_EX_x005fTemporalExtent_x005fPropertyType_EX_x005fTemporalExtent	(1)	/**< union variant selector value for member EX_x005fTemporalExtent */
        gmd__EX_x005fTemporalExtent_x005fType *EX_x005fTemporalExtent;
        #define SOAP_UNION_plu__gmd__union_EX_x005fTemporalExtent_x005fPropertyType_EX_x005fSpatialTemporalExtent	(2)	/**< union variant selector value for member EX_x005fSpatialTemporalExtent */
        gmd__EX_x005fSpatialTemporalExtent_x005fType *EX_x005fSpatialTemporalExtent;
};
#endif

/* PlannedLandUse_v3.0.h:15143 */
#ifndef SOAP_TYPE_plu___gmd__EX_x005fTemporalExtent_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__EX_x005fTemporalExtent_x005fPropertyType_sequence (-1441)
/* Wrapper: */
class SOAP_CMAC __gmd__EX_x005fTemporalExtent_x005fPropertyType_sequence {
      public:
        /// Union with union _gmd__union_EX_x005fTemporalExtent_x005fPropertyType variant selector __unionEX_x005fTemporalExtent set to one of: SOAP_UNION_plu__gmd__union_EX_x005fTemporalExtent_x005fPropertyType_EX_x005fTemporalExtent SOAP_UNION_plu__gmd__union_EX_x005fTemporalExtent_x005fPropertyType_EX_x005fSpatialTemporalExtent
        int __unionEX_x005fTemporalExtent;
        union _gmd__union_EX_x005fTemporalExtent_x005fPropertyType union_EX_x005fTemporalExtent_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__EX_x005fTemporalExtent_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__EX_x005fTemporalExtent_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__EX_x005fTemporalExtent_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__EX_x005fTemporalExtent_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__EX_x005fTemporalExtent_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__EX_x005fTemporalExtent_x005fPropertyType_sequence() : __unionEX_x005fTemporalExtent() { }
        virtual ~__gmd__EX_x005fTemporalExtent_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__EX_x005fTemporalExtent_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__EX_x005fTemporalExtent_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__EX_x005fTemporalExtent_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1685 */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fTemporalExtent_x005fPropertyType
#define SOAP_TYPE_plu_gmd__EX_x005fTemporalExtent_x005fPropertyType (-516)
/* complex XML schema type 'gmd:EX_TemporalExtent_PropertyType': */
class SOAP_CMAC gmd__EX_x005fTemporalExtent_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__EX_x005fTemporalExtent_x005fPropertyType_sequence *__EX_x005fTemporalExtent_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__EX_x005fTemporalExtent_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__EX_x005fTemporalExtent_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_x005fTemporalExtent_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__EX_x005fTemporalExtent_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__EX_x005fTemporalExtent_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__EX_x005fTemporalExtent_x005fPropertyType() : __EX_x005fTemporalExtent_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__EX_x005fTemporalExtent_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__EX_x005fTemporalExtent_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_x005fTemporalExtent_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__EX_x005fTemporalExtent_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15197 */
#ifndef SOAP_TYPE_plu___gmd__EX_x005fVerticalExtent_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__EX_x005fVerticalExtent_x005fPropertyType_sequence (-1446)
/* Wrapper: */
class SOAP_CMAC __gmd__EX_x005fVerticalExtent_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:EX_VerticalExtent' of XML schema type 'gmd:EX_VerticalExtent_Type'
        gmd__EX_x005fVerticalExtent_x005fType *EX_x005fVerticalExtent;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__EX_x005fVerticalExtent_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__EX_x005fVerticalExtent_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__EX_x005fVerticalExtent_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__EX_x005fVerticalExtent_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__EX_x005fVerticalExtent_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__EX_x005fVerticalExtent_x005fPropertyType_sequence() : EX_x005fVerticalExtent() { }
        virtual ~__gmd__EX_x005fVerticalExtent_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__EX_x005fVerticalExtent_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__EX_x005fVerticalExtent_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__EX_x005fVerticalExtent_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1691 */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fVerticalExtent_x005fPropertyType
#define SOAP_TYPE_plu_gmd__EX_x005fVerticalExtent_x005fPropertyType (-518)
/* complex XML schema type 'gmd:EX_VerticalExtent_PropertyType': */
class SOAP_CMAC gmd__EX_x005fVerticalExtent_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__EX_x005fVerticalExtent_x005fPropertyType_sequence *__EX_x005fVerticalExtent_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__EX_x005fVerticalExtent_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__EX_x005fVerticalExtent_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_x005fVerticalExtent_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__EX_x005fVerticalExtent_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__EX_x005fVerticalExtent_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__EX_x005fVerticalExtent_x005fPropertyType() : __EX_x005fVerticalExtent_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__EX_x005fVerticalExtent_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__EX_x005fVerticalExtent_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_x005fVerticalExtent_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__EX_x005fVerticalExtent_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15242 */
#ifndef SOAP_TYPE_plu___gmd__EX_x005fBoundingPolygon_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__EX_x005fBoundingPolygon_x005fPropertyType_sequence (-1449)
/* Wrapper: */
class SOAP_CMAC __gmd__EX_x005fBoundingPolygon_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:EX_BoundingPolygon' of XML schema type 'gmd:EX_BoundingPolygon_Type'
        gmd__EX_x005fBoundingPolygon_x005fType *EX_x005fBoundingPolygon;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__EX_x005fBoundingPolygon_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__EX_x005fBoundingPolygon_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__EX_x005fBoundingPolygon_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__EX_x005fBoundingPolygon_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__EX_x005fBoundingPolygon_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__EX_x005fBoundingPolygon_x005fPropertyType_sequence() : EX_x005fBoundingPolygon() { }
        virtual ~__gmd__EX_x005fBoundingPolygon_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__EX_x005fBoundingPolygon_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__EX_x005fBoundingPolygon_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__EX_x005fBoundingPolygon_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1697 */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fBoundingPolygon_x005fPropertyType
#define SOAP_TYPE_plu_gmd__EX_x005fBoundingPolygon_x005fPropertyType (-520)
/* complex XML schema type 'gmd:EX_BoundingPolygon_PropertyType': */
class SOAP_CMAC gmd__EX_x005fBoundingPolygon_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__EX_x005fBoundingPolygon_x005fPropertyType_sequence *__EX_x005fBoundingPolygon_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__EX_x005fBoundingPolygon_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__EX_x005fBoundingPolygon_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_x005fBoundingPolygon_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__EX_x005fBoundingPolygon_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__EX_x005fBoundingPolygon_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__EX_x005fBoundingPolygon_x005fPropertyType() : __EX_x005fBoundingPolygon_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__EX_x005fBoundingPolygon_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__EX_x005fBoundingPolygon_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_x005fBoundingPolygon_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__EX_x005fBoundingPolygon_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15287 */
#ifndef SOAP_TYPE_plu___gmd__EX_x005fExtent_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__EX_x005fExtent_x005fPropertyType_sequence (-1452)
/* Wrapper: */
class SOAP_CMAC __gmd__EX_x005fExtent_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:EX_Extent' of XML schema type 'gmd:EX_Extent_Type'
        gmd__EX_x005fExtent_x005fType *EX_x005fExtent;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__EX_x005fExtent_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__EX_x005fExtent_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__EX_x005fExtent_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__EX_x005fExtent_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__EX_x005fExtent_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__EX_x005fExtent_x005fPropertyType_sequence() : EX_x005fExtent() { }
        virtual ~__gmd__EX_x005fExtent_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__EX_x005fExtent_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__EX_x005fExtent_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__EX_x005fExtent_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1703 */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fExtent_x005fPropertyType
#define SOAP_TYPE_plu_gmd__EX_x005fExtent_x005fPropertyType (-522)
/* complex XML schema type 'gmd:EX_Extent_PropertyType': */
class SOAP_CMAC gmd__EX_x005fExtent_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__EX_x005fExtent_x005fPropertyType_sequence *__EX_x005fExtent_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__EX_x005fExtent_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__EX_x005fExtent_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_x005fExtent_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__EX_x005fExtent_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__EX_x005fExtent_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__EX_x005fExtent_x005fPropertyType() : __EX_x005fExtent_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__EX_x005fExtent_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__EX_x005fExtent_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_x005fExtent_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__EX_x005fExtent_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15339 */
#ifndef SOAP_TYPE_plu__gmd__union_EX_x005fGeographicExtent_x005fPropertyType
#define SOAP_TYPE_plu__gmd__union_EX_x005fGeographicExtent_x005fPropertyType (-1455)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_EX_x005fGeographicExtent_x005fPropertyType
{
        #define SOAP_UNION_plu__gmd__union_EX_x005fGeographicExtent_x005fPropertyType_EX_x005fBoundingPolygon	(1)	/**< union variant selector value for member EX_x005fBoundingPolygon */
        gmd__EX_x005fBoundingPolygon_x005fType *EX_x005fBoundingPolygon;
        #define SOAP_UNION_plu__gmd__union_EX_x005fGeographicExtent_x005fPropertyType_EX_x005fGeographicBoundingBox	(2)	/**< union variant selector value for member EX_x005fGeographicBoundingBox */
        gmd__EX_x005fGeographicBoundingBox_x005fType *EX_x005fGeographicBoundingBox;
        #define SOAP_UNION_plu__gmd__union_EX_x005fGeographicExtent_x005fPropertyType_EX_x005fGeographicDescription	(3)	/**< union variant selector value for member EX_x005fGeographicDescription */
        gmd__EX_x005fGeographicDescription_x005fType *EX_x005fGeographicDescription;
};
#endif

/* PlannedLandUse_v3.0.h:15332 */
#ifndef SOAP_TYPE_plu___gmd__EX_x005fGeographicExtent_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__EX_x005fGeographicExtent_x005fPropertyType_sequence (-1454)
/* Wrapper: */
class SOAP_CMAC __gmd__EX_x005fGeographicExtent_x005fPropertyType_sequence {
      public:
        /// Union with union _gmd__union_EX_x005fGeographicExtent_x005fPropertyType variant selector __unionAbstractEX_x005fGeographicExtent set to one of: SOAP_UNION_plu__gmd__union_EX_x005fGeographicExtent_x005fPropertyType_EX_x005fBoundingPolygon SOAP_UNION_plu__gmd__union_EX_x005fGeographicExtent_x005fPropertyType_EX_x005fGeographicBoundingBox SOAP_UNION_plu__gmd__union_EX_x005fGeographicExtent_x005fPropertyType_EX_x005fGeographicDescription
        int __unionAbstractEX_x005fGeographicExtent;
        union _gmd__union_EX_x005fGeographicExtent_x005fPropertyType union_EX_x005fGeographicExtent_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__EX_x005fGeographicExtent_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__EX_x005fGeographicExtent_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__EX_x005fGeographicExtent_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__EX_x005fGeographicExtent_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__EX_x005fGeographicExtent_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__EX_x005fGeographicExtent_x005fPropertyType_sequence() : __unionAbstractEX_x005fGeographicExtent() { }
        virtual ~__gmd__EX_x005fGeographicExtent_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__EX_x005fGeographicExtent_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__EX_x005fGeographicExtent_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__EX_x005fGeographicExtent_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1709 */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fGeographicExtent_x005fPropertyType
#define SOAP_TYPE_plu_gmd__EX_x005fGeographicExtent_x005fPropertyType (-524)
/* complex XML schema type 'gmd:EX_GeographicExtent_PropertyType': */
class SOAP_CMAC gmd__EX_x005fGeographicExtent_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__EX_x005fGeographicExtent_x005fPropertyType_sequence *__EX_x005fGeographicExtent_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__EX_x005fGeographicExtent_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__EX_x005fGeographicExtent_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_x005fGeographicExtent_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__EX_x005fGeographicExtent_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__EX_x005fGeographicExtent_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__EX_x005fGeographicExtent_x005fPropertyType() : __EX_x005fGeographicExtent_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__EX_x005fGeographicExtent_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__EX_x005fGeographicExtent_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_x005fGeographicExtent_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__EX_x005fGeographicExtent_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15389 */
#ifndef SOAP_TYPE_plu___gmd__EX_x005fGeographicBoundingBox_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__EX_x005fGeographicBoundingBox_x005fPropertyType_sequence (-1459)
/* Wrapper: */
class SOAP_CMAC __gmd__EX_x005fGeographicBoundingBox_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:EX_GeographicBoundingBox' of XML schema type 'gmd:EX_GeographicBoundingBox_Type'
        gmd__EX_x005fGeographicBoundingBox_x005fType *EX_x005fGeographicBoundingBox;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__EX_x005fGeographicBoundingBox_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__EX_x005fGeographicBoundingBox_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__EX_x005fGeographicBoundingBox_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__EX_x005fGeographicBoundingBox_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__EX_x005fGeographicBoundingBox_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__EX_x005fGeographicBoundingBox_x005fPropertyType_sequence() : EX_x005fGeographicBoundingBox() { }
        virtual ~__gmd__EX_x005fGeographicBoundingBox_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__EX_x005fGeographicBoundingBox_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__EX_x005fGeographicBoundingBox_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__EX_x005fGeographicBoundingBox_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1715 */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fGeographicBoundingBox_x005fPropertyType
#define SOAP_TYPE_plu_gmd__EX_x005fGeographicBoundingBox_x005fPropertyType (-526)
/* complex XML schema type 'gmd:EX_GeographicBoundingBox_PropertyType': */
class SOAP_CMAC gmd__EX_x005fGeographicBoundingBox_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__EX_x005fGeographicBoundingBox_x005fPropertyType_sequence *__EX_x005fGeographicBoundingBox_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__EX_x005fGeographicBoundingBox_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__EX_x005fGeographicBoundingBox_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_x005fGeographicBoundingBox_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__EX_x005fGeographicBoundingBox_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__EX_x005fGeographicBoundingBox_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__EX_x005fGeographicBoundingBox_x005fPropertyType() : __EX_x005fGeographicBoundingBox_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__EX_x005fGeographicBoundingBox_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__EX_x005fGeographicBoundingBox_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_x005fGeographicBoundingBox_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__EX_x005fGeographicBoundingBox_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15434 */
#ifndef SOAP_TYPE_plu___gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType_sequence (-1461)
/* Wrapper: */
class SOAP_CMAC __gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:EX_SpatialTemporalExtent' of XML schema type 'gmd:EX_SpatialTemporalExtent_Type'
        gmd__EX_x005fSpatialTemporalExtent_x005fType *EX_x005fSpatialTemporalExtent;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType_sequence() : EX_x005fSpatialTemporalExtent() { }
        virtual ~__gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1721 */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType
#define SOAP_TYPE_plu_gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType (-528)
/* complex XML schema type 'gmd:EX_SpatialTemporalExtent_PropertyType': */
class SOAP_CMAC gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType_sequence *__EX_x005fSpatialTemporalExtent_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType() : __EX_x005fSpatialTemporalExtent_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15479 */
#ifndef SOAP_TYPE_plu___gmd__EX_x005fGeographicDescription_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__EX_x005fGeographicDescription_x005fPropertyType_sequence (-1463)
/* Wrapper: */
class SOAP_CMAC __gmd__EX_x005fGeographicDescription_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:EX_GeographicDescription' of XML schema type 'gmd:EX_GeographicDescription_Type'
        gmd__EX_x005fGeographicDescription_x005fType *EX_x005fGeographicDescription;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__EX_x005fGeographicDescription_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__EX_x005fGeographicDescription_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__EX_x005fGeographicDescription_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__EX_x005fGeographicDescription_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__EX_x005fGeographicDescription_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__EX_x005fGeographicDescription_x005fPropertyType_sequence() : EX_x005fGeographicDescription() { }
        virtual ~__gmd__EX_x005fGeographicDescription_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__EX_x005fGeographicDescription_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__EX_x005fGeographicDescription_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__EX_x005fGeographicDescription_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1727 */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fGeographicDescription_x005fPropertyType
#define SOAP_TYPE_plu_gmd__EX_x005fGeographicDescription_x005fPropertyType (-530)
/* complex XML schema type 'gmd:EX_GeographicDescription_PropertyType': */
class SOAP_CMAC gmd__EX_x005fGeographicDescription_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__EX_x005fGeographicDescription_x005fPropertyType_sequence *__EX_x005fGeographicDescription_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__EX_x005fGeographicDescription_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__EX_x005fGeographicDescription_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_x005fGeographicDescription_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__EX_x005fGeographicDescription_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__EX_x005fGeographicDescription_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__EX_x005fGeographicDescription_x005fPropertyType() : __EX_x005fGeographicDescription_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__EX_x005fGeographicDescription_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__EX_x005fGeographicDescription_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_x005fGeographicDescription_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__EX_x005fGeographicDescription_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15524 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fExtendedElementInformation_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fExtendedElementInformation_x005fPropertyType_sequence (-1465)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fExtendedElementInformation_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_ExtendedElementInformation' of XML schema type 'gmd:MD_ExtendedElementInformation_Type'
        gmd__MD_x005fExtendedElementInformation_x005fType *MD_x005fExtendedElementInformation;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fExtendedElementInformation_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fExtendedElementInformation_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fExtendedElementInformation_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fExtendedElementInformation_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fExtendedElementInformation_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fExtendedElementInformation_x005fPropertyType_sequence() : MD_x005fExtendedElementInformation() { }
        virtual ~__gmd__MD_x005fExtendedElementInformation_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fExtendedElementInformation_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fExtendedElementInformation_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fExtendedElementInformation_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1733 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fExtendedElementInformation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fExtendedElementInformation_x005fPropertyType (-532)
/* complex XML schema type 'gmd:MD_ExtendedElementInformation_PropertyType': */
class SOAP_CMAC gmd__MD_x005fExtendedElementInformation_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fExtendedElementInformation_x005fPropertyType_sequence *__MD_x005fExtendedElementInformation_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fExtendedElementInformation_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fExtendedElementInformation_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fExtendedElementInformation_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fExtendedElementInformation_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fExtendedElementInformation_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fExtendedElementInformation_x005fPropertyType() : __MD_x005fExtendedElementInformation_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fExtendedElementInformation_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fExtendedElementInformation_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fExtendedElementInformation_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fExtendedElementInformation_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15569 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType_sequence (-1468)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_MetadataExtensionInformation' of XML schema type 'gmd:MD_MetadataExtensionInformation_Type'
        gmd__MD_x005fMetadataExtensionInformation_x005fType *MD_x005fMetadataExtensionInformation;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType_sequence() : MD_x005fMetadataExtensionInformation() { }
        virtual ~__gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1739 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType (-534)
/* complex XML schema type 'gmd:MD_MetadataExtensionInformation_PropertyType': */
class SOAP_CMAC gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType_sequence *__MD_x005fMetadataExtensionInformation_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType() : __MD_x005fMetadataExtensionInformation_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15614 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fObligationCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fObligationCode_x005fPropertyType_sequence (-1471)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fObligationCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_ObligationCode' of XML schema type 'gmd:MD_ObligationCode_Type'
        enum gmd__MD_x005fObligationCode_x005fType MD_x005fObligationCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fObligationCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fObligationCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fObligationCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fObligationCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fObligationCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fObligationCode_x005fPropertyType_sequence() : MD_x005fObligationCode() { }
        virtual ~__gmd__MD_x005fObligationCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fObligationCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fObligationCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fObligationCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1742 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fObligationCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fObligationCode_x005fPropertyType (-535)
/* complex XML schema type 'gmd:MD_ObligationCode_PropertyType': */
class SOAP_CMAC gmd__MD_x005fObligationCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fObligationCode_x005fPropertyType_sequence *__MD_x005fObligationCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fObligationCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fObligationCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fObligationCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fObligationCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fObligationCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fObligationCode_x005fPropertyType() : __MD_x005fObligationCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fObligationCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fObligationCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fObligationCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fObligationCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15639 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fDatatypeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fDatatypeCode_x005fPropertyType_sequence (-1473)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fDatatypeCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_DatatypeCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *MD_x005fDatatypeCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fDatatypeCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fDatatypeCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fDatatypeCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fDatatypeCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fDatatypeCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fDatatypeCode_x005fPropertyType_sequence() : MD_x005fDatatypeCode() { }
        virtual ~__gmd__MD_x005fDatatypeCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fDatatypeCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fDatatypeCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fDatatypeCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1745 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDatatypeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fDatatypeCode_x005fPropertyType (-536)
/* complex XML schema type 'gmd:MD_DatatypeCode_PropertyType': */
class SOAP_CMAC gmd__MD_x005fDatatypeCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fDatatypeCode_x005fPropertyType_sequence *__MD_x005fDatatypeCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fDatatypeCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fDatatypeCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fDatatypeCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fDatatypeCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fDatatypeCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fDatatypeCode_x005fPropertyType() : __MD_x005fDatatypeCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fDatatypeCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fDatatypeCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fDatatypeCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fDatatypeCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15664 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType_sequence (-1475)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_FeatureCatalogueDescription' of XML schema type 'gmd:MD_FeatureCatalogueDescription_Type'
        gmd__MD_x005fFeatureCatalogueDescription_x005fType *MD_x005fFeatureCatalogueDescription;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType_sequence() : MD_x005fFeatureCatalogueDescription() { }
        virtual ~__gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1751 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType (-538)
/* complex XML schema type 'gmd:MD_FeatureCatalogueDescription_PropertyType': */
class SOAP_CMAC gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType_sequence *__MD_x005fFeatureCatalogueDescription_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType() : __MD_x005fFeatureCatalogueDescription_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15715 */
#ifndef SOAP_TYPE_plu__gmd__union_MD_x005fCoverageDescription_x005fPropertyType
#define SOAP_TYPE_plu__gmd__union_MD_x005fCoverageDescription_x005fPropertyType (-1479)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_MD_x005fCoverageDescription_x005fPropertyType
{
        #define SOAP_UNION_plu__gmd__union_MD_x005fCoverageDescription_x005fPropertyType_MD_x005fCoverageDescription	(1)	/**< union variant selector value for member MD_x005fCoverageDescription */
        gmd__MD_x005fCoverageDescription_x005fType *MD_x005fCoverageDescription;
        #define SOAP_UNION_plu__gmd__union_MD_x005fCoverageDescription_x005fPropertyType_MD_x005fImageDescription	(2)	/**< union variant selector value for member MD_x005fImageDescription */
        gmd__MD_x005fImageDescription_x005fType *MD_x005fImageDescription;
};
#endif

/* PlannedLandUse_v3.0.h:15709 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fCoverageDescription_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fCoverageDescription_x005fPropertyType_sequence (-1478)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fCoverageDescription_x005fPropertyType_sequence {
      public:
        /// Union with union _gmd__union_MD_x005fCoverageDescription_x005fPropertyType variant selector __unionMD_x005fCoverageDescription set to one of: SOAP_UNION_plu__gmd__union_MD_x005fCoverageDescription_x005fPropertyType_MD_x005fCoverageDescription SOAP_UNION_plu__gmd__union_MD_x005fCoverageDescription_x005fPropertyType_MD_x005fImageDescription
        int __unionMD_x005fCoverageDescription;
        union _gmd__union_MD_x005fCoverageDescription_x005fPropertyType union_MD_x005fCoverageDescription_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fCoverageDescription_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fCoverageDescription_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fCoverageDescription_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fCoverageDescription_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fCoverageDescription_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fCoverageDescription_x005fPropertyType_sequence() : __unionMD_x005fCoverageDescription() { }
        virtual ~__gmd__MD_x005fCoverageDescription_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fCoverageDescription_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fCoverageDescription_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fCoverageDescription_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1757 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fCoverageDescription_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fCoverageDescription_x005fPropertyType (-540)
/* complex XML schema type 'gmd:MD_CoverageDescription_PropertyType': */
class SOAP_CMAC gmd__MD_x005fCoverageDescription_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fCoverageDescription_x005fPropertyType_sequence *__MD_x005fCoverageDescription_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fCoverageDescription_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fCoverageDescription_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fCoverageDescription_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fCoverageDescription_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fCoverageDescription_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fCoverageDescription_x005fPropertyType() : __MD_x005fCoverageDescription_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fCoverageDescription_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fCoverageDescription_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fCoverageDescription_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fCoverageDescription_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15763 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fImageDescription_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fImageDescription_x005fPropertyType_sequence (-1483)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fImageDescription_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_ImageDescription' of XML schema type 'gmd:MD_ImageDescription_Type'
        gmd__MD_x005fImageDescription_x005fType *MD_x005fImageDescription;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fImageDescription_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fImageDescription_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fImageDescription_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fImageDescription_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fImageDescription_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fImageDescription_x005fPropertyType_sequence() : MD_x005fImageDescription() { }
        virtual ~__gmd__MD_x005fImageDescription_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fImageDescription_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fImageDescription_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fImageDescription_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1763 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fImageDescription_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fImageDescription_x005fPropertyType (-542)
/* complex XML schema type 'gmd:MD_ImageDescription_PropertyType': */
class SOAP_CMAC gmd__MD_x005fImageDescription_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fImageDescription_x005fPropertyType_sequence *__MD_x005fImageDescription_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fImageDescription_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fImageDescription_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fImageDescription_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fImageDescription_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fImageDescription_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fImageDescription_x005fPropertyType() : __MD_x005fImageDescription_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fImageDescription_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fImageDescription_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fImageDescription_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fImageDescription_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15815 */
#ifndef SOAP_TYPE_plu__gmd__union_MD_x005fContentInformation_x005fPropertyType
#define SOAP_TYPE_plu__gmd__union_MD_x005fContentInformation_x005fPropertyType (-1486)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_MD_x005fContentInformation_x005fPropertyType
{
        #define SOAP_UNION_plu__gmd__union_MD_x005fContentInformation_x005fPropertyType_MD_x005fFeatureCatalogueDescription	(1)	/**< union variant selector value for member MD_x005fFeatureCatalogueDescription */
        gmd__MD_x005fFeatureCatalogueDescription_x005fType *MD_x005fFeatureCatalogueDescription;
        #define SOAP_UNION_plu__gmd__union_MD_x005fContentInformation_x005fPropertyType_MD_x005fCoverageDescription	(2)	/**< union variant selector value for member MD_x005fCoverageDescription */
        gmd__MD_x005fCoverageDescription_x005fType *MD_x005fCoverageDescription;
        #define SOAP_UNION_plu__gmd__union_MD_x005fContentInformation_x005fPropertyType_MD_x005fImageDescription	(3)	/**< union variant selector value for member MD_x005fImageDescription */
        gmd__MD_x005fImageDescription_x005fType *MD_x005fImageDescription;
};
#endif

/* PlannedLandUse_v3.0.h:15808 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fContentInformation_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fContentInformation_x005fPropertyType_sequence (-1485)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fContentInformation_x005fPropertyType_sequence {
      public:
        /// Union with union _gmd__union_MD_x005fContentInformation_x005fPropertyType variant selector __unionAbstractMD_x005fContentInformation set to one of: SOAP_UNION_plu__gmd__union_MD_x005fContentInformation_x005fPropertyType_MD_x005fFeatureCatalogueDescription SOAP_UNION_plu__gmd__union_MD_x005fContentInformation_x005fPropertyType_MD_x005fCoverageDescription SOAP_UNION_plu__gmd__union_MD_x005fContentInformation_x005fPropertyType_MD_x005fImageDescription
        int __unionAbstractMD_x005fContentInformation;
        union _gmd__union_MD_x005fContentInformation_x005fPropertyType union_MD_x005fContentInformation_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fContentInformation_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fContentInformation_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fContentInformation_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fContentInformation_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fContentInformation_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fContentInformation_x005fPropertyType_sequence() : __unionAbstractMD_x005fContentInformation() { }
        virtual ~__gmd__MD_x005fContentInformation_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fContentInformation_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fContentInformation_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fContentInformation_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1769 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fContentInformation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fContentInformation_x005fPropertyType (-544)
/* complex XML schema type 'gmd:MD_ContentInformation_PropertyType': */
class SOAP_CMAC gmd__MD_x005fContentInformation_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fContentInformation_x005fPropertyType_sequence *__MD_x005fContentInformation_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fContentInformation_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fContentInformation_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fContentInformation_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fContentInformation_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fContentInformation_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fContentInformation_x005fPropertyType() : __MD_x005fContentInformation_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fContentInformation_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fContentInformation_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fContentInformation_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fContentInformation_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15873 */
#ifndef SOAP_TYPE_plu__gmd__union_MD_x005fRangeDimension_x005fPropertyType
#define SOAP_TYPE_plu__gmd__union_MD_x005fRangeDimension_x005fPropertyType (-1489)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_MD_x005fRangeDimension_x005fPropertyType
{
        #define SOAP_UNION_plu__gmd__union_MD_x005fRangeDimension_x005fPropertyType_MD_x005fRangeDimension	(1)	/**< union variant selector value for member MD_x005fRangeDimension */
        gmd__MD_x005fRangeDimension_x005fType *MD_x005fRangeDimension;
        #define SOAP_UNION_plu__gmd__union_MD_x005fRangeDimension_x005fPropertyType_MD_x005fBand	(2)	/**< union variant selector value for member MD_x005fBand */
        gmd__MD_x005fBand_x005fType *MD_x005fBand;
};
#endif

/* PlannedLandUse_v3.0.h:15867 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fRangeDimension_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fRangeDimension_x005fPropertyType_sequence (-1488)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fRangeDimension_x005fPropertyType_sequence {
      public:
        /// Union with union _gmd__union_MD_x005fRangeDimension_x005fPropertyType variant selector __unionMD_x005fRangeDimension set to one of: SOAP_UNION_plu__gmd__union_MD_x005fRangeDimension_x005fPropertyType_MD_x005fRangeDimension SOAP_UNION_plu__gmd__union_MD_x005fRangeDimension_x005fPropertyType_MD_x005fBand
        int __unionMD_x005fRangeDimension;
        union _gmd__union_MD_x005fRangeDimension_x005fPropertyType union_MD_x005fRangeDimension_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fRangeDimension_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fRangeDimension_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fRangeDimension_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fRangeDimension_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fRangeDimension_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fRangeDimension_x005fPropertyType_sequence() : __unionMD_x005fRangeDimension() { }
        virtual ~__gmd__MD_x005fRangeDimension_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fRangeDimension_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fRangeDimension_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fRangeDimension_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1775 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fRangeDimension_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fRangeDimension_x005fPropertyType (-546)
/* complex XML schema type 'gmd:MD_RangeDimension_PropertyType': */
class SOAP_CMAC gmd__MD_x005fRangeDimension_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fRangeDimension_x005fPropertyType_sequence *__MD_x005fRangeDimension_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fRangeDimension_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fRangeDimension_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fRangeDimension_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fRangeDimension_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fRangeDimension_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fRangeDimension_x005fPropertyType() : __MD_x005fRangeDimension_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fRangeDimension_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fRangeDimension_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fRangeDimension_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fRangeDimension_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15921 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fBand_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fBand_x005fPropertyType_sequence (-1493)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fBand_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_Band' of XML schema type 'gmd:MD_Band_Type'
        gmd__MD_x005fBand_x005fType *MD_x005fBand;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fBand_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fBand_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fBand_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fBand_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fBand_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fBand_x005fPropertyType_sequence() : MD_x005fBand() { }
        virtual ~__gmd__MD_x005fBand_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fBand_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fBand_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fBand_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1781 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fBand_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fBand_x005fPropertyType (-548)
/* complex XML schema type 'gmd:MD_Band_PropertyType': */
class SOAP_CMAC gmd__MD_x005fBand_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fBand_x005fPropertyType_sequence *__MD_x005fBand_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fBand_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fBand_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fBand_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fBand_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fBand_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fBand_x005fPropertyType() : __MD_x005fBand_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fBand_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fBand_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fBand_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fBand_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15966 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType_sequence (-1495)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_CoverageContentTypeCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *MD_x005fCoverageContentTypeCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType_sequence() : MD_x005fCoverageContentTypeCode() { }
        virtual ~__gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1784 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType (-549)
/* complex XML schema type 'gmd:MD_CoverageContentTypeCode_PropertyType': */
class SOAP_CMAC gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType_sequence *__MD_x005fCoverageContentTypeCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType() : __MD_x005fCoverageContentTypeCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:15991 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fImagingConditionCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fImagingConditionCode_x005fPropertyType_sequence (-1497)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fImagingConditionCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_ImagingConditionCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *MD_x005fImagingConditionCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fImagingConditionCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fImagingConditionCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fImagingConditionCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fImagingConditionCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fImagingConditionCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fImagingConditionCode_x005fPropertyType_sequence() : MD_x005fImagingConditionCode() { }
        virtual ~__gmd__MD_x005fImagingConditionCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fImagingConditionCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fImagingConditionCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fImagingConditionCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1787 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fImagingConditionCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fImagingConditionCode_x005fPropertyType (-550)
/* complex XML schema type 'gmd:MD_ImagingConditionCode_PropertyType': */
class SOAP_CMAC gmd__MD_x005fImagingConditionCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fImagingConditionCode_x005fPropertyType_sequence *__MD_x005fImagingConditionCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fImagingConditionCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fImagingConditionCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fImagingConditionCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fImagingConditionCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fImagingConditionCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fImagingConditionCode_x005fPropertyType() : __MD_x005fImagingConditionCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fImagingConditionCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fImagingConditionCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fImagingConditionCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fImagingConditionCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16016 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType_sequence (-1499)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_ApplicationSchemaInformation' of XML schema type 'gmd:MD_ApplicationSchemaInformation_Type'
        gmd__MD_x005fApplicationSchemaInformation_x005fType *MD_x005fApplicationSchemaInformation;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType_sequence() : MD_x005fApplicationSchemaInformation() { }
        virtual ~__gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1793 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType (-552)
/* complex XML schema type 'gmd:MD_ApplicationSchemaInformation_PropertyType': */
class SOAP_CMAC gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType_sequence *__MD_x005fApplicationSchemaInformation_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType() : __MD_x005fApplicationSchemaInformation_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16061 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType_sequence (-1502)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_PortrayalCatalogueReference' of XML schema type 'gmd:MD_PortrayalCatalogueReference_Type'
        gmd__MD_x005fPortrayalCatalogueReference_x005fType *MD_x005fPortrayalCatalogueReference;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType_sequence() : MD_x005fPortrayalCatalogueReference() { }
        virtual ~__gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1799 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType (-554)
/* complex XML schema type 'gmd:MD_PortrayalCatalogueReference_PropertyType': */
class SOAP_CMAC gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType_sequence *__MD_x005fPortrayalCatalogueReference_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType() : __MD_x005fPortrayalCatalogueReference_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16106 */
#ifndef SOAP_TYPE_plu___gmd__LI_x005fProcessStep_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__LI_x005fProcessStep_x005fPropertyType_sequence (-1505)
/* Wrapper: */
class SOAP_CMAC __gmd__LI_x005fProcessStep_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:LI_ProcessStep' of XML schema type 'gmd:LI_ProcessStep_Type'
        gmd__LI_x005fProcessStep_x005fType *LI_x005fProcessStep;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__LI_x005fProcessStep_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__LI_x005fProcessStep_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__LI_x005fProcessStep_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__LI_x005fProcessStep_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__LI_x005fProcessStep_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__LI_x005fProcessStep_x005fPropertyType_sequence() : LI_x005fProcessStep() { }
        virtual ~__gmd__LI_x005fProcessStep_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__LI_x005fProcessStep_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__LI_x005fProcessStep_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__LI_x005fProcessStep_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1805 */
#ifndef SOAP_TYPE_plu_gmd__LI_x005fProcessStep_x005fPropertyType
#define SOAP_TYPE_plu_gmd__LI_x005fProcessStep_x005fPropertyType (-556)
/* Type gmd__LI_x005fProcessStep_x005fPropertyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gmd:LI_ProcessStep_PropertyType': */
class SOAP_CMAC gmd__LI_x005fProcessStep_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__LI_x005fProcessStep_x005fPropertyType_sequence *__LI_x005fProcessStep_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__LI_x005fProcessStep_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__LI_x005fProcessStep_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__LI_x005fProcessStep_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__LI_x005fProcessStep_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__LI_x005fProcessStep_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__LI_x005fProcessStep_x005fPropertyType() : __LI_x005fProcessStep_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__LI_x005fProcessStep_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__LI_x005fProcessStep_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__LI_x005fProcessStep_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__LI_x005fProcessStep_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16151 */
#ifndef SOAP_TYPE_plu___gmd__LI_x005fSource_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__LI_x005fSource_x005fPropertyType_sequence (-1508)
/* Wrapper: */
class SOAP_CMAC __gmd__LI_x005fSource_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:LI_Source' of XML schema type 'gmd:LI_Source_Type'
        gmd__LI_x005fSource_x005fType *LI_x005fSource;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__LI_x005fSource_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__LI_x005fSource_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__LI_x005fSource_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__LI_x005fSource_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__LI_x005fSource_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__LI_x005fSource_x005fPropertyType_sequence() : LI_x005fSource() { }
        virtual ~__gmd__LI_x005fSource_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__LI_x005fSource_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__LI_x005fSource_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__LI_x005fSource_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1811 */
#ifndef SOAP_TYPE_plu_gmd__LI_x005fSource_x005fPropertyType
#define SOAP_TYPE_plu_gmd__LI_x005fSource_x005fPropertyType (-558)
/* complex XML schema type 'gmd:LI_Source_PropertyType': */
class SOAP_CMAC gmd__LI_x005fSource_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__LI_x005fSource_x005fPropertyType_sequence *__LI_x005fSource_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__LI_x005fSource_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__LI_x005fSource_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__LI_x005fSource_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__LI_x005fSource_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__LI_x005fSource_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__LI_x005fSource_x005fPropertyType() : __LI_x005fSource_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__LI_x005fSource_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__LI_x005fSource_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__LI_x005fSource_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__LI_x005fSource_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16196 */
#ifndef SOAP_TYPE_plu___gmd__LI_x005fLineage_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__LI_x005fLineage_x005fPropertyType_sequence (-1511)
/* Wrapper: */
class SOAP_CMAC __gmd__LI_x005fLineage_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:LI_Lineage' of XML schema type 'gmd:LI_Lineage_Type'
        gmd__LI_x005fLineage_x005fType *LI_x005fLineage;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__LI_x005fLineage_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__LI_x005fLineage_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__LI_x005fLineage_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__LI_x005fLineage_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__LI_x005fLineage_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__LI_x005fLineage_x005fPropertyType_sequence() : LI_x005fLineage() { }
        virtual ~__gmd__LI_x005fLineage_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__LI_x005fLineage_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__LI_x005fLineage_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__LI_x005fLineage_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1817 */
#ifndef SOAP_TYPE_plu_gmd__LI_x005fLineage_x005fPropertyType
#define SOAP_TYPE_plu_gmd__LI_x005fLineage_x005fPropertyType (-560)
/* complex XML schema type 'gmd:LI_Lineage_PropertyType': */
class SOAP_CMAC gmd__LI_x005fLineage_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__LI_x005fLineage_x005fPropertyType_sequence *__LI_x005fLineage_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__LI_x005fLineage_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__LI_x005fLineage_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__LI_x005fLineage_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__LI_x005fLineage_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__LI_x005fLineage_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__LI_x005fLineage_x005fPropertyType() : __LI_x005fLineage_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__LI_x005fLineage_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__LI_x005fLineage_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__LI_x005fLineage_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__LI_x005fLineage_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16241 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fConformanceResult_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fConformanceResult_x005fPropertyType_sequence (-1514)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fConformanceResult_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_ConformanceResult' of XML schema type 'gmd:DQ_ConformanceResult_Type'
        gmd__DQ_x005fConformanceResult_x005fType *DQ_x005fConformanceResult;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fConformanceResult_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fConformanceResult_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fConformanceResult_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fConformanceResult_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fConformanceResult_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fConformanceResult_x005fPropertyType_sequence() : DQ_x005fConformanceResult() { }
        virtual ~__gmd__DQ_x005fConformanceResult_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fConformanceResult_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fConformanceResult_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fConformanceResult_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1823 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fConformanceResult_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fConformanceResult_x005fPropertyType (-562)
/* complex XML schema type 'gmd:DQ_ConformanceResult_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fConformanceResult_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fConformanceResult_x005fPropertyType_sequence *__DQ_x005fConformanceResult_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fConformanceResult_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fConformanceResult_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fConformanceResult_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fConformanceResult_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fConformanceResult_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fConformanceResult_x005fPropertyType() : __DQ_x005fConformanceResult_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fConformanceResult_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fConformanceResult_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fConformanceResult_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fConformanceResult_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16286 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fQuantitativeResult_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fQuantitativeResult_x005fPropertyType_sequence (-1517)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fQuantitativeResult_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_QuantitativeResult' of XML schema type 'gmd:DQ_QuantitativeResult_Type'
        gmd__DQ_x005fQuantitativeResult_x005fType *DQ_x005fQuantitativeResult;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fQuantitativeResult_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fQuantitativeResult_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fQuantitativeResult_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fQuantitativeResult_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fQuantitativeResult_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fQuantitativeResult_x005fPropertyType_sequence() : DQ_x005fQuantitativeResult() { }
        virtual ~__gmd__DQ_x005fQuantitativeResult_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fQuantitativeResult_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fQuantitativeResult_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fQuantitativeResult_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1829 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeResult_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeResult_x005fPropertyType (-564)
/* complex XML schema type 'gmd:DQ_QuantitativeResult_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fQuantitativeResult_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fQuantitativeResult_x005fPropertyType_sequence *__DQ_x005fQuantitativeResult_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeResult_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeResult_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fQuantitativeResult_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fQuantitativeResult_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fQuantitativeResult_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fQuantitativeResult_x005fPropertyType() : __DQ_x005fQuantitativeResult_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fQuantitativeResult_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fQuantitativeResult_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fQuantitativeResult_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fQuantitativeResult_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16338 */
#ifndef SOAP_TYPE_plu__gmd__union_DQ_x005fResult_x005fPropertyType
#define SOAP_TYPE_plu__gmd__union_DQ_x005fResult_x005fPropertyType (-1521)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_DQ_x005fResult_x005fPropertyType
{
        #define SOAP_UNION_plu__gmd__union_DQ_x005fResult_x005fPropertyType_DQ_x005fConformanceResult	(1)	/**< union variant selector value for member DQ_x005fConformanceResult */
        gmd__DQ_x005fConformanceResult_x005fType *DQ_x005fConformanceResult;
        #define SOAP_UNION_plu__gmd__union_DQ_x005fResult_x005fPropertyType_DQ_x005fQuantitativeResult	(2)	/**< union variant selector value for member DQ_x005fQuantitativeResult */
        gmd__DQ_x005fQuantitativeResult_x005fType *DQ_x005fQuantitativeResult;
};
#endif

/* PlannedLandUse_v3.0.h:16331 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fResult_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fResult_x005fPropertyType_sequence (-1520)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fResult_x005fPropertyType_sequence {
      public:
        /// Union with union _gmd__union_DQ_x005fResult_x005fPropertyType variant selector __unionAbstractDQ_x005fResult set to one of: SOAP_UNION_plu__gmd__union_DQ_x005fResult_x005fPropertyType_DQ_x005fConformanceResult SOAP_UNION_plu__gmd__union_DQ_x005fResult_x005fPropertyType_DQ_x005fQuantitativeResult
        int __unionAbstractDQ_x005fResult;
        union _gmd__union_DQ_x005fResult_x005fPropertyType union_DQ_x005fResult_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fResult_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fResult_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fResult_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fResult_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fResult_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fResult_x005fPropertyType_sequence() : __unionAbstractDQ_x005fResult() { }
        virtual ~__gmd__DQ_x005fResult_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fResult_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fResult_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fResult_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1835 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fResult_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fResult_x005fPropertyType (-566)
/* complex XML schema type 'gmd:DQ_Result_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fResult_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fResult_x005fPropertyType_sequence *__DQ_x005fResult_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fResult_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fResult_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fResult_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fResult_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fResult_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fResult_x005fPropertyType() : __DQ_x005fResult_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fResult_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fResult_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fResult_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fResult_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16386 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fTemporalValidity_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fTemporalValidity_x005fPropertyType_sequence (-1523)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fTemporalValidity_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_TemporalValidity' of XML schema type 'gmd:DQ_TemporalValidity_Type'
        gmd__DQ_x005fTemporalValidity_x005fType *DQ_x005fTemporalValidity;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fTemporalValidity_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fTemporalValidity_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fTemporalValidity_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fTemporalValidity_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fTemporalValidity_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fTemporalValidity_x005fPropertyType_sequence() : DQ_x005fTemporalValidity() { }
        virtual ~__gmd__DQ_x005fTemporalValidity_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fTemporalValidity_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fTemporalValidity_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fTemporalValidity_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1841 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fTemporalValidity_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fTemporalValidity_x005fPropertyType (-568)
/* complex XML schema type 'gmd:DQ_TemporalValidity_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fTemporalValidity_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fTemporalValidity_x005fPropertyType_sequence *__DQ_x005fTemporalValidity_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fTemporalValidity_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fTemporalValidity_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fTemporalValidity_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fTemporalValidity_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fTemporalValidity_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fTemporalValidity_x005fPropertyType() : __DQ_x005fTemporalValidity_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fTemporalValidity_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fTemporalValidity_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fTemporalValidity_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fTemporalValidity_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16431 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fTemporalConsistency_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fTemporalConsistency_x005fPropertyType_sequence (-1526)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fTemporalConsistency_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_TemporalConsistency' of XML schema type 'gmd:DQ_TemporalConsistency_Type'
        gmd__DQ_x005fTemporalConsistency_x005fType *DQ_x005fTemporalConsistency;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fTemporalConsistency_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fTemporalConsistency_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fTemporalConsistency_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fTemporalConsistency_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fTemporalConsistency_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fTemporalConsistency_x005fPropertyType_sequence() : DQ_x005fTemporalConsistency() { }
        virtual ~__gmd__DQ_x005fTemporalConsistency_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fTemporalConsistency_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fTemporalConsistency_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fTemporalConsistency_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1847 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fTemporalConsistency_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fTemporalConsistency_x005fPropertyType (-570)
/* complex XML schema type 'gmd:DQ_TemporalConsistency_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fTemporalConsistency_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fTemporalConsistency_x005fPropertyType_sequence *__DQ_x005fTemporalConsistency_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fTemporalConsistency_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fTemporalConsistency_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fTemporalConsistency_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fTemporalConsistency_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fTemporalConsistency_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fTemporalConsistency_x005fPropertyType() : __DQ_x005fTemporalConsistency_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fTemporalConsistency_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fTemporalConsistency_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fTemporalConsistency_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fTemporalConsistency_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16476 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType_sequence (-1529)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_AccuracyOfATimeMeasurement' of XML schema type 'gmd:DQ_AccuracyOfATimeMeasurement_Type'
        gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType *DQ_x005fAccuracyOfATimeMeasurement;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType_sequence() : DQ_x005fAccuracyOfATimeMeasurement() { }
        virtual ~__gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1853 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType (-572)
/* complex XML schema type 'gmd:DQ_AccuracyOfATimeMeasurement_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType_sequence *__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType() : __DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16521 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType_sequence (-1532)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_QuantitativeAttributeAccuracy' of XML schema type 'gmd:DQ_QuantitativeAttributeAccuracy_Type'
        gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType *DQ_x005fQuantitativeAttributeAccuracy;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType_sequence() : DQ_x005fQuantitativeAttributeAccuracy() { }
        virtual ~__gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1859 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType (-574)
/* complex XML schema type 'gmd:DQ_QuantitativeAttributeAccuracy_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType_sequence *__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType() : __DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16566 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType_sequence (-1535)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_NonQuantitativeAttributeAccuracy' of XML schema type 'gmd:DQ_NonQuantitativeAttributeAccuracy_Type'
        gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType *DQ_x005fNonQuantitativeAttributeAccuracy;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType_sequence() : DQ_x005fNonQuantitativeAttributeAccuracy() { }
        virtual ~__gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1865 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType (-576)
/* complex XML schema type 'gmd:DQ_NonQuantitativeAttributeAccuracy_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType_sequence *__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType() : __DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16611 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType_sequence (-1538)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_ThematicClassificationCorrectness' of XML schema type 'gmd:DQ_ThematicClassificationCorrectness_Type'
        gmd__DQ_x005fThematicClassificationCorrectness_x005fType *DQ_x005fThematicClassificationCorrectness;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType_sequence() : DQ_x005fThematicClassificationCorrectness() { }
        virtual ~__gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1871 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType (-578)
/* complex XML schema type 'gmd:DQ_ThematicClassificationCorrectness_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType_sequence *__DQ_x005fThematicClassificationCorrectness_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType() : __DQ_x005fThematicClassificationCorrectness_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16656 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType_sequence (-1541)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_RelativeInternalPositionalAccuracy' of XML schema type 'gmd:DQ_RelativeInternalPositionalAccuracy_Type'
        gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType *DQ_x005fRelativeInternalPositionalAccuracy;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType_sequence() : DQ_x005fRelativeInternalPositionalAccuracy() { }
        virtual ~__gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1877 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType (-580)
/* complex XML schema type 'gmd:DQ_RelativeInternalPositionalAccuracy_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType_sequence *__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType() : __DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16701 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType_sequence (-1543)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_GriddedDataPositionalAccuracy' of XML schema type 'gmd:DQ_GriddedDataPositionalAccuracy_Type'
        gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType *DQ_x005fGriddedDataPositionalAccuracy;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType_sequence() : DQ_x005fGriddedDataPositionalAccuracy() { }
        virtual ~__gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1883 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType (-582)
/* complex XML schema type 'gmd:DQ_GriddedDataPositionalAccuracy_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType_sequence *__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType() : __DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16746 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType_sequence (-1545)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_AbsoluteExternalPositionalAccuracy' of XML schema type 'gmd:DQ_AbsoluteExternalPositionalAccuracy_Type'
        gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType *DQ_x005fAbsoluteExternalPositionalAccuracy;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType_sequence() : DQ_x005fAbsoluteExternalPositionalAccuracy() { }
        virtual ~__gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1889 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType (-584)
/* complex XML schema type 'gmd:DQ_AbsoluteExternalPositionalAccuracy_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType_sequence *__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType() : __DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16791 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fTopologicalConsistency_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fTopologicalConsistency_x005fPropertyType_sequence (-1547)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fTopologicalConsistency_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_TopologicalConsistency' of XML schema type 'gmd:DQ_TopologicalConsistency_Type'
        gmd__DQ_x005fTopologicalConsistency_x005fType *DQ_x005fTopologicalConsistency;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fTopologicalConsistency_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fTopologicalConsistency_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fTopologicalConsistency_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fTopologicalConsistency_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fTopologicalConsistency_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fTopologicalConsistency_x005fPropertyType_sequence() : DQ_x005fTopologicalConsistency() { }
        virtual ~__gmd__DQ_x005fTopologicalConsistency_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fTopologicalConsistency_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fTopologicalConsistency_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fTopologicalConsistency_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1895 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fTopologicalConsistency_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fTopologicalConsistency_x005fPropertyType (-586)
/* complex XML schema type 'gmd:DQ_TopologicalConsistency_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fTopologicalConsistency_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fTopologicalConsistency_x005fPropertyType_sequence *__DQ_x005fTopologicalConsistency_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fTopologicalConsistency_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fTopologicalConsistency_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fTopologicalConsistency_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fTopologicalConsistency_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fTopologicalConsistency_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fTopologicalConsistency_x005fPropertyType() : __DQ_x005fTopologicalConsistency_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fTopologicalConsistency_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fTopologicalConsistency_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fTopologicalConsistency_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fTopologicalConsistency_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16836 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fFormatConsistency_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fFormatConsistency_x005fPropertyType_sequence (-1550)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fFormatConsistency_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_FormatConsistency' of XML schema type 'gmd:DQ_FormatConsistency_Type'
        gmd__DQ_x005fFormatConsistency_x005fType *DQ_x005fFormatConsistency;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fFormatConsistency_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fFormatConsistency_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fFormatConsistency_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fFormatConsistency_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fFormatConsistency_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fFormatConsistency_x005fPropertyType_sequence() : DQ_x005fFormatConsistency() { }
        virtual ~__gmd__DQ_x005fFormatConsistency_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fFormatConsistency_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fFormatConsistency_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fFormatConsistency_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1901 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fFormatConsistency_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fFormatConsistency_x005fPropertyType (-588)
/* complex XML schema type 'gmd:DQ_FormatConsistency_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fFormatConsistency_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fFormatConsistency_x005fPropertyType_sequence *__DQ_x005fFormatConsistency_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fFormatConsistency_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fFormatConsistency_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fFormatConsistency_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fFormatConsistency_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fFormatConsistency_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fFormatConsistency_x005fPropertyType() : __DQ_x005fFormatConsistency_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fFormatConsistency_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fFormatConsistency_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fFormatConsistency_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fFormatConsistency_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16881 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fDomainConsistency_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fDomainConsistency_x005fPropertyType_sequence (-1553)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fDomainConsistency_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_DomainConsistency' of XML schema type 'gmd:DQ_DomainConsistency_Type'
        gmd__DQ_x005fDomainConsistency_x005fType *DQ_x005fDomainConsistency;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fDomainConsistency_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fDomainConsistency_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fDomainConsistency_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fDomainConsistency_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fDomainConsistency_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fDomainConsistency_x005fPropertyType_sequence() : DQ_x005fDomainConsistency() { }
        virtual ~__gmd__DQ_x005fDomainConsistency_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fDomainConsistency_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fDomainConsistency_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fDomainConsistency_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1907 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fDomainConsistency_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fDomainConsistency_x005fPropertyType (-590)
/* complex XML schema type 'gmd:DQ_DomainConsistency_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fDomainConsistency_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fDomainConsistency_x005fPropertyType_sequence *__DQ_x005fDomainConsistency_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fDomainConsistency_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fDomainConsistency_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fDomainConsistency_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fDomainConsistency_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fDomainConsistency_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fDomainConsistency_x005fPropertyType() : __DQ_x005fDomainConsistency_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fDomainConsistency_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fDomainConsistency_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fDomainConsistency_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fDomainConsistency_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16926 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fConceptualConsistency_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fConceptualConsistency_x005fPropertyType_sequence (-1556)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fConceptualConsistency_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_ConceptualConsistency' of XML schema type 'gmd:DQ_ConceptualConsistency_Type'
        gmd__DQ_x005fConceptualConsistency_x005fType *DQ_x005fConceptualConsistency;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fConceptualConsistency_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fConceptualConsistency_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fConceptualConsistency_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fConceptualConsistency_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fConceptualConsistency_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fConceptualConsistency_x005fPropertyType_sequence() : DQ_x005fConceptualConsistency() { }
        virtual ~__gmd__DQ_x005fConceptualConsistency_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fConceptualConsistency_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fConceptualConsistency_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fConceptualConsistency_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1913 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fConceptualConsistency_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fConceptualConsistency_x005fPropertyType (-592)
/* complex XML schema type 'gmd:DQ_ConceptualConsistency_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fConceptualConsistency_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fConceptualConsistency_x005fPropertyType_sequence *__DQ_x005fConceptualConsistency_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fConceptualConsistency_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fConceptualConsistency_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fConceptualConsistency_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fConceptualConsistency_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fConceptualConsistency_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fConceptualConsistency_x005fPropertyType() : __DQ_x005fConceptualConsistency_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fConceptualConsistency_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fConceptualConsistency_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fConceptualConsistency_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fConceptualConsistency_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:16971 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fCompletenessOmission_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fCompletenessOmission_x005fPropertyType_sequence (-1559)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fCompletenessOmission_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_CompletenessOmission' of XML schema type 'gmd:DQ_CompletenessOmission_Type'
        gmd__DQ_x005fCompletenessOmission_x005fType *DQ_x005fCompletenessOmission;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fCompletenessOmission_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fCompletenessOmission_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fCompletenessOmission_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fCompletenessOmission_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fCompletenessOmission_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fCompletenessOmission_x005fPropertyType_sequence() : DQ_x005fCompletenessOmission() { }
        virtual ~__gmd__DQ_x005fCompletenessOmission_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fCompletenessOmission_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fCompletenessOmission_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fCompletenessOmission_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1919 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fCompletenessOmission_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fCompletenessOmission_x005fPropertyType (-594)
/* complex XML schema type 'gmd:DQ_CompletenessOmission_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fCompletenessOmission_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fCompletenessOmission_x005fPropertyType_sequence *__DQ_x005fCompletenessOmission_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fCompletenessOmission_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fCompletenessOmission_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fCompletenessOmission_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fCompletenessOmission_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fCompletenessOmission_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fCompletenessOmission_x005fPropertyType() : __DQ_x005fCompletenessOmission_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fCompletenessOmission_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fCompletenessOmission_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fCompletenessOmission_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fCompletenessOmission_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17016 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fCompletenessCommission_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fCompletenessCommission_x005fPropertyType_sequence (-1562)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fCompletenessCommission_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_CompletenessCommission' of XML schema type 'gmd:DQ_CompletenessCommission_Type'
        gmd__DQ_x005fCompletenessCommission_x005fType *DQ_x005fCompletenessCommission;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fCompletenessCommission_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fCompletenessCommission_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fCompletenessCommission_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fCompletenessCommission_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fCompletenessCommission_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fCompletenessCommission_x005fPropertyType_sequence() : DQ_x005fCompletenessCommission() { }
        virtual ~__gmd__DQ_x005fCompletenessCommission_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fCompletenessCommission_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fCompletenessCommission_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fCompletenessCommission_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1925 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fCompletenessCommission_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fCompletenessCommission_x005fPropertyType (-596)
/* complex XML schema type 'gmd:DQ_CompletenessCommission_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fCompletenessCommission_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fCompletenessCommission_x005fPropertyType_sequence *__DQ_x005fCompletenessCommission_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fCompletenessCommission_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fCompletenessCommission_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fCompletenessCommission_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fCompletenessCommission_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fCompletenessCommission_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fCompletenessCommission_x005fPropertyType() : __DQ_x005fCompletenessCommission_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fCompletenessCommission_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fCompletenessCommission_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fCompletenessCommission_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fCompletenessCommission_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17068 */
#ifndef SOAP_TYPE_plu__gmd__union_DQ_x005fTemporalAccuracy_x005fPropertyType
#define SOAP_TYPE_plu__gmd__union_DQ_x005fTemporalAccuracy_x005fPropertyType (-1566)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_DQ_x005fTemporalAccuracy_x005fPropertyType
{
        #define SOAP_UNION_plu__gmd__union_DQ_x005fTemporalAccuracy_x005fPropertyType_DQ_x005fTemporalValidity	(1)	/**< union variant selector value for member DQ_x005fTemporalValidity */
        gmd__DQ_x005fTemporalValidity_x005fType *DQ_x005fTemporalValidity;
        #define SOAP_UNION_plu__gmd__union_DQ_x005fTemporalAccuracy_x005fPropertyType_DQ_x005fTemporalConsistency	(2)	/**< union variant selector value for member DQ_x005fTemporalConsistency */
        gmd__DQ_x005fTemporalConsistency_x005fType *DQ_x005fTemporalConsistency;
        #define SOAP_UNION_plu__gmd__union_DQ_x005fTemporalAccuracy_x005fPropertyType_DQ_x005fAccuracyOfATimeMeasurement	(3)	/**< union variant selector value for member DQ_x005fAccuracyOfATimeMeasurement */
        gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType *DQ_x005fAccuracyOfATimeMeasurement;
};
#endif

/* PlannedLandUse_v3.0.h:17061 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fTemporalAccuracy_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fTemporalAccuracy_x005fPropertyType_sequence (-1565)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fTemporalAccuracy_x005fPropertyType_sequence {
      public:
        /// Union with union _gmd__union_DQ_x005fTemporalAccuracy_x005fPropertyType variant selector __unionAbstractDQ_x005fTemporalAccuracy set to one of: SOAP_UNION_plu__gmd__union_DQ_x005fTemporalAccuracy_x005fPropertyType_DQ_x005fTemporalValidity SOAP_UNION_plu__gmd__union_DQ_x005fTemporalAccuracy_x005fPropertyType_DQ_x005fTemporalConsistency SOAP_UNION_plu__gmd__union_DQ_x005fTemporalAccuracy_x005fPropertyType_DQ_x005fAccuracyOfATimeMeasurement
        int __unionAbstractDQ_x005fTemporalAccuracy;
        union _gmd__union_DQ_x005fTemporalAccuracy_x005fPropertyType union_DQ_x005fTemporalAccuracy_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fTemporalAccuracy_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fTemporalAccuracy_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fTemporalAccuracy_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fTemporalAccuracy_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fTemporalAccuracy_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fTemporalAccuracy_x005fPropertyType_sequence() : __unionAbstractDQ_x005fTemporalAccuracy() { }
        virtual ~__gmd__DQ_x005fTemporalAccuracy_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fTemporalAccuracy_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fTemporalAccuracy_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fTemporalAccuracy_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1931 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fTemporalAccuracy_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fTemporalAccuracy_x005fPropertyType (-598)
/* complex XML schema type 'gmd:DQ_TemporalAccuracy_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fTemporalAccuracy_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fTemporalAccuracy_x005fPropertyType_sequence *__DQ_x005fTemporalAccuracy_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fTemporalAccuracy_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fTemporalAccuracy_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fTemporalAccuracy_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fTemporalAccuracy_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fTemporalAccuracy_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fTemporalAccuracy_x005fPropertyType() : __DQ_x005fTemporalAccuracy_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fTemporalAccuracy_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fTemporalAccuracy_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fTemporalAccuracy_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fTemporalAccuracy_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17125 */
#ifndef SOAP_TYPE_plu__gmd__union_DQ_x005fThematicAccuracy_x005fPropertyType
#define SOAP_TYPE_plu__gmd__union_DQ_x005fThematicAccuracy_x005fPropertyType (-1569)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_DQ_x005fThematicAccuracy_x005fPropertyType
{
        #define SOAP_UNION_plu__gmd__union_DQ_x005fThematicAccuracy_x005fPropertyType_DQ_x005fQuantitativeAttributeAccuracy	(1)	/**< union variant selector value for member DQ_x005fQuantitativeAttributeAccuracy */
        gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType *DQ_x005fQuantitativeAttributeAccuracy;
        #define SOAP_UNION_plu__gmd__union_DQ_x005fThematicAccuracy_x005fPropertyType_DQ_x005fNonQuantitativeAttributeAccuracy	(2)	/**< union variant selector value for member DQ_x005fNonQuantitativeAttributeAccuracy */
        gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType *DQ_x005fNonQuantitativeAttributeAccuracy;
        #define SOAP_UNION_plu__gmd__union_DQ_x005fThematicAccuracy_x005fPropertyType_DQ_x005fThematicClassificationCorrectness	(3)	/**< union variant selector value for member DQ_x005fThematicClassificationCorrectness */
        gmd__DQ_x005fThematicClassificationCorrectness_x005fType *DQ_x005fThematicClassificationCorrectness;
};
#endif

/* PlannedLandUse_v3.0.h:17118 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fThematicAccuracy_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fThematicAccuracy_x005fPropertyType_sequence (-1568)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fThematicAccuracy_x005fPropertyType_sequence {
      public:
        /// Union with union _gmd__union_DQ_x005fThematicAccuracy_x005fPropertyType variant selector __unionAbstractDQ_x005fThematicAccuracy set to one of: SOAP_UNION_plu__gmd__union_DQ_x005fThematicAccuracy_x005fPropertyType_DQ_x005fQuantitativeAttributeAccuracy SOAP_UNION_plu__gmd__union_DQ_x005fThematicAccuracy_x005fPropertyType_DQ_x005fNonQuantitativeAttributeAccuracy SOAP_UNION_plu__gmd__union_DQ_x005fThematicAccuracy_x005fPropertyType_DQ_x005fThematicClassificationCorrectness
        int __unionAbstractDQ_x005fThematicAccuracy;
        union _gmd__union_DQ_x005fThematicAccuracy_x005fPropertyType union_DQ_x005fThematicAccuracy_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fThematicAccuracy_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fThematicAccuracy_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fThematicAccuracy_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fThematicAccuracy_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fThematicAccuracy_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fThematicAccuracy_x005fPropertyType_sequence() : __unionAbstractDQ_x005fThematicAccuracy() { }
        virtual ~__gmd__DQ_x005fThematicAccuracy_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fThematicAccuracy_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fThematicAccuracy_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fThematicAccuracy_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1937 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fThematicAccuracy_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fThematicAccuracy_x005fPropertyType (-600)
/* complex XML schema type 'gmd:DQ_ThematicAccuracy_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fThematicAccuracy_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fThematicAccuracy_x005fPropertyType_sequence *__DQ_x005fThematicAccuracy_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fThematicAccuracy_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fThematicAccuracy_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fThematicAccuracy_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fThematicAccuracy_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fThematicAccuracy_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fThematicAccuracy_x005fPropertyType() : __DQ_x005fThematicAccuracy_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fThematicAccuracy_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fThematicAccuracy_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fThematicAccuracy_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fThematicAccuracy_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17182 */
#ifndef SOAP_TYPE_plu__gmd__union_DQ_x005fPositionalAccuracy_x005fPropertyType
#define SOAP_TYPE_plu__gmd__union_DQ_x005fPositionalAccuracy_x005fPropertyType (-1572)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_DQ_x005fPositionalAccuracy_x005fPropertyType
{
        #define SOAP_UNION_plu__gmd__union_DQ_x005fPositionalAccuracy_x005fPropertyType_DQ_x005fRelativeInternalPositionalAccuracy	(1)	/**< union variant selector value for member DQ_x005fRelativeInternalPositionalAccuracy */
        gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType *DQ_x005fRelativeInternalPositionalAccuracy;
        #define SOAP_UNION_plu__gmd__union_DQ_x005fPositionalAccuracy_x005fPropertyType_DQ_x005fGriddedDataPositionalAccuracy	(2)	/**< union variant selector value for member DQ_x005fGriddedDataPositionalAccuracy */
        gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType *DQ_x005fGriddedDataPositionalAccuracy;
        #define SOAP_UNION_plu__gmd__union_DQ_x005fPositionalAccuracy_x005fPropertyType_DQ_x005fAbsoluteExternalPositionalAccuracy	(3)	/**< union variant selector value for member DQ_x005fAbsoluteExternalPositionalAccuracy */
        gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType *DQ_x005fAbsoluteExternalPositionalAccuracy;
};
#endif

/* PlannedLandUse_v3.0.h:17175 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fPositionalAccuracy_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fPositionalAccuracy_x005fPropertyType_sequence (-1571)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fPositionalAccuracy_x005fPropertyType_sequence {
      public:
        /// Union with union _gmd__union_DQ_x005fPositionalAccuracy_x005fPropertyType variant selector __unionAbstractDQ_x005fPositionalAccuracy set to one of: SOAP_UNION_plu__gmd__union_DQ_x005fPositionalAccuracy_x005fPropertyType_DQ_x005fRelativeInternalPositionalAccuracy SOAP_UNION_plu__gmd__union_DQ_x005fPositionalAccuracy_x005fPropertyType_DQ_x005fGriddedDataPositionalAccuracy SOAP_UNION_plu__gmd__union_DQ_x005fPositionalAccuracy_x005fPropertyType_DQ_x005fAbsoluteExternalPositionalAccuracy
        int __unionAbstractDQ_x005fPositionalAccuracy;
        union _gmd__union_DQ_x005fPositionalAccuracy_x005fPropertyType union_DQ_x005fPositionalAccuracy_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fPositionalAccuracy_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fPositionalAccuracy_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fPositionalAccuracy_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fPositionalAccuracy_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fPositionalAccuracy_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fPositionalAccuracy_x005fPropertyType_sequence() : __unionAbstractDQ_x005fPositionalAccuracy() { }
        virtual ~__gmd__DQ_x005fPositionalAccuracy_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fPositionalAccuracy_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fPositionalAccuracy_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fPositionalAccuracy_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1943 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fPositionalAccuracy_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fPositionalAccuracy_x005fPropertyType (-602)
/* complex XML schema type 'gmd:DQ_PositionalAccuracy_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fPositionalAccuracy_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fPositionalAccuracy_x005fPropertyType_sequence *__DQ_x005fPositionalAccuracy_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fPositionalAccuracy_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fPositionalAccuracy_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fPositionalAccuracy_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fPositionalAccuracy_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fPositionalAccuracy_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fPositionalAccuracy_x005fPropertyType() : __DQ_x005fPositionalAccuracy_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fPositionalAccuracy_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fPositionalAccuracy_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fPositionalAccuracy_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fPositionalAccuracy_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17239 */
#ifndef SOAP_TYPE_plu__gmd__union_DQ_x005fLogicalConsistency_x005fPropertyType
#define SOAP_TYPE_plu__gmd__union_DQ_x005fLogicalConsistency_x005fPropertyType (-1575)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_DQ_x005fLogicalConsistency_x005fPropertyType
{
        #define SOAP_UNION_plu__gmd__union_DQ_x005fLogicalConsistency_x005fPropertyType_DQ_x005fTopologicalConsistency	(1)	/**< union variant selector value for member DQ_x005fTopologicalConsistency */
        gmd__DQ_x005fTopologicalConsistency_x005fType *DQ_x005fTopologicalConsistency;
        #define SOAP_UNION_plu__gmd__union_DQ_x005fLogicalConsistency_x005fPropertyType_DQ_x005fFormatConsistency	(2)	/**< union variant selector value for member DQ_x005fFormatConsistency */
        gmd__DQ_x005fFormatConsistency_x005fType *DQ_x005fFormatConsistency;
        #define SOAP_UNION_plu__gmd__union_DQ_x005fLogicalConsistency_x005fPropertyType_DQ_x005fDomainConsistency	(3)	/**< union variant selector value for member DQ_x005fDomainConsistency */
        gmd__DQ_x005fDomainConsistency_x005fType *DQ_x005fDomainConsistency;
        #define SOAP_UNION_plu__gmd__union_DQ_x005fLogicalConsistency_x005fPropertyType_DQ_x005fConceptualConsistency	(4)	/**< union variant selector value for member DQ_x005fConceptualConsistency */
        gmd__DQ_x005fConceptualConsistency_x005fType *DQ_x005fConceptualConsistency;
};
#endif

/* PlannedLandUse_v3.0.h:17232 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fLogicalConsistency_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fLogicalConsistency_x005fPropertyType_sequence (-1574)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fLogicalConsistency_x005fPropertyType_sequence {
      public:
        /// Union with union _gmd__union_DQ_x005fLogicalConsistency_x005fPropertyType variant selector __unionAbstractDQ_x005fLogicalConsistency set to one of: SOAP_UNION_plu__gmd__union_DQ_x005fLogicalConsistency_x005fPropertyType_DQ_x005fTopologicalConsistency SOAP_UNION_plu__gmd__union_DQ_x005fLogicalConsistency_x005fPropertyType_DQ_x005fFormatConsistency SOAP_UNION_plu__gmd__union_DQ_x005fLogicalConsistency_x005fPropertyType_DQ_x005fDomainConsistency SOAP_UNION_plu__gmd__union_DQ_x005fLogicalConsistency_x005fPropertyType_DQ_x005fConceptualConsistency
        int __unionAbstractDQ_x005fLogicalConsistency;
        union _gmd__union_DQ_x005fLogicalConsistency_x005fPropertyType union_DQ_x005fLogicalConsistency_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fLogicalConsistency_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fLogicalConsistency_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fLogicalConsistency_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fLogicalConsistency_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fLogicalConsistency_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fLogicalConsistency_x005fPropertyType_sequence() : __unionAbstractDQ_x005fLogicalConsistency() { }
        virtual ~__gmd__DQ_x005fLogicalConsistency_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fLogicalConsistency_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fLogicalConsistency_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fLogicalConsistency_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1949 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fLogicalConsistency_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fLogicalConsistency_x005fPropertyType (-604)
/* complex XML schema type 'gmd:DQ_LogicalConsistency_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fLogicalConsistency_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fLogicalConsistency_x005fPropertyType_sequence *__DQ_x005fLogicalConsistency_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fLogicalConsistency_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fLogicalConsistency_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fLogicalConsistency_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fLogicalConsistency_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fLogicalConsistency_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fLogicalConsistency_x005fPropertyType() : __DQ_x005fLogicalConsistency_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fLogicalConsistency_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fLogicalConsistency_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fLogicalConsistency_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fLogicalConsistency_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17298 */
#ifndef SOAP_TYPE_plu__gmd__union_DQ_x005fCompleteness_x005fPropertyType
#define SOAP_TYPE_plu__gmd__union_DQ_x005fCompleteness_x005fPropertyType (-1578)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_DQ_x005fCompleteness_x005fPropertyType
{
        #define SOAP_UNION_plu__gmd__union_DQ_x005fCompleteness_x005fPropertyType_DQ_x005fCompletenessOmission	(1)	/**< union variant selector value for member DQ_x005fCompletenessOmission */
        gmd__DQ_x005fCompletenessOmission_x005fType *DQ_x005fCompletenessOmission;
        #define SOAP_UNION_plu__gmd__union_DQ_x005fCompleteness_x005fPropertyType_DQ_x005fCompletenessCommission	(2)	/**< union variant selector value for member DQ_x005fCompletenessCommission */
        gmd__DQ_x005fCompletenessCommission_x005fType *DQ_x005fCompletenessCommission;
};
#endif

/* PlannedLandUse_v3.0.h:17291 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fCompleteness_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fCompleteness_x005fPropertyType_sequence (-1577)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fCompleteness_x005fPropertyType_sequence {
      public:
        /// Union with union _gmd__union_DQ_x005fCompleteness_x005fPropertyType variant selector __unionAbstractDQ_x005fCompleteness set to one of: SOAP_UNION_plu__gmd__union_DQ_x005fCompleteness_x005fPropertyType_DQ_x005fCompletenessOmission SOAP_UNION_plu__gmd__union_DQ_x005fCompleteness_x005fPropertyType_DQ_x005fCompletenessCommission
        int __unionAbstractDQ_x005fCompleteness;
        union _gmd__union_DQ_x005fCompleteness_x005fPropertyType union_DQ_x005fCompleteness_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fCompleteness_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fCompleteness_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fCompleteness_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fCompleteness_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fCompleteness_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fCompleteness_x005fPropertyType_sequence() : __unionAbstractDQ_x005fCompleteness() { }
        virtual ~__gmd__DQ_x005fCompleteness_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fCompleteness_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fCompleteness_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fCompleteness_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1955 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fCompleteness_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fCompleteness_x005fPropertyType (-606)
/* complex XML schema type 'gmd:DQ_Completeness_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fCompleteness_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fCompleteness_x005fPropertyType_sequence *__DQ_x005fCompleteness_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fCompleteness_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fCompleteness_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fCompleteness_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fCompleteness_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fCompleteness_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fCompleteness_x005fPropertyType() : __DQ_x005fCompleteness_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fCompleteness_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fCompleteness_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fCompleteness_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fCompleteness_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17353 */
#ifndef SOAP_TYPE_plu__gmd__union_DQ_x005fElement_x005fPropertyType
#define SOAP_TYPE_plu__gmd__union_DQ_x005fElement_x005fPropertyType (-1581)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_DQ_x005fElement_x005fPropertyType
{
};
#endif

/* PlannedLandUse_v3.0.h:17346 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fElement_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fElement_x005fPropertyType_sequence (-1580)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fElement_x005fPropertyType_sequence {
      public:
        /// Union with union _gmd__union_DQ_x005fElement_x005fPropertyType variant selector __unionAbstractDQ_x005fElement set to one of:
        int __unionAbstractDQ_x005fElement;
        union _gmd__union_DQ_x005fElement_x005fPropertyType union_DQ_x005fElement_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fElement_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fElement_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fElement_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fElement_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fElement_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fElement_x005fPropertyType_sequence() : __unionAbstractDQ_x005fElement() { }
        virtual ~__gmd__DQ_x005fElement_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fElement_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fElement_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fElement_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1961 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fElement_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fElement_x005fPropertyType (-608)
/* complex XML schema type 'gmd:DQ_Element_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fElement_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fElement_x005fPropertyType_sequence *__DQ_x005fElement_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fElement_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fElement_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fElement_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fElement_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fElement_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fElement_x005fPropertyType() : __DQ_x005fElement_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fElement_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fElement_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fElement_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fElement_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17397 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fDataQuality_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fDataQuality_x005fPropertyType_sequence (-1583)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fDataQuality_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_DataQuality' of XML schema type 'gmd:DQ_DataQuality_Type'
        gmd__DQ_x005fDataQuality_x005fType *DQ_x005fDataQuality;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fDataQuality_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fDataQuality_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fDataQuality_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fDataQuality_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fDataQuality_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fDataQuality_x005fPropertyType_sequence() : DQ_x005fDataQuality() { }
        virtual ~__gmd__DQ_x005fDataQuality_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fDataQuality_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fDataQuality_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fDataQuality_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1967 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fDataQuality_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fDataQuality_x005fPropertyType (-610)
/* complex XML schema type 'gmd:DQ_DataQuality_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fDataQuality_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fDataQuality_x005fPropertyType_sequence *__DQ_x005fDataQuality_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fDataQuality_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fDataQuality_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fDataQuality_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fDataQuality_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fDataQuality_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fDataQuality_x005fPropertyType() : __DQ_x005fDataQuality_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fDataQuality_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fDataQuality_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fDataQuality_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fDataQuality_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17442 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fScope_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fScope_x005fPropertyType_sequence (-1586)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fScope_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_Scope' of XML schema type 'gmd:DQ_Scope_Type'
        gmd__DQ_x005fScope_x005fType *DQ_x005fScope;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fScope_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fScope_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fScope_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fScope_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fScope_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fScope_x005fPropertyType_sequence() : DQ_x005fScope() { }
        virtual ~__gmd__DQ_x005fScope_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fScope_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fScope_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fScope_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1973 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fScope_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fScope_x005fPropertyType (-612)
/* complex XML schema type 'gmd:DQ_Scope_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fScope_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fScope_x005fPropertyType_sequence *__DQ_x005fScope_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fScope_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fScope_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fScope_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fScope_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fScope_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fScope_x005fPropertyType() : __DQ_x005fScope_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DQ_x005fScope_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fScope_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fScope_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fScope_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17487 */
#ifndef SOAP_TYPE_plu___gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType_sequence (-1589)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_EvaluationMethodTypeCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *DQ_x005fEvaluationMethodTypeCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType_sequence() : DQ_x005fEvaluationMethodTypeCode() { }
        virtual ~__gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1976 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType (-613)
/* complex XML schema type 'gmd:DQ_EvaluationMethodTypeCode_PropertyType': */
class SOAP_CMAC gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType_sequence *__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType() : __DQ_x005fEvaluationMethodTypeCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17519 */
#ifndef SOAP_TYPE_plu__gmd__union_MD_x005fIdentification_x005fPropertyType
#define SOAP_TYPE_plu__gmd__union_MD_x005fIdentification_x005fPropertyType (-1592)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_MD_x005fIdentification_x005fPropertyType
{
        #define SOAP_UNION_plu__gmd__union_MD_x005fIdentification_x005fPropertyType_MD_x005fDataIdentification	(1)	/**< union variant selector value for member MD_x005fDataIdentification */
        gmd__MD_x005fDataIdentification_x005fType *MD_x005fDataIdentification;
        #define SOAP_UNION_plu__gmd__union_MD_x005fIdentification_x005fPropertyType_MD_x005fServiceIdentification	(2)	/**< union variant selector value for member MD_x005fServiceIdentification */
        gmd__MD_x005fServiceIdentification_x005fType *MD_x005fServiceIdentification;
};
#endif

/* PlannedLandUse_v3.0.h:17512 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fIdentification_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fIdentification_x005fPropertyType_sequence (-1591)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fIdentification_x005fPropertyType_sequence {
      public:
        /// Union with union _gmd__union_MD_x005fIdentification_x005fPropertyType variant selector __unionAbstractMD_x005fIdentification set to one of: SOAP_UNION_plu__gmd__union_MD_x005fIdentification_x005fPropertyType_MD_x005fDataIdentification SOAP_UNION_plu__gmd__union_MD_x005fIdentification_x005fPropertyType_MD_x005fServiceIdentification
        int __unionAbstractMD_x005fIdentification;
        union _gmd__union_MD_x005fIdentification_x005fPropertyType union_MD_x005fIdentification_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fIdentification_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fIdentification_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fIdentification_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fIdentification_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fIdentification_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fIdentification_x005fPropertyType_sequence() : __unionAbstractMD_x005fIdentification() { }
        virtual ~__gmd__MD_x005fIdentification_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fIdentification_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fIdentification_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fIdentification_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1982 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fIdentification_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fIdentification_x005fPropertyType (-615)
/* complex XML schema type 'gmd:MD_Identification_PropertyType': */
class SOAP_CMAC gmd__MD_x005fIdentification_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fIdentification_x005fPropertyType_sequence *__MD_x005fIdentification_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fIdentification_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fIdentification_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fIdentification_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fIdentification_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fIdentification_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fIdentification_x005fPropertyType() : __MD_x005fIdentification_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fIdentification_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fIdentification_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fIdentification_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fIdentification_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17567 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fBrowseGraphic_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fBrowseGraphic_x005fPropertyType_sequence (-1596)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fBrowseGraphic_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_BrowseGraphic' of XML schema type 'gmd:MD_BrowseGraphic_Type'
        gmd__MD_x005fBrowseGraphic_x005fType *MD_x005fBrowseGraphic;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fBrowseGraphic_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fBrowseGraphic_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fBrowseGraphic_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fBrowseGraphic_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fBrowseGraphic_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fBrowseGraphic_x005fPropertyType_sequence() : MD_x005fBrowseGraphic() { }
        virtual ~__gmd__MD_x005fBrowseGraphic_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fBrowseGraphic_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fBrowseGraphic_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fBrowseGraphic_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1988 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fBrowseGraphic_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fBrowseGraphic_x005fPropertyType (-617)
/* complex XML schema type 'gmd:MD_BrowseGraphic_PropertyType': */
class SOAP_CMAC gmd__MD_x005fBrowseGraphic_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fBrowseGraphic_x005fPropertyType_sequence *__MD_x005fBrowseGraphic_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fBrowseGraphic_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fBrowseGraphic_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fBrowseGraphic_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fBrowseGraphic_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fBrowseGraphic_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fBrowseGraphic_x005fPropertyType() : __MD_x005fBrowseGraphic_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fBrowseGraphic_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fBrowseGraphic_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fBrowseGraphic_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fBrowseGraphic_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17612 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fDataIdentification_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fDataIdentification_x005fPropertyType_sequence (-1599)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fDataIdentification_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_DataIdentification' of XML schema type 'gmd:MD_DataIdentification_Type'
        gmd__MD_x005fDataIdentification_x005fType *MD_x005fDataIdentification;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fDataIdentification_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fDataIdentification_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fDataIdentification_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fDataIdentification_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fDataIdentification_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fDataIdentification_x005fPropertyType_sequence() : MD_x005fDataIdentification() { }
        virtual ~__gmd__MD_x005fDataIdentification_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fDataIdentification_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fDataIdentification_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fDataIdentification_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1994 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDataIdentification_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fDataIdentification_x005fPropertyType (-619)
/* complex XML schema type 'gmd:MD_DataIdentification_PropertyType': */
class SOAP_CMAC gmd__MD_x005fDataIdentification_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fDataIdentification_x005fPropertyType_sequence *__MD_x005fDataIdentification_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fDataIdentification_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fDataIdentification_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fDataIdentification_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fDataIdentification_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fDataIdentification_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fDataIdentification_x005fPropertyType() : __MD_x005fDataIdentification_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fDataIdentification_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fDataIdentification_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fDataIdentification_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fDataIdentification_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17657 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fServiceIdentification_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fServiceIdentification_x005fPropertyType_sequence (-1601)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fServiceIdentification_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_ServiceIdentification' of XML schema type 'gmd:MD_ServiceIdentification_Type'
        gmd__MD_x005fServiceIdentification_x005fType *MD_x005fServiceIdentification;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fServiceIdentification_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fServiceIdentification_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fServiceIdentification_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fServiceIdentification_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fServiceIdentification_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fServiceIdentification_x005fPropertyType_sequence() : MD_x005fServiceIdentification() { }
        virtual ~__gmd__MD_x005fServiceIdentification_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fServiceIdentification_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fServiceIdentification_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fServiceIdentification_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2000 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fServiceIdentification_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fServiceIdentification_x005fPropertyType (-621)
/* complex XML schema type 'gmd:MD_ServiceIdentification_PropertyType': */
class SOAP_CMAC gmd__MD_x005fServiceIdentification_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fServiceIdentification_x005fPropertyType_sequence *__MD_x005fServiceIdentification_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fServiceIdentification_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fServiceIdentification_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fServiceIdentification_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fServiceIdentification_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fServiceIdentification_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fServiceIdentification_x005fPropertyType() : __MD_x005fServiceIdentification_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fServiceIdentification_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fServiceIdentification_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fServiceIdentification_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fServiceIdentification_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17702 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fRepresentativeFraction_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fRepresentativeFraction_x005fPropertyType_sequence (-1603)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fRepresentativeFraction_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_RepresentativeFraction' of XML schema type 'gmd:MD_RepresentativeFraction_Type'
        gmd__MD_x005fRepresentativeFraction_x005fType *MD_x005fRepresentativeFraction;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fRepresentativeFraction_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fRepresentativeFraction_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fRepresentativeFraction_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fRepresentativeFraction_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fRepresentativeFraction_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fRepresentativeFraction_x005fPropertyType_sequence() : MD_x005fRepresentativeFraction() { }
        virtual ~__gmd__MD_x005fRepresentativeFraction_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fRepresentativeFraction_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fRepresentativeFraction_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fRepresentativeFraction_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2006 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fRepresentativeFraction_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fRepresentativeFraction_x005fPropertyType (-623)
/* complex XML schema type 'gmd:MD_RepresentativeFraction_PropertyType': */
class SOAP_CMAC gmd__MD_x005fRepresentativeFraction_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fRepresentativeFraction_x005fPropertyType_sequence *__MD_x005fRepresentativeFraction_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fRepresentativeFraction_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fRepresentativeFraction_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fRepresentativeFraction_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fRepresentativeFraction_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fRepresentativeFraction_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fRepresentativeFraction_x005fPropertyType() : __MD_x005fRepresentativeFraction_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fRepresentativeFraction_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fRepresentativeFraction_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fRepresentativeFraction_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fRepresentativeFraction_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17747 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fUsage_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fUsage_x005fPropertyType_sequence (-1606)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fUsage_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_Usage' of XML schema type 'gmd:MD_Usage_Type'
        gmd__MD_x005fUsage_x005fType *MD_x005fUsage;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fUsage_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fUsage_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fUsage_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fUsage_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fUsage_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fUsage_x005fPropertyType_sequence() : MD_x005fUsage() { }
        virtual ~__gmd__MD_x005fUsage_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fUsage_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fUsage_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fUsage_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2012 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fUsage_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fUsage_x005fPropertyType (-625)
/* complex XML schema type 'gmd:MD_Usage_PropertyType': */
class SOAP_CMAC gmd__MD_x005fUsage_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fUsage_x005fPropertyType_sequence *__MD_x005fUsage_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fUsage_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fUsage_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fUsage_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fUsage_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fUsage_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fUsage_x005fPropertyType() : __MD_x005fUsage_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fUsage_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fUsage_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fUsage_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fUsage_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17792 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fKeywords_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fKeywords_x005fPropertyType_sequence (-1609)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fKeywords_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_Keywords' of XML schema type 'gmd:MD_Keywords_Type'
        gmd__MD_x005fKeywords_x005fType *MD_x005fKeywords;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fKeywords_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fKeywords_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fKeywords_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fKeywords_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fKeywords_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fKeywords_x005fPropertyType_sequence() : MD_x005fKeywords() { }
        virtual ~__gmd__MD_x005fKeywords_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fKeywords_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fKeywords_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fKeywords_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2018 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fKeywords_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fKeywords_x005fPropertyType (-627)
/* complex XML schema type 'gmd:MD_Keywords_PropertyType': */
class SOAP_CMAC gmd__MD_x005fKeywords_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fKeywords_x005fPropertyType_sequence *__MD_x005fKeywords_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fKeywords_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fKeywords_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fKeywords_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fKeywords_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fKeywords_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fKeywords_x005fPropertyType() : __MD_x005fKeywords_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fKeywords_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fKeywords_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fKeywords_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fKeywords_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17837 */
#ifndef SOAP_TYPE_plu___gmd__DS_x005fAssociation_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DS_x005fAssociation_x005fPropertyType_sequence (-1612)
/* Wrapper: */
class SOAP_CMAC __gmd__DS_x005fAssociation_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DS_Association' of XML schema type 'gmd:DS_Association_Type'
        gmd__DS_x005fAssociation_x005fType *DS_x005fAssociation;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DS_x005fAssociation_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DS_x005fAssociation_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DS_x005fAssociation_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DS_x005fAssociation_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DS_x005fAssociation_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DS_x005fAssociation_x005fPropertyType_sequence() : DS_x005fAssociation() { }
        virtual ~__gmd__DS_x005fAssociation_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DS_x005fAssociation_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DS_x005fAssociation_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DS_x005fAssociation_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2024 */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fAssociation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fAssociation_x005fPropertyType (-629)
/* complex XML schema type 'gmd:DS_Association_PropertyType': */
class SOAP_CMAC gmd__DS_x005fAssociation_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DS_x005fAssociation_x005fPropertyType_sequence *__DS_x005fAssociation_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DS_x005fAssociation_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DS_x005fAssociation_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DS_x005fAssociation_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DS_x005fAssociation_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DS_x005fAssociation_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DS_x005fAssociation_x005fPropertyType() : __DS_x005fAssociation_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__DS_x005fAssociation_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DS_x005fAssociation_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DS_x005fAssociation_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DS_x005fAssociation_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17882 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fAggregateInformation_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fAggregateInformation_x005fPropertyType_sequence (-1615)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fAggregateInformation_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_AggregateInformation' of XML schema type 'gmd:MD_AggregateInformation_Type'
        gmd__MD_x005fAggregateInformation_x005fType *MD_x005fAggregateInformation;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fAggregateInformation_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fAggregateInformation_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fAggregateInformation_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fAggregateInformation_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fAggregateInformation_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fAggregateInformation_x005fPropertyType_sequence() : MD_x005fAggregateInformation() { }
        virtual ~__gmd__MD_x005fAggregateInformation_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fAggregateInformation_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fAggregateInformation_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fAggregateInformation_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2030 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fAggregateInformation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fAggregateInformation_x005fPropertyType (-631)
/* complex XML schema type 'gmd:MD_AggregateInformation_PropertyType': */
class SOAP_CMAC gmd__MD_x005fAggregateInformation_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fAggregateInformation_x005fPropertyType_sequence *__MD_x005fAggregateInformation_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fAggregateInformation_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fAggregateInformation_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fAggregateInformation_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fAggregateInformation_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fAggregateInformation_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fAggregateInformation_x005fPropertyType() : __MD_x005fAggregateInformation_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fAggregateInformation_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fAggregateInformation_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fAggregateInformation_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fAggregateInformation_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17930 */
#ifndef SOAP_TYPE_plu__gmd__union_MD_x005fResolution_x005fType
#define SOAP_TYPE_plu__gmd__union_MD_x005fResolution_x005fType (-1618)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_MD_x005fResolution_x005fType
{
        #define SOAP_UNION_plu__gmd__union_MD_x005fResolution_x005fType_equivalentScale	(1)	/**< union variant selector value for member equivalentScale */
        gmd__MD_x005fRepresentativeFraction_x005fPropertyType *equivalentScale;
        #define SOAP_UNION_plu__gmd__union_MD_x005fResolution_x005fType_distance	(2)	/**< union variant selector value for member distance */
        gco__Distance_x005fPropertyType *distance;
};
#endif

/* PlannedLandUse_v3.0.h:2033 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fResolution_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fResolution_x005fType (-632)
/* complex XML schema type 'gmd:MD_Resolution_Type': */
class SOAP_CMAC gmd__MD_x005fResolution_x005fType : public xsd__anyType {
      public:
        /// Union with union _gmd__union_MD_x005fResolution_x005fType variant selector __union_MD_x005fResolution_x005fType set to one of: SOAP_UNION_plu__gmd__union_MD_x005fResolution_x005fType_equivalentScale SOAP_UNION_plu__gmd__union_MD_x005fResolution_x005fType_distance
        int __union_MD_x005fResolution_x005fType;
        union _gmd__union_MD_x005fResolution_x005fType union_MD_x005fResolution_x005fType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fResolution_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fResolution_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fResolution_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fResolution_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fResolution_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fResolution_x005fType() : __union_MD_x005fResolution_x005fType() { }
        virtual ~gmd__MD_x005fResolution_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fResolution_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fResolution_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fResolution_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17954 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fResolution_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fResolution_x005fPropertyType_sequence (-1621)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fResolution_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_Resolution' of XML schema type 'gmd:MD_Resolution_Type'
        gmd__MD_x005fResolution_x005fType *MD_x005fResolution;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fResolution_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fResolution_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fResolution_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fResolution_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fResolution_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fResolution_x005fPropertyType_sequence() : MD_x005fResolution() { }
        virtual ~__gmd__MD_x005fResolution_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fResolution_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fResolution_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fResolution_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2036 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fResolution_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fResolution_x005fPropertyType (-633)
/* complex XML schema type 'gmd:MD_Resolution_PropertyType': */
class SOAP_CMAC gmd__MD_x005fResolution_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fResolution_x005fPropertyType_sequence *__MD_x005fResolution_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fResolution_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fResolution_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fResolution_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fResolution_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fResolution_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fResolution_x005fPropertyType() : __MD_x005fResolution_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fResolution_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fResolution_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fResolution_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fResolution_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:17979 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fTopicCategoryCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fTopicCategoryCode_x005fPropertyType_sequence (-1624)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fTopicCategoryCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_TopicCategoryCode' of XML schema type 'gmd:MD_TopicCategoryCode_Type'
        enum gmd__MD_x005fTopicCategoryCode_x005fType MD_x005fTopicCategoryCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fTopicCategoryCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fTopicCategoryCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fTopicCategoryCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fTopicCategoryCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fTopicCategoryCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fTopicCategoryCode_x005fPropertyType_sequence() : MD_x005fTopicCategoryCode() { }
        virtual ~__gmd__MD_x005fTopicCategoryCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fTopicCategoryCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fTopicCategoryCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fTopicCategoryCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2039 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fTopicCategoryCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fTopicCategoryCode_x005fPropertyType (-634)
/* complex XML schema type 'gmd:MD_TopicCategoryCode_PropertyType': */
class SOAP_CMAC gmd__MD_x005fTopicCategoryCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fTopicCategoryCode_x005fPropertyType_sequence *__MD_x005fTopicCategoryCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fTopicCategoryCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fTopicCategoryCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fTopicCategoryCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fTopicCategoryCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fTopicCategoryCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fTopicCategoryCode_x005fPropertyType() : __MD_x005fTopicCategoryCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fTopicCategoryCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fTopicCategoryCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fTopicCategoryCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fTopicCategoryCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18004 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fCharacterSetCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fCharacterSetCode_x005fPropertyType_sequence (-1626)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fCharacterSetCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_CharacterSetCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *MD_x005fCharacterSetCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fCharacterSetCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fCharacterSetCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fCharacterSetCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fCharacterSetCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fCharacterSetCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fCharacterSetCode_x005fPropertyType_sequence() : MD_x005fCharacterSetCode() { }
        virtual ~__gmd__MD_x005fCharacterSetCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fCharacterSetCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fCharacterSetCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fCharacterSetCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2042 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fCharacterSetCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fCharacterSetCode_x005fPropertyType (-635)
/* complex XML schema type 'gmd:MD_CharacterSetCode_PropertyType': */
class SOAP_CMAC gmd__MD_x005fCharacterSetCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fCharacterSetCode_x005fPropertyType_sequence *__MD_x005fCharacterSetCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fCharacterSetCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fCharacterSetCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fCharacterSetCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fCharacterSetCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fCharacterSetCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fCharacterSetCode_x005fPropertyType() : __MD_x005fCharacterSetCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fCharacterSetCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fCharacterSetCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fCharacterSetCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fCharacterSetCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18029 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType_sequence (-1628)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_SpatialRepresentationTypeCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *MD_x005fSpatialRepresentationTypeCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType_sequence() : MD_x005fSpatialRepresentationTypeCode() { }
        virtual ~__gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2045 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType (-636)
/* complex XML schema type 'gmd:MD_SpatialRepresentationTypeCode_PropertyType': */
class SOAP_CMAC gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType_sequence *__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType() : __MD_x005fSpatialRepresentationTypeCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18054 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fProgressCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fProgressCode_x005fPropertyType_sequence (-1630)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fProgressCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_ProgressCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *MD_x005fProgressCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fProgressCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fProgressCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fProgressCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fProgressCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fProgressCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fProgressCode_x005fPropertyType_sequence() : MD_x005fProgressCode() { }
        virtual ~__gmd__MD_x005fProgressCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fProgressCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fProgressCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fProgressCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2048 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fProgressCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fProgressCode_x005fPropertyType (-637)
/* complex XML schema type 'gmd:MD_ProgressCode_PropertyType': */
class SOAP_CMAC gmd__MD_x005fProgressCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fProgressCode_x005fPropertyType_sequence *__MD_x005fProgressCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fProgressCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fProgressCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fProgressCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fProgressCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fProgressCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fProgressCode_x005fPropertyType() : __MD_x005fProgressCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fProgressCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fProgressCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fProgressCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fProgressCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18079 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fKeywordTypeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fKeywordTypeCode_x005fPropertyType_sequence (-1632)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fKeywordTypeCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_KeywordTypeCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *MD_x005fKeywordTypeCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fKeywordTypeCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fKeywordTypeCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fKeywordTypeCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fKeywordTypeCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fKeywordTypeCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fKeywordTypeCode_x005fPropertyType_sequence() : MD_x005fKeywordTypeCode() { }
        virtual ~__gmd__MD_x005fKeywordTypeCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fKeywordTypeCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fKeywordTypeCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fKeywordTypeCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2051 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fKeywordTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fKeywordTypeCode_x005fPropertyType (-638)
/* complex XML schema type 'gmd:MD_KeywordTypeCode_PropertyType': */
class SOAP_CMAC gmd__MD_x005fKeywordTypeCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fKeywordTypeCode_x005fPropertyType_sequence *__MD_x005fKeywordTypeCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fKeywordTypeCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fKeywordTypeCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fKeywordTypeCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fKeywordTypeCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fKeywordTypeCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fKeywordTypeCode_x005fPropertyType() : __MD_x005fKeywordTypeCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fKeywordTypeCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fKeywordTypeCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fKeywordTypeCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fKeywordTypeCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18104 */
#ifndef SOAP_TYPE_plu___gmd__DS_x005fAssociationTypeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DS_x005fAssociationTypeCode_x005fPropertyType_sequence (-1634)
/* Wrapper: */
class SOAP_CMAC __gmd__DS_x005fAssociationTypeCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DS_AssociationTypeCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *DS_x005fAssociationTypeCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DS_x005fAssociationTypeCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DS_x005fAssociationTypeCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DS_x005fAssociationTypeCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DS_x005fAssociationTypeCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DS_x005fAssociationTypeCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DS_x005fAssociationTypeCode_x005fPropertyType_sequence() : DS_x005fAssociationTypeCode() { }
        virtual ~__gmd__DS_x005fAssociationTypeCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DS_x005fAssociationTypeCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DS_x005fAssociationTypeCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DS_x005fAssociationTypeCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2054 */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fAssociationTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fAssociationTypeCode_x005fPropertyType (-639)
/* complex XML schema type 'gmd:DS_AssociationTypeCode_PropertyType': */
class SOAP_CMAC gmd__DS_x005fAssociationTypeCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DS_x005fAssociationTypeCode_x005fPropertyType_sequence *__DS_x005fAssociationTypeCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DS_x005fAssociationTypeCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DS_x005fAssociationTypeCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DS_x005fAssociationTypeCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DS_x005fAssociationTypeCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DS_x005fAssociationTypeCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DS_x005fAssociationTypeCode_x005fPropertyType() : __DS_x005fAssociationTypeCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__DS_x005fAssociationTypeCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DS_x005fAssociationTypeCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DS_x005fAssociationTypeCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DS_x005fAssociationTypeCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18129 */
#ifndef SOAP_TYPE_plu___gmd__DS_x005fInitiativeTypeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__DS_x005fInitiativeTypeCode_x005fPropertyType_sequence (-1636)
/* Wrapper: */
class SOAP_CMAC __gmd__DS_x005fInitiativeTypeCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:DS_InitiativeTypeCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *DS_x005fInitiativeTypeCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__DS_x005fInitiativeTypeCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__DS_x005fInitiativeTypeCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DS_x005fInitiativeTypeCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DS_x005fInitiativeTypeCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__DS_x005fInitiativeTypeCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__DS_x005fInitiativeTypeCode_x005fPropertyType_sequence() : DS_x005fInitiativeTypeCode() { }
        virtual ~__gmd__DS_x005fInitiativeTypeCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DS_x005fInitiativeTypeCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DS_x005fInitiativeTypeCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DS_x005fInitiativeTypeCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2057 */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fInitiativeTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fInitiativeTypeCode_x005fPropertyType (-640)
/* complex XML schema type 'gmd:DS_InitiativeTypeCode_PropertyType': */
class SOAP_CMAC gmd__DS_x005fInitiativeTypeCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__DS_x005fInitiativeTypeCode_x005fPropertyType_sequence *__DS_x005fInitiativeTypeCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DS_x005fInitiativeTypeCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DS_x005fInitiativeTypeCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DS_x005fInitiativeTypeCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__DS_x005fInitiativeTypeCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DS_x005fInitiativeTypeCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__DS_x005fInitiativeTypeCode_x005fPropertyType() : __DS_x005fInitiativeTypeCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__DS_x005fInitiativeTypeCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DS_x005fInitiativeTypeCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DS_x005fInitiativeTypeCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DS_x005fInitiativeTypeCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18160 */
#ifndef SOAP_TYPE_plu__gmd__union_MD_x005fConstraints_x005fPropertyType
#define SOAP_TYPE_plu__gmd__union_MD_x005fConstraints_x005fPropertyType (-1639)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_MD_x005fConstraints_x005fPropertyType
{
        #define SOAP_UNION_plu__gmd__union_MD_x005fConstraints_x005fPropertyType_MD_x005fConstraints	(1)	/**< union variant selector value for member MD_x005fConstraints */
        gmd__MD_x005fConstraints_x005fType *MD_x005fConstraints;
        #define SOAP_UNION_plu__gmd__union_MD_x005fConstraints_x005fPropertyType_MD_x005fLegalConstraints	(2)	/**< union variant selector value for member MD_x005fLegalConstraints */
        gmd__MD_x005fLegalConstraints_x005fType *MD_x005fLegalConstraints;
        #define SOAP_UNION_plu__gmd__union_MD_x005fConstraints_x005fPropertyType_MD_x005fSecurityConstraints	(3)	/**< union variant selector value for member MD_x005fSecurityConstraints */
        gmd__MD_x005fSecurityConstraints_x005fType *MD_x005fSecurityConstraints;
};
#endif

/* PlannedLandUse_v3.0.h:18154 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fConstraints_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fConstraints_x005fPropertyType_sequence (-1638)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fConstraints_x005fPropertyType_sequence {
      public:
        /// Union with union _gmd__union_MD_x005fConstraints_x005fPropertyType variant selector __unionMD_x005fConstraints set to one of: SOAP_UNION_plu__gmd__union_MD_x005fConstraints_x005fPropertyType_MD_x005fConstraints SOAP_UNION_plu__gmd__union_MD_x005fConstraints_x005fPropertyType_MD_x005fLegalConstraints SOAP_UNION_plu__gmd__union_MD_x005fConstraints_x005fPropertyType_MD_x005fSecurityConstraints
        int __unionMD_x005fConstraints;
        union _gmd__union_MD_x005fConstraints_x005fPropertyType union_MD_x005fConstraints_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fConstraints_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fConstraints_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fConstraints_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fConstraints_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fConstraints_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fConstraints_x005fPropertyType_sequence() : __unionMD_x005fConstraints() { }
        virtual ~__gmd__MD_x005fConstraints_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fConstraints_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fConstraints_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fConstraints_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2063 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fConstraints_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fConstraints_x005fPropertyType (-642)
/* complex XML schema type 'gmd:MD_Constraints_PropertyType': */
class SOAP_CMAC gmd__MD_x005fConstraints_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fConstraints_x005fPropertyType_sequence *__MD_x005fConstraints_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fConstraints_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fConstraints_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fConstraints_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fConstraints_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fConstraints_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fConstraints_x005fPropertyType() : __MD_x005fConstraints_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fConstraints_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fConstraints_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fConstraints_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fConstraints_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18210 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fLegalConstraints_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fLegalConstraints_x005fPropertyType_sequence (-1644)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fLegalConstraints_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_LegalConstraints' of XML schema type 'gmd:MD_LegalConstraints_Type'
        gmd__MD_x005fLegalConstraints_x005fType *MD_x005fLegalConstraints;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fLegalConstraints_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fLegalConstraints_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fLegalConstraints_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fLegalConstraints_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fLegalConstraints_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fLegalConstraints_x005fPropertyType_sequence() : MD_x005fLegalConstraints() { }
        virtual ~__gmd__MD_x005fLegalConstraints_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fLegalConstraints_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fLegalConstraints_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fLegalConstraints_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2069 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fLegalConstraints_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fLegalConstraints_x005fPropertyType (-644)
/* complex XML schema type 'gmd:MD_LegalConstraints_PropertyType': */
class SOAP_CMAC gmd__MD_x005fLegalConstraints_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fLegalConstraints_x005fPropertyType_sequence *__MD_x005fLegalConstraints_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fLegalConstraints_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fLegalConstraints_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fLegalConstraints_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fLegalConstraints_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fLegalConstraints_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fLegalConstraints_x005fPropertyType() : __MD_x005fLegalConstraints_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fLegalConstraints_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fLegalConstraints_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fLegalConstraints_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fLegalConstraints_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18255 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fSecurityConstraints_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fSecurityConstraints_x005fPropertyType_sequence (-1646)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fSecurityConstraints_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_SecurityConstraints' of XML schema type 'gmd:MD_SecurityConstraints_Type'
        gmd__MD_x005fSecurityConstraints_x005fType *MD_x005fSecurityConstraints;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fSecurityConstraints_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fSecurityConstraints_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fSecurityConstraints_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fSecurityConstraints_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fSecurityConstraints_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fSecurityConstraints_x005fPropertyType_sequence() : MD_x005fSecurityConstraints() { }
        virtual ~__gmd__MD_x005fSecurityConstraints_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fSecurityConstraints_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fSecurityConstraints_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fSecurityConstraints_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2075 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fSecurityConstraints_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fSecurityConstraints_x005fPropertyType (-646)
/* complex XML schema type 'gmd:MD_SecurityConstraints_PropertyType': */
class SOAP_CMAC gmd__MD_x005fSecurityConstraints_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fSecurityConstraints_x005fPropertyType_sequence *__MD_x005fSecurityConstraints_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fSecurityConstraints_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fSecurityConstraints_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fSecurityConstraints_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fSecurityConstraints_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fSecurityConstraints_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fSecurityConstraints_x005fPropertyType() : __MD_x005fSecurityConstraints_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fSecurityConstraints_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fSecurityConstraints_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fSecurityConstraints_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fSecurityConstraints_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18300 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fClassificationCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fClassificationCode_x005fPropertyType_sequence (-1648)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fClassificationCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_ClassificationCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *MD_x005fClassificationCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fClassificationCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fClassificationCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fClassificationCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fClassificationCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fClassificationCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fClassificationCode_x005fPropertyType_sequence() : MD_x005fClassificationCode() { }
        virtual ~__gmd__MD_x005fClassificationCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fClassificationCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fClassificationCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fClassificationCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2078 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fClassificationCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fClassificationCode_x005fPropertyType (-647)
/* complex XML schema type 'gmd:MD_ClassificationCode_PropertyType': */
class SOAP_CMAC gmd__MD_x005fClassificationCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fClassificationCode_x005fPropertyType_sequence *__MD_x005fClassificationCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fClassificationCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fClassificationCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fClassificationCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fClassificationCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fClassificationCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fClassificationCode_x005fPropertyType() : __MD_x005fClassificationCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fClassificationCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fClassificationCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fClassificationCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fClassificationCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18325 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fRestrictionCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fRestrictionCode_x005fPropertyType_sequence (-1650)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fRestrictionCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_RestrictionCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *MD_x005fRestrictionCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fRestrictionCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fRestrictionCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fRestrictionCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fRestrictionCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fRestrictionCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fRestrictionCode_x005fPropertyType_sequence() : MD_x005fRestrictionCode() { }
        virtual ~__gmd__MD_x005fRestrictionCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fRestrictionCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fRestrictionCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fRestrictionCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2081 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fRestrictionCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fRestrictionCode_x005fPropertyType (-648)
/* complex XML schema type 'gmd:MD_RestrictionCode_PropertyType': */
class SOAP_CMAC gmd__MD_x005fRestrictionCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fRestrictionCode_x005fPropertyType_sequence *__MD_x005fRestrictionCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fRestrictionCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fRestrictionCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fRestrictionCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fRestrictionCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fRestrictionCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fRestrictionCode_x005fPropertyType() : __MD_x005fRestrictionCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fRestrictionCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fRestrictionCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fRestrictionCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fRestrictionCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18350 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fMedium_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fMedium_x005fPropertyType_sequence (-1652)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fMedium_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_Medium' of XML schema type 'gmd:MD_Medium_Type'
        gmd__MD_x005fMedium_x005fType *MD_x005fMedium;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fMedium_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fMedium_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fMedium_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fMedium_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fMedium_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fMedium_x005fPropertyType_sequence() : MD_x005fMedium() { }
        virtual ~__gmd__MD_x005fMedium_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fMedium_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fMedium_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fMedium_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2087 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMedium_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fMedium_x005fPropertyType (-650)
/* complex XML schema type 'gmd:MD_Medium_PropertyType': */
class SOAP_CMAC gmd__MD_x005fMedium_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fMedium_x005fPropertyType_sequence *__MD_x005fMedium_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fMedium_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fMedium_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fMedium_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fMedium_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fMedium_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fMedium_x005fPropertyType() : __MD_x005fMedium_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fMedium_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fMedium_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fMedium_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fMedium_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18395 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fDigitalTransferOptions_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fDigitalTransferOptions_x005fPropertyType_sequence (-1655)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fDigitalTransferOptions_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_DigitalTransferOptions' of XML schema type 'gmd:MD_DigitalTransferOptions_Type'
        gmd__MD_x005fDigitalTransferOptions_x005fType *MD_x005fDigitalTransferOptions;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fDigitalTransferOptions_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fDigitalTransferOptions_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fDigitalTransferOptions_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fDigitalTransferOptions_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fDigitalTransferOptions_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fDigitalTransferOptions_x005fPropertyType_sequence() : MD_x005fDigitalTransferOptions() { }
        virtual ~__gmd__MD_x005fDigitalTransferOptions_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fDigitalTransferOptions_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fDigitalTransferOptions_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fDigitalTransferOptions_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2093 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDigitalTransferOptions_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fDigitalTransferOptions_x005fPropertyType (-652)
/* complex XML schema type 'gmd:MD_DigitalTransferOptions_PropertyType': */
class SOAP_CMAC gmd__MD_x005fDigitalTransferOptions_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fDigitalTransferOptions_x005fPropertyType_sequence *__MD_x005fDigitalTransferOptions_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fDigitalTransferOptions_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fDigitalTransferOptions_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fDigitalTransferOptions_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fDigitalTransferOptions_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fDigitalTransferOptions_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fDigitalTransferOptions_x005fPropertyType() : __MD_x005fDigitalTransferOptions_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fDigitalTransferOptions_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fDigitalTransferOptions_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fDigitalTransferOptions_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fDigitalTransferOptions_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18440 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fStandardOrderProcess_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fStandardOrderProcess_x005fPropertyType_sequence (-1658)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fStandardOrderProcess_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_StandardOrderProcess' of XML schema type 'gmd:MD_StandardOrderProcess_Type'
        gmd__MD_x005fStandardOrderProcess_x005fType *MD_x005fStandardOrderProcess;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fStandardOrderProcess_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fStandardOrderProcess_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fStandardOrderProcess_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fStandardOrderProcess_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fStandardOrderProcess_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fStandardOrderProcess_x005fPropertyType_sequence() : MD_x005fStandardOrderProcess() { }
        virtual ~__gmd__MD_x005fStandardOrderProcess_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fStandardOrderProcess_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fStandardOrderProcess_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fStandardOrderProcess_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2099 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fStandardOrderProcess_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fStandardOrderProcess_x005fPropertyType (-654)
/* complex XML schema type 'gmd:MD_StandardOrderProcess_PropertyType': */
class SOAP_CMAC gmd__MD_x005fStandardOrderProcess_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fStandardOrderProcess_x005fPropertyType_sequence *__MD_x005fStandardOrderProcess_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fStandardOrderProcess_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fStandardOrderProcess_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fStandardOrderProcess_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fStandardOrderProcess_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fStandardOrderProcess_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fStandardOrderProcess_x005fPropertyType() : __MD_x005fStandardOrderProcess_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fStandardOrderProcess_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fStandardOrderProcess_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fStandardOrderProcess_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fStandardOrderProcess_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18485 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fDistributor_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fDistributor_x005fPropertyType_sequence (-1661)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fDistributor_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_Distributor' of XML schema type 'gmd:MD_Distributor_Type'
        gmd__MD_x005fDistributor_x005fType *MD_x005fDistributor;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fDistributor_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fDistributor_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fDistributor_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fDistributor_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fDistributor_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fDistributor_x005fPropertyType_sequence() : MD_x005fDistributor() { }
        virtual ~__gmd__MD_x005fDistributor_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fDistributor_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fDistributor_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fDistributor_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2105 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDistributor_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fDistributor_x005fPropertyType (-656)
/* complex XML schema type 'gmd:MD_Distributor_PropertyType': */
class SOAP_CMAC gmd__MD_x005fDistributor_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fDistributor_x005fPropertyType_sequence *__MD_x005fDistributor_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fDistributor_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fDistributor_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fDistributor_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fDistributor_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fDistributor_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fDistributor_x005fPropertyType() : __MD_x005fDistributor_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fDistributor_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fDistributor_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fDistributor_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fDistributor_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18530 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fDistribution_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fDistribution_x005fPropertyType_sequence (-1664)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fDistribution_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_Distribution' of XML schema type 'gmd:MD_Distribution_Type'
        gmd__MD_x005fDistribution_x005fType *MD_x005fDistribution;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fDistribution_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fDistribution_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fDistribution_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fDistribution_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fDistribution_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fDistribution_x005fPropertyType_sequence() : MD_x005fDistribution() { }
        virtual ~__gmd__MD_x005fDistribution_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fDistribution_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fDistribution_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fDistribution_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2111 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDistribution_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fDistribution_x005fPropertyType (-658)
/* complex XML schema type 'gmd:MD_Distribution_PropertyType': */
class SOAP_CMAC gmd__MD_x005fDistribution_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fDistribution_x005fPropertyType_sequence *__MD_x005fDistribution_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fDistribution_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fDistribution_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fDistribution_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fDistribution_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fDistribution_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fDistribution_x005fPropertyType() : __MD_x005fDistribution_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fDistribution_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fDistribution_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fDistribution_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fDistribution_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18575 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fFormat_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fFormat_x005fPropertyType_sequence (-1667)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fFormat_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_Format' of XML schema type 'gmd:MD_Format_Type'
        gmd__MD_x005fFormat_x005fType *MD_x005fFormat;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fFormat_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fFormat_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fFormat_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fFormat_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fFormat_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fFormat_x005fPropertyType_sequence() : MD_x005fFormat() { }
        virtual ~__gmd__MD_x005fFormat_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fFormat_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fFormat_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fFormat_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2117 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fFormat_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fFormat_x005fPropertyType (-660)
/* Type gmd__MD_x005fFormat_x005fPropertyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gmd:MD_Format_PropertyType': */
class SOAP_CMAC gmd__MD_x005fFormat_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fFormat_x005fPropertyType_sequence *__MD_x005fFormat_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fFormat_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fFormat_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fFormat_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fFormat_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fFormat_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fFormat_x005fPropertyType() : __MD_x005fFormat_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fFormat_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fFormat_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fFormat_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fFormat_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18620 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fDistributionUnits_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fDistributionUnits_x005fPropertyType_sequence (-1670)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fDistributionUnits_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_DistributionUnits' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *MD_x005fDistributionUnits;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fDistributionUnits_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fDistributionUnits_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fDistributionUnits_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fDistributionUnits_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fDistributionUnits_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fDistributionUnits_x005fPropertyType_sequence() : MD_x005fDistributionUnits() { }
        virtual ~__gmd__MD_x005fDistributionUnits_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fDistributionUnits_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fDistributionUnits_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fDistributionUnits_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2120 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDistributionUnits_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fDistributionUnits_x005fPropertyType (-661)
/* complex XML schema type 'gmd:MD_DistributionUnits_PropertyType': */
class SOAP_CMAC gmd__MD_x005fDistributionUnits_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fDistributionUnits_x005fPropertyType_sequence *__MD_x005fDistributionUnits_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fDistributionUnits_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fDistributionUnits_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fDistributionUnits_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fDistributionUnits_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fDistributionUnits_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fDistributionUnits_x005fPropertyType() : __MD_x005fDistributionUnits_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fDistributionUnits_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fDistributionUnits_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fDistributionUnits_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fDistributionUnits_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18645 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fMediumFormatCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fMediumFormatCode_x005fPropertyType_sequence (-1672)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fMediumFormatCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_MediumFormatCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *MD_x005fMediumFormatCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fMediumFormatCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fMediumFormatCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fMediumFormatCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fMediumFormatCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fMediumFormatCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fMediumFormatCode_x005fPropertyType_sequence() : MD_x005fMediumFormatCode() { }
        virtual ~__gmd__MD_x005fMediumFormatCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fMediumFormatCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fMediumFormatCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fMediumFormatCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2123 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMediumFormatCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fMediumFormatCode_x005fPropertyType (-662)
/* complex XML schema type 'gmd:MD_MediumFormatCode_PropertyType': */
class SOAP_CMAC gmd__MD_x005fMediumFormatCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fMediumFormatCode_x005fPropertyType_sequence *__MD_x005fMediumFormatCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fMediumFormatCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fMediumFormatCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fMediumFormatCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fMediumFormatCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fMediumFormatCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fMediumFormatCode_x005fPropertyType() : __MD_x005fMediumFormatCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fMediumFormatCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fMediumFormatCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fMediumFormatCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fMediumFormatCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18670 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fMediumNameCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fMediumNameCode_x005fPropertyType_sequence (-1674)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fMediumNameCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_MediumNameCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *MD_x005fMediumNameCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fMediumNameCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fMediumNameCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fMediumNameCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fMediumNameCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fMediumNameCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fMediumNameCode_x005fPropertyType_sequence() : MD_x005fMediumNameCode() { }
        virtual ~__gmd__MD_x005fMediumNameCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fMediumNameCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fMediumNameCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fMediumNameCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2126 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMediumNameCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fMediumNameCode_x005fPropertyType (-663)
/* complex XML schema type 'gmd:MD_MediumNameCode_PropertyType': */
class SOAP_CMAC gmd__MD_x005fMediumNameCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fMediumNameCode_x005fPropertyType_sequence *__MD_x005fMediumNameCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fMediumNameCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fMediumNameCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fMediumNameCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fMediumNameCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fMediumNameCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fMediumNameCode_x005fPropertyType() : __MD_x005fMediumNameCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fMediumNameCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fMediumNameCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fMediumNameCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fMediumNameCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18695 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fMaintenanceInformation_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fMaintenanceInformation_x005fPropertyType_sequence (-1676)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fMaintenanceInformation_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_MaintenanceInformation' of XML schema type 'gmd:MD_MaintenanceInformation_Type'
        gmd__MD_x005fMaintenanceInformation_x005fType *MD_x005fMaintenanceInformation;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fMaintenanceInformation_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fMaintenanceInformation_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fMaintenanceInformation_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fMaintenanceInformation_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fMaintenanceInformation_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fMaintenanceInformation_x005fPropertyType_sequence() : MD_x005fMaintenanceInformation() { }
        virtual ~__gmd__MD_x005fMaintenanceInformation_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fMaintenanceInformation_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fMaintenanceInformation_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fMaintenanceInformation_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2132 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMaintenanceInformation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fMaintenanceInformation_x005fPropertyType (-665)
/* complex XML schema type 'gmd:MD_MaintenanceInformation_PropertyType': */
class SOAP_CMAC gmd__MD_x005fMaintenanceInformation_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fMaintenanceInformation_x005fPropertyType_sequence *__MD_x005fMaintenanceInformation_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fMaintenanceInformation_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fMaintenanceInformation_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fMaintenanceInformation_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fMaintenanceInformation_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fMaintenanceInformation_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fMaintenanceInformation_x005fPropertyType() : __MD_x005fMaintenanceInformation_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__MD_x005fMaintenanceInformation_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fMaintenanceInformation_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fMaintenanceInformation_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fMaintenanceInformation_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18746 */
#ifndef SOAP_TYPE_plu__gmd__union_MD_x005fScopeDescription_x005fType
#define SOAP_TYPE_plu__gmd__union_MD_x005fScopeDescription_x005fType (-1679)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_MD_x005fScopeDescription_x005fType
{
        #define SOAP_UNION_plu__gmd__union_MD_x005fScopeDescription_x005fType_attributes	(1)	/**< union variant selector value for member attributes */
        std::vector<gco__ObjectReference_x005fPropertyType *> *attributes;
        #define SOAP_UNION_plu__gmd__union_MD_x005fScopeDescription_x005fType_features	(2)	/**< union variant selector value for member features */
        std::vector<gco__ObjectReference_x005fPropertyType *> *features;
        #define SOAP_UNION_plu__gmd__union_MD_x005fScopeDescription_x005fType_featureInstances	(3)	/**< union variant selector value for member featureInstances */
        std::vector<gco__ObjectReference_x005fPropertyType *> *featureInstances;
        #define SOAP_UNION_plu__gmd__union_MD_x005fScopeDescription_x005fType_attributeInstances	(4)	/**< union variant selector value for member attributeInstances */
        std::vector<gco__ObjectReference_x005fPropertyType *> *attributeInstances;
        #define SOAP_UNION_plu__gmd__union_MD_x005fScopeDescription_x005fType_dataset	(5)	/**< union variant selector value for member dataset */
        gco__CharacterString_x005fPropertyType *dataset;
        #define SOAP_UNION_plu__gmd__union_MD_x005fScopeDescription_x005fType_other	(6)	/**< union variant selector value for member other */
        gco__CharacterString_x005fPropertyType *other;
};
#endif

/* PlannedLandUse_v3.0.h:2135 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fScopeDescription_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fScopeDescription_x005fType (-666)
/* complex XML schema type 'gmd:MD_ScopeDescription_Type': */
class SOAP_CMAC gmd__MD_x005fScopeDescription_x005fType : public xsd__anyType {
      public:
        /// Union with union _gmd__union_MD_x005fScopeDescription_x005fType variant selector __union_MD_x005fScopeDescription_x005fType set to one of: SOAP_UNION_plu__gmd__union_MD_x005fScopeDescription_x005fType_attributes SOAP_UNION_plu__gmd__union_MD_x005fScopeDescription_x005fType_features SOAP_UNION_plu__gmd__union_MD_x005fScopeDescription_x005fType_featureInstances SOAP_UNION_plu__gmd__union_MD_x005fScopeDescription_x005fType_attributeInstances SOAP_UNION_plu__gmd__union_MD_x005fScopeDescription_x005fType_dataset SOAP_UNION_plu__gmd__union_MD_x005fScopeDescription_x005fType_other
        int __union_MD_x005fScopeDescription_x005fType;
        union _gmd__union_MD_x005fScopeDescription_x005fType union_MD_x005fScopeDescription_x005fType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fScopeDescription_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fScopeDescription_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fScopeDescription_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fScopeDescription_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fScopeDescription_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fScopeDescription_x005fType() : __union_MD_x005fScopeDescription_x005fType() { }
        virtual ~gmd__MD_x005fScopeDescription_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fScopeDescription_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fScopeDescription_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fScopeDescription_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18778 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fScopeDescription_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fScopeDescription_x005fPropertyType_sequence (-1684)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fScopeDescription_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_ScopeDescription' of XML schema type 'gmd:MD_ScopeDescription_Type'
        gmd__MD_x005fScopeDescription_x005fType *MD_x005fScopeDescription;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fScopeDescription_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fScopeDescription_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fScopeDescription_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fScopeDescription_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fScopeDescription_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fScopeDescription_x005fPropertyType_sequence() : MD_x005fScopeDescription() { }
        virtual ~__gmd__MD_x005fScopeDescription_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fScopeDescription_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fScopeDescription_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fScopeDescription_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2138 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fScopeDescription_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fScopeDescription_x005fPropertyType (-667)
/* complex XML schema type 'gmd:MD_ScopeDescription_PropertyType': */
class SOAP_CMAC gmd__MD_x005fScopeDescription_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fScopeDescription_x005fPropertyType_sequence *__MD_x005fScopeDescription_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fScopeDescription_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fScopeDescription_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fScopeDescription_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fScopeDescription_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fScopeDescription_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fScopeDescription_x005fPropertyType() : __MD_x005fScopeDescription_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fScopeDescription_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fScopeDescription_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fScopeDescription_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fScopeDescription_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18803 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType_sequence (-1687)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_MaintenanceFrequencyCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *MD_x005fMaintenanceFrequencyCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType_sequence() : MD_x005fMaintenanceFrequencyCode() { }
        virtual ~__gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2141 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType (-668)
/* complex XML schema type 'gmd:MD_MaintenanceFrequencyCode_PropertyType': */
class SOAP_CMAC gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType_sequence *__MD_x005fMaintenanceFrequencyCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType() : __MD_x005fMaintenanceFrequencyCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18828 */
#ifndef SOAP_TYPE_plu___gmd__MD_x005fScopeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__MD_x005fScopeCode_x005fPropertyType_sequence (-1689)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_x005fScopeCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_ScopeCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *MD_x005fScopeCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__MD_x005fScopeCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__MD_x005fScopeCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_x005fScopeCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_x005fScopeCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__MD_x005fScopeCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__MD_x005fScopeCode_x005fPropertyType_sequence() : MD_x005fScopeCode() { }
        virtual ~__gmd__MD_x005fScopeCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_x005fScopeCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_x005fScopeCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_x005fScopeCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2144 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fScopeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fScopeCode_x005fPropertyType (-669)
/* complex XML schema type 'gmd:MD_ScopeCode_PropertyType': */
class SOAP_CMAC gmd__MD_x005fScopeCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__MD_x005fScopeCode_x005fPropertyType_sequence *__MD_x005fScopeCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fScopeCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fScopeCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fScopeCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fScopeCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fScopeCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fScopeCode_x005fPropertyType() : __MD_x005fScopeCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__MD_x005fScopeCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fScopeCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fScopeCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fScopeCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18853 */
#ifndef SOAP_TYPE_plu___gmd__PT_x005fLocale_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__PT_x005fLocale_x005fPropertyType_sequence (-1691)
/* Wrapper: */
class SOAP_CMAC __gmd__PT_x005fLocale_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:PT_Locale' of XML schema type 'gmd:PT_Locale_Type'
        gmd__PT_x005fLocale_x005fType *PT_x005fLocale;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__PT_x005fLocale_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__PT_x005fLocale_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__PT_x005fLocale_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__PT_x005fLocale_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__PT_x005fLocale_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__PT_x005fLocale_x005fPropertyType_sequence() : PT_x005fLocale() { }
        virtual ~__gmd__PT_x005fLocale_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__PT_x005fLocale_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__PT_x005fLocale_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__PT_x005fLocale_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2156 */
#ifndef SOAP_TYPE_plu_gmd__PT_x005fLocale_x005fPropertyType
#define SOAP_TYPE_plu_gmd__PT_x005fLocale_x005fPropertyType (-673)
/* complex XML schema type 'gmd:PT_Locale_PropertyType': */
class SOAP_CMAC gmd__PT_x005fLocale_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__PT_x005fLocale_x005fPropertyType_sequence *__PT_x005fLocale_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__PT_x005fLocale_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__PT_x005fLocale_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__PT_x005fLocale_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__PT_x005fLocale_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__PT_x005fLocale_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__PT_x005fLocale_x005fPropertyType() : __PT_x005fLocale_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__PT_x005fLocale_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__PT_x005fLocale_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__PT_x005fLocale_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__PT_x005fLocale_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2165 */
#ifndef SOAP_TYPE_plu_gmd__PT_x005fLocaleContainer_x005fType
#define SOAP_TYPE_plu_gmd__PT_x005fLocaleContainer_x005fType (-676)
/* complex XML schema type 'gmd:PT_LocaleContainer_Type': */
class SOAP_CMAC gmd__PT_x005fLocaleContainer_x005fType : public xsd__anyType {
      public:
        /// Required element 'gmd:description' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *description;
        /// Required element 'gmd:locale' of XML schema type 'gmd:PT_Locale_PropertyType'
        gmd__PT_x005fLocale_x005fPropertyType *locale;
        /// Required element 'gmd:date' of XML schema type 'gmd:CI_Date_PropertyType'
        std::vector<gmd__CI_x005fDate_x005fPropertyType *> date;
        /// Required element 'gmd:responsibleParty' of XML schema type 'gmd:CI_ResponsibleParty_PropertyType'
        std::vector<gmd__CI_x005fResponsibleParty_x005fPropertyType *> responsibleParty;
        /// Required element 'gmd:localisedString' of XML schema type 'gmd:LocalisedCharacterString_PropertyType'
        std::vector<gmd__LocalisedCharacterString_x005fPropertyType *> localisedString;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__PT_x005fLocaleContainer_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__PT_x005fLocaleContainer_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__PT_x005fLocaleContainer_x005fType, default initialized and not managed by a soap context
        virtual gmd__PT_x005fLocaleContainer_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__PT_x005fLocaleContainer_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__PT_x005fLocaleContainer_x005fType() : description(), locale(), date(), responsibleParty(), localisedString() { }
        virtual ~gmd__PT_x005fLocaleContainer_x005fType() { }
        /// Friend allocator used by soap_new_gmd__PT_x005fLocaleContainer_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__PT_x005fLocaleContainer_x005fType * SOAP_FMAC2 soap_instantiate_gmd__PT_x005fLocaleContainer_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18924 */
#ifndef SOAP_TYPE_plu___gmd__PT_x005fLocaleContainer_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__PT_x005fLocaleContainer_x005fPropertyType_sequence (-1701)
/* Wrapper: */
class SOAP_CMAC __gmd__PT_x005fLocaleContainer_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:PT_LocaleContainer' of XML schema type 'gmd:PT_LocaleContainer_Type'
        gmd__PT_x005fLocaleContainer_x005fType *PT_x005fLocaleContainer;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__PT_x005fLocaleContainer_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__PT_x005fLocaleContainer_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__PT_x005fLocaleContainer_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__PT_x005fLocaleContainer_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__PT_x005fLocaleContainer_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__PT_x005fLocaleContainer_x005fPropertyType_sequence() : PT_x005fLocaleContainer() { }
        virtual ~__gmd__PT_x005fLocaleContainer_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__PT_x005fLocaleContainer_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__PT_x005fLocaleContainer_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__PT_x005fLocaleContainer_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2168 */
#ifndef SOAP_TYPE_plu_gmd__PT_x005fLocaleContainer_x005fPropertyType
#define SOAP_TYPE_plu_gmd__PT_x005fLocaleContainer_x005fPropertyType (-677)
/* complex XML schema type 'gmd:PT_LocaleContainer_PropertyType': */
class SOAP_CMAC gmd__PT_x005fLocaleContainer_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__PT_x005fLocaleContainer_x005fPropertyType_sequence *__PT_x005fLocaleContainer_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__PT_x005fLocaleContainer_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__PT_x005fLocaleContainer_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__PT_x005fLocaleContainer_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__PT_x005fLocaleContainer_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__PT_x005fLocaleContainer_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__PT_x005fLocaleContainer_x005fPropertyType() : __PT_x005fLocaleContainer_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gmd__PT_x005fLocaleContainer_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__PT_x005fLocaleContainer_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__PT_x005fLocaleContainer_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__PT_x005fLocaleContainer_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18969 */
#ifndef SOAP_TYPE_plu___gmd__LanguageCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__LanguageCode_x005fPropertyType_sequence (-1704)
/* Wrapper: */
class SOAP_CMAC __gmd__LanguageCode_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:LanguageCode' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *LanguageCode;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__LanguageCode_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__LanguageCode_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__LanguageCode_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__LanguageCode_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__LanguageCode_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__LanguageCode_x005fPropertyType_sequence() : LanguageCode() { }
        virtual ~__gmd__LanguageCode_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__LanguageCode_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__LanguageCode_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__LanguageCode_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2171 */
#ifndef SOAP_TYPE_plu_gmd__LanguageCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__LanguageCode_x005fPropertyType (-678)
/* complex XML schema type 'gmd:LanguageCode_PropertyType': */
class SOAP_CMAC gmd__LanguageCode_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__LanguageCode_x005fPropertyType_sequence *__LanguageCode_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__LanguageCode_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__LanguageCode_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__LanguageCode_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__LanguageCode_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__LanguageCode_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__LanguageCode_x005fPropertyType() : __LanguageCode_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__LanguageCode_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__LanguageCode_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__LanguageCode_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__LanguageCode_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:18994 */
#ifndef SOAP_TYPE_plu___gmd__Country_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__Country_x005fPropertyType_sequence (-1706)
/* Wrapper: */
class SOAP_CMAC __gmd__Country_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:Country' of XML schema type 'gco:CodeListValue_Type'
        gco__CodeListValue_x005fType *Country;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__Country_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__Country_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__Country_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__Country_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__Country_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__Country_x005fPropertyType_sequence() : Country() { }
        virtual ~__gmd__Country_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__Country_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__Country_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__Country_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2174 */
#ifndef SOAP_TYPE_plu_gmd__Country_x005fPropertyType
#define SOAP_TYPE_plu_gmd__Country_x005fPropertyType (-679)
/* complex XML schema type 'gmd:Country_PropertyType': */
class SOAP_CMAC gmd__Country_x005fPropertyType : public xsd__anyType {
      public:
        __gmd__Country_x005fPropertyType_sequence *__Country_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__Country_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__Country_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__Country_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__Country_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__Country_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__Country_x005fPropertyType() : __Country_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gmd__Country_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__Country_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__Country_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__Country_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2177 */
#ifndef SOAP_TYPE_plu_xlink__simple
#define SOAP_TYPE_plu_xlink__simple (-680)
/* complex XML schema type 'xlink:simple': */
class SOAP_CMAC xlink__simple : public xsd__anyType {
      public:
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_plu_xlink__simple
        virtual long soap_type(void) const { return SOAP_TYPE_plu_xlink__simple; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__simple, default initialized and not managed by a soap context
        virtual xlink__simple *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__simple); }
      public:
        /// Constructor with default initializations
        xlink__simple() : xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), __mixed() { }
        virtual ~xlink__simple() { }
        /// Friend allocator used by soap_new_xlink__simple(struct soap*, int)
        friend SOAP_FMAC1 xlink__simple * SOAP_FMAC2 soap_instantiate_xlink__simple(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:19088 */
#ifndef SOAP_TYPE_plu__xlink__union_extended
#define SOAP_TYPE_plu__xlink__union_extended (-1709)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _xlink__union_extended
{
};
#endif

/* PlannedLandUse_v3.0.h:19084 */
#ifndef SOAP_TYPE_plu___xlink__union_extended
#define SOAP_TYPE_plu___xlink__union_extended (-1708)
/* Wrapper: */
class SOAP_CMAC __xlink__union_extended {
      public:
        /// Union with union _xlink__union_extended variant selector __union_extended set to one of:
        int __union_extended;
        union _xlink__union_extended union_extended;
      public:
        /// Return unique type id SOAP_TYPE_plu___xlink__union_extended
        virtual long soap_type(void) const { return SOAP_TYPE_plu___xlink__union_extended; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __xlink__union_extended, default initialized and not managed by a soap context
        virtual __xlink__union_extended *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__xlink__union_extended); }
      public:
        /// Constructor with default initializations
        __xlink__union_extended() : __union_extended() { }
        virtual ~__xlink__union_extended() { }
        /// Friend allocator used by soap_new___xlink__union_extended(struct soap*, int)
        friend SOAP_FMAC1 __xlink__union_extended * SOAP_FMAC2 soap_instantiate___xlink__union_extended(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2180 */
#ifndef SOAP_TYPE_plu_xlink__extended
#define SOAP_TYPE_plu_xlink__extended (-681)
/* complex XML schema type 'xlink:extended': */
class SOAP_CMAC xlink__extended : public xsd__anyType {
      public:
        /// Sequence of elements '-union-extended' of XML schema type '-xlink:union-extended' stored in dynamic array __union_extended of length __size_extended
        int __size_extended;
        __xlink__union_extended *__union_extended;
        /// Required attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType xlink__type;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
      public:
        /// Return unique type id SOAP_TYPE_plu_xlink__extended
        virtual long soap_type(void) const { return SOAP_TYPE_plu_xlink__extended; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__extended, default initialized and not managed by a soap context
        virtual xlink__extended *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__extended); }
      public:
        /// Constructor with default initializations
        xlink__extended() : __size_extended(), __union_extended(), xlink__type(), xlink__role(), xlink__title() { }
        virtual ~xlink__extended() { }
        /// Friend allocator used by soap_new_xlink__extended(struct soap*, int)
        friend SOAP_FMAC1 xlink__extended * SOAP_FMAC2 soap_instantiate_xlink__extended(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2183 */
#ifndef SOAP_TYPE_plu_xlink__titleEltType
#define SOAP_TYPE_plu_xlink__titleEltType (-682)
/* complex XML schema type 'xlink:titleEltType': */
class SOAP_CMAC xlink__titleEltType : public xsd__anyType {
      public:
        /// Required attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType xlink__type;
        /// Optional attribute 'xml:lang' of XML schema type 'xml:lang'
        char **xml__lang;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_plu_xlink__titleEltType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_xlink__titleEltType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__titleEltType, default initialized and not managed by a soap context
        virtual xlink__titleEltType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__titleEltType); }
      public:
        /// Constructor with default initializations
        xlink__titleEltType() : xlink__type(), xml__lang(), __mixed() { }
        virtual ~xlink__titleEltType() { }
        /// Friend allocator used by soap_new_xlink__titleEltType(struct soap*, int)
        friend SOAP_FMAC1 xlink__titleEltType * SOAP_FMAC2 soap_instantiate_xlink__titleEltType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2186 */
#ifndef SOAP_TYPE_plu_xlink__resourceType
#define SOAP_TYPE_plu_xlink__resourceType (-683)
/* complex XML schema type 'xlink:resourceType': */
class SOAP_CMAC xlink__resourceType : public xsd__anyType {
      public:
        /// Required attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType xlink__type;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:label' of XML schema type 'xlink:labelType'
        char **xlink__label;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_plu_xlink__resourceType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_xlink__resourceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__resourceType, default initialized and not managed by a soap context
        virtual xlink__resourceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__resourceType); }
      public:
        /// Constructor with default initializations
        xlink__resourceType() : xlink__type(), xlink__role(), xlink__title(), xlink__label(), __mixed() { }
        virtual ~xlink__resourceType() { }
        /// Friend allocator used by soap_new_xlink__resourceType(struct soap*, int)
        friend SOAP_FMAC1 xlink__resourceType * SOAP_FMAC2 soap_instantiate_xlink__resourceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:19215 */
#ifndef SOAP_TYPE_plu__xlink__union_locatorType
#define SOAP_TYPE_plu__xlink__union_locatorType (-1714)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _xlink__union_locatorType
{
};
#endif

/* PlannedLandUse_v3.0.h:19210 */
#ifndef SOAP_TYPE_plu___xlink__union_locatorType
#define SOAP_TYPE_plu___xlink__union_locatorType (-1713)
/* Wrapper: */
class SOAP_CMAC __xlink__union_locatorType {
      public:
        /// Union with union _xlink__union_locatorType variant selector __uniontitle set to one of:
        int __uniontitle;
        union _xlink__union_locatorType union_locatorType;
      public:
        /// Return unique type id SOAP_TYPE_plu___xlink__union_locatorType
        virtual long soap_type(void) const { return SOAP_TYPE_plu___xlink__union_locatorType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __xlink__union_locatorType, default initialized and not managed by a soap context
        virtual __xlink__union_locatorType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__xlink__union_locatorType); }
      public:
        /// Constructor with default initializations
        __xlink__union_locatorType() : __uniontitle() { }
        virtual ~__xlink__union_locatorType() { }
        /// Friend allocator used by soap_new___xlink__union_locatorType(struct soap*, int)
        friend SOAP_FMAC1 __xlink__union_locatorType * SOAP_FMAC2 soap_instantiate___xlink__union_locatorType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2189 */
#ifndef SOAP_TYPE_plu_xlink__locatorType
#define SOAP_TYPE_plu_xlink__locatorType (-684)
/* complex XML schema type 'xlink:locatorType': */
class SOAP_CMAC xlink__locatorType : public xsd__anyType {
      public:
        /// Sequence of elements '-union-locatorType' of XML schema type '-xlink:union-locatorType' stored in dynamic array __union_locatorType of length __sizetitle
        int __sizetitle;
        __xlink__union_locatorType *__union_locatorType;
        /// Required attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType xlink__type;
        /// Required attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char *xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:label' of XML schema type 'xlink:labelType'
        char **xlink__label;
      public:
        /// Return unique type id SOAP_TYPE_plu_xlink__locatorType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_xlink__locatorType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__locatorType, default initialized and not managed by a soap context
        virtual xlink__locatorType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__locatorType); }
      public:
        /// Constructor with default initializations
        xlink__locatorType() : __sizetitle(), __union_locatorType(), xlink__type(), xlink__href(), xlink__role(), xlink__title(), xlink__label() { }
        virtual ~xlink__locatorType() { }
        /// Friend allocator used by soap_new_xlink__locatorType(struct soap*, int)
        friend SOAP_FMAC1 xlink__locatorType * SOAP_FMAC2 soap_instantiate_xlink__locatorType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:19261 */
#ifndef SOAP_TYPE_plu__xlink__union_arcType
#define SOAP_TYPE_plu__xlink__union_arcType (-1717)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _xlink__union_arcType
{
};
#endif

/* PlannedLandUse_v3.0.h:19256 */
#ifndef SOAP_TYPE_plu___xlink__union_arcType
#define SOAP_TYPE_plu___xlink__union_arcType (-1716)
/* Wrapper: */
class SOAP_CMAC __xlink__union_arcType {
      public:
        /// Union with union _xlink__union_arcType variant selector __uniontitle set to one of:
        int __uniontitle;
        union _xlink__union_arcType union_arcType;
      public:
        /// Return unique type id SOAP_TYPE_plu___xlink__union_arcType
        virtual long soap_type(void) const { return SOAP_TYPE_plu___xlink__union_arcType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __xlink__union_arcType, default initialized and not managed by a soap context
        virtual __xlink__union_arcType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__xlink__union_arcType); }
      public:
        /// Constructor with default initializations
        __xlink__union_arcType() : __uniontitle() { }
        virtual ~__xlink__union_arcType() { }
        /// Friend allocator used by soap_new___xlink__union_arcType(struct soap*, int)
        friend SOAP_FMAC1 __xlink__union_arcType * SOAP_FMAC2 soap_instantiate___xlink__union_arcType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2192 */
#ifndef SOAP_TYPE_plu_xlink__arcType
#define SOAP_TYPE_plu_xlink__arcType (-685)
/* complex XML schema type 'xlink:arcType': */
class SOAP_CMAC xlink__arcType : public xsd__anyType {
      public:
        /// Sequence of elements '-union-arcType' of XML schema type '-xlink:union-arcType' stored in dynamic array __union_arcType of length __sizetitle
        int __sizetitle;
        __xlink__union_arcType *__union_arcType;
        /// Required attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType xlink__type;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
        /// Optional attribute 'xlink:from' of XML schema type 'xlink:fromType'
        char **xlink__from;
        /// Optional attribute 'xlink:to' of XML schema type 'xlink:toType'
        char **xlink__to;
      public:
        /// Return unique type id SOAP_TYPE_plu_xlink__arcType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_xlink__arcType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xlink__arcType, default initialized and not managed by a soap context
        virtual xlink__arcType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xlink__arcType); }
      public:
        /// Constructor with default initializations
        xlink__arcType() : __sizetitle(), __union_arcType(), xlink__type(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), xlink__from(), xlink__to() { }
        virtual ~xlink__arcType() { }
        /// Friend allocator used by soap_new_xlink__arcType(struct soap*, int)
        friend SOAP_FMAC1 xlink__arcType * SOAP_FMAC2 soap_instantiate_xlink__arcType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:19310 */
#ifndef SOAP_TYPE_plu___gco__TypeName_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__TypeName_x005fPropertyType_sequence (-1721)
/* Wrapper: */
class SOAP_CMAC __gco__TypeName_x005fPropertyType_sequence {
      public:
        /// Required element 'gco:TypeName' of XML schema type 'gco:TypeName_Type'
        gco__TypeName_x005fType *TypeName;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__TypeName_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__TypeName_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__TypeName_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__TypeName_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__TypeName_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__TypeName_x005fPropertyType_sequence() : TypeName() { }
        virtual ~__gco__TypeName_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__TypeName_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__TypeName_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__TypeName_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2198 */
#ifndef SOAP_TYPE_plu_gco__TypeName_x005fPropertyType
#define SOAP_TYPE_plu_gco__TypeName_x005fPropertyType (-687)
/* complex XML schema type 'gco:TypeName_PropertyType': */
class SOAP_CMAC gco__TypeName_x005fPropertyType : public xsd__anyType {
      public:
        __gco__TypeName_x005fPropertyType_sequence *__TypeName_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__TypeName_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__TypeName_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__TypeName_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__TypeName_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__TypeName_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__TypeName_x005fPropertyType() : __TypeName_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gco__TypeName_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__TypeName_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__TypeName_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__TypeName_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:19355 */
#ifndef SOAP_TYPE_plu___gco__MemberName_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__MemberName_x005fPropertyType_sequence (-1724)
/* Wrapper: */
class SOAP_CMAC __gco__MemberName_x005fPropertyType_sequence {
      public:
        /// Required element 'gco:MemberName' of XML schema type 'gco:MemberName_Type'
        gco__MemberName_x005fType *MemberName;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__MemberName_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__MemberName_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__MemberName_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__MemberName_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__MemberName_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__MemberName_x005fPropertyType_sequence() : MemberName() { }
        virtual ~__gco__MemberName_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__MemberName_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__MemberName_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__MemberName_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2204 */
#ifndef SOAP_TYPE_plu_gco__MemberName_x005fPropertyType
#define SOAP_TYPE_plu_gco__MemberName_x005fPropertyType (-689)
/* complex XML schema type 'gco:MemberName_PropertyType': */
class SOAP_CMAC gco__MemberName_x005fPropertyType : public xsd__anyType {
      public:
        __gco__MemberName_x005fPropertyType_sequence *__MemberName_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__MemberName_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__MemberName_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__MemberName_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__MemberName_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__MemberName_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__MemberName_x005fPropertyType() : __MemberName_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gco__MemberName_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__MemberName_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__MemberName_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__MemberName_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:19400 */
#ifndef SOAP_TYPE_plu___gco__Multiplicity_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__Multiplicity_x005fPropertyType_sequence (-1727)
/* Wrapper: */
class SOAP_CMAC __gco__Multiplicity_x005fPropertyType_sequence {
      public:
        /// Required element 'gco:Multiplicity' of XML schema type 'gco:Multiplicity_Type'
        gco__Multiplicity_x005fType *Multiplicity;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__Multiplicity_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__Multiplicity_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__Multiplicity_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__Multiplicity_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__Multiplicity_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__Multiplicity_x005fPropertyType_sequence() : Multiplicity() { }
        virtual ~__gco__Multiplicity_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__Multiplicity_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__Multiplicity_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__Multiplicity_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2210 */
#ifndef SOAP_TYPE_plu_gco__Multiplicity_x005fPropertyType
#define SOAP_TYPE_plu_gco__Multiplicity_x005fPropertyType (-691)
/* complex XML schema type 'gco:Multiplicity_PropertyType': */
class SOAP_CMAC gco__Multiplicity_x005fPropertyType : public xsd__anyType {
      public:
        __gco__Multiplicity_x005fPropertyType_sequence *__Multiplicity_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__Multiplicity_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__Multiplicity_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Multiplicity_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__Multiplicity_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__Multiplicity_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__Multiplicity_x005fPropertyType() : __Multiplicity_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gco__Multiplicity_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__Multiplicity_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__Multiplicity_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__Multiplicity_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:19445 */
#ifndef SOAP_TYPE_plu___gco__MultiplicityRange_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__MultiplicityRange_x005fPropertyType_sequence (-1730)
/* Wrapper: */
class SOAP_CMAC __gco__MultiplicityRange_x005fPropertyType_sequence {
      public:
        /// Required element 'gco:MultiplicityRange' of XML schema type 'gco:MultiplicityRange_Type'
        gco__MultiplicityRange_x005fType *MultiplicityRange;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__MultiplicityRange_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__MultiplicityRange_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__MultiplicityRange_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__MultiplicityRange_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__MultiplicityRange_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__MultiplicityRange_x005fPropertyType_sequence() : MultiplicityRange() { }
        virtual ~__gco__MultiplicityRange_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__MultiplicityRange_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__MultiplicityRange_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__MultiplicityRange_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2216 */
#ifndef SOAP_TYPE_plu_gco__MultiplicityRange_x005fPropertyType
#define SOAP_TYPE_plu_gco__MultiplicityRange_x005fPropertyType (-693)
/* complex XML schema type 'gco:MultiplicityRange_PropertyType': */
class SOAP_CMAC gco__MultiplicityRange_x005fPropertyType : public xsd__anyType {
      public:
        __gco__MultiplicityRange_x005fPropertyType_sequence *__MultiplicityRange_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__MultiplicityRange_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__MultiplicityRange_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__MultiplicityRange_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__MultiplicityRange_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__MultiplicityRange_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__MultiplicityRange_x005fPropertyType() : __MultiplicityRange_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gco__MultiplicityRange_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__MultiplicityRange_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__MultiplicityRange_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__MultiplicityRange_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:19496 */
#ifndef SOAP_TYPE_plu__gco__union_Measure_x005fPropertyType
#define SOAP_TYPE_plu__gco__union_Measure_x005fPropertyType (-1734)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gco__union_Measure_x005fPropertyType
{
        #define SOAP_UNION_plu__gco__union_Measure_x005fPropertyType_Measure	(1)	/**< union variant selector value for member Measure */
        gml__MeasureType *Measure;
        #define SOAP_UNION_plu__gco__union_Measure_x005fPropertyType_Length	(2)	/**< union variant selector value for member Length */
        gml__LengthType *Length;
        #define SOAP_UNION_plu__gco__union_Measure_x005fPropertyType_Distance	(3)	/**< union variant selector value for member Distance */
        gml__LengthType *Distance;
        #define SOAP_UNION_plu__gco__union_Measure_x005fPropertyType_Angle	(4)	/**< union variant selector value for member Angle */
        gml__AngleType *Angle;
        #define SOAP_UNION_plu__gco__union_Measure_x005fPropertyType_Scale	(5)	/**< union variant selector value for member Scale */
        gml__ScaleType *Scale;
};
#endif

/* PlannedLandUse_v3.0.h:19490 */
#ifndef SOAP_TYPE_plu___gco__Measure_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__Measure_x005fPropertyType_sequence (-1733)
/* Wrapper: */
class SOAP_CMAC __gco__Measure_x005fPropertyType_sequence {
      public:
        /// Union with union _gco__union_Measure_x005fPropertyType variant selector __unionMeasure set to one of: SOAP_UNION_plu__gco__union_Measure_x005fPropertyType_Measure SOAP_UNION_plu__gco__union_Measure_x005fPropertyType_Length SOAP_UNION_plu__gco__union_Measure_x005fPropertyType_Distance SOAP_UNION_plu__gco__union_Measure_x005fPropertyType_Angle SOAP_UNION_plu__gco__union_Measure_x005fPropertyType_Scale
        int __unionMeasure;
        union _gco__union_Measure_x005fPropertyType union_Measure_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__Measure_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__Measure_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__Measure_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__Measure_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__Measure_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__Measure_x005fPropertyType_sequence() : __unionMeasure() { }
        virtual ~__gco__Measure_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__Measure_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__Measure_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__Measure_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2219 */
#ifndef SOAP_TYPE_plu_gco__Measure_x005fPropertyType
#define SOAP_TYPE_plu_gco__Measure_x005fPropertyType (-694)
/* complex XML schema type 'gco:Measure_PropertyType': */
class SOAP_CMAC gco__Measure_x005fPropertyType : public xsd__anyType {
      public:
        __gco__Measure_x005fPropertyType_sequence *__Measure_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__Measure_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__Measure_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Measure_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__Measure_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__Measure_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__Measure_x005fPropertyType() : __Measure_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gco__Measure_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__Measure_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__Measure_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__Measure_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:19538 */
#ifndef SOAP_TYPE_plu__gco__union_Length_x005fPropertyType
#define SOAP_TYPE_plu__gco__union_Length_x005fPropertyType (-1738)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gco__union_Length_x005fPropertyType
{
        #define SOAP_UNION_plu__gco__union_Length_x005fPropertyType_Length	(1)	/**< union variant selector value for member Length */
        gml__LengthType *Length;
        #define SOAP_UNION_plu__gco__union_Length_x005fPropertyType_Distance	(2)	/**< union variant selector value for member Distance */
        gml__LengthType *Distance;
};
#endif

/* PlannedLandUse_v3.0.h:19532 */
#ifndef SOAP_TYPE_plu___gco__Length_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__Length_x005fPropertyType_sequence (-1737)
/* Wrapper: */
class SOAP_CMAC __gco__Length_x005fPropertyType_sequence {
      public:
        /// Union with union _gco__union_Length_x005fPropertyType variant selector __unionLength set to one of: SOAP_UNION_plu__gco__union_Length_x005fPropertyType_Length SOAP_UNION_plu__gco__union_Length_x005fPropertyType_Distance
        int __unionLength;
        union _gco__union_Length_x005fPropertyType union_Length_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__Length_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__Length_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__Length_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__Length_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__Length_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__Length_x005fPropertyType_sequence() : __unionLength() { }
        virtual ~__gco__Length_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__Length_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__Length_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__Length_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2222 */
#ifndef SOAP_TYPE_plu_gco__Length_x005fPropertyType
#define SOAP_TYPE_plu_gco__Length_x005fPropertyType (-695)
/* complex XML schema type 'gco:Length_PropertyType': */
class SOAP_CMAC gco__Length_x005fPropertyType : public xsd__anyType {
      public:
        __gco__Length_x005fPropertyType_sequence *__Length_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__Length_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__Length_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Length_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__Length_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__Length_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__Length_x005fPropertyType() : __Length_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gco__Length_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__Length_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__Length_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__Length_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:19566 */
#ifndef SOAP_TYPE_plu___gco__Angle_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__Angle_x005fPropertyType_sequence (-1740)
/* Wrapper: */
class SOAP_CMAC __gco__Angle_x005fPropertyType_sequence {
      public:
        /// Required element 'gco:Angle' of XML schema type 'gml:AngleType'
        gml__AngleType *Angle;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__Angle_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__Angle_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__Angle_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__Angle_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__Angle_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__Angle_x005fPropertyType_sequence() : Angle() { }
        virtual ~__gco__Angle_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__Angle_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__Angle_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__Angle_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2225 */
#ifndef SOAP_TYPE_plu_gco__Angle_x005fPropertyType
#define SOAP_TYPE_plu_gco__Angle_x005fPropertyType (-696)
/* complex XML schema type 'gco:Angle_PropertyType': */
class SOAP_CMAC gco__Angle_x005fPropertyType : public xsd__anyType {
      public:
        __gco__Angle_x005fPropertyType_sequence *__Angle_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__Angle_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__Angle_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Angle_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__Angle_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__Angle_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__Angle_x005fPropertyType() : __Angle_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gco__Angle_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__Angle_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__Angle_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__Angle_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:19591 */
#ifndef SOAP_TYPE_plu___gco__Scale_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__Scale_x005fPropertyType_sequence (-1742)
/* Wrapper: */
class SOAP_CMAC __gco__Scale_x005fPropertyType_sequence {
      public:
        /// Required element 'gco:Scale' of XML schema type 'gml:ScaleType'
        gml__ScaleType *Scale;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__Scale_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__Scale_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__Scale_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__Scale_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__Scale_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__Scale_x005fPropertyType_sequence() : Scale() { }
        virtual ~__gco__Scale_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__Scale_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__Scale_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__Scale_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2228 */
#ifndef SOAP_TYPE_plu_gco__Scale_x005fPropertyType
#define SOAP_TYPE_plu_gco__Scale_x005fPropertyType (-697)
/* complex XML schema type 'gco:Scale_PropertyType': */
class SOAP_CMAC gco__Scale_x005fPropertyType : public xsd__anyType {
      public:
        __gco__Scale_x005fPropertyType_sequence *__Scale_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__Scale_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__Scale_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Scale_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__Scale_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__Scale_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__Scale_x005fPropertyType() : __Scale_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gco__Scale_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__Scale_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__Scale_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__Scale_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:19616 */
#ifndef SOAP_TYPE_plu___gco__Distance_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__Distance_x005fPropertyType_sequence (-1744)
/* Wrapper: */
class SOAP_CMAC __gco__Distance_x005fPropertyType_sequence {
      public:
        /// Required element 'gco:Distance' of XML schema type 'gml:LengthType'
        gml__LengthType *Distance;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__Distance_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__Distance_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__Distance_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__Distance_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__Distance_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__Distance_x005fPropertyType_sequence() : Distance() { }
        virtual ~__gco__Distance_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__Distance_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__Distance_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__Distance_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2231 */
#ifndef SOAP_TYPE_plu_gco__Distance_x005fPropertyType
#define SOAP_TYPE_plu_gco__Distance_x005fPropertyType (-698)
/* complex XML schema type 'gco:Distance_PropertyType': */
class SOAP_CMAC gco__Distance_x005fPropertyType : public xsd__anyType {
      public:
        __gco__Distance_x005fPropertyType_sequence *__Distance_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__Distance_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__Distance_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Distance_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__Distance_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__Distance_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__Distance_x005fPropertyType() : __Distance_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gco__Distance_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__Distance_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__Distance_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__Distance_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:19647 */
#ifndef SOAP_TYPE_plu__gco__union_CharacterString_x005fPropertyType
#define SOAP_TYPE_plu__gco__union_CharacterString_x005fPropertyType (-1747)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gco__union_CharacterString_x005fPropertyType
{
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_CharacterString	(1)	/**< union variant selector value for member CharacterString */
        std::string *CharacterString;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fPixelOrientationCode	(2)	/**< union variant selector value for member gmd__MD_x005fPixelOrientationCode */
        enum gmd__MD_x005fPixelOrientationCode_x005fType gmd__MD_x005fPixelOrientationCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fTopologyLevelCode	(3)	/**< union variant selector value for member gmd__MD_x005fTopologyLevelCode */
        gco__CodeListValue_x005fType *gmd__MD_x005fTopologyLevelCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fGeometricObjectTypeCode	(4)	/**< union variant selector value for member gmd__MD_x005fGeometricObjectTypeCode */
        gco__CodeListValue_x005fType *gmd__MD_x005fGeometricObjectTypeCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fCellGeometryCode	(5)	/**< union variant selector value for member gmd__MD_x005fCellGeometryCode */
        gco__CodeListValue_x005fType *gmd__MD_x005fCellGeometryCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fDimensionNameTypeCode	(6)	/**< union variant selector value for member gmd__MD_x005fDimensionNameTypeCode */
        gco__CodeListValue_x005fType *gmd__MD_x005fDimensionNameTypeCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__CI_x005fRoleCode	(7)	/**< union variant selector value for member gmd__CI_x005fRoleCode */
        gco__CodeListValue_x005fType *gmd__CI_x005fRoleCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__CI_x005fPresentationFormCode	(8)	/**< union variant selector value for member gmd__CI_x005fPresentationFormCode */
        gco__CodeListValue_x005fType *gmd__CI_x005fPresentationFormCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__CI_x005fOnLineFunctionCode	(9)	/**< union variant selector value for member gmd__CI_x005fOnLineFunctionCode */
        gco__CodeListValue_x005fType *gmd__CI_x005fOnLineFunctionCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__CI_x005fDateTypeCode	(10)	/**< union variant selector value for member gmd__CI_x005fDateTypeCode */
        gco__CodeListValue_x005fType *gmd__CI_x005fDateTypeCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fObligationCode	(11)	/**< union variant selector value for member gmd__MD_x005fObligationCode */
        enum gmd__MD_x005fObligationCode_x005fType gmd__MD_x005fObligationCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fDatatypeCode	(12)	/**< union variant selector value for member gmd__MD_x005fDatatypeCode */
        gco__CodeListValue_x005fType *gmd__MD_x005fDatatypeCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fCoverageContentTypeCode	(13)	/**< union variant selector value for member gmd__MD_x005fCoverageContentTypeCode */
        gco__CodeListValue_x005fType *gmd__MD_x005fCoverageContentTypeCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fImagingConditionCode	(14)	/**< union variant selector value for member gmd__MD_x005fImagingConditionCode */
        gco__CodeListValue_x005fType *gmd__MD_x005fImagingConditionCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__DQ_x005fEvaluationMethodTypeCode	(15)	/**< union variant selector value for member gmd__DQ_x005fEvaluationMethodTypeCode */
        gco__CodeListValue_x005fType *gmd__DQ_x005fEvaluationMethodTypeCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fTopicCategoryCode	(16)	/**< union variant selector value for member gmd__MD_x005fTopicCategoryCode */
        enum gmd__MD_x005fTopicCategoryCode_x005fType gmd__MD_x005fTopicCategoryCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fCharacterSetCode	(17)	/**< union variant selector value for member gmd__MD_x005fCharacterSetCode */
        gco__CodeListValue_x005fType *gmd__MD_x005fCharacterSetCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fSpatialRepresentationTypeCode	(18)	/**< union variant selector value for member gmd__MD_x005fSpatialRepresentationTypeCode */
        gco__CodeListValue_x005fType *gmd__MD_x005fSpatialRepresentationTypeCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fProgressCode	(19)	/**< union variant selector value for member gmd__MD_x005fProgressCode */
        gco__CodeListValue_x005fType *gmd__MD_x005fProgressCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fKeywordTypeCode	(20)	/**< union variant selector value for member gmd__MD_x005fKeywordTypeCode */
        gco__CodeListValue_x005fType *gmd__MD_x005fKeywordTypeCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__DS_x005fAssociationTypeCode	(21)	/**< union variant selector value for member gmd__DS_x005fAssociationTypeCode */
        gco__CodeListValue_x005fType *gmd__DS_x005fAssociationTypeCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__DS_x005fInitiativeTypeCode	(22)	/**< union variant selector value for member gmd__DS_x005fInitiativeTypeCode */
        gco__CodeListValue_x005fType *gmd__DS_x005fInitiativeTypeCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fClassificationCode	(23)	/**< union variant selector value for member gmd__MD_x005fClassificationCode */
        gco__CodeListValue_x005fType *gmd__MD_x005fClassificationCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fRestrictionCode	(24)	/**< union variant selector value for member gmd__MD_x005fRestrictionCode */
        gco__CodeListValue_x005fType *gmd__MD_x005fRestrictionCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fDistributionUnits	(25)	/**< union variant selector value for member gmd__MD_x005fDistributionUnits */
        gco__CodeListValue_x005fType *gmd__MD_x005fDistributionUnits;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fMediumFormatCode	(26)	/**< union variant selector value for member gmd__MD_x005fMediumFormatCode */
        gco__CodeListValue_x005fType *gmd__MD_x005fMediumFormatCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fMediumNameCode	(27)	/**< union variant selector value for member gmd__MD_x005fMediumNameCode */
        gco__CodeListValue_x005fType *gmd__MD_x005fMediumNameCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fMaintenanceFrequencyCode	(28)	/**< union variant selector value for member gmd__MD_x005fMaintenanceFrequencyCode */
        gco__CodeListValue_x005fType *gmd__MD_x005fMaintenanceFrequencyCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fScopeCode	(29)	/**< union variant selector value for member gmd__MD_x005fScopeCode */
        gco__CodeListValue_x005fType *gmd__MD_x005fScopeCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__LocalisedCharacterString	(30)	/**< union variant selector value for member gmd__LocalisedCharacterString */
        gmd__LocalisedCharacterString_x005fType *gmd__LocalisedCharacterString;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__LanguageCode	(31)	/**< union variant selector value for member gmd__LanguageCode */
        gco__CodeListValue_x005fType *gmd__LanguageCode;
        #define SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__Country	(32)	/**< union variant selector value for member gmd__Country */
        gco__CodeListValue_x005fType *gmd__Country;
};
#endif

/* PlannedLandUse_v3.0.h:19641 */
#ifndef SOAP_TYPE_plu___gco__CharacterString_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__CharacterString_x005fPropertyType_sequence (-1746)
/* Wrapper: */
class SOAP_CMAC __gco__CharacterString_x005fPropertyType_sequence {
      public:
        /// Union with union _gco__union_CharacterString_x005fPropertyType variant selector __unionCharacterString set to one of: SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_CharacterString SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fPixelOrientationCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fTopologyLevelCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fGeometricObjectTypeCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fCellGeometryCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fDimensionNameTypeCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__CI_x005fRoleCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__CI_x005fPresentationFormCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__CI_x005fOnLineFunctionCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__CI_x005fDateTypeCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fObligationCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fDatatypeCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fCoverageContentTypeCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fImagingConditionCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__DQ_x005fEvaluationMethodTypeCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fTopicCategoryCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fCharacterSetCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fSpatialRepresentationTypeCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fProgressCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fKeywordTypeCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__DS_x005fAssociationTypeCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__DS_x005fInitiativeTypeCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fClassificationCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fRestrictionCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fDistributionUnits SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fMediumFormatCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fMediumNameCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fMaintenanceFrequencyCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__MD_x005fScopeCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__LocalisedCharacterString SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__LanguageCode SOAP_UNION_plu__gco__union_CharacterString_x005fPropertyType_gmd__Country
        int __unionCharacterString;
        union _gco__union_CharacterString_x005fPropertyType union_CharacterString_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__CharacterString_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__CharacterString_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__CharacterString_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__CharacterString_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__CharacterString_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__CharacterString_x005fPropertyType_sequence() : __unionCharacterString() { }
        virtual ~__gco__CharacterString_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__CharacterString_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__CharacterString_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__CharacterString_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2234 */
#ifndef SOAP_TYPE_plu_gco__CharacterString_x005fPropertyType
#define SOAP_TYPE_plu_gco__CharacterString_x005fPropertyType (-699)
/* complex XML schema type 'gco:CharacterString_PropertyType': */
class SOAP_CMAC gco__CharacterString_x005fPropertyType : public xsd__anyType {
      public:
        __gco__CharacterString_x005fPropertyType_sequence *__CharacterString_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__CharacterString_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__CharacterString_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__CharacterString_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__CharacterString_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__CharacterString_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__CharacterString_x005fPropertyType() : __CharacterString_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gco__CharacterString_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__CharacterString_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__CharacterString_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__CharacterString_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:19797 */
#ifndef SOAP_TYPE_plu___gco__Boolean_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__Boolean_x005fPropertyType_sequence (-1750)
/* Wrapper: */
class SOAP_CMAC __gco__Boolean_x005fPropertyType_sequence {
      public:
        /// Required element 'gco:Boolean' of XML schema type 'xsd:boolean'
        bool Boolean;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__Boolean_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__Boolean_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__Boolean_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__Boolean_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__Boolean_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__Boolean_x005fPropertyType_sequence() : Boolean() { }
        virtual ~__gco__Boolean_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__Boolean_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__Boolean_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__Boolean_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2237 */
#ifndef SOAP_TYPE_plu_gco__Boolean_x005fPropertyType
#define SOAP_TYPE_plu_gco__Boolean_x005fPropertyType (-700)
/* complex XML schema type 'gco:Boolean_PropertyType': */
class SOAP_CMAC gco__Boolean_x005fPropertyType : public xsd__anyType {
      public:
        __gco__Boolean_x005fPropertyType_sequence *__Boolean_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__Boolean_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__Boolean_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Boolean_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__Boolean_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__Boolean_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__Boolean_x005fPropertyType() : __Boolean_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gco__Boolean_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__Boolean_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__Boolean_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__Boolean_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:19829 */
#ifndef SOAP_TYPE_plu__gco__union_GenericName_x005fPropertyType
#define SOAP_TYPE_plu__gco__union_GenericName_x005fPropertyType (-1753)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gco__union_GenericName_x005fPropertyType
{
        #define SOAP_UNION_plu__gco__union_GenericName_x005fPropertyType_LocalName	(1)	/**< union variant selector value for member LocalName */
        gml__CodeType *LocalName;
        #define SOAP_UNION_plu__gco__union_GenericName_x005fPropertyType_ScopedName	(2)	/**< union variant selector value for member ScopedName */
        gml__CodeType *ScopedName;
};
#endif

/* PlannedLandUse_v3.0.h:19822 */
#ifndef SOAP_TYPE_plu___gco__GenericName_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__GenericName_x005fPropertyType_sequence (-1752)
/* Wrapper: */
class SOAP_CMAC __gco__GenericName_x005fPropertyType_sequence {
      public:
        /// Union with union _gco__union_GenericName_x005fPropertyType variant selector __unionAbstractGenericName set to one of: SOAP_UNION_plu__gco__union_GenericName_x005fPropertyType_LocalName SOAP_UNION_plu__gco__union_GenericName_x005fPropertyType_ScopedName
        int __unionAbstractGenericName;
        union _gco__union_GenericName_x005fPropertyType union_GenericName_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__GenericName_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__GenericName_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__GenericName_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__GenericName_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__GenericName_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__GenericName_x005fPropertyType_sequence() : __unionAbstractGenericName() { }
        virtual ~__gco__GenericName_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__GenericName_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__GenericName_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__GenericName_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2240 */
#ifndef SOAP_TYPE_plu_gco__GenericName_x005fPropertyType
#define SOAP_TYPE_plu_gco__GenericName_x005fPropertyType (-701)
/* complex XML schema type 'gco:GenericName_PropertyType': */
class SOAP_CMAC gco__GenericName_x005fPropertyType : public xsd__anyType {
      public:
        __gco__GenericName_x005fPropertyType_sequence *__GenericName_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__GenericName_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__GenericName_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__GenericName_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__GenericName_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__GenericName_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__GenericName_x005fPropertyType() : __GenericName_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gco__GenericName_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__GenericName_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__GenericName_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__GenericName_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:19857 */
#ifndef SOAP_TYPE_plu___gco__LocalName_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__LocalName_x005fPropertyType_sequence (-1755)
/* Wrapper: */
class SOAP_CMAC __gco__LocalName_x005fPropertyType_sequence {
      public:
        /// Required element 'gco:LocalName' of XML schema type 'gml:CodeType'
        gml__CodeType *LocalName;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__LocalName_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__LocalName_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__LocalName_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__LocalName_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__LocalName_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__LocalName_x005fPropertyType_sequence() : LocalName() { }
        virtual ~__gco__LocalName_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__LocalName_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__LocalName_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__LocalName_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2243 */
#ifndef SOAP_TYPE_plu_gco__LocalName_x005fPropertyType
#define SOAP_TYPE_plu_gco__LocalName_x005fPropertyType (-702)
/* complex XML schema type 'gco:LocalName_PropertyType': */
class SOAP_CMAC gco__LocalName_x005fPropertyType : public xsd__anyType {
      public:
        __gco__LocalName_x005fPropertyType_sequence *__LocalName_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__LocalName_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__LocalName_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__LocalName_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__LocalName_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__LocalName_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__LocalName_x005fPropertyType() : __LocalName_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gco__LocalName_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__LocalName_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__LocalName_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__LocalName_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:19882 */
#ifndef SOAP_TYPE_plu___gco__ScopedName_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__ScopedName_x005fPropertyType_sequence (-1757)
/* Wrapper: */
class SOAP_CMAC __gco__ScopedName_x005fPropertyType_sequence {
      public:
        /// Required element 'gco:ScopedName' of XML schema type 'gml:CodeType'
        gml__CodeType *ScopedName;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__ScopedName_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__ScopedName_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__ScopedName_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__ScopedName_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__ScopedName_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__ScopedName_x005fPropertyType_sequence() : ScopedName() { }
        virtual ~__gco__ScopedName_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__ScopedName_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__ScopedName_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__ScopedName_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2246 */
#ifndef SOAP_TYPE_plu_gco__ScopedName_x005fPropertyType
#define SOAP_TYPE_plu_gco__ScopedName_x005fPropertyType (-703)
/* complex XML schema type 'gco:ScopedName_PropertyType': */
class SOAP_CMAC gco__ScopedName_x005fPropertyType : public xsd__anyType {
      public:
        __gco__ScopedName_x005fPropertyType_sequence *__ScopedName_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__ScopedName_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__ScopedName_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__ScopedName_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__ScopedName_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__ScopedName_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__ScopedName_x005fPropertyType() : __ScopedName_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gco__ScopedName_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__ScopedName_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__ScopedName_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__ScopedName_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:19917 */
#ifndef SOAP_TYPE_plu__gco__union_UomAngle_x005fPropertyType
#define SOAP_TYPE_plu__gco__union_UomAngle_x005fPropertyType (-1760)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gco__union_UomAngle_x005fPropertyType
{
        #define SOAP_UNION_plu__gco__union_UomAngle_x005fPropertyType_gml__UnitDefinition	(1)	/**< union variant selector value for member gml__UnitDefinition */
        gml__UnitDefinitionType *gml__UnitDefinition;
        #define SOAP_UNION_plu__gco__union_UomAngle_x005fPropertyType_gml__BaseUnit	(2)	/**< union variant selector value for member gml__BaseUnit */
        gml__BaseUnitType *gml__BaseUnit;
        #define SOAP_UNION_plu__gco__union_UomAngle_x005fPropertyType_gml__DerivedUnit	(3)	/**< union variant selector value for member gml__DerivedUnit */
        gml__DerivedUnitType *gml__DerivedUnit;
        #define SOAP_UNION_plu__gco__union_UomAngle_x005fPropertyType_gml__ConventionalUnit	(4)	/**< union variant selector value for member gml__ConventionalUnit */
        gml__ConventionalUnitType *gml__ConventionalUnit;
};
#endif

/* PlannedLandUse_v3.0.h:19907 */
#ifndef SOAP_TYPE_plu___gco__UomAngle_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__UomAngle_x005fPropertyType_sequence (-1759)
/* Wrapper: */
class SOAP_CMAC __gco__UomAngle_x005fPropertyType_sequence {
      public:
        /// Union with union _gco__union_UomAngle_x005fPropertyType variant selector __unionUnitDefinition set to one of: SOAP_UNION_plu__gco__union_UomAngle_x005fPropertyType_gml__UnitDefinition SOAP_UNION_plu__gco__union_UomAngle_x005fPropertyType_gml__BaseUnit SOAP_UNION_plu__gco__union_UomAngle_x005fPropertyType_gml__DerivedUnit SOAP_UNION_plu__gco__union_UomAngle_x005fPropertyType_gml__ConventionalUnit
        int __unionUnitDefinition;
        union _gco__union_UomAngle_x005fPropertyType union_UomAngle_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__UomAngle_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__UomAngle_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__UomAngle_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__UomAngle_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__UomAngle_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__UomAngle_x005fPropertyType_sequence() : __unionUnitDefinition() { }
        virtual ~__gco__UomAngle_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__UomAngle_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__UomAngle_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__UomAngle_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2249 */
#ifndef SOAP_TYPE_plu_gco__UomAngle_x005fPropertyType
#define SOAP_TYPE_plu_gco__UomAngle_x005fPropertyType (-704)
/* complex XML schema type 'gco:UomAngle_PropertyType': */
class SOAP_CMAC gco__UomAngle_x005fPropertyType : public xsd__anyType {
      public:
        __gco__UomAngle_x005fPropertyType_sequence *__UomAngle_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__UomAngle_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__UomAngle_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__UomAngle_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__UomAngle_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__UomAngle_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__UomAngle_x005fPropertyType() : __UomAngle_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gco__UomAngle_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__UomAngle_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__UomAngle_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__UomAngle_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:19995 */
#ifndef SOAP_TYPE_plu__gco__union_UomLength_x005fPropertyType
#define SOAP_TYPE_plu__gco__union_UomLength_x005fPropertyType (-1767)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gco__union_UomLength_x005fPropertyType
{
        #define SOAP_UNION_plu__gco__union_UomLength_x005fPropertyType_gml__UnitDefinition	(1)	/**< union variant selector value for member gml__UnitDefinition */
        gml__UnitDefinitionType *gml__UnitDefinition;
        #define SOAP_UNION_plu__gco__union_UomLength_x005fPropertyType_gml__BaseUnit	(2)	/**< union variant selector value for member gml__BaseUnit */
        gml__BaseUnitType *gml__BaseUnit;
        #define SOAP_UNION_plu__gco__union_UomLength_x005fPropertyType_gml__DerivedUnit	(3)	/**< union variant selector value for member gml__DerivedUnit */
        gml__DerivedUnitType *gml__DerivedUnit;
        #define SOAP_UNION_plu__gco__union_UomLength_x005fPropertyType_gml__ConventionalUnit	(4)	/**< union variant selector value for member gml__ConventionalUnit */
        gml__ConventionalUnitType *gml__ConventionalUnit;
};
#endif

/* PlannedLandUse_v3.0.h:19985 */
#ifndef SOAP_TYPE_plu___gco__UomLength_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__UomLength_x005fPropertyType_sequence (-1766)
/* Wrapper: */
class SOAP_CMAC __gco__UomLength_x005fPropertyType_sequence {
      public:
        /// Union with union _gco__union_UomLength_x005fPropertyType variant selector __unionUnitDefinition set to one of: SOAP_UNION_plu__gco__union_UomLength_x005fPropertyType_gml__UnitDefinition SOAP_UNION_plu__gco__union_UomLength_x005fPropertyType_gml__BaseUnit SOAP_UNION_plu__gco__union_UomLength_x005fPropertyType_gml__DerivedUnit SOAP_UNION_plu__gco__union_UomLength_x005fPropertyType_gml__ConventionalUnit
        int __unionUnitDefinition;
        union _gco__union_UomLength_x005fPropertyType union_UomLength_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__UomLength_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__UomLength_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__UomLength_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__UomLength_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__UomLength_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__UomLength_x005fPropertyType_sequence() : __unionUnitDefinition() { }
        virtual ~__gco__UomLength_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__UomLength_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__UomLength_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__UomLength_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2252 */
#ifndef SOAP_TYPE_plu_gco__UomLength_x005fPropertyType
#define SOAP_TYPE_plu_gco__UomLength_x005fPropertyType (-705)
/* complex XML schema type 'gco:UomLength_PropertyType': */
class SOAP_CMAC gco__UomLength_x005fPropertyType : public xsd__anyType {
      public:
        __gco__UomLength_x005fPropertyType_sequence *__UomLength_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__UomLength_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__UomLength_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__UomLength_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__UomLength_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__UomLength_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__UomLength_x005fPropertyType() : __UomLength_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gco__UomLength_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__UomLength_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__UomLength_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__UomLength_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:20073 */
#ifndef SOAP_TYPE_plu__gco__union_UomScale_x005fPropertyType
#define SOAP_TYPE_plu__gco__union_UomScale_x005fPropertyType (-1770)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gco__union_UomScale_x005fPropertyType
{
        #define SOAP_UNION_plu__gco__union_UomScale_x005fPropertyType_gml__UnitDefinition	(1)	/**< union variant selector value for member gml__UnitDefinition */
        gml__UnitDefinitionType *gml__UnitDefinition;
        #define SOAP_UNION_plu__gco__union_UomScale_x005fPropertyType_gml__BaseUnit	(2)	/**< union variant selector value for member gml__BaseUnit */
        gml__BaseUnitType *gml__BaseUnit;
        #define SOAP_UNION_plu__gco__union_UomScale_x005fPropertyType_gml__DerivedUnit	(3)	/**< union variant selector value for member gml__DerivedUnit */
        gml__DerivedUnitType *gml__DerivedUnit;
        #define SOAP_UNION_plu__gco__union_UomScale_x005fPropertyType_gml__ConventionalUnit	(4)	/**< union variant selector value for member gml__ConventionalUnit */
        gml__ConventionalUnitType *gml__ConventionalUnit;
};
#endif

/* PlannedLandUse_v3.0.h:20063 */
#ifndef SOAP_TYPE_plu___gco__UomScale_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__UomScale_x005fPropertyType_sequence (-1769)
/* Wrapper: */
class SOAP_CMAC __gco__UomScale_x005fPropertyType_sequence {
      public:
        /// Union with union _gco__union_UomScale_x005fPropertyType variant selector __unionUnitDefinition set to one of: SOAP_UNION_plu__gco__union_UomScale_x005fPropertyType_gml__UnitDefinition SOAP_UNION_plu__gco__union_UomScale_x005fPropertyType_gml__BaseUnit SOAP_UNION_plu__gco__union_UomScale_x005fPropertyType_gml__DerivedUnit SOAP_UNION_plu__gco__union_UomScale_x005fPropertyType_gml__ConventionalUnit
        int __unionUnitDefinition;
        union _gco__union_UomScale_x005fPropertyType union_UomScale_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__UomScale_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__UomScale_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__UomScale_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__UomScale_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__UomScale_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__UomScale_x005fPropertyType_sequence() : __unionUnitDefinition() { }
        virtual ~__gco__UomScale_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__UomScale_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__UomScale_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__UomScale_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2255 */
#ifndef SOAP_TYPE_plu_gco__UomScale_x005fPropertyType
#define SOAP_TYPE_plu_gco__UomScale_x005fPropertyType (-706)
/* complex XML schema type 'gco:UomScale_PropertyType': */
class SOAP_CMAC gco__UomScale_x005fPropertyType : public xsd__anyType {
      public:
        __gco__UomScale_x005fPropertyType_sequence *__UomScale_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__UomScale_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__UomScale_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__UomScale_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__UomScale_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__UomScale_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__UomScale_x005fPropertyType() : __UomScale_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gco__UomScale_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__UomScale_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__UomScale_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__UomScale_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:20151 */
#ifndef SOAP_TYPE_plu__gco__union_UnitOfMeasure_x005fPropertyType
#define SOAP_TYPE_plu__gco__union_UnitOfMeasure_x005fPropertyType (-1773)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gco__union_UnitOfMeasure_x005fPropertyType
{
        #define SOAP_UNION_plu__gco__union_UnitOfMeasure_x005fPropertyType_gml__UnitDefinition	(1)	/**< union variant selector value for member gml__UnitDefinition */
        gml__UnitDefinitionType *gml__UnitDefinition;
        #define SOAP_UNION_plu__gco__union_UnitOfMeasure_x005fPropertyType_gml__BaseUnit	(2)	/**< union variant selector value for member gml__BaseUnit */
        gml__BaseUnitType *gml__BaseUnit;
        #define SOAP_UNION_plu__gco__union_UnitOfMeasure_x005fPropertyType_gml__DerivedUnit	(3)	/**< union variant selector value for member gml__DerivedUnit */
        gml__DerivedUnitType *gml__DerivedUnit;
        #define SOAP_UNION_plu__gco__union_UnitOfMeasure_x005fPropertyType_gml__ConventionalUnit	(4)	/**< union variant selector value for member gml__ConventionalUnit */
        gml__ConventionalUnitType *gml__ConventionalUnit;
};
#endif

/* PlannedLandUse_v3.0.h:20141 */
#ifndef SOAP_TYPE_plu___gco__UnitOfMeasure_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__UnitOfMeasure_x005fPropertyType_sequence (-1772)
/* Wrapper: */
class SOAP_CMAC __gco__UnitOfMeasure_x005fPropertyType_sequence {
      public:
        /// Union with union _gco__union_UnitOfMeasure_x005fPropertyType variant selector __unionUnitDefinition set to one of: SOAP_UNION_plu__gco__union_UnitOfMeasure_x005fPropertyType_gml__UnitDefinition SOAP_UNION_plu__gco__union_UnitOfMeasure_x005fPropertyType_gml__BaseUnit SOAP_UNION_plu__gco__union_UnitOfMeasure_x005fPropertyType_gml__DerivedUnit SOAP_UNION_plu__gco__union_UnitOfMeasure_x005fPropertyType_gml__ConventionalUnit
        int __unionUnitDefinition;
        union _gco__union_UnitOfMeasure_x005fPropertyType union_UnitOfMeasure_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__UnitOfMeasure_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__UnitOfMeasure_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__UnitOfMeasure_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__UnitOfMeasure_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__UnitOfMeasure_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__UnitOfMeasure_x005fPropertyType_sequence() : __unionUnitDefinition() { }
        virtual ~__gco__UnitOfMeasure_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__UnitOfMeasure_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__UnitOfMeasure_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__UnitOfMeasure_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2258 */
#ifndef SOAP_TYPE_plu_gco__UnitOfMeasure_x005fPropertyType
#define SOAP_TYPE_plu_gco__UnitOfMeasure_x005fPropertyType (-707)
/* complex XML schema type 'gco:UnitOfMeasure_PropertyType': */
class SOAP_CMAC gco__UnitOfMeasure_x005fPropertyType : public xsd__anyType {
      public:
        __gco__UnitOfMeasure_x005fPropertyType_sequence *__UnitOfMeasure_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__UnitOfMeasure_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__UnitOfMeasure_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__UnitOfMeasure_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__UnitOfMeasure_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__UnitOfMeasure_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__UnitOfMeasure_x005fPropertyType() : __UnitOfMeasure_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gco__UnitOfMeasure_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__UnitOfMeasure_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__UnitOfMeasure_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__UnitOfMeasure_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:20229 */
#ifndef SOAP_TYPE_plu__gco__union_UomArea_x005fPropertyType
#define SOAP_TYPE_plu__gco__union_UomArea_x005fPropertyType (-1776)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gco__union_UomArea_x005fPropertyType
{
        #define SOAP_UNION_plu__gco__union_UomArea_x005fPropertyType_gml__UnitDefinition	(1)	/**< union variant selector value for member gml__UnitDefinition */
        gml__UnitDefinitionType *gml__UnitDefinition;
        #define SOAP_UNION_plu__gco__union_UomArea_x005fPropertyType_gml__BaseUnit	(2)	/**< union variant selector value for member gml__BaseUnit */
        gml__BaseUnitType *gml__BaseUnit;
        #define SOAP_UNION_plu__gco__union_UomArea_x005fPropertyType_gml__DerivedUnit	(3)	/**< union variant selector value for member gml__DerivedUnit */
        gml__DerivedUnitType *gml__DerivedUnit;
        #define SOAP_UNION_plu__gco__union_UomArea_x005fPropertyType_gml__ConventionalUnit	(4)	/**< union variant selector value for member gml__ConventionalUnit */
        gml__ConventionalUnitType *gml__ConventionalUnit;
};
#endif

/* PlannedLandUse_v3.0.h:20219 */
#ifndef SOAP_TYPE_plu___gco__UomArea_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__UomArea_x005fPropertyType_sequence (-1775)
/* Wrapper: */
class SOAP_CMAC __gco__UomArea_x005fPropertyType_sequence {
      public:
        /// Union with union _gco__union_UomArea_x005fPropertyType variant selector __unionUnitDefinition set to one of: SOAP_UNION_plu__gco__union_UomArea_x005fPropertyType_gml__UnitDefinition SOAP_UNION_plu__gco__union_UomArea_x005fPropertyType_gml__BaseUnit SOAP_UNION_plu__gco__union_UomArea_x005fPropertyType_gml__DerivedUnit SOAP_UNION_plu__gco__union_UomArea_x005fPropertyType_gml__ConventionalUnit
        int __unionUnitDefinition;
        union _gco__union_UomArea_x005fPropertyType union_UomArea_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__UomArea_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__UomArea_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__UomArea_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__UomArea_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__UomArea_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__UomArea_x005fPropertyType_sequence() : __unionUnitDefinition() { }
        virtual ~__gco__UomArea_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__UomArea_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__UomArea_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__UomArea_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2261 */
#ifndef SOAP_TYPE_plu_gco__UomArea_x005fPropertyType
#define SOAP_TYPE_plu_gco__UomArea_x005fPropertyType (-708)
/* complex XML schema type 'gco:UomArea_PropertyType': */
class SOAP_CMAC gco__UomArea_x005fPropertyType : public xsd__anyType {
      public:
        __gco__UomArea_x005fPropertyType_sequence *__UomArea_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__UomArea_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__UomArea_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__UomArea_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__UomArea_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__UomArea_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__UomArea_x005fPropertyType() : __UomArea_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gco__UomArea_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__UomArea_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__UomArea_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__UomArea_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:20307 */
#ifndef SOAP_TYPE_plu__gco__union_UomVelocity_x005fPropertyType
#define SOAP_TYPE_plu__gco__union_UomVelocity_x005fPropertyType (-1779)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gco__union_UomVelocity_x005fPropertyType
{
        #define SOAP_UNION_plu__gco__union_UomVelocity_x005fPropertyType_gml__UnitDefinition	(1)	/**< union variant selector value for member gml__UnitDefinition */
        gml__UnitDefinitionType *gml__UnitDefinition;
        #define SOAP_UNION_plu__gco__union_UomVelocity_x005fPropertyType_gml__BaseUnit	(2)	/**< union variant selector value for member gml__BaseUnit */
        gml__BaseUnitType *gml__BaseUnit;
        #define SOAP_UNION_plu__gco__union_UomVelocity_x005fPropertyType_gml__DerivedUnit	(3)	/**< union variant selector value for member gml__DerivedUnit */
        gml__DerivedUnitType *gml__DerivedUnit;
        #define SOAP_UNION_plu__gco__union_UomVelocity_x005fPropertyType_gml__ConventionalUnit	(4)	/**< union variant selector value for member gml__ConventionalUnit */
        gml__ConventionalUnitType *gml__ConventionalUnit;
};
#endif

/* PlannedLandUse_v3.0.h:20297 */
#ifndef SOAP_TYPE_plu___gco__UomVelocity_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__UomVelocity_x005fPropertyType_sequence (-1778)
/* Wrapper: */
class SOAP_CMAC __gco__UomVelocity_x005fPropertyType_sequence {
      public:
        /// Union with union _gco__union_UomVelocity_x005fPropertyType variant selector __unionUnitDefinition set to one of: SOAP_UNION_plu__gco__union_UomVelocity_x005fPropertyType_gml__UnitDefinition SOAP_UNION_plu__gco__union_UomVelocity_x005fPropertyType_gml__BaseUnit SOAP_UNION_plu__gco__union_UomVelocity_x005fPropertyType_gml__DerivedUnit SOAP_UNION_plu__gco__union_UomVelocity_x005fPropertyType_gml__ConventionalUnit
        int __unionUnitDefinition;
        union _gco__union_UomVelocity_x005fPropertyType union_UomVelocity_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__UomVelocity_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__UomVelocity_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__UomVelocity_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__UomVelocity_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__UomVelocity_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__UomVelocity_x005fPropertyType_sequence() : __unionUnitDefinition() { }
        virtual ~__gco__UomVelocity_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__UomVelocity_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__UomVelocity_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__UomVelocity_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2264 */
#ifndef SOAP_TYPE_plu_gco__UomVelocity_x005fPropertyType
#define SOAP_TYPE_plu_gco__UomVelocity_x005fPropertyType (-709)
/* complex XML schema type 'gco:UomVelocity_PropertyType': */
class SOAP_CMAC gco__UomVelocity_x005fPropertyType : public xsd__anyType {
      public:
        __gco__UomVelocity_x005fPropertyType_sequence *__UomVelocity_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__UomVelocity_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__UomVelocity_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__UomVelocity_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__UomVelocity_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__UomVelocity_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__UomVelocity_x005fPropertyType() : __UomVelocity_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gco__UomVelocity_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__UomVelocity_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__UomVelocity_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__UomVelocity_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:20385 */
#ifndef SOAP_TYPE_plu__gco__union_UomTime_x005fPropertyType
#define SOAP_TYPE_plu__gco__union_UomTime_x005fPropertyType (-1782)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gco__union_UomTime_x005fPropertyType
{
        #define SOAP_UNION_plu__gco__union_UomTime_x005fPropertyType_gml__UnitDefinition	(1)	/**< union variant selector value for member gml__UnitDefinition */
        gml__UnitDefinitionType *gml__UnitDefinition;
        #define SOAP_UNION_plu__gco__union_UomTime_x005fPropertyType_gml__BaseUnit	(2)	/**< union variant selector value for member gml__BaseUnit */
        gml__BaseUnitType *gml__BaseUnit;
        #define SOAP_UNION_plu__gco__union_UomTime_x005fPropertyType_gml__DerivedUnit	(3)	/**< union variant selector value for member gml__DerivedUnit */
        gml__DerivedUnitType *gml__DerivedUnit;
        #define SOAP_UNION_plu__gco__union_UomTime_x005fPropertyType_gml__ConventionalUnit	(4)	/**< union variant selector value for member gml__ConventionalUnit */
        gml__ConventionalUnitType *gml__ConventionalUnit;
};
#endif

/* PlannedLandUse_v3.0.h:20375 */
#ifndef SOAP_TYPE_plu___gco__UomTime_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__UomTime_x005fPropertyType_sequence (-1781)
/* Wrapper: */
class SOAP_CMAC __gco__UomTime_x005fPropertyType_sequence {
      public:
        /// Union with union _gco__union_UomTime_x005fPropertyType variant selector __unionUnitDefinition set to one of: SOAP_UNION_plu__gco__union_UomTime_x005fPropertyType_gml__UnitDefinition SOAP_UNION_plu__gco__union_UomTime_x005fPropertyType_gml__BaseUnit SOAP_UNION_plu__gco__union_UomTime_x005fPropertyType_gml__DerivedUnit SOAP_UNION_plu__gco__union_UomTime_x005fPropertyType_gml__ConventionalUnit
        int __unionUnitDefinition;
        union _gco__union_UomTime_x005fPropertyType union_UomTime_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__UomTime_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__UomTime_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__UomTime_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__UomTime_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__UomTime_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__UomTime_x005fPropertyType_sequence() : __unionUnitDefinition() { }
        virtual ~__gco__UomTime_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__UomTime_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__UomTime_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__UomTime_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2267 */
#ifndef SOAP_TYPE_plu_gco__UomTime_x005fPropertyType
#define SOAP_TYPE_plu_gco__UomTime_x005fPropertyType (-710)
/* complex XML schema type 'gco:UomTime_PropertyType': */
class SOAP_CMAC gco__UomTime_x005fPropertyType : public xsd__anyType {
      public:
        __gco__UomTime_x005fPropertyType_sequence *__UomTime_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__UomTime_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__UomTime_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__UomTime_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__UomTime_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__UomTime_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__UomTime_x005fPropertyType() : __UomTime_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gco__UomTime_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__UomTime_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__UomTime_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__UomTime_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:20463 */
#ifndef SOAP_TYPE_plu__gco__union_UomVolume_x005fPropertyType
#define SOAP_TYPE_plu__gco__union_UomVolume_x005fPropertyType (-1785)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gco__union_UomVolume_x005fPropertyType
{
        #define SOAP_UNION_plu__gco__union_UomVolume_x005fPropertyType_gml__UnitDefinition	(1)	/**< union variant selector value for member gml__UnitDefinition */
        gml__UnitDefinitionType *gml__UnitDefinition;
        #define SOAP_UNION_plu__gco__union_UomVolume_x005fPropertyType_gml__BaseUnit	(2)	/**< union variant selector value for member gml__BaseUnit */
        gml__BaseUnitType *gml__BaseUnit;
        #define SOAP_UNION_plu__gco__union_UomVolume_x005fPropertyType_gml__DerivedUnit	(3)	/**< union variant selector value for member gml__DerivedUnit */
        gml__DerivedUnitType *gml__DerivedUnit;
        #define SOAP_UNION_plu__gco__union_UomVolume_x005fPropertyType_gml__ConventionalUnit	(4)	/**< union variant selector value for member gml__ConventionalUnit */
        gml__ConventionalUnitType *gml__ConventionalUnit;
};
#endif

/* PlannedLandUse_v3.0.h:20453 */
#ifndef SOAP_TYPE_plu___gco__UomVolume_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__UomVolume_x005fPropertyType_sequence (-1784)
/* Wrapper: */
class SOAP_CMAC __gco__UomVolume_x005fPropertyType_sequence {
      public:
        /// Union with union _gco__union_UomVolume_x005fPropertyType variant selector __unionUnitDefinition set to one of: SOAP_UNION_plu__gco__union_UomVolume_x005fPropertyType_gml__UnitDefinition SOAP_UNION_plu__gco__union_UomVolume_x005fPropertyType_gml__BaseUnit SOAP_UNION_plu__gco__union_UomVolume_x005fPropertyType_gml__DerivedUnit SOAP_UNION_plu__gco__union_UomVolume_x005fPropertyType_gml__ConventionalUnit
        int __unionUnitDefinition;
        union _gco__union_UomVolume_x005fPropertyType union_UomVolume_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__UomVolume_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__UomVolume_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__UomVolume_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__UomVolume_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__UomVolume_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__UomVolume_x005fPropertyType_sequence() : __unionUnitDefinition() { }
        virtual ~__gco__UomVolume_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__UomVolume_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__UomVolume_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__UomVolume_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2270 */
#ifndef SOAP_TYPE_plu_gco__UomVolume_x005fPropertyType
#define SOAP_TYPE_plu_gco__UomVolume_x005fPropertyType (-711)
/* complex XML schema type 'gco:UomVolume_PropertyType': */
class SOAP_CMAC gco__UomVolume_x005fPropertyType : public xsd__anyType {
      public:
        __gco__UomVolume_x005fPropertyType_sequence *__UomVolume_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__UomVolume_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__UomVolume_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__UomVolume_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__UomVolume_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__UomVolume_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__UomVolume_x005fPropertyType() : __UomVolume_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gco__UomVolume_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__UomVolume_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__UomVolume_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__UomVolume_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:20531 */
#ifndef SOAP_TYPE_plu___gco__DateTime_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__DateTime_x005fPropertyType_sequence (-1787)
/* Wrapper: */
class SOAP_CMAC __gco__DateTime_x005fPropertyType_sequence {
      public:
        /// Required element 'gco:DateTime' of XML schema type 'xsd:dateTime'
        time_t DateTime;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__DateTime_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__DateTime_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__DateTime_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__DateTime_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__DateTime_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__DateTime_x005fPropertyType_sequence() : DateTime() { }
        virtual ~__gco__DateTime_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__DateTime_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__DateTime_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__DateTime_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2273 */
#ifndef SOAP_TYPE_plu_gco__DateTime_x005fPropertyType
#define SOAP_TYPE_plu_gco__DateTime_x005fPropertyType (-712)
/* complex XML schema type 'gco:DateTime_PropertyType': */
class SOAP_CMAC gco__DateTime_x005fPropertyType : public xsd__anyType {
      public:
        __gco__DateTime_x005fPropertyType_sequence *__DateTime_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__DateTime_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__DateTime_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__DateTime_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__DateTime_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__DateTime_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__DateTime_x005fPropertyType() : __DateTime_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gco__DateTime_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__DateTime_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__DateTime_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__DateTime_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:20559 */
#ifndef SOAP_TYPE_plu__gco__union_Date_x005fPropertyType
#define SOAP_TYPE_plu__gco__union_Date_x005fPropertyType (-1789)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gco__union_Date_x005fPropertyType
{
        #define SOAP_UNION_plu__gco__union_Date_x005fPropertyType_Date	(1)	/**< union variant selector value for member Date */
        std::string *Date;
        #define SOAP_UNION_plu__gco__union_Date_x005fPropertyType_DateTime	(2)	/**< union variant selector value for member DateTime */
        time_t DateTime;
};
#endif

/* PlannedLandUse_v3.0.h:2276 */
#ifndef SOAP_TYPE_plu_gco__Date_x005fPropertyType
#define SOAP_TYPE_plu_gco__Date_x005fPropertyType (-713)
/* complex XML schema type 'gco:Date_PropertyType': */
class SOAP_CMAC gco__Date_x005fPropertyType : public xsd__anyType {
      public:
        /// Union with union _gco__union_Date_x005fPropertyType variant selector __union_Date_x005fPropertyType set to one of: SOAP_UNION_plu__gco__union_Date_x005fPropertyType_Date SOAP_UNION_plu__gco__union_Date_x005fPropertyType_DateTime
        int __union_Date_x005fPropertyType;
        union _gco__union_Date_x005fPropertyType union_Date_x005fPropertyType;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__Date_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__Date_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Date_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__Date_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__Date_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__Date_x005fPropertyType() : __union_Date_x005fPropertyType(), gco__nilReason() { }
        virtual ~gco__Date_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__Date_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__Date_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__Date_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:20588 */
#ifndef SOAP_TYPE_plu__gco__union_Number_x005fPropertyType
#define SOAP_TYPE_plu__gco__union_Number_x005fPropertyType (-1791)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gco__union_Number_x005fPropertyType
{
        #define SOAP_UNION_plu__gco__union_Number_x005fPropertyType_Real	(1)	/**< union variant selector value for member Real */
        double Real;
        #define SOAP_UNION_plu__gco__union_Number_x005fPropertyType_Decimal	(2)	/**< union variant selector value for member Decimal */
        double *Decimal;
        #define SOAP_UNION_plu__gco__union_Number_x005fPropertyType_Integer	(3)	/**< union variant selector value for member Integer */
        long Integer;
};
#endif

/* PlannedLandUse_v3.0.h:2279 */
#ifndef SOAP_TYPE_plu_gco__Number_x005fPropertyType
#define SOAP_TYPE_plu_gco__Number_x005fPropertyType (-714)
/* complex XML schema type 'gco:Number_PropertyType': */
class SOAP_CMAC gco__Number_x005fPropertyType : public xsd__anyType {
      public:
        /// Union with union _gco__union_Number_x005fPropertyType variant selector __union_Number_x005fPropertyType set to one of: SOAP_UNION_plu__gco__union_Number_x005fPropertyType_Real SOAP_UNION_plu__gco__union_Number_x005fPropertyType_Decimal SOAP_UNION_plu__gco__union_Number_x005fPropertyType_Integer
        int __union_Number_x005fPropertyType;
        union _gco__union_Number_x005fPropertyType union_Number_x005fPropertyType;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__Number_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__Number_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Number_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__Number_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__Number_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__Number_x005fPropertyType() : __union_Number_x005fPropertyType(), gco__nilReason() { }
        virtual ~gco__Number_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__Number_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__Number_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__Number_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:20616 */
#ifndef SOAP_TYPE_plu___gco__Decimal_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__Decimal_x005fPropertyType_sequence (-1793)
/* Wrapper: */
class SOAP_CMAC __gco__Decimal_x005fPropertyType_sequence {
      public:
        /// Required element 'gco:Decimal' of XML schema type 'xsd:decimal'
        double Decimal;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__Decimal_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__Decimal_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__Decimal_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__Decimal_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__Decimal_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__Decimal_x005fPropertyType_sequence() : Decimal() { }
        virtual ~__gco__Decimal_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__Decimal_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__Decimal_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__Decimal_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2282 */
#ifndef SOAP_TYPE_plu_gco__Decimal_x005fPropertyType
#define SOAP_TYPE_plu_gco__Decimal_x005fPropertyType (-715)
/* complex XML schema type 'gco:Decimal_PropertyType': */
class SOAP_CMAC gco__Decimal_x005fPropertyType : public xsd__anyType {
      public:
        __gco__Decimal_x005fPropertyType_sequence *__Decimal_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__Decimal_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__Decimal_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Decimal_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__Decimal_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__Decimal_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__Decimal_x005fPropertyType() : __Decimal_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gco__Decimal_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__Decimal_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__Decimal_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__Decimal_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:20641 */
#ifndef SOAP_TYPE_plu___gco__Real_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__Real_x005fPropertyType_sequence (-1795)
/* Wrapper: */
class SOAP_CMAC __gco__Real_x005fPropertyType_sequence {
      public:
        /// Required element 'gco:Real' of XML schema type 'xsd:double'
        double Real;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__Real_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__Real_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__Real_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__Real_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__Real_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__Real_x005fPropertyType_sequence() : Real() { }
        virtual ~__gco__Real_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__Real_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__Real_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__Real_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2285 */
#ifndef SOAP_TYPE_plu_gco__Real_x005fPropertyType
#define SOAP_TYPE_plu_gco__Real_x005fPropertyType (-716)
/* complex XML schema type 'gco:Real_PropertyType': */
class SOAP_CMAC gco__Real_x005fPropertyType : public xsd__anyType {
      public:
        __gco__Real_x005fPropertyType_sequence *__Real_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__Real_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__Real_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Real_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__Real_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__Real_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__Real_x005fPropertyType() : __Real_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gco__Real_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__Real_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__Real_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__Real_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:20666 */
#ifndef SOAP_TYPE_plu___gco__Integer_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__Integer_x005fPropertyType_sequence (-1797)
/* Wrapper: */
class SOAP_CMAC __gco__Integer_x005fPropertyType_sequence {
      public:
        /// Required element 'gco:Integer' of XML schema type 'xsd:long'
        long Integer;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__Integer_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__Integer_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__Integer_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__Integer_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__Integer_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__Integer_x005fPropertyType_sequence() : Integer() { }
        virtual ~__gco__Integer_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__Integer_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__Integer_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__Integer_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2288 */
#ifndef SOAP_TYPE_plu_gco__Integer_x005fPropertyType
#define SOAP_TYPE_plu_gco__Integer_x005fPropertyType (-717)
/* complex XML schema type 'gco:Integer_PropertyType': */
class SOAP_CMAC gco__Integer_x005fPropertyType : public xsd__anyType {
      public:
        __gco__Integer_x005fPropertyType_sequence *__Integer_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__Integer_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__Integer_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Integer_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__Integer_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__Integer_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__Integer_x005fPropertyType() : __Integer_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gco__Integer_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__Integer_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__Integer_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__Integer_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:20691 */
#ifndef SOAP_TYPE_plu___gco__UnlimitedInteger_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__UnlimitedInteger_x005fPropertyType_sequence (-1799)
/* Wrapper: */
class SOAP_CMAC __gco__UnlimitedInteger_x005fPropertyType_sequence {
      public:
        /// Required element 'gco:UnlimitedInteger' of XML schema type 'gco:UnlimitedInteger_Type'
        gco__UnlimitedInteger_x005fType *UnlimitedInteger;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__UnlimitedInteger_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__UnlimitedInteger_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__UnlimitedInteger_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__UnlimitedInteger_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__UnlimitedInteger_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__UnlimitedInteger_x005fPropertyType_sequence() : UnlimitedInteger() { }
        virtual ~__gco__UnlimitedInteger_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__UnlimitedInteger_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__UnlimitedInteger_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__UnlimitedInteger_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2294 */
#ifndef SOAP_TYPE_plu_gco__UnlimitedInteger_x005fPropertyType
#define SOAP_TYPE_plu_gco__UnlimitedInteger_x005fPropertyType (-719)
/* complex XML schema type 'gco:UnlimitedInteger_PropertyType': */
class SOAP_CMAC gco__UnlimitedInteger_x005fPropertyType : public xsd__anyType {
      public:
        __gco__UnlimitedInteger_x005fPropertyType_sequence *__UnlimitedInteger_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__UnlimitedInteger_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__UnlimitedInteger_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__UnlimitedInteger_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__UnlimitedInteger_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__UnlimitedInteger_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__UnlimitedInteger_x005fPropertyType() : __UnlimitedInteger_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gco__UnlimitedInteger_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__UnlimitedInteger_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__UnlimitedInteger_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__UnlimitedInteger_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:20716 */
#ifndef SOAP_TYPE_plu___gco__Record_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__Record_x005fPropertyType_sequence (-1802)
/* Wrapper: */
class SOAP_CMAC __gco__Record_x005fPropertyType_sequence {
      public:
        /// Required element 'gco:Record' of XML schema type 'xsd:anyType'
        char *Record;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__Record_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__Record_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__Record_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__Record_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__Record_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__Record_x005fPropertyType_sequence() : Record() { }
        virtual ~__gco__Record_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__Record_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__Record_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__Record_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2297 */
#ifndef SOAP_TYPE_plu_gco__Record_x005fPropertyType
#define SOAP_TYPE_plu_gco__Record_x005fPropertyType (-720)
/* complex XML schema type 'gco:Record_PropertyType': */
class SOAP_CMAC gco__Record_x005fPropertyType : public xsd__anyType {
      public:
        __gco__Record_x005fPropertyType_sequence *__Record_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__Record_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__Record_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Record_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__Record_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__Record_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__Record_x005fPropertyType() : __Record_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gco__Record_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__Record_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__Record_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__Record_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:20761 */
#ifndef SOAP_TYPE_plu___gco__RecordType_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__RecordType_x005fPropertyType_sequence (-1804)
/* Wrapper: */
class SOAP_CMAC __gco__RecordType_x005fPropertyType_sequence {
      public:
        /// Required element 'gco:RecordType' of XML schema type 'gco:RecordType_Type'
        gco__RecordType_x005fType *RecordType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__RecordType_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__RecordType_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__RecordType_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__RecordType_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__RecordType_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__RecordType_x005fPropertyType_sequence() : RecordType() { }
        virtual ~__gco__RecordType_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__RecordType_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__RecordType_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__RecordType_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2303 */
#ifndef SOAP_TYPE_plu_gco__RecordType_x005fPropertyType
#define SOAP_TYPE_plu_gco__RecordType_x005fPropertyType (-722)
/* complex XML schema type 'gco:RecordType_PropertyType': */
class SOAP_CMAC gco__RecordType_x005fPropertyType : public xsd__anyType {
      public:
        __gco__RecordType_x005fPropertyType_sequence *__RecordType_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__RecordType_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__RecordType_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__RecordType_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__RecordType_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__RecordType_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__RecordType_x005fPropertyType() : __RecordType_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gco__RecordType_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__RecordType_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__RecordType_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__RecordType_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:20786 */
#ifndef SOAP_TYPE_plu___gco__Binary_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gco__Binary_x005fPropertyType_sequence (-1807)
/* Wrapper: */
class SOAP_CMAC __gco__Binary_x005fPropertyType_sequence {
      public:
        /// Required element 'gco:Binary' of XML schema type 'gco:Binary_Type'
        gco__Binary_x005fType *Binary;
      public:
        /// Return unique type id SOAP_TYPE_plu___gco__Binary_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gco__Binary_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__Binary_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__Binary_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gco__Binary_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gco__Binary_x005fPropertyType_sequence() : Binary() { }
        virtual ~__gco__Binary_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__Binary_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__Binary_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__Binary_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2309 */
#ifndef SOAP_TYPE_plu_gco__Binary_x005fPropertyType
#define SOAP_TYPE_plu_gco__Binary_x005fPropertyType (-724)
/* complex XML schema type 'gco:Binary_PropertyType': */
class SOAP_CMAC gco__Binary_x005fPropertyType : public xsd__anyType {
      public:
        __gco__Binary_x005fPropertyType_sequence *__Binary_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__Binary_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__Binary_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Binary_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__Binary_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__Binary_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__Binary_x005fPropertyType() : __Binary_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gco__Binary_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__Binary_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__Binary_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__Binary_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2312 */
#ifndef SOAP_TYPE_plu_gco__AbstractObject_x005fType
#define SOAP_TYPE_plu_gco__AbstractObject_x005fType (-725)
/* simple XML schema type 'gco:AbstractObject_Type': */
class SOAP_CMAC gco__AbstractObject_x005fType : public xsd__anyType {
      public:
        /// Optional attribute 'id' of XML schema type 'xsd:ID'
        char **id;
        /// Optional attribute 'uuid' of XML schema type 'xsd:string'
        std::string *uuid;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__AbstractObject_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__AbstractObject_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__AbstractObject_x005fType, default initialized and not managed by a soap context
        virtual gco__AbstractObject_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__AbstractObject_x005fType); }
      public:
        /// Constructor with default initializations
        gco__AbstractObject_x005fType() : id(), uuid() { }
        virtual ~gco__AbstractObject_x005fType() { }
        /// Friend allocator used by soap_new_gco__AbstractObject_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gco__AbstractObject_x005fType * SOAP_FMAC2 soap_instantiate_gco__AbstractObject_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2315 */
#ifndef SOAP_TYPE_plu_gco__ObjectReference_x005fPropertyType
#define SOAP_TYPE_plu_gco__ObjectReference_x005fPropertyType (-726)
/* simple XML schema type 'gco:ObjectReference_PropertyType': */
class SOAP_CMAC gco__ObjectReference_x005fPropertyType : public xsd__anyType {
      public:
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__ObjectReference_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__ObjectReference_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__ObjectReference_x005fPropertyType, default initialized and not managed by a soap context
        virtual gco__ObjectReference_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__ObjectReference_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gco__ObjectReference_x005fPropertyType() : gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gco__ObjectReference_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gco__ObjectReference_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__ObjectReference_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gco__ObjectReference_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:20879 */
#ifndef SOAP_TYPE_plu___gss__GM_x005fPoint_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gss__GM_x005fPoint_x005fPropertyType_sequence (-1810)
/* Wrapper: */
class SOAP_CMAC __gss__GM_x005fPoint_x005fPropertyType_sequence {
      public:
        /// Required element 'gml:Point' of XML schema type 'gml:PointType'
        gml__PointType *gml__Point;
      public:
        /// Return unique type id SOAP_TYPE_plu___gss__GM_x005fPoint_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gss__GM_x005fPoint_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gss__GM_x005fPoint_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gss__GM_x005fPoint_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gss__GM_x005fPoint_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gss__GM_x005fPoint_x005fPropertyType_sequence() : gml__Point() { }
        virtual ~__gss__GM_x005fPoint_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gss__GM_x005fPoint_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gss__GM_x005fPoint_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gss__GM_x005fPoint_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2324 */
#ifndef SOAP_TYPE_plu_gss__GM_x005fPoint_x005fPropertyType
#define SOAP_TYPE_plu_gss__GM_x005fPoint_x005fPropertyType (-728)
/* complex XML schema type 'gss:GM_Point_PropertyType': */
class SOAP_CMAC gss__GM_x005fPoint_x005fPropertyType : public xsd__anyType {
      public:
        __gss__GM_x005fPoint_x005fPropertyType_sequence *__GM_x005fPoint_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gss__GM_x005fPoint_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gss__GM_x005fPoint_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gss__GM_x005fPoint_x005fPropertyType, default initialized and not managed by a soap context
        virtual gss__GM_x005fPoint_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gss__GM_x005fPoint_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gss__GM_x005fPoint_x005fPropertyType() : __GM_x005fPoint_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gss__GM_x005fPoint_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gss__GM_x005fPoint_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gss__GM_x005fPoint_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gss__GM_x005fPoint_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:20937 */
#ifndef SOAP_TYPE_plu__gss__union_GM_x005fObject_x005fPropertyType
#define SOAP_TYPE_plu__gss__union_GM_x005fObject_x005fPropertyType (-1813)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gss__union_GM_x005fObject_x005fPropertyType
{
        #define SOAP_UNION_plu__gss__union_GM_x005fObject_x005fPropertyType_gml__GeometricComplex	(1)	/**< union variant selector value for member gml__GeometricComplex */
        gml__GeometricComplexType *gml__GeometricComplex;
};
#endif

/* PlannedLandUse_v3.0.h:20927 */
#ifndef SOAP_TYPE_plu___gss__GM_x005fObject_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gss__GM_x005fObject_x005fPropertyType_sequence (-1812)
/* Wrapper: */
class SOAP_CMAC __gss__GM_x005fObject_x005fPropertyType_sequence {
      public:
        /// Union with union _gss__union_GM_x005fObject_x005fPropertyType variant selector __unionAbstractGeometry set to one of: SOAP_UNION_plu__gss__union_GM_x005fObject_x005fPropertyType_gml__GeometricComplex
        int __unionAbstractGeometry;
        union _gss__union_GM_x005fObject_x005fPropertyType union_GM_x005fObject_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gss__GM_x005fObject_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gss__GM_x005fObject_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gss__GM_x005fObject_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gss__GM_x005fObject_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gss__GM_x005fObject_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gss__GM_x005fObject_x005fPropertyType_sequence() : __unionAbstractGeometry() { }
        virtual ~__gss__GM_x005fObject_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gss__GM_x005fObject_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gss__GM_x005fObject_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gss__GM_x005fObject_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2327 */
#ifndef SOAP_TYPE_plu_gss__GM_x005fObject_x005fPropertyType
#define SOAP_TYPE_plu_gss__GM_x005fObject_x005fPropertyType (-729)
/* complex XML schema type 'gss:GM_Object_PropertyType': */
class SOAP_CMAC gss__GM_x005fObject_x005fPropertyType : public xsd__anyType {
      public:
        __gss__GM_x005fObject_x005fPropertyType_sequence *__GM_x005fObject_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gss__GM_x005fObject_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gss__GM_x005fObject_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gss__GM_x005fObject_x005fPropertyType, default initialized and not managed by a soap context
        virtual gss__GM_x005fObject_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gss__GM_x005fObject_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gss__GM_x005fObject_x005fPropertyType() : __GM_x005fObject_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gss__GM_x005fObject_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gss__GM_x005fObject_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gss__GM_x005fObject_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gss__GM_x005fObject_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21001 */
#ifndef SOAP_TYPE_plu__gts__union_TM_x005fPrimitive_x005fPropertyType
#define SOAP_TYPE_plu__gts__union_TM_x005fPrimitive_x005fPropertyType (-1816)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gts__union_TM_x005fPrimitive_x005fPropertyType
{
};
#endif

/* PlannedLandUse_v3.0.h:20991 */
#ifndef SOAP_TYPE_plu___gts__TM_x005fPrimitive_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gts__TM_x005fPrimitive_x005fPropertyType_sequence (-1815)
/* Wrapper: */
class SOAP_CMAC __gts__TM_x005fPrimitive_x005fPropertyType_sequence {
      public:
        /// Union with union _gts__union_TM_x005fPrimitive_x005fPropertyType variant selector __unionAbstractTimePrimitive set to one of:
        int __unionAbstractTimePrimitive;
        union _gts__union_TM_x005fPrimitive_x005fPropertyType union_TM_x005fPrimitive_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gts__TM_x005fPrimitive_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gts__TM_x005fPrimitive_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gts__TM_x005fPrimitive_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gts__TM_x005fPrimitive_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gts__TM_x005fPrimitive_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gts__TM_x005fPrimitive_x005fPropertyType_sequence() : __unionAbstractTimePrimitive() { }
        virtual ~__gts__TM_x005fPrimitive_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gts__TM_x005fPrimitive_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gts__TM_x005fPrimitive_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gts__TM_x005fPrimitive_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2330 */
#ifndef SOAP_TYPE_plu_gts__TM_x005fPrimitive_x005fPropertyType
#define SOAP_TYPE_plu_gts__TM_x005fPrimitive_x005fPropertyType (-730)
/* complex XML schema type 'gts:TM_Primitive_PropertyType': */
class SOAP_CMAC gts__TM_x005fPrimitive_x005fPropertyType : public xsd__anyType {
      public:
        __gts__TM_x005fPrimitive_x005fPropertyType_sequence *__TM_x005fPrimitive_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gts__TM_x005fPrimitive_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gts__TM_x005fPrimitive_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gts__TM_x005fPrimitive_x005fPropertyType, default initialized and not managed by a soap context
        virtual gts__TM_x005fPrimitive_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gts__TM_x005fPrimitive_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gts__TM_x005fPrimitive_x005fPropertyType() : __TM_x005fPrimitive_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gts__TM_x005fPrimitive_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gts__TM_x005fPrimitive_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gts__TM_x005fPrimitive_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gts__TM_x005fPrimitive_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21045 */
#ifndef SOAP_TYPE_plu___gts__TM_x005fPeriodDuration_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gts__TM_x005fPeriodDuration_x005fPropertyType_sequence (-1818)
/* Wrapper: */
class SOAP_CMAC __gts__TM_x005fPeriodDuration_x005fPropertyType_sequence {
      public:
        /// Required element 'gts:TM_PeriodDuration' of XML schema type 'xsd:duration'
        char *TM_x005fPeriodDuration;
      public:
        /// Return unique type id SOAP_TYPE_plu___gts__TM_x005fPeriodDuration_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gts__TM_x005fPeriodDuration_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gts__TM_x005fPeriodDuration_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gts__TM_x005fPeriodDuration_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gts__TM_x005fPeriodDuration_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gts__TM_x005fPeriodDuration_x005fPropertyType_sequence() : TM_x005fPeriodDuration() { }
        virtual ~__gts__TM_x005fPeriodDuration_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gts__TM_x005fPeriodDuration_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gts__TM_x005fPeriodDuration_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gts__TM_x005fPeriodDuration_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2333 */
#ifndef SOAP_TYPE_plu_gts__TM_x005fPeriodDuration_x005fPropertyType
#define SOAP_TYPE_plu_gts__TM_x005fPeriodDuration_x005fPropertyType (-731)
/* complex XML schema type 'gts:TM_PeriodDuration_PropertyType': */
class SOAP_CMAC gts__TM_x005fPeriodDuration_x005fPropertyType : public xsd__anyType {
      public:
        __gts__TM_x005fPeriodDuration_x005fPropertyType_sequence *__TM_x005fPeriodDuration_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu_gts__TM_x005fPeriodDuration_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gts__TM_x005fPeriodDuration_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gts__TM_x005fPeriodDuration_x005fPropertyType, default initialized and not managed by a soap context
        virtual gts__TM_x005fPeriodDuration_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gts__TM_x005fPeriodDuration_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gts__TM_x005fPeriodDuration_x005fPropertyType() : __TM_x005fPeriodDuration_x005fPropertyType_sequence(), gco__nilReason() { }
        virtual ~gts__TM_x005fPeriodDuration_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gts__TM_x005fPeriodDuration_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gts__TM_x005fPeriodDuration_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gts__TM_x005fPeriodDuration_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21088 */
#ifndef SOAP_TYPE_plu__gsr__union_SC_x005fCRS_x005fPropertyType
#define SOAP_TYPE_plu__gsr__union_SC_x005fCRS_x005fPropertyType (-1821)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gsr__union_SC_x005fCRS_x005fPropertyType
{
        #define SOAP_UNION_plu__gsr__union_SC_x005fCRS_x005fPropertyType_gml__CompoundCRS	(1)	/**< union variant selector value for member gml__CompoundCRS */
        gml__CompoundCRSType *gml__CompoundCRS;
};
#endif

/* PlannedLandUse_v3.0.h:21078 */
#ifndef SOAP_TYPE_plu___gsr__SC_x005fCRS_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gsr__SC_x005fCRS_x005fPropertyType_sequence (-1820)
/* Wrapper: */
class SOAP_CMAC __gsr__SC_x005fCRS_x005fPropertyType_sequence {
      public:
        /// Union with union _gsr__union_SC_x005fCRS_x005fPropertyType variant selector __unionAbstractCRS set to one of: SOAP_UNION_plu__gsr__union_SC_x005fCRS_x005fPropertyType_gml__CompoundCRS
        int __unionAbstractCRS;
        union _gsr__union_SC_x005fCRS_x005fPropertyType union_SC_x005fCRS_x005fPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gsr__SC_x005fCRS_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gsr__SC_x005fCRS_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gsr__SC_x005fCRS_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gsr__SC_x005fCRS_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gsr__SC_x005fCRS_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gsr__SC_x005fCRS_x005fPropertyType_sequence() : __unionAbstractCRS() { }
        virtual ~__gsr__SC_x005fCRS_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gsr__SC_x005fCRS_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gsr__SC_x005fCRS_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gsr__SC_x005fCRS_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2336 */
#ifndef SOAP_TYPE_plu_gsr__SC_x005fCRS_x005fPropertyType
#define SOAP_TYPE_plu_gsr__SC_x005fCRS_x005fPropertyType (-732)
/* complex XML schema type 'gsr:SC_CRS_PropertyType': */
class SOAP_CMAC gsr__SC_x005fCRS_x005fPropertyType : public xsd__anyType {
      public:
        __gsr__SC_x005fCRS_x005fPropertyType_sequence *__SC_x005fCRS_x005fPropertyType_sequence;
        /// Optional attribute 'gco:nilReason' of XML schema type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Optional attribute 'uuidref' of XML schema type 'xsd:string'
        std::string *uuidref;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gsr__SC_x005fCRS_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gsr__SC_x005fCRS_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gsr__SC_x005fCRS_x005fPropertyType, default initialized and not managed by a soap context
        virtual gsr__SC_x005fCRS_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gsr__SC_x005fCRS_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gsr__SC_x005fCRS_x005fPropertyType() : __SC_x005fCRS_x005fPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gsr__SC_x005fCRS_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gsr__SC_x005fCRS_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gsr__SC_x005fCRS_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gsr__SC_x005fCRS_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:314 */
#ifndef SOAP_TYPE_plu_plu__DimensioningIndicationMeasureValueType
#define SOAP_TYPE_plu_plu__DimensioningIndicationMeasureValueType (-59)
/* complex XML schema type 'plu:DimensioningIndicationMeasureValueType': */
class SOAP_CMAC plu__DimensioningIndicationMeasureValueType : public plu__DimensioningIndicationValueType {
      public:
        /// Required element 'plu:value' of XML schema type 'gml:MeasureType'
        gml__MeasureType *value;
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__DimensioningIndicationMeasureValueType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__DimensioningIndicationMeasureValueType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__DimensioningIndicationMeasureValueType, default initialized and not managed by a soap context
        virtual plu__DimensioningIndicationMeasureValueType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__DimensioningIndicationMeasureValueType); }
      public:
        /// Constructor with default initializations
        plu__DimensioningIndicationMeasureValueType() : value() { }
        virtual ~plu__DimensioningIndicationMeasureValueType() { }
        /// Friend allocator used by soap_new_plu__DimensioningIndicationMeasureValueType(struct soap*, int)
        friend SOAP_FMAC1 plu__DimensioningIndicationMeasureValueType * SOAP_FMAC2 soap_instantiate_plu__DimensioningIndicationMeasureValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:320 */
#ifndef SOAP_TYPE_plu_plu__DimensioningIndicationIntegerValueType
#define SOAP_TYPE_plu_plu__DimensioningIndicationIntegerValueType (-61)
/* complex XML schema type 'plu:DimensioningIndicationIntegerValueType': */
class SOAP_CMAC plu__DimensioningIndicationIntegerValueType : public plu__DimensioningIndicationValueType {
      public:
        /// Required element 'plu:value' of XML schema type 'xsd:long'
        long value;
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__DimensioningIndicationIntegerValueType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__DimensioningIndicationIntegerValueType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__DimensioningIndicationIntegerValueType, default initialized and not managed by a soap context
        virtual plu__DimensioningIndicationIntegerValueType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__DimensioningIndicationIntegerValueType); }
      public:
        /// Constructor with default initializations
        plu__DimensioningIndicationIntegerValueType() : value() { }
        virtual ~plu__DimensioningIndicationIntegerValueType() { }
        /// Friend allocator used by soap_new_plu__DimensioningIndicationIntegerValueType(struct soap*, int)
        friend SOAP_FMAC1 plu__DimensioningIndicationIntegerValueType * SOAP_FMAC2 soap_instantiate_plu__DimensioningIndicationIntegerValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:326 */
#ifndef SOAP_TYPE_plu_plu__DimensioningIndicationCharacterValueType
#define SOAP_TYPE_plu_plu__DimensioningIndicationCharacterValueType (-63)
/* complex XML schema type 'plu:DimensioningIndicationCharacterValueType': */
class SOAP_CMAC plu__DimensioningIndicationCharacterValueType : public plu__DimensioningIndicationValueType {
      public:
        /// Required element 'plu:value' of XML schema type 'xsd:string'
        std::string value;
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__DimensioningIndicationCharacterValueType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__DimensioningIndicationCharacterValueType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__DimensioningIndicationCharacterValueType, default initialized and not managed by a soap context
        virtual plu__DimensioningIndicationCharacterValueType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__DimensioningIndicationCharacterValueType); }
      public:
        /// Constructor with default initializations
        plu__DimensioningIndicationCharacterValueType() : value() { }
        virtual ~plu__DimensioningIndicationCharacterValueType() { }
        /// Friend allocator used by soap_new_plu__DimensioningIndicationCharacterValueType(struct soap*, int)
        friend SOAP_FMAC1 plu__DimensioningIndicationCharacterValueType * SOAP_FMAC2 soap_instantiate_plu__DimensioningIndicationCharacterValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:350 */
#ifndef SOAP_TYPE_plu_plu__DimensioningIndicationRealValueType
#define SOAP_TYPE_plu_plu__DimensioningIndicationRealValueType (-71)
/* complex XML schema type 'plu:DimensioningIndicationRealValueType': */
class SOAP_CMAC plu__DimensioningIndicationRealValueType : public plu__DimensioningIndicationValueType {
      public:
        /// Required element 'plu:value' of XML schema type 'xsd:double'
        double value;
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__DimensioningIndicationRealValueType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__DimensioningIndicationRealValueType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__DimensioningIndicationRealValueType, default initialized and not managed by a soap context
        virtual plu__DimensioningIndicationRealValueType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__DimensioningIndicationRealValueType); }
      public:
        /// Constructor with default initializations
        plu__DimensioningIndicationRealValueType() : value() { }
        virtual ~plu__DimensioningIndicationRealValueType() { }
        /// Friend allocator used by soap_new_plu__DimensioningIndicationRealValueType(struct soap*, int)
        friend SOAP_FMAC1 plu__DimensioningIndicationRealValueType * SOAP_FMAC2 soap_instantiate_plu__DimensioningIndicationRealValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21306 */
#ifndef SOAP_TYPE_plu__base2__DocumentCitationType_shortName
#define SOAP_TYPE_plu__base2__DocumentCitationType_shortName (-1823)
/* simple XML schema type 'base2:DocumentCitationType-shortName': */
class SOAP_CMAC _base2__DocumentCitationType_shortName {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__base2__DocumentCitationType_shortName
        virtual long soap_type(void) const { return SOAP_TYPE_plu__base2__DocumentCitationType_shortName; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _base2__DocumentCitationType_shortName, default initialized and not managed by a soap context
        virtual _base2__DocumentCitationType_shortName *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_base2__DocumentCitationType_shortName); }
      public:
        /// Constructor with default initializations
        _base2__DocumentCitationType_shortName() : __item(), nilReason() { }
        virtual ~_base2__DocumentCitationType_shortName() { }
        /// Friend allocator used by soap_new__base2__DocumentCitationType_shortName(struct soap*, int)
        friend SOAP_FMAC1 _base2__DocumentCitationType_shortName * SOAP_FMAC2 soap_instantiate__base2__DocumentCitationType_shortName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21329 */
#ifndef SOAP_TYPE_plu__base2__DocumentCitationType_date
#define SOAP_TYPE_plu__base2__DocumentCitationType_date (-1825)
/* complex XML schema type 'base2:DocumentCitationType-date': */
class SOAP_CMAC _base2__DocumentCitationType_date {
      public:
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
        /// Required element 'gmd:CI_Date' of XML schema type 'gmd:CI_Date_Type'
        gmd__CI_x005fDate_x005fType *gmd__CI_x005fDate;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__base2__DocumentCitationType_date
        virtual long soap_type(void) const { return SOAP_TYPE_plu__base2__DocumentCitationType_date; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _base2__DocumentCitationType_date, default initialized and not managed by a soap context
        virtual _base2__DocumentCitationType_date *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_base2__DocumentCitationType_date); }
      public:
        /// Constructor with default initializations
        _base2__DocumentCitationType_date() : owns((bool)0), gmd__CI_x005fDate(), nilReason() { }
        virtual ~_base2__DocumentCitationType_date() { }
        /// Friend allocator used by soap_new__base2__DocumentCitationType_date(struct soap*, int)
        friend SOAP_FMAC1 _base2__DocumentCitationType_date * SOAP_FMAC2 soap_instantiate__base2__DocumentCitationType_date(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21360 */
#ifndef SOAP_TYPE_plu__base2__DocumentCitationType_link
#define SOAP_TYPE_plu__base2__DocumentCitationType_link (-1827)
/* simple XML schema type 'base2:DocumentCitationType-link': */
class SOAP_CMAC _base2__DocumentCitationType_link {
      public:
        /// Simple content of XML schema type 'xsd:anyURI' wrapped by this struct
        char *__item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__base2__DocumentCitationType_link
        virtual long soap_type(void) const { return SOAP_TYPE_plu__base2__DocumentCitationType_link; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _base2__DocumentCitationType_link, default initialized and not managed by a soap context
        virtual _base2__DocumentCitationType_link *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_base2__DocumentCitationType_link); }
      public:
        /// Constructor with default initializations
        _base2__DocumentCitationType_link() : __item(), nilReason() { }
        virtual ~_base2__DocumentCitationType_link() { }
        /// Friend allocator used by soap_new__base2__DocumentCitationType_link(struct soap*, int)
        friend SOAP_FMAC1 _base2__DocumentCitationType_link * SOAP_FMAC2 soap_instantiate__base2__DocumentCitationType_link(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21387 */
#ifndef SOAP_TYPE_plu__base2__DocumentCitationType_specificReference
#define SOAP_TYPE_plu__base2__DocumentCitationType_specificReference (-1830)
/* simple XML schema type 'base2:DocumentCitationType-specificReference': */
class SOAP_CMAC _base2__DocumentCitationType_specificReference {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__base2__DocumentCitationType_specificReference
        virtual long soap_type(void) const { return SOAP_TYPE_plu__base2__DocumentCitationType_specificReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _base2__DocumentCitationType_specificReference, default initialized and not managed by a soap context
        virtual _base2__DocumentCitationType_specificReference *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_base2__DocumentCitationType_specificReference); }
      public:
        /// Constructor with default initializations
        _base2__DocumentCitationType_specificReference() : __item(), nilReason() { }
        virtual ~_base2__DocumentCitationType_specificReference() { }
        /// Friend allocator used by soap_new__base2__DocumentCitationType_specificReference(struct soap*, int)
        friend SOAP_FMAC1 _base2__DocumentCitationType_specificReference * SOAP_FMAC2 soap_instantiate__base2__DocumentCitationType_specificReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:404 */
#ifndef SOAP_TYPE_plu_base2__DocumentCitationType
#define SOAP_TYPE_plu_base2__DocumentCitationType (-89)
/* complex XML schema type 'base2:DocumentCitationType': */
class SOAP_CMAC base2__DocumentCitationType : public gml__AbstractGMLType {
      public:
        /// Required element 'base2:name' of XML schema type 'xsd:string'
        std::string name;
        /// Optional element 'base2:shortName' of XML schema type 'base2:DocumentCitationType-shortName'
        _base2__DocumentCitationType_shortName *shortName;
        /// Required nillable (xsi:nil when NULL) element 'base2:date' of XML schema type 'base2:DocumentCitationType-date'
        _base2__DocumentCitationType_date *date;
        /// Required element 'base2:link' of XML schema type 'base2:DocumentCitationType-link'
        std::vector<_base2__DocumentCitationType_link> *link;
        /// Optional element 'base2:specificReference' of XML schema type 'base2:DocumentCitationType-specificReference'
        std::vector<_base2__DocumentCitationType_specificReference> *specificReference;
      public:
        /// Return unique type id SOAP_TYPE_plu_base2__DocumentCitationType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_base2__DocumentCitationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type base2__DocumentCitationType, default initialized and not managed by a soap context
        virtual base2__DocumentCitationType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(base2__DocumentCitationType); }
      public:
        /// Constructor with default initializations
        base2__DocumentCitationType() : name(), shortName(), date(), link(), specificReference() { }
        virtual ~base2__DocumentCitationType() { }
        /// Friend allocator used by soap_new_base2__DocumentCitationType(struct soap*, int)
        friend SOAP_FMAC1 base2__DocumentCitationType * SOAP_FMAC2 soap_instantiate_base2__DocumentCitationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:440 */
#ifndef SOAP_TYPE_plu__sc__taggedValue
#define SOAP_TYPE_plu__sc__taggedValue (-101)
/* simple XML schema type 'sc:taggedValue': */
class SOAP_CMAC _sc__taggedValue {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'tag' of XML schema type 'xsd:string'
        std::string *tag;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_plu__sc__taggedValue
        virtual long soap_type(void) const { return SOAP_TYPE_plu__sc__taggedValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _sc__taggedValue, default initialized and not managed by a soap context
        virtual _sc__taggedValue *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_sc__taggedValue); }
      public:
        /// Constructor with default initializations
        _sc__taggedValue() : __item(), tag(), soap() { }
        virtual ~_sc__taggedValue() { }
        /// Friend allocator used by soap_new__sc__taggedValue(struct soap*, int)
        friend SOAP_FMAC1 _sc__taggedValue * SOAP_FMAC2 soap_instantiate__sc__taggedValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21450 */
#ifndef SOAP_TYPE_plu__gml__union_DynamicFeatureMemberType
#define SOAP_TYPE_plu__gml__union_DynamicFeatureMemberType (-1834)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_DynamicFeatureMemberType
{
        #define SOAP_UNION_plu__gml__union_DynamicFeatureMemberType_DynamicFeature	(1)	/**< union variant selector value for member DynamicFeature */
        std::vector<gml__DynamicFeatureType *> *DynamicFeature;
        #define SOAP_UNION_plu__gml__union_DynamicFeatureMemberType_DynamicFeatureCollection	(2)	/**< union variant selector value for member DynamicFeatureCollection */
        gml__DynamicFeatureCollectionType *DynamicFeatureCollection;
};
#endif

/* PlannedLandUse_v3.0.h:21445 */
#ifndef SOAP_TYPE_plu___gml__union_DynamicFeatureMemberType
#define SOAP_TYPE_plu___gml__union_DynamicFeatureMemberType (-1833)
/* Type __gml__union_DynamicFeatureMemberType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* Wrapper: */
class SOAP_CMAC __gml__union_DynamicFeatureMemberType {
      public:
        /// Union with union _gml__union_DynamicFeatureMemberType variant selector __unionDynamicFeature set to one of: SOAP_UNION_plu__gml__union_DynamicFeatureMemberType_DynamicFeature SOAP_UNION_plu__gml__union_DynamicFeatureMemberType_DynamicFeatureCollection
        int __unionDynamicFeature;
        union _gml__union_DynamicFeatureMemberType union_DynamicFeatureMemberType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_DynamicFeatureMemberType
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_DynamicFeatureMemberType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_DynamicFeatureMemberType, default initialized and not managed by a soap context
        virtual __gml__union_DynamicFeatureMemberType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_DynamicFeatureMemberType); }
      public:
        /// Constructor with default initializations
        __gml__union_DynamicFeatureMemberType() : __unionDynamicFeature() { }
        virtual ~__gml__union_DynamicFeatureMemberType() { }
        /// Friend allocator used by soap_new___gml__union_DynamicFeatureMemberType(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_DynamicFeatureMemberType * SOAP_FMAC2 soap_instantiate___gml__union_DynamicFeatureMemberType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:449 */
#ifndef SOAP_TYPE_plu_gml__DynamicFeatureMemberType
#define SOAP_TYPE_plu_gml__DynamicFeatureMemberType (-104)
/* complex XML schema type 'gml:DynamicFeatureMemberType': */
class SOAP_CMAC gml__DynamicFeatureMemberType : public gml__AbstractFeatureMemberType {
      public:
        /// Sequence of elements '-union-DynamicFeatureMemberType' of XML schema type '-gml:union-DynamicFeatureMemberType' stored in dynamic array __union_DynamicFeatureMemberType of length __sizeDynamicFeature
        int __sizeDynamicFeature;
        __gml__union_DynamicFeatureMemberType *__union_DynamicFeatureMemberType;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DynamicFeatureMemberType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DynamicFeatureMemberType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DynamicFeatureMemberType, default initialized and not managed by a soap context
        virtual gml__DynamicFeatureMemberType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DynamicFeatureMemberType); }
      public:
        /// Constructor with default initializations
        gml__DynamicFeatureMemberType() : __sizeDynamicFeature(), __union_DynamicFeatureMemberType(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__DynamicFeatureMemberType() { }
        /// Friend allocator used by soap_new_gml__DynamicFeatureMemberType(struct soap*, int)
        friend SOAP_FMAC1 gml__DynamicFeatureMemberType * SOAP_FMAC2 soap_instantiate_gml__DynamicFeatureMemberType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:452 */
#ifndef SOAP_TYPE_plu_gml__AbstractTimeSliceType
#define SOAP_TYPE_plu_gml__AbstractTimeSliceType (-105)
/* complex XML schema type 'gml:AbstractTimeSliceType': */
class SOAP_CMAC gml__AbstractTimeSliceType : public gml__AbstractGMLType {
      public:
        /// Required element 'gml:validTime' of XML schema type 'gml:TimePrimitivePropertyType'
        gml__TimePrimitivePropertyType *validTime;
        /// Optional element 'gml:dataSource' of XML schema type 'gml:StringOrRefType'
        gml__StringOrRefType *dataSource;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractTimeSliceType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractTimeSliceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractTimeSliceType, default initialized and not managed by a soap context
        virtual gml__AbstractTimeSliceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractTimeSliceType); }
      public:
        /// Constructor with default initializations
        gml__AbstractTimeSliceType() : validTime(), dataSource() { }
        virtual ~gml__AbstractTimeSliceType() { }
        /// Friend allocator used by soap_new_gml__AbstractTimeSliceType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractTimeSliceType * SOAP_FMAC2 soap_instantiate_gml__AbstractTimeSliceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:458 */
#ifndef SOAP_TYPE_plu_gml__AbstractTopologyType
#define SOAP_TYPE_plu_gml__AbstractTopologyType (-107)
/* complex XML schema type 'gml:AbstractTopologyType': */
class SOAP_CMAC gml__AbstractTopologyType : public gml__AbstractGMLType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractTopologyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractTopologyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractTopologyType, default initialized and not managed by a soap context
        virtual gml__AbstractTopologyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractTopologyType); }
      public:
        /// Constructor with default initializations
        gml__AbstractTopologyType() { }
        virtual ~gml__AbstractTopologyType() { }
        /// Friend allocator used by soap_new_gml__AbstractTopologyType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractTopologyType * SOAP_FMAC2 soap_instantiate_gml__AbstractTopologyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21631 */
#ifndef SOAP_TYPE_plu__gml__union_LineStringSegmentType_
#define SOAP_TYPE_plu__gml__union_LineStringSegmentType_ (-1842)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_LineStringSegmentType_
{
        #define SOAP_UNION_plu__gml__union_LineStringSegmentType__pos	(1)	/**< union variant selector value for member pos */
        gml__DirectPositionType *pos;
        #define SOAP_UNION_plu__gml__union_LineStringSegmentType__pointProperty	(2)	/**< union variant selector value for member pointProperty */
        gml__PointPropertyType *pointProperty;
        #define SOAP_UNION_plu__gml__union_LineStringSegmentType__pointRep	(3)	/**< union variant selector value for member pointRep */
        gml__PointPropertyType *pointRep;
};
#endif

/* PlannedLandUse_v3.0.h:21627 */
#ifndef SOAP_TYPE_plu___gml__union_LineStringSegmentType_
#define SOAP_TYPE_plu___gml__union_LineStringSegmentType_ (-1841)
/* Wrapper: */
class SOAP_CMAC __gml__union_LineStringSegmentType_ {
      public:
        /// Union with union _gml__union_LineStringSegmentType_ variant selector __union_LineStringSegmentType_ set to one of: SOAP_UNION_plu__gml__union_LineStringSegmentType__pos SOAP_UNION_plu__gml__union_LineStringSegmentType__pointProperty SOAP_UNION_plu__gml__union_LineStringSegmentType__pointRep
        int __union_LineStringSegmentType_;
        union _gml__union_LineStringSegmentType_ union_LineStringSegmentType_;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_LineStringSegmentType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_LineStringSegmentType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_LineStringSegmentType_, default initialized and not managed by a soap context
        virtual __gml__union_LineStringSegmentType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_LineStringSegmentType_); }
      public:
        /// Constructor with default initializations
        __gml__union_LineStringSegmentType_() : __union_LineStringSegmentType_() { }
        virtual ~__gml__union_LineStringSegmentType_() { }
        /// Friend allocator used by soap_new___gml__union_LineStringSegmentType_(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_LineStringSegmentType_ * SOAP_FMAC2 soap_instantiate___gml__union_LineStringSegmentType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21625 */
#ifndef SOAP_TYPE_plu____gml__union_LineStringSegmentType_
#define SOAP_TYPE_plu____gml__union_LineStringSegmentType_ (-1840)
/* Wrapper: */
struct SOAP_CMAC ___gml__union_LineStringSegmentType_ {
      public:
        /** Sequence of at least 2 elements '-union-LineStringSegmentType' of XML schema type '-gml:union-LineStringSegmentType' stored in dynamic array __union_LineStringSegmentType_ of length __size_LineStringSegmentType_ */
        int __size_LineStringSegmentType_;
        __gml__union_LineStringSegmentType_ *__union_LineStringSegmentType_;
      public:
        /** Return unique type id SOAP_TYPE_plu____gml__union_LineStringSegmentType_ */
        long soap_type() const { return SOAP_TYPE_plu____gml__union_LineStringSegmentType_; }
        /** Friend allocator */
        friend SOAP_FMAC1 ___gml__union_LineStringSegmentType_ * SOAP_FMAC2 soap_instantiate____gml__union_LineStringSegmentType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21622 */
#ifndef SOAP_TYPE_plu__gml__union_LineStringSegmentType
#define SOAP_TYPE_plu__gml__union_LineStringSegmentType (-1839)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_LineStringSegmentType
{
        #define SOAP_UNION_plu__gml__union_LineStringSegmentType___union_LineStringSegmentType_	(1)	/**< union variant selector value for member __union_LineStringSegmentType_ */
        struct ___gml__union_LineStringSegmentType_ __union_LineStringSegmentType_;
        #define SOAP_UNION_plu__gml__union_LineStringSegmentType_posList	(2)	/**< union variant selector value for member posList */
        gml__DirectPositionListType *posList;
        #define SOAP_UNION_plu__gml__union_LineStringSegmentType_coordinates	(3)	/**< union variant selector value for member coordinates */
        gml__CoordinatesType *coordinates;
};
#endif

/* PlannedLandUse_v3.0.h:596 */
#ifndef SOAP_TYPE_plu_gml__LineStringSegmentType
#define SOAP_TYPE_plu_gml__LineStringSegmentType (-153)
/* complex XML schema type 'gml:LineStringSegmentType': */
class SOAP_CMAC gml__LineStringSegmentType : public gml__AbstractCurveSegmentType {
      public:
        /// Union with union _gml__union_LineStringSegmentType variant selector __union_LineStringSegmentType set to one of: SOAP_UNION_plu__gml__union_LineStringSegmentType___union_LineStringSegmentType_ SOAP_UNION_plu__gml__union_LineStringSegmentType_posList SOAP_UNION_plu__gml__union_LineStringSegmentType_coordinates
        int __union_LineStringSegmentType;
        union _gml__union_LineStringSegmentType union_LineStringSegmentType;
        /// Optional attribute 'interpolation' of XML schema type 'gml:CurveInterpolationType'
        enum gml__CurveInterpolationType *interpolation;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__LineStringSegmentType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__LineStringSegmentType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__LineStringSegmentType, default initialized and not managed by a soap context
        virtual gml__LineStringSegmentType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__LineStringSegmentType); }
      public:
        /// Constructor with default initializations
        gml__LineStringSegmentType() : __union_LineStringSegmentType(), interpolation() { }
        virtual ~gml__LineStringSegmentType() { }
        /// Friend allocator used by soap_new_gml__LineStringSegmentType(struct soap*, int)
        friend SOAP_FMAC1 gml__LineStringSegmentType * SOAP_FMAC2 soap_instantiate_gml__LineStringSegmentType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21689 */
#ifndef SOAP_TYPE_plu__gml__union_ArcStringType_
#define SOAP_TYPE_plu__gml__union_ArcStringType_ (-1850)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ArcStringType_
{
        #define SOAP_UNION_plu__gml__union_ArcStringType__pos	(1)	/**< union variant selector value for member pos */
        gml__DirectPositionType *pos;
        #define SOAP_UNION_plu__gml__union_ArcStringType__pointProperty	(2)	/**< union variant selector value for member pointProperty */
        gml__PointPropertyType *pointProperty;
        #define SOAP_UNION_plu__gml__union_ArcStringType__pointRep	(3)	/**< union variant selector value for member pointRep */
        gml__PointPropertyType *pointRep;
};
#endif

/* PlannedLandUse_v3.0.h:21685 */
#ifndef SOAP_TYPE_plu___gml__union_ArcStringType_
#define SOAP_TYPE_plu___gml__union_ArcStringType_ (-1849)
/* Wrapper: */
class SOAP_CMAC __gml__union_ArcStringType_ {
      public:
        /// Union with union _gml__union_ArcStringType_ variant selector __union_ArcStringType_ set to one of: SOAP_UNION_plu__gml__union_ArcStringType__pos SOAP_UNION_plu__gml__union_ArcStringType__pointProperty SOAP_UNION_plu__gml__union_ArcStringType__pointRep
        int __union_ArcStringType_;
        union _gml__union_ArcStringType_ union_ArcStringType_;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_ArcStringType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_ArcStringType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_ArcStringType_, default initialized and not managed by a soap context
        virtual __gml__union_ArcStringType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_ArcStringType_); }
      public:
        /// Constructor with default initializations
        __gml__union_ArcStringType_() : __union_ArcStringType_() { }
        virtual ~__gml__union_ArcStringType_() { }
        /// Friend allocator used by soap_new___gml__union_ArcStringType_(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_ArcStringType_ * SOAP_FMAC2 soap_instantiate___gml__union_ArcStringType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21683 */
#ifndef SOAP_TYPE_plu____gml__union_ArcStringType_
#define SOAP_TYPE_plu____gml__union_ArcStringType_ (-1848)
/* Wrapper: */
struct SOAP_CMAC ___gml__union_ArcStringType_ {
      public:
        /** Sequence of at least 3 elements '-union-ArcStringType' of XML schema type '-gml:union-ArcStringType' stored in dynamic array __union_ArcStringType_ of length __size_ArcStringType_ */
        int __size_ArcStringType_;
        __gml__union_ArcStringType_ *__union_ArcStringType_;
      public:
        /** Return unique type id SOAP_TYPE_plu____gml__union_ArcStringType_ */
        long soap_type() const { return SOAP_TYPE_plu____gml__union_ArcStringType_; }
        /** Friend allocator */
        friend SOAP_FMAC1 ___gml__union_ArcStringType_ * SOAP_FMAC2 soap_instantiate____gml__union_ArcStringType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21680 */
#ifndef SOAP_TYPE_plu__gml__union_ArcStringType
#define SOAP_TYPE_plu__gml__union_ArcStringType (-1847)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ArcStringType
{
        #define SOAP_UNION_plu__gml__union_ArcStringType___union_ArcStringType_	(1)	/**< union variant selector value for member __union_ArcStringType_ */
        struct ___gml__union_ArcStringType_ __union_ArcStringType_;
        #define SOAP_UNION_plu__gml__union_ArcStringType_posList	(2)	/**< union variant selector value for member posList */
        gml__DirectPositionListType *posList;
        #define SOAP_UNION_plu__gml__union_ArcStringType_coordinates	(3)	/**< union variant selector value for member coordinates */
        gml__CoordinatesType *coordinates;
};
#endif

/* PlannedLandUse_v3.0.h:599 */
#ifndef SOAP_TYPE_plu_gml__ArcStringType
#define SOAP_TYPE_plu_gml__ArcStringType (-154)
/* complex XML schema type 'gml:ArcStringType': */
class SOAP_CMAC gml__ArcStringType : public gml__AbstractCurveSegmentType {
      public:
        /// Union with union _gml__union_ArcStringType variant selector __union_ArcStringType set to one of: SOAP_UNION_plu__gml__union_ArcStringType___union_ArcStringType_ SOAP_UNION_plu__gml__union_ArcStringType_posList SOAP_UNION_plu__gml__union_ArcStringType_coordinates
        int __union_ArcStringType;
        union _gml__union_ArcStringType union_ArcStringType;
        /// Optional attribute 'interpolation' of XML schema type 'gml:CurveInterpolationType'
        enum gml__CurveInterpolationType *interpolation;
        /// Optional attribute 'numArc' of XML schema type 'xsd:long'
        long *numArc;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ArcStringType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ArcStringType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ArcStringType, default initialized and not managed by a soap context
        virtual gml__ArcStringType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ArcStringType); }
      public:
        /// Constructor with default initializations
        gml__ArcStringType() : __union_ArcStringType(), interpolation(), numArc() { }
        virtual ~gml__ArcStringType() { }
        /// Friend allocator used by soap_new_gml__ArcStringType(struct soap*, int)
        friend SOAP_FMAC1 gml__ArcStringType * SOAP_FMAC2 soap_instantiate_gml__ArcStringType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21749 */
#ifndef SOAP_TYPE_plu__gml__union_ArcStringByBulgeType_
#define SOAP_TYPE_plu__gml__union_ArcStringByBulgeType_ (-1856)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ArcStringByBulgeType_
{
        #define SOAP_UNION_plu__gml__union_ArcStringByBulgeType__pos	(1)	/**< union variant selector value for member pos */
        gml__DirectPositionType *pos;
        #define SOAP_UNION_plu__gml__union_ArcStringByBulgeType__pointProperty	(2)	/**< union variant selector value for member pointProperty */
        gml__PointPropertyType *pointProperty;
        #define SOAP_UNION_plu__gml__union_ArcStringByBulgeType__pointRep	(3)	/**< union variant selector value for member pointRep */
        gml__PointPropertyType *pointRep;
};
#endif

/* PlannedLandUse_v3.0.h:21745 */
#ifndef SOAP_TYPE_plu___gml__union_ArcStringByBulgeType_
#define SOAP_TYPE_plu___gml__union_ArcStringByBulgeType_ (-1855)
/* Wrapper: */
class SOAP_CMAC __gml__union_ArcStringByBulgeType_ {
      public:
        /// Union with union _gml__union_ArcStringByBulgeType_ variant selector __union_ArcStringByBulgeType_ set to one of: SOAP_UNION_plu__gml__union_ArcStringByBulgeType__pos SOAP_UNION_plu__gml__union_ArcStringByBulgeType__pointProperty SOAP_UNION_plu__gml__union_ArcStringByBulgeType__pointRep
        int __union_ArcStringByBulgeType_;
        union _gml__union_ArcStringByBulgeType_ union_ArcStringByBulgeType_;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_ArcStringByBulgeType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_ArcStringByBulgeType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_ArcStringByBulgeType_, default initialized and not managed by a soap context
        virtual __gml__union_ArcStringByBulgeType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_ArcStringByBulgeType_); }
      public:
        /// Constructor with default initializations
        __gml__union_ArcStringByBulgeType_() : __union_ArcStringByBulgeType_() { }
        virtual ~__gml__union_ArcStringByBulgeType_() { }
        /// Friend allocator used by soap_new___gml__union_ArcStringByBulgeType_(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_ArcStringByBulgeType_ * SOAP_FMAC2 soap_instantiate___gml__union_ArcStringByBulgeType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21743 */
#ifndef SOAP_TYPE_plu____gml__union_ArcStringByBulgeType_
#define SOAP_TYPE_plu____gml__union_ArcStringByBulgeType_ (-1854)
/* Wrapper: */
struct SOAP_CMAC ___gml__union_ArcStringByBulgeType_ {
      public:
        /** Sequence of at least 2 elements '-union-ArcStringByBulgeType' of XML schema type '-gml:union-ArcStringByBulgeType' stored in dynamic array __union_ArcStringByBulgeType_ of length __size_ArcStringByBulgeType_ */
        int __size_ArcStringByBulgeType_;
        __gml__union_ArcStringByBulgeType_ *__union_ArcStringByBulgeType_;
      public:
        /** Return unique type id SOAP_TYPE_plu____gml__union_ArcStringByBulgeType_ */
        long soap_type() const { return SOAP_TYPE_plu____gml__union_ArcStringByBulgeType_; }
        /** Friend allocator */
        friend SOAP_FMAC1 ___gml__union_ArcStringByBulgeType_ * SOAP_FMAC2 soap_instantiate____gml__union_ArcStringByBulgeType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21740 */
#ifndef SOAP_TYPE_plu__gml__union_ArcStringByBulgeType
#define SOAP_TYPE_plu__gml__union_ArcStringByBulgeType (-1853)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ArcStringByBulgeType
{
        #define SOAP_UNION_plu__gml__union_ArcStringByBulgeType___union_ArcStringByBulgeType_	(1)	/**< union variant selector value for member __union_ArcStringByBulgeType_ */
        struct ___gml__union_ArcStringByBulgeType_ __union_ArcStringByBulgeType_;
        #define SOAP_UNION_plu__gml__union_ArcStringByBulgeType_posList	(2)	/**< union variant selector value for member posList */
        gml__DirectPositionListType *posList;
        #define SOAP_UNION_plu__gml__union_ArcStringByBulgeType_coordinates	(3)	/**< union variant selector value for member coordinates */
        gml__CoordinatesType *coordinates;
};
#endif

/* PlannedLandUse_v3.0.h:608 */
#ifndef SOAP_TYPE_plu_gml__ArcStringByBulgeType
#define SOAP_TYPE_plu_gml__ArcStringByBulgeType (-157)
/* complex XML schema type 'gml:ArcStringByBulgeType': */
class SOAP_CMAC gml__ArcStringByBulgeType : public gml__AbstractCurveSegmentType {
      public:
        /// Union with union _gml__union_ArcStringByBulgeType variant selector __union_ArcStringByBulgeType set to one of: SOAP_UNION_plu__gml__union_ArcStringByBulgeType___union_ArcStringByBulgeType_ SOAP_UNION_plu__gml__union_ArcStringByBulgeType_posList SOAP_UNION_plu__gml__union_ArcStringByBulgeType_coordinates
        int __union_ArcStringByBulgeType;
        union _gml__union_ArcStringByBulgeType union_ArcStringByBulgeType;
        /// Required element 'gml:bulge' of XML schema type 'xsd:double'
        std::vector<double> bulge;
        /// Required element 'gml:normal' of XML schema type 'gml:VectorType'
        std::vector<gml__VectorType *> normal;
        /// Optional attribute 'interpolation' of XML schema type 'gml:CurveInterpolationType'
        enum gml__CurveInterpolationType *interpolation;
        /// Optional attribute 'numArc' of XML schema type 'xsd:long'
        long *numArc;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ArcStringByBulgeType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ArcStringByBulgeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ArcStringByBulgeType, default initialized and not managed by a soap context
        virtual gml__ArcStringByBulgeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ArcStringByBulgeType); }
      public:
        /// Constructor with default initializations
        gml__ArcStringByBulgeType() : __union_ArcStringByBulgeType(), bulge(), normal(), interpolation(), numArc() { }
        virtual ~gml__ArcStringByBulgeType() { }
        /// Friend allocator used by soap_new_gml__ArcStringByBulgeType(struct soap*, int)
        friend SOAP_FMAC1 gml__ArcStringByBulgeType * SOAP_FMAC2 soap_instantiate_gml__ArcStringByBulgeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21804 */
#ifndef SOAP_TYPE_plu__gml__union_ArcByCenterPointType
#define SOAP_TYPE_plu__gml__union_ArcByCenterPointType (-1859)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ArcByCenterPointType
{
        #define SOAP_UNION_plu__gml__union_ArcByCenterPointType_pos	(1)	/**< union variant selector value for member pos */
        gml__DirectPositionType *pos;
        #define SOAP_UNION_plu__gml__union_ArcByCenterPointType_pointProperty	(2)	/**< union variant selector value for member pointProperty */
        gml__PointPropertyType *pointProperty;
        #define SOAP_UNION_plu__gml__union_ArcByCenterPointType_pointRep	(3)	/**< union variant selector value for member pointRep */
        gml__PointPropertyType *pointRep;
        #define SOAP_UNION_plu__gml__union_ArcByCenterPointType_posList	(4)	/**< union variant selector value for member posList */
        gml__DirectPositionListType *posList;
        #define SOAP_UNION_plu__gml__union_ArcByCenterPointType_coordinates	(5)	/**< union variant selector value for member coordinates */
        gml__CoordinatesType *coordinates;
};
#endif

/* PlannedLandUse_v3.0.h:614 */
#ifndef SOAP_TYPE_plu_gml__ArcByCenterPointType
#define SOAP_TYPE_plu_gml__ArcByCenterPointType (-159)
/* complex XML schema type 'gml:ArcByCenterPointType': */
class SOAP_CMAC gml__ArcByCenterPointType : public gml__AbstractCurveSegmentType {
      public:
        /// Union with union _gml__union_ArcByCenterPointType variant selector __union_ArcByCenterPointType set to one of: SOAP_UNION_plu__gml__union_ArcByCenterPointType_pos SOAP_UNION_plu__gml__union_ArcByCenterPointType_pointProperty SOAP_UNION_plu__gml__union_ArcByCenterPointType_pointRep SOAP_UNION_plu__gml__union_ArcByCenterPointType_posList SOAP_UNION_plu__gml__union_ArcByCenterPointType_coordinates
        int __union_ArcByCenterPointType;
        union _gml__union_ArcByCenterPointType union_ArcByCenterPointType;
        /// Required element 'gml:radius' of XML schema type 'gml:LengthType'
        gml__LengthType *radius;
        /// Optional element 'gml:startAngle' of XML schema type 'gml:AngleType'
        gml__AngleType *startAngle;
        /// Optional element 'gml:endAngle' of XML schema type 'gml:AngleType'
        gml__AngleType *endAngle;
        /// Optional attribute 'interpolation' of XML schema type 'gml:CurveInterpolationType'
        enum gml__CurveInterpolationType *interpolation;
        /// Required attribute 'numArc' of XML schema type 'xsd:long'
        long numArc;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ArcByCenterPointType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ArcByCenterPointType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ArcByCenterPointType, default initialized and not managed by a soap context
        virtual gml__ArcByCenterPointType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ArcByCenterPointType); }
      public:
        /// Constructor with default initializations
        gml__ArcByCenterPointType() : __union_ArcByCenterPointType(), radius(), startAngle(), endAngle(), interpolation(), numArc() { }
        virtual ~gml__ArcByCenterPointType() { }
        /// Friend allocator used by soap_new_gml__ArcByCenterPointType(struct soap*, int)
        friend SOAP_FMAC1 gml__ArcByCenterPointType * SOAP_FMAC2 soap_instantiate_gml__ArcByCenterPointType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21868 */
#ifndef SOAP_TYPE_plu__gml__union_CubicSplineType_
#define SOAP_TYPE_plu__gml__union_CubicSplineType_ (-1863)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_CubicSplineType_
{
        #define SOAP_UNION_plu__gml__union_CubicSplineType__pos	(1)	/**< union variant selector value for member pos */
        gml__DirectPositionType *pos;
        #define SOAP_UNION_plu__gml__union_CubicSplineType__pointProperty	(2)	/**< union variant selector value for member pointProperty */
        gml__PointPropertyType *pointProperty;
        #define SOAP_UNION_plu__gml__union_CubicSplineType__pointRep	(3)	/**< union variant selector value for member pointRep */
        gml__PointPropertyType *pointRep;
};
#endif

/* PlannedLandUse_v3.0.h:21864 */
#ifndef SOAP_TYPE_plu___gml__union_CubicSplineType_
#define SOAP_TYPE_plu___gml__union_CubicSplineType_ (-1862)
/* Wrapper: */
class SOAP_CMAC __gml__union_CubicSplineType_ {
      public:
        /// Union with union _gml__union_CubicSplineType_ variant selector __union_CubicSplineType_ set to one of: SOAP_UNION_plu__gml__union_CubicSplineType__pos SOAP_UNION_plu__gml__union_CubicSplineType__pointProperty SOAP_UNION_plu__gml__union_CubicSplineType__pointRep
        int __union_CubicSplineType_;
        union _gml__union_CubicSplineType_ union_CubicSplineType_;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_CubicSplineType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_CubicSplineType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_CubicSplineType_, default initialized and not managed by a soap context
        virtual __gml__union_CubicSplineType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_CubicSplineType_); }
      public:
        /// Constructor with default initializations
        __gml__union_CubicSplineType_() : __union_CubicSplineType_() { }
        virtual ~__gml__union_CubicSplineType_() { }
        /// Friend allocator used by soap_new___gml__union_CubicSplineType_(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_CubicSplineType_ * SOAP_FMAC2 soap_instantiate___gml__union_CubicSplineType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21862 */
#ifndef SOAP_TYPE_plu____gml__union_CubicSplineType_
#define SOAP_TYPE_plu____gml__union_CubicSplineType_ (-1861)
/* Wrapper: */
struct SOAP_CMAC ___gml__union_CubicSplineType_ {
      public:
        /** Sequence of at least 2 elements '-union-CubicSplineType' of XML schema type '-gml:union-CubicSplineType' stored in dynamic array __union_CubicSplineType_ of length __size_CubicSplineType_ */
        int __size_CubicSplineType_;
        __gml__union_CubicSplineType_ *__union_CubicSplineType_;
      public:
        /** Return unique type id SOAP_TYPE_plu____gml__union_CubicSplineType_ */
        long soap_type() const { return SOAP_TYPE_plu____gml__union_CubicSplineType_; }
        /** Friend allocator */
        friend SOAP_FMAC1 ___gml__union_CubicSplineType_ * SOAP_FMAC2 soap_instantiate____gml__union_CubicSplineType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21859 */
#ifndef SOAP_TYPE_plu__gml__union_CubicSplineType
#define SOAP_TYPE_plu__gml__union_CubicSplineType (-1860)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_CubicSplineType
{
        #define SOAP_UNION_plu__gml__union_CubicSplineType___union_CubicSplineType_	(1)	/**< union variant selector value for member __union_CubicSplineType_ */
        struct ___gml__union_CubicSplineType_ __union_CubicSplineType_;
        #define SOAP_UNION_plu__gml__union_CubicSplineType_posList	(2)	/**< union variant selector value for member posList */
        gml__DirectPositionListType *posList;
        #define SOAP_UNION_plu__gml__union_CubicSplineType_coordinates	(3)	/**< union variant selector value for member coordinates */
        gml__CoordinatesType *coordinates;
};
#endif

/* PlannedLandUse_v3.0.h:620 */
#ifndef SOAP_TYPE_plu_gml__CubicSplineType
#define SOAP_TYPE_plu_gml__CubicSplineType (-161)
/* complex XML schema type 'gml:CubicSplineType': */
class SOAP_CMAC gml__CubicSplineType : public gml__AbstractCurveSegmentType {
      public:
        /// Union with union _gml__union_CubicSplineType variant selector __union_CubicSplineType set to one of: SOAP_UNION_plu__gml__union_CubicSplineType___union_CubicSplineType_ SOAP_UNION_plu__gml__union_CubicSplineType_posList SOAP_UNION_plu__gml__union_CubicSplineType_coordinates
        int __union_CubicSplineType;
        union _gml__union_CubicSplineType union_CubicSplineType;
        /// Required element 'gml:vectorAtStart' of XML schema type 'gml:VectorType'
        gml__VectorType *vectorAtStart;
        /// Required element 'gml:vectorAtEnd' of XML schema type 'gml:VectorType'
        gml__VectorType *vectorAtEnd;
        /// Optional attribute 'interpolation' of XML schema type 'gml:CurveInterpolationType'
        enum gml__CurveInterpolationType *interpolation;
        /// Optional attribute 'degree' of XML schema type 'xsd:long'
        long *degree;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CubicSplineType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CubicSplineType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CubicSplineType, default initialized and not managed by a soap context
        virtual gml__CubicSplineType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CubicSplineType); }
      public:
        /// Constructor with default initializations
        gml__CubicSplineType() : __union_CubicSplineType(), vectorAtStart(), vectorAtEnd(), interpolation(), degree() { }
        virtual ~gml__CubicSplineType() { }
        /// Friend allocator used by soap_new_gml__CubicSplineType(struct soap*, int)
        friend SOAP_FMAC1 gml__CubicSplineType * SOAP_FMAC2 soap_instantiate_gml__CubicSplineType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21932 */
#ifndef SOAP_TYPE_plu__gml__union_BSplineType_
#define SOAP_TYPE_plu__gml__union_BSplineType_ (-1868)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_BSplineType_
{
        #define SOAP_UNION_plu__gml__union_BSplineType__pos	(1)	/**< union variant selector value for member pos */
        gml__DirectPositionType *pos;
        #define SOAP_UNION_plu__gml__union_BSplineType__pointProperty	(2)	/**< union variant selector value for member pointProperty */
        gml__PointPropertyType *pointProperty;
        #define SOAP_UNION_plu__gml__union_BSplineType__pointRep	(3)	/**< union variant selector value for member pointRep */
        gml__PointPropertyType *pointRep;
};
#endif

/* PlannedLandUse_v3.0.h:21928 */
#ifndef SOAP_TYPE_plu___gml__union_BSplineType_
#define SOAP_TYPE_plu___gml__union_BSplineType_ (-1867)
/* Wrapper: */
class SOAP_CMAC __gml__union_BSplineType_ {
      public:
        /// Union with union _gml__union_BSplineType_ variant selector __union_BSplineType_ set to one of: SOAP_UNION_plu__gml__union_BSplineType__pos SOAP_UNION_plu__gml__union_BSplineType__pointProperty SOAP_UNION_plu__gml__union_BSplineType__pointRep
        int __union_BSplineType_;
        union _gml__union_BSplineType_ union_BSplineType_;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_BSplineType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_BSplineType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_BSplineType_, default initialized and not managed by a soap context
        virtual __gml__union_BSplineType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_BSplineType_); }
      public:
        /// Constructor with default initializations
        __gml__union_BSplineType_() : __union_BSplineType_() { }
        virtual ~__gml__union_BSplineType_() { }
        /// Friend allocator used by soap_new___gml__union_BSplineType_(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_BSplineType_ * SOAP_FMAC2 soap_instantiate___gml__union_BSplineType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21926 */
#ifndef SOAP_TYPE_plu____gml__union_BSplineType_
#define SOAP_TYPE_plu____gml__union_BSplineType_ (-1866)
/* Wrapper: */
struct SOAP_CMAC ___gml__union_BSplineType_ {
      public:
        /** Sequence of elements '-union-BSplineType' of XML schema type '-gml:union-BSplineType' stored in dynamic array __union_BSplineType_ of length __size_BSplineType_ */
        int __size_BSplineType_;
        __gml__union_BSplineType_ *__union_BSplineType_;
      public:
        /** Return unique type id SOAP_TYPE_plu____gml__union_BSplineType_ */
        long soap_type() const { return SOAP_TYPE_plu____gml__union_BSplineType_; }
        /** Friend allocator */
        friend SOAP_FMAC1 ___gml__union_BSplineType_ * SOAP_FMAC2 soap_instantiate____gml__union_BSplineType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:21923 */
#ifndef SOAP_TYPE_plu__gml__union_BSplineType
#define SOAP_TYPE_plu__gml__union_BSplineType (-1865)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_BSplineType
{
        #define SOAP_UNION_plu__gml__union_BSplineType___union_BSplineType_	(1)	/**< union variant selector value for member __union_BSplineType_ */
        struct ___gml__union_BSplineType_ __union_BSplineType_;
        #define SOAP_UNION_plu__gml__union_BSplineType_posList	(2)	/**< union variant selector value for member posList */
        gml__DirectPositionListType *posList;
        #define SOAP_UNION_plu__gml__union_BSplineType_coordinates	(3)	/**< union variant selector value for member coordinates */
        gml__CoordinatesType *coordinates;
};
#endif

/* PlannedLandUse_v3.0.h:623 */
#ifndef SOAP_TYPE_plu_gml__BSplineType
#define SOAP_TYPE_plu_gml__BSplineType (-162)
/* complex XML schema type 'gml:BSplineType': */
class SOAP_CMAC gml__BSplineType : public gml__AbstractCurveSegmentType {
      public:
        /// Union with union _gml__union_BSplineType variant selector __union_BSplineType set to one of: SOAP_UNION_plu__gml__union_BSplineType___union_BSplineType_ SOAP_UNION_plu__gml__union_BSplineType_posList SOAP_UNION_plu__gml__union_BSplineType_coordinates
        int __union_BSplineType;
        union _gml__union_BSplineType union_BSplineType;
        /// Required element 'gml:degree' of XML schema type 'xsd:nonNegativeInteger'
        ULONG64 degree;
        /// Required element 'gml:knot' of XML schema type 'gml:KnotPropertyType'
        std::vector<gml__KnotPropertyType *> knot;
        /// Optional attribute 'interpolation' of XML schema type 'gml:CurveInterpolationType'
        enum gml__CurveInterpolationType interpolation;	///< initialized with default value = (enum gml__CurveInterpolationType)8
        /// Optional attribute 'isPolynomial' of XML schema type 'xsd:boolean'
        bool *isPolynomial;
        /// Optional attribute 'knotType' of XML schema type 'gml:KnotTypesType'
        enum gml__KnotTypesType *knotType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__BSplineType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__BSplineType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__BSplineType, default initialized and not managed by a soap context
        virtual gml__BSplineType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__BSplineType); }
      public:
        /// Constructor with default initializations
        gml__BSplineType() : __union_BSplineType(), degree(), knot(), interpolation((enum gml__CurveInterpolationType)8), isPolynomial(), knotType() { }
        virtual ~gml__BSplineType() { }
        /// Friend allocator used by soap_new_gml__BSplineType(struct soap*, int)
        friend SOAP_FMAC1 gml__BSplineType * SOAP_FMAC2 soap_instantiate_gml__BSplineType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:635 */
#ifndef SOAP_TYPE_plu_gml__OffsetCurveType
#define SOAP_TYPE_plu_gml__OffsetCurveType (-166)
/* complex XML schema type 'gml:OffsetCurveType': */
class SOAP_CMAC gml__OffsetCurveType : public gml__AbstractCurveSegmentType {
      public:
        /// Required element 'gml:offsetBase' of XML schema type 'gml:CurvePropertyType'
        gml__CurvePropertyType *offsetBase;
        /// Required element 'gml:distance' of XML schema type 'gml:LengthType'
        gml__LengthType *distance;
        /// Optional element 'gml:refDirection' of XML schema type 'gml:VectorType'
        gml__VectorType *refDirection;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__OffsetCurveType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__OffsetCurveType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__OffsetCurveType, default initialized and not managed by a soap context
        virtual gml__OffsetCurveType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__OffsetCurveType); }
      public:
        /// Constructor with default initializations
        gml__OffsetCurveType() : offsetBase(), distance(), refDirection() { }
        virtual ~gml__OffsetCurveType() { }
        /// Friend allocator used by soap_new_gml__OffsetCurveType(struct soap*, int)
        friend SOAP_FMAC1 gml__OffsetCurveType * SOAP_FMAC2 soap_instantiate_gml__OffsetCurveType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:22026 */
#ifndef SOAP_TYPE_plu__gml__ClothoidType_refLocation
#define SOAP_TYPE_plu__gml__ClothoidType_refLocation (-1875)
/* complex XML schema type 'gml:ClothoidType-refLocation': */
class SOAP_CMAC _gml__ClothoidType_refLocation {
      public:
        /// Required element 'gml:AffinePlacement' of XML schema type 'gml:AffinePlacementType'
        gml__AffinePlacementType *AffinePlacement;
      public:
        /// Return unique type id SOAP_TYPE_plu__gml__ClothoidType_refLocation
        virtual long soap_type(void) const { return SOAP_TYPE_plu__gml__ClothoidType_refLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _gml__ClothoidType_refLocation, default initialized and not managed by a soap context
        virtual _gml__ClothoidType_refLocation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_gml__ClothoidType_refLocation); }
      public:
        /// Constructor with default initializations
        _gml__ClothoidType_refLocation() : AffinePlacement() { }
        virtual ~_gml__ClothoidType_refLocation() { }
        /// Friend allocator used by soap_new__gml__ClothoidType_refLocation(struct soap*, int)
        friend SOAP_FMAC1 _gml__ClothoidType_refLocation * SOAP_FMAC2 soap_instantiate__gml__ClothoidType_refLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:641 */
#ifndef SOAP_TYPE_plu_gml__ClothoidType
#define SOAP_TYPE_plu_gml__ClothoidType (-168)
/* complex XML schema type 'gml:ClothoidType': */
class SOAP_CMAC gml__ClothoidType : public gml__AbstractCurveSegmentType {
      public:
        /// Required element 'gml:refLocation' of XML schema type 'gml:ClothoidType-refLocation'
        _gml__ClothoidType_refLocation refLocation;
        /// Required element 'gml:scaleFactor' of XML schema type 'xsd:decimal'
        double scaleFactor;
        /// Required element 'gml:startParameter' of XML schema type 'xsd:double'
        double startParameter;
        /// Required element 'gml:endParameter' of XML schema type 'xsd:double'
        double endParameter;
        /// Optional attribute 'interpolation' of XML schema type 'gml:CurveInterpolationType'
        enum gml__CurveInterpolationType *interpolation;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ClothoidType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ClothoidType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ClothoidType, default initialized and not managed by a soap context
        virtual gml__ClothoidType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ClothoidType); }
      public:
        /// Constructor with default initializations
        gml__ClothoidType() : refLocation(), scaleFactor(), startParameter(), endParameter(), interpolation() { }
        virtual ~gml__ClothoidType() { }
        /// Friend allocator used by soap_new_gml__ClothoidType(struct soap*, int)
        friend SOAP_FMAC1 gml__ClothoidType * SOAP_FMAC2 soap_instantiate_gml__ClothoidType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:22082 */
#ifndef SOAP_TYPE_plu__gml__union_GeodesicStringType_
#define SOAP_TYPE_plu__gml__union_GeodesicStringType_ (-1877)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_GeodesicStringType_
{
        #define SOAP_UNION_plu__gml__union_GeodesicStringType__pos	(1)	/**< union variant selector value for member pos */
        gml__DirectPositionType *pos;
        #define SOAP_UNION_plu__gml__union_GeodesicStringType__pointProperty	(2)	/**< union variant selector value for member pointProperty */
        gml__PointPropertyType *pointProperty;
};
#endif

/* PlannedLandUse_v3.0.h:22078 */
#ifndef SOAP_TYPE_plu___gml__union_GeodesicStringType_
#define SOAP_TYPE_plu___gml__union_GeodesicStringType_ (-1876)
/* Wrapper: */
class SOAP_CMAC __gml__union_GeodesicStringType_ {
      public:
        /// Union with union _gml__union_GeodesicStringType_ variant selector __union_GeodesicStringType_ set to one of: SOAP_UNION_plu__gml__union_GeodesicStringType__pos SOAP_UNION_plu__gml__union_GeodesicStringType__pointProperty
        int __union_GeodesicStringType_;
        union _gml__union_GeodesicStringType_ union_GeodesicStringType_;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_GeodesicStringType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_GeodesicStringType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_GeodesicStringType_, default initialized and not managed by a soap context
        virtual __gml__union_GeodesicStringType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_GeodesicStringType_); }
      public:
        /// Constructor with default initializations
        __gml__union_GeodesicStringType_() : __union_GeodesicStringType_() { }
        virtual ~__gml__union_GeodesicStringType_() { }
        /// Friend allocator used by soap_new___gml__union_GeodesicStringType_(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_GeodesicStringType_ * SOAP_FMAC2 soap_instantiate___gml__union_GeodesicStringType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:644 */
#ifndef SOAP_TYPE_plu_gml__GeodesicStringType
#define SOAP_TYPE_plu_gml__GeodesicStringType (-169)
/* complex XML schema type 'gml:GeodesicStringType': */
class SOAP_CMAC gml__GeodesicStringType : public gml__AbstractCurveSegmentType {
      public:
        /// Optional element 'gml:posList' of XML schema type 'gml:DirectPositionListType'
        gml__DirectPositionListType *posList;
        /// Sequence of at least 2 elements '-union-GeodesicStringType' of XML schema type '-gml:union-GeodesicStringType' stored in dynamic array __union_GeodesicStringType_ of length __size_GeodesicStringType_
        int __size_GeodesicStringType_;
        __gml__union_GeodesicStringType_ *__union_GeodesicStringType_;
        /// Optional attribute 'interpolation' of XML schema type 'gml:CurveInterpolationType'
        enum gml__CurveInterpolationType *interpolation;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GeodesicStringType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GeodesicStringType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeodesicStringType, default initialized and not managed by a soap context
        virtual gml__GeodesicStringType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GeodesicStringType); }
      public:
        /// Constructor with default initializations
        gml__GeodesicStringType() : posList(), __size_GeodesicStringType_(), __union_GeodesicStringType_(), interpolation() { }
        virtual ~gml__GeodesicStringType() { }
        /// Friend allocator used by soap_new_gml__GeodesicStringType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeodesicStringType * SOAP_FMAC2 soap_instantiate_gml__GeodesicStringType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:662 */
#ifndef SOAP_TYPE_plu_gml__PolygonPatchType
#define SOAP_TYPE_plu_gml__PolygonPatchType (-175)
/* complex XML schema type 'gml:PolygonPatchType': */
class SOAP_CMAC gml__PolygonPatchType : public gml__AbstractSurfacePatchType {
      public:
        /// Optional element 'gml:exterior' of XML schema type 'gml:AbstractRingPropertyType'
        gml__AbstractRingPropertyType *exterior;
        /// Optional element 'gml:interior' of XML schema type 'gml:AbstractRingPropertyType'
        std::vector<gml__AbstractRingPropertyType *> interior;
        /// Optional attribute 'interpolation' of XML schema type 'gml:SurfaceInterpolationType'
        enum gml__SurfaceInterpolationType *interpolation;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__PolygonPatchType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__PolygonPatchType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__PolygonPatchType, default initialized and not managed by a soap context
        virtual gml__PolygonPatchType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__PolygonPatchType); }
      public:
        /// Constructor with default initializations
        gml__PolygonPatchType() : exterior(), interior(), interpolation() { }
        virtual ~gml__PolygonPatchType() { }
        /// Friend allocator used by soap_new_gml__PolygonPatchType(struct soap*, int)
        friend SOAP_FMAC1 gml__PolygonPatchType * SOAP_FMAC2 soap_instantiate_gml__PolygonPatchType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:665 */
#ifndef SOAP_TYPE_plu_gml__TriangleType
#define SOAP_TYPE_plu_gml__TriangleType (-176)
/* complex XML schema type 'gml:TriangleType': */
class SOAP_CMAC gml__TriangleType : public gml__AbstractSurfacePatchType {
      public:
        /// Required element 'gml:exterior' of XML schema type 'gml:AbstractRingPropertyType'
        gml__AbstractRingPropertyType *exterior;
        /// Optional attribute 'interpolation' of XML schema type 'gml:SurfaceInterpolationType'
        enum gml__SurfaceInterpolationType *interpolation;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TriangleType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TriangleType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TriangleType, default initialized and not managed by a soap context
        virtual gml__TriangleType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TriangleType); }
      public:
        /// Constructor with default initializations
        gml__TriangleType() : exterior(), interpolation() { }
        virtual ~gml__TriangleType() { }
        /// Friend allocator used by soap_new_gml__TriangleType(struct soap*, int)
        friend SOAP_FMAC1 gml__TriangleType * SOAP_FMAC2 soap_instantiate_gml__TriangleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:668 */
#ifndef SOAP_TYPE_plu_gml__RectangleType
#define SOAP_TYPE_plu_gml__RectangleType (-177)
/* complex XML schema type 'gml:RectangleType': */
class SOAP_CMAC gml__RectangleType : public gml__AbstractSurfacePatchType {
      public:
        /// Required element 'gml:exterior' of XML schema type 'gml:AbstractRingPropertyType'
        gml__AbstractRingPropertyType *exterior;
        /// Optional attribute 'interpolation' of XML schema type 'gml:SurfaceInterpolationType'
        enum gml__SurfaceInterpolationType *interpolation;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__RectangleType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__RectangleType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__RectangleType, default initialized and not managed by a soap context
        virtual gml__RectangleType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__RectangleType); }
      public:
        /// Constructor with default initializations
        gml__RectangleType() : exterior(), interpolation() { }
        virtual ~gml__RectangleType() { }
        /// Friend allocator used by soap_new_gml__RectangleType(struct soap*, int)
        friend SOAP_FMAC1 gml__RectangleType * SOAP_FMAC2 soap_instantiate_gml__RectangleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:677 */
#ifndef SOAP_TYPE_plu_gml__AbstractParametricCurveSurfaceType
#define SOAP_TYPE_plu_gml__AbstractParametricCurveSurfaceType (-180)
/* simple XML schema type 'gml:AbstractParametricCurveSurfaceType': */
class SOAP_CMAC gml__AbstractParametricCurveSurfaceType : public gml__AbstractSurfacePatchType {
      public:
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractParametricCurveSurfaceType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractParametricCurveSurfaceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractParametricCurveSurfaceType, default initialized and not managed by a soap context
        virtual gml__AbstractParametricCurveSurfaceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractParametricCurveSurfaceType); }
      public:
        /// Constructor with default initializations
        gml__AbstractParametricCurveSurfaceType() : aggregationType() { }
        virtual ~gml__AbstractParametricCurveSurfaceType() { }
        /// Friend allocator used by soap_new_gml__AbstractParametricCurveSurfaceType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractParametricCurveSurfaceType * SOAP_FMAC2 soap_instantiate_gml__AbstractParametricCurveSurfaceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:740 */
#ifndef SOAP_TYPE_plu_gml__AbstractGeometryType
#define SOAP_TYPE_plu_gml__AbstractGeometryType (-201)
/* complex XML schema type 'gml:AbstractGeometryType': */
class SOAP_CMAC gml__AbstractGeometryType : public gml__AbstractGMLType {
      public:
        /// Optional attribute 'srsName' of XML schema type 'xsd:anyURI'
        char **srsName;
        /// Optional attribute 'srsDimension' of XML schema type 'xsd:positiveInteger'
        ULONG64 *srsDimension;
        /// Optional attribute 'axisLabels' of XML schema type 'gml:NCNameList'
        std::string *axisLabels;
        /// Optional attribute 'uomLabels' of XML schema type 'gml:NCNameList'
        std::string *uomLabels;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractGeometryType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractGeometryType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractGeometryType, default initialized and not managed by a soap context
        virtual gml__AbstractGeometryType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractGeometryType); }
      public:
        /// Constructor with default initializations
        gml__AbstractGeometryType() : srsName(), srsDimension(), axisLabels(), uomLabels() { }
        virtual ~gml__AbstractGeometryType() { }
        /// Friend allocator used by soap_new_gml__AbstractGeometryType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractGeometryType * SOAP_FMAC2 soap_instantiate_gml__AbstractGeometryType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:749 */
#ifndef SOAP_TYPE_plu_gml__DirectPositionType
#define SOAP_TYPE_plu_gml__DirectPositionType (-204)
/* simple XML schema type 'gml:DirectPositionType': */
class SOAP_CMAC gml__DirectPositionType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:doubleList' wrapped by this struct
        std::string __item;
        /// Optional attribute 'srsName' of XML schema type 'xsd:anyURI'
        char **srsName;
        /// Optional attribute 'srsDimension' of XML schema type 'xsd:positiveInteger'
        ULONG64 *srsDimension;
        /// Optional attribute 'axisLabels' of XML schema type 'gml:NCNameList'
        std::string *axisLabels;
        /// Optional attribute 'uomLabels' of XML schema type 'gml:NCNameList'
        std::string *uomLabels;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DirectPositionType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DirectPositionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DirectPositionType, default initialized and not managed by a soap context
        virtual gml__DirectPositionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DirectPositionType); }
      public:
        /// Constructor with default initializations
        gml__DirectPositionType() : __item(), srsName(), srsDimension(), axisLabels(), uomLabels() { }
        virtual ~gml__DirectPositionType() { }
        /// Friend allocator used by soap_new_gml__DirectPositionType(struct soap*, int)
        friend SOAP_FMAC1 gml__DirectPositionType * SOAP_FMAC2 soap_instantiate_gml__DirectPositionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:752 */
#ifndef SOAP_TYPE_plu_gml__DirectPositionListType
#define SOAP_TYPE_plu_gml__DirectPositionListType (-205)
/* simple XML schema type 'gml:DirectPositionListType': */
class SOAP_CMAC gml__DirectPositionListType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:doubleList' wrapped by this struct
        std::string __item;
        /// Optional attribute 'count' of XML schema type 'xsd:positiveInteger'
        ULONG64 *count;
        /// Optional attribute 'srsName' of XML schema type 'xsd:anyURI'
        char **srsName;
        /// Optional attribute 'srsDimension' of XML schema type 'xsd:positiveInteger'
        ULONG64 *srsDimension;
        /// Optional attribute 'axisLabels' of XML schema type 'gml:NCNameList'
        std::string *axisLabels;
        /// Optional attribute 'uomLabels' of XML schema type 'gml:NCNameList'
        std::string *uomLabels;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DirectPositionListType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DirectPositionListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DirectPositionListType, default initialized and not managed by a soap context
        virtual gml__DirectPositionListType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DirectPositionListType); }
      public:
        /// Constructor with default initializations
        gml__DirectPositionListType() : __item(), count(), srsName(), srsDimension(), axisLabels(), uomLabels() { }
        virtual ~gml__DirectPositionListType() { }
        /// Friend allocator used by soap_new_gml__DirectPositionListType(struct soap*, int)
        friend SOAP_FMAC1 gml__DirectPositionListType * SOAP_FMAC2 soap_instantiate_gml__DirectPositionListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:824 */
#ifndef SOAP_TYPE_plu_gml__DerivationUnitTermType
#define SOAP_TYPE_plu_gml__DerivationUnitTermType (-229)
/* simple XML schema type 'gml:DerivationUnitTermType': */
class SOAP_CMAC gml__DerivationUnitTermType : public gml__UnitOfMeasureType {
      public:
        /// Optional attribute 'exponent' of XML schema type 'xsd:long'
        long *exponent;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DerivationUnitTermType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DerivationUnitTermType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DerivationUnitTermType, default initialized and not managed by a soap context
        virtual gml__DerivationUnitTermType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DerivationUnitTermType); }
      public:
        /// Constructor with default initializations
        gml__DerivationUnitTermType() : exponent() { }
        virtual ~gml__DerivationUnitTermType() { }
        /// Friend allocator used by soap_new_gml__DerivationUnitTermType(struct soap*, int)
        friend SOAP_FMAC1 gml__DerivationUnitTermType * SOAP_FMAC2 soap_instantiate_gml__DerivationUnitTermType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:22385 */
#ifndef SOAP_TYPE_plu__gml__union_ConversionToPreferredUnitType
#define SOAP_TYPE_plu__gml__union_ConversionToPreferredUnitType (-1883)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ConversionToPreferredUnitType
{
        #define SOAP_UNION_plu__gml__union_ConversionToPreferredUnitType_factor	(1)	/**< union variant selector value for member factor */
        double factor;
        #define SOAP_UNION_plu__gml__union_ConversionToPreferredUnitType_formula	(2)	/**< union variant selector value for member formula */
        gml__FormulaType *formula;
};
#endif

/* PlannedLandUse_v3.0.h:830 */
#ifndef SOAP_TYPE_plu_gml__ConversionToPreferredUnitType
#define SOAP_TYPE_plu_gml__ConversionToPreferredUnitType (-231)
/* complex XML schema type 'gml:ConversionToPreferredUnitType': */
class SOAP_CMAC gml__ConversionToPreferredUnitType : public gml__UnitOfMeasureType {
      public:
        /// Union with union _gml__union_ConversionToPreferredUnitType variant selector __union_ConversionToPreferredUnitType set to one of: SOAP_UNION_plu__gml__union_ConversionToPreferredUnitType_factor SOAP_UNION_plu__gml__union_ConversionToPreferredUnitType_formula
        int __union_ConversionToPreferredUnitType;
        union _gml__union_ConversionToPreferredUnitType union_ConversionToPreferredUnitType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ConversionToPreferredUnitType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ConversionToPreferredUnitType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ConversionToPreferredUnitType, default initialized and not managed by a soap context
        virtual gml__ConversionToPreferredUnitType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ConversionToPreferredUnitType); }
      public:
        /// Constructor with default initializations
        gml__ConversionToPreferredUnitType() : __union_ConversionToPreferredUnitType() { }
        virtual ~gml__ConversionToPreferredUnitType() { }
        /// Friend allocator used by soap_new_gml__ConversionToPreferredUnitType(struct soap*, int)
        friend SOAP_FMAC1 gml__ConversionToPreferredUnitType * SOAP_FMAC2 soap_instantiate_gml__ConversionToPreferredUnitType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:836 */
#ifndef SOAP_TYPE_plu_gml__DefinitionBaseType
#define SOAP_TYPE_plu_gml__DefinitionBaseType (-233)
/* complex XML schema type 'gml:DefinitionBaseType': */
class SOAP_CMAC gml__DefinitionBaseType : public xsd__anyType {
      public:
        /// Optional element 'gml:metaDataProperty' of XML schema type 'gml:MetaDataPropertyType'
        std::vector<gml__MetaDataPropertyType *> metaDataProperty;
        /// Optional element 'gml:description' of XML schema type 'gml:StringOrRefType'
        gml__StringOrRefType *description;
        /// Optional element 'gml:descriptionReference' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *descriptionReference;
        /// Required element 'gml:identifier' of XML schema type 'gml:CodeWithAuthorityType'
        gml__CodeWithAuthorityType *identifier;
        /// Optional element 'gml:name' of XML schema type 'gml:CodeType'
        std::vector<gml__CodeType *> name;
        /// Required attribute 'gml:id' of XML schema type 'xsd:ID'
        char *gml__id;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DefinitionBaseType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DefinitionBaseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DefinitionBaseType, default initialized and not managed by a soap context
        virtual gml__DefinitionBaseType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DefinitionBaseType); }
      public:
        /// Constructor with default initializations
        gml__DefinitionBaseType() : metaDataProperty(), description(), descriptionReference(), identifier(), name(), gml__id() { }
        virtual ~gml__DefinitionBaseType() { }
        /// Friend allocator used by soap_new_gml__DefinitionBaseType(struct soap*, int)
        friend SOAP_FMAC1 gml__DefinitionBaseType * SOAP_FMAC2 soap_instantiate_gml__DefinitionBaseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:22476 */
#ifndef SOAP_TYPE_plu__gml__union_DictionaryEntryType
#define SOAP_TYPE_plu__gml__union_DictionaryEntryType (-1886)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_DictionaryEntryType
{
        #define SOAP_UNION_plu__gml__union_DictionaryEntryType_Definition	(1)	/**< union variant selector value for member Definition */
        gml__DefinitionType *Definition;
        #define SOAP_UNION_plu__gml__union_DictionaryEntryType_UnitDefinition	(2)	/**< union variant selector value for member UnitDefinition */
        gml__UnitDefinitionType *UnitDefinition;
        #define SOAP_UNION_plu__gml__union_DictionaryEntryType_BaseUnit	(3)	/**< union variant selector value for member BaseUnit */
        gml__BaseUnitType *BaseUnit;
        #define SOAP_UNION_plu__gml__union_DictionaryEntryType_DerivedUnit	(4)	/**< union variant selector value for member DerivedUnit */
        gml__DerivedUnitType *DerivedUnit;
        #define SOAP_UNION_plu__gml__union_DictionaryEntryType_ConventionalUnit	(5)	/**< union variant selector value for member ConventionalUnit */
        gml__ConventionalUnitType *ConventionalUnit;
        #define SOAP_UNION_plu__gml__union_DictionaryEntryType_Dictionary	(6)	/**< union variant selector value for member Dictionary */
        gml__DictionaryType *Dictionary;
        #define SOAP_UNION_plu__gml__union_DictionaryEntryType_CoordinateSystemAxis	(7)	/**< union variant selector value for member CoordinateSystemAxis */
        gml__CoordinateSystemAxisType *CoordinateSystemAxis;
        #define SOAP_UNION_plu__gml__union_DictionaryEntryType_Ellipsoid	(8)	/**< union variant selector value for member Ellipsoid */
        gml__EllipsoidType *Ellipsoid;
        #define SOAP_UNION_plu__gml__union_DictionaryEntryType_PrimeMeridian	(9)	/**< union variant selector value for member PrimeMeridian */
        gml__PrimeMeridianType *PrimeMeridian;
        #define SOAP_UNION_plu__gml__union_DictionaryEntryType_OperationMethod	(10)	/**< union variant selector value for member OperationMethod */
        gml__OperationMethodType *OperationMethod;
        #define SOAP_UNION_plu__gml__union_DictionaryEntryType_TimeReferenceSystem	(11)	/**< union variant selector value for member TimeReferenceSystem */
        gml__TimeReferenceSystemType *TimeReferenceSystem;
        #define SOAP_UNION_plu__gml__union_DictionaryEntryType_TimeCoordinateSystem	(12)	/**< union variant selector value for member TimeCoordinateSystem */
        gml__TimeCoordinateSystemType *TimeCoordinateSystem;
        #define SOAP_UNION_plu__gml__union_DictionaryEntryType_TimeCalendar	(13)	/**< union variant selector value for member TimeCalendar */
        gml__TimeCalendarType *TimeCalendar;
        #define SOAP_UNION_plu__gml__union_DictionaryEntryType_TimeClock	(14)	/**< union variant selector value for member TimeClock */
        gml__TimeClockType *TimeClock;
        #define SOAP_UNION_plu__gml__union_DictionaryEntryType_TimeOrdinalReferenceSystem	(15)	/**< union variant selector value for member TimeOrdinalReferenceSystem */
        gml__TimeOrdinalReferenceSystemType *TimeOrdinalReferenceSystem;
        #define SOAP_UNION_plu__gml__union_DictionaryEntryType_DefinitionCollection	(16)	/**< union variant selector value for member DefinitionCollection */
        gml__DictionaryType *DefinitionCollection;
        #define SOAP_UNION_plu__gml__union_DictionaryEntryType_DefinitionProxy	(17)	/**< union variant selector value for member DefinitionProxy */
        gml__DefinitionProxyType *DefinitionProxy;
};
#endif

/* PlannedLandUse_v3.0.h:22465 */
#ifndef SOAP_TYPE_plu___gml__DictionaryEntryType_sequence
#define SOAP_TYPE_plu___gml__DictionaryEntryType_sequence (-1885)
/* Wrapper: */
class SOAP_CMAC __gml__DictionaryEntryType_sequence {
      public:
        /// Union with union _gml__union_DictionaryEntryType variant selector __unionDefinition set to one of: SOAP_UNION_plu__gml__union_DictionaryEntryType_Definition SOAP_UNION_plu__gml__union_DictionaryEntryType_UnitDefinition SOAP_UNION_plu__gml__union_DictionaryEntryType_BaseUnit SOAP_UNION_plu__gml__union_DictionaryEntryType_DerivedUnit SOAP_UNION_plu__gml__union_DictionaryEntryType_ConventionalUnit SOAP_UNION_plu__gml__union_DictionaryEntryType_Dictionary SOAP_UNION_plu__gml__union_DictionaryEntryType_CoordinateSystemAxis SOAP_UNION_plu__gml__union_DictionaryEntryType_Ellipsoid SOAP_UNION_plu__gml__union_DictionaryEntryType_PrimeMeridian SOAP_UNION_plu__gml__union_DictionaryEntryType_OperationMethod SOAP_UNION_plu__gml__union_DictionaryEntryType_TimeReferenceSystem SOAP_UNION_plu__gml__union_DictionaryEntryType_TimeCoordinateSystem SOAP_UNION_plu__gml__union_DictionaryEntryType_TimeCalendar SOAP_UNION_plu__gml__union_DictionaryEntryType_TimeClock SOAP_UNION_plu__gml__union_DictionaryEntryType_TimeOrdinalReferenceSystem SOAP_UNION_plu__gml__union_DictionaryEntryType_DefinitionCollection SOAP_UNION_plu__gml__union_DictionaryEntryType_DefinitionProxy
        int __unionDefinition;
        union _gml__union_DictionaryEntryType union_DictionaryEntryType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__DictionaryEntryType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__DictionaryEntryType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__DictionaryEntryType_sequence, default initialized and not managed by a soap context
        virtual __gml__DictionaryEntryType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__DictionaryEntryType_sequence); }
      public:
        /// Constructor with default initializations
        __gml__DictionaryEntryType_sequence() : __unionDefinition() { }
        virtual ~__gml__DictionaryEntryType_sequence() { }
        /// Friend allocator used by soap_new___gml__DictionaryEntryType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__DictionaryEntryType_sequence * SOAP_FMAC2 soap_instantiate___gml__DictionaryEntryType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:845 */
#ifndef SOAP_TYPE_plu_gml__DictionaryEntryType
#define SOAP_TYPE_plu_gml__DictionaryEntryType (-236)
/* complex XML schema type 'gml:DictionaryEntryType': */
class SOAP_CMAC gml__DictionaryEntryType : public gml__AbstractMemberType {
      public:
        __gml__DictionaryEntryType_sequence *__DictionaryEntryType_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DictionaryEntryType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DictionaryEntryType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DictionaryEntryType, default initialized and not managed by a soap context
        virtual gml__DictionaryEntryType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DictionaryEntryType); }
      public:
        /// Constructor with default initializations
        gml__DictionaryEntryType() : __DictionaryEntryType_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__DictionaryEntryType() { }
        /// Friend allocator used by soap_new_gml__DictionaryEntryType(struct soap*, int)
        friend SOAP_FMAC1 gml__DictionaryEntryType * SOAP_FMAC2 soap_instantiate_gml__DictionaryEntryType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:866 */
#ifndef SOAP_TYPE_plu_gml__CodeType
#define SOAP_TYPE_plu_gml__CodeType (-243)
/* simple XML schema type 'gml:CodeType': */
class SOAP_CMAC gml__CodeType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'codeSpace' of XML schema type 'xsd:anyURI'
        char **codeSpace;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CodeType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CodeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CodeType, default initialized and not managed by a soap context
        virtual gml__CodeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CodeType); }
      public:
        /// Constructor with default initializations
        gml__CodeType() : __item(), codeSpace() { }
        virtual ~gml__CodeType() { }
        /// Friend allocator used by soap_new_gml__CodeType(struct soap*, int)
        friend SOAP_FMAC1 gml__CodeType * SOAP_FMAC2 soap_instantiate_gml__CodeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:872 */
#ifndef SOAP_TYPE_plu_gml__MeasureType
#define SOAP_TYPE_plu_gml__MeasureType (-245)
/* simple XML schema type 'gml:MeasureType': */
class SOAP_CMAC gml__MeasureType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:double' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'gml:UomIdentifier'
        std::string uom;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__MeasureType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__MeasureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__MeasureType, default initialized and not managed by a soap context
        virtual gml__MeasureType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__MeasureType); }
      public:
        /// Constructor with default initializations
        gml__MeasureType() : __item(), uom() { }
        virtual ~gml__MeasureType() { }
        /// Friend allocator used by soap_new_gml__MeasureType(struct soap*, int)
        friend SOAP_FMAC1 gml__MeasureType * SOAP_FMAC2 soap_instantiate_gml__MeasureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:875 */
#ifndef SOAP_TYPE_plu_gml__CoordinatesType
#define SOAP_TYPE_plu_gml__CoordinatesType (-246)
/* simple XML schema type 'gml:CoordinatesType': */
class SOAP_CMAC gml__CoordinatesType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'decimal' of XML schema type 'xsd:string'
        std::string decimal;	///< initialized with default value = "."
        /// Optional attribute 'cs' of XML schema type 'xsd:string'
        std::string cs;	///< initialized with default value = ","
        /// Optional attribute 'ts' of XML schema type 'xsd:string'
        std::string ts;	///< initialized with default value = " "
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CoordinatesType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CoordinatesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CoordinatesType, default initialized and not managed by a soap context
        virtual gml__CoordinatesType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CoordinatesType); }
      public:
        /// Constructor with default initializations
        gml__CoordinatesType() : __item(), decimal("."), cs(","), ts(" ") { }
        virtual ~gml__CoordinatesType() { }
        /// Friend allocator used by soap_new_gml__CoordinatesType(struct soap*, int)
        friend SOAP_FMAC1 gml__CoordinatesType * SOAP_FMAC2 soap_instantiate_gml__CoordinatesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:878 */
#ifndef SOAP_TYPE_plu_gml__CodeListType
#define SOAP_TYPE_plu_gml__CodeListType (-247)
/* simple XML schema type 'gml:CodeListType': */
class SOAP_CMAC gml__CodeListType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:NameList' wrapped by this struct
        std::string __item;
        /// Optional attribute 'codeSpace' of XML schema type 'xsd:anyURI'
        char **codeSpace;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CodeListType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CodeListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CodeListType, default initialized and not managed by a soap context
        virtual gml__CodeListType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CodeListType); }
      public:
        /// Constructor with default initializations
        gml__CodeListType() : __item(), codeSpace() { }
        virtual ~gml__CodeListType() { }
        /// Friend allocator used by soap_new_gml__CodeListType(struct soap*, int)
        friend SOAP_FMAC1 gml__CodeListType * SOAP_FMAC2 soap_instantiate_gml__CodeListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:881 */
#ifndef SOAP_TYPE_plu_gml__CodeOrNilReasonListType
#define SOAP_TYPE_plu_gml__CodeOrNilReasonListType (-248)
/* simple XML schema type 'gml:CodeOrNilReasonListType': */
class SOAP_CMAC gml__CodeOrNilReasonListType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:NameOrNilReasonList' wrapped by this struct
        std::string __item;
        /// Optional attribute 'codeSpace' of XML schema type 'xsd:anyURI'
        char **codeSpace;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CodeOrNilReasonListType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CodeOrNilReasonListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CodeOrNilReasonListType, default initialized and not managed by a soap context
        virtual gml__CodeOrNilReasonListType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CodeOrNilReasonListType); }
      public:
        /// Constructor with default initializations
        gml__CodeOrNilReasonListType() : __item(), codeSpace() { }
        virtual ~gml__CodeOrNilReasonListType() { }
        /// Friend allocator used by soap_new_gml__CodeOrNilReasonListType(struct soap*, int)
        friend SOAP_FMAC1 gml__CodeOrNilReasonListType * SOAP_FMAC2 soap_instantiate_gml__CodeOrNilReasonListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:884 */
#ifndef SOAP_TYPE_plu_gml__MeasureListType
#define SOAP_TYPE_plu_gml__MeasureListType (-249)
/* simple XML schema type 'gml:MeasureListType': */
class SOAP_CMAC gml__MeasureListType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:doubleList' wrapped by this struct
        std::string __item;
        /// Required attribute 'uom' of XML schema type 'gml:UomIdentifier'
        std::string uom;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__MeasureListType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__MeasureListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__MeasureListType, default initialized and not managed by a soap context
        virtual gml__MeasureListType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__MeasureListType); }
      public:
        /// Constructor with default initializations
        gml__MeasureListType() : __item(), uom() { }
        virtual ~gml__MeasureListType() { }
        /// Friend allocator used by soap_new_gml__MeasureListType(struct soap*, int)
        friend SOAP_FMAC1 gml__MeasureListType * SOAP_FMAC2 soap_instantiate_gml__MeasureListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:887 */
#ifndef SOAP_TYPE_plu_gml__MeasureOrNilReasonListType
#define SOAP_TYPE_plu_gml__MeasureOrNilReasonListType (-250)
/* simple XML schema type 'gml:MeasureOrNilReasonListType': */
class SOAP_CMAC gml__MeasureOrNilReasonListType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:doubleOrNilReasonList' wrapped by this struct
        std::string __item;
        /// Required attribute 'uom' of XML schema type 'gml:UomIdentifier'
        std::string uom;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__MeasureOrNilReasonListType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__MeasureOrNilReasonListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__MeasureOrNilReasonListType, default initialized and not managed by a soap context
        virtual gml__MeasureOrNilReasonListType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__MeasureOrNilReasonListType); }
      public:
        /// Constructor with default initializations
        gml__MeasureOrNilReasonListType() : __item(), uom() { }
        virtual ~gml__MeasureOrNilReasonListType() { }
        /// Friend allocator used by soap_new_gml__MeasureOrNilReasonListType(struct soap*, int)
        friend SOAP_FMAC1 gml__MeasureOrNilReasonListType * SOAP_FMAC2 soap_instantiate_gml__MeasureOrNilReasonListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:22842 */
#ifndef SOAP_TYPE_plu__gml__union_AbstractFeatureType
#define SOAP_TYPE_plu__gml__union_AbstractFeatureType (-1894)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_AbstractFeatureType
{
        #define SOAP_UNION_plu__gml__union_AbstractFeatureType_location	(1)	/**< union variant selector value for member location */
        gml__LocationPropertyType *location;
        #define SOAP_UNION_plu__gml__union_AbstractFeatureType_priorityLocation	(2)	/**< union variant selector value for member priorityLocation */
        gml__PriorityLocationPropertyType *priorityLocation;
};
#endif

/* PlannedLandUse_v3.0.h:923 */
#ifndef SOAP_TYPE_plu_gml__AbstractFeatureType
#define SOAP_TYPE_plu_gml__AbstractFeatureType (-262)
/* complex XML schema type 'gml:AbstractFeatureType': */
class SOAP_CMAC gml__AbstractFeatureType : public gml__AbstractGMLType {
      public:
        /// Optional element 'gml:boundedBy' of XML schema type 'gml:BoundingShapeType'
        gml__BoundingShapeType *boundedBy;
        /// Union with union _gml__union_AbstractFeatureType variant selector __unionlocation set to one of: SOAP_UNION_plu__gml__union_AbstractFeatureType_location SOAP_UNION_plu__gml__union_AbstractFeatureType_priorityLocation
        int __unionlocation;
        union _gml__union_AbstractFeatureType union_AbstractFeatureType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractFeatureType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractFeatureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractFeatureType, default initialized and not managed by a soap context
        virtual gml__AbstractFeatureType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractFeatureType); }
      public:
        /// Constructor with default initializations
        gml__AbstractFeatureType() : boundedBy(), __unionlocation() { }
        virtual ~gml__AbstractFeatureType() { }
        /// Friend allocator used by soap_new_gml__AbstractFeatureType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractFeatureType * SOAP_FMAC2 soap_instantiate_gml__AbstractFeatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:932 */
#ifndef SOAP_TYPE_plu_gml__EnvelopeWithTimePeriodType
#define SOAP_TYPE_plu_gml__EnvelopeWithTimePeriodType (-265)
/* complex XML schema type 'gml:EnvelopeWithTimePeriodType': */
class SOAP_CMAC gml__EnvelopeWithTimePeriodType : public gml__EnvelopeType {
      public:
        /// Required element 'gml:beginPosition' of XML schema type 'gml:TimePositionType'
        gml__TimePositionType *beginPosition;
        /// Required element 'gml:endPosition' of XML schema type 'gml:TimePositionType'
        gml__TimePositionType *endPosition;
        /// Optional attribute 'frame' of XML schema type 'xsd:anyURI'
        char *frame;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__EnvelopeWithTimePeriodType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__EnvelopeWithTimePeriodType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__EnvelopeWithTimePeriodType, default initialized and not managed by a soap context
        virtual gml__EnvelopeWithTimePeriodType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__EnvelopeWithTimePeriodType); }
      public:
        /// Constructor with default initializations
        gml__EnvelopeWithTimePeriodType() : beginPosition(), endPosition(), frame() { }
        virtual ~gml__EnvelopeWithTimePeriodType() { }
        /// Friend allocator used by soap_new_gml__EnvelopeWithTimePeriodType(struct soap*, int)
        friend SOAP_FMAC1 gml__EnvelopeWithTimePeriodType * SOAP_FMAC2 soap_instantiate_gml__EnvelopeWithTimePeriodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:938 */
#ifndef SOAP_TYPE_plu_gml__AbstractTimeObjectType
#define SOAP_TYPE_plu_gml__AbstractTimeObjectType (-267)
/* complex XML schema type 'gml:AbstractTimeObjectType': */
class SOAP_CMAC gml__AbstractTimeObjectType : public gml__AbstractGMLType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractTimeObjectType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractTimeObjectType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractTimeObjectType, default initialized and not managed by a soap context
        virtual gml__AbstractTimeObjectType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractTimeObjectType); }
      public:
        /// Constructor with default initializations
        gml__AbstractTimeObjectType() { }
        virtual ~gml__AbstractTimeObjectType() { }
        /// Friend allocator used by soap_new_gml__AbstractTimeObjectType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractTimeObjectType * SOAP_FMAC2 soap_instantiate_gml__AbstractTimeObjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:947 */
#ifndef SOAP_TYPE_plu_gml__RelatedTimeType
#define SOAP_TYPE_plu_gml__RelatedTimeType (-270)
/* complex XML schema type 'gml:RelatedTimeType': */
class SOAP_CMAC gml__RelatedTimeType : public gml__TimePrimitivePropertyType {
      public:
        /// Optional attribute 'relativePosition' of XML schema type 'gml:RelatedTimeType-relativePosition'
        enum _gml__RelatedTimeType_relativePosition *relativePosition;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__RelatedTimeType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__RelatedTimeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__RelatedTimeType, default initialized and not managed by a soap context
        virtual gml__RelatedTimeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__RelatedTimeType); }
      public:
        /// Constructor with default initializations
        gml__RelatedTimeType() : relativePosition() { }
        virtual ~gml__RelatedTimeType() { }
        /// Friend allocator used by soap_new_gml__RelatedTimeType(struct soap*, int)
        friend SOAP_FMAC1 gml__RelatedTimeType * SOAP_FMAC2 soap_instantiate_gml__RelatedTimeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:968 */
#ifndef SOAP_TYPE_plu_gml__TimePositionType
#define SOAP_TYPE_plu_gml__TimePositionType (-277)
/* simple XML schema type 'gml:TimePositionType': */
class SOAP_CMAC gml__TimePositionType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:TimePositionUnion' wrapped by this struct
        std::string __item;
        /// Optional attribute 'frame' of XML schema type 'xsd:anyURI'
        char *frame;
        /// Optional attribute 'calendarEraName' of XML schema type 'xsd:string'
        std::string *calendarEraName;
        /// Optional attribute 'indeterminatePosition' of XML schema type 'gml:TimeIndeterminateValueType'
        enum gml__TimeIndeterminateValueType *indeterminatePosition;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimePositionType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimePositionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimePositionType, default initialized and not managed by a soap context
        virtual gml__TimePositionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimePositionType); }
      public:
        /// Constructor with default initializations
        gml__TimePositionType() : __item(), frame(), calendarEraName(), indeterminatePosition() { }
        virtual ~gml__TimePositionType() { }
        /// Friend allocator used by soap_new_gml__TimePositionType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimePositionType * SOAP_FMAC2 soap_instantiate_gml__TimePositionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:971 */
#ifndef SOAP_TYPE_plu_gml__TimeIntervalLengthType
#define SOAP_TYPE_plu_gml__TimeIntervalLengthType (-278)
/* simple XML schema type 'gml:TimeIntervalLengthType': */
class SOAP_CMAC gml__TimeIntervalLengthType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:decimal' wrapped by this struct
        double __item;
        /// Required attribute 'unit' of XML schema type 'gml:TimeUnitType'
        std::string unit;
        /// Optional attribute 'radix' of XML schema type 'xsd:positiveInteger'
        ULONG64 *radix;
        /// Optional attribute 'factor' of XML schema type 'xsd:long'
        long *factor;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeIntervalLengthType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeIntervalLengthType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeIntervalLengthType, default initialized and not managed by a soap context
        virtual gml__TimeIntervalLengthType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeIntervalLengthType); }
      public:
        /// Constructor with default initializations
        gml__TimeIntervalLengthType() : __item(), unit(), radix(), factor() { }
        virtual ~gml__TimeIntervalLengthType() { }
        /// Friend allocator used by soap_new_gml__TimeIntervalLengthType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeIntervalLengthType * SOAP_FMAC2 soap_instantiate_gml__TimeIntervalLengthType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:980 */
#ifndef SOAP_TYPE_plu_gml__CompositeValueType
#define SOAP_TYPE_plu_gml__CompositeValueType (-281)
/* Type gml__CompositeValueType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gml:CompositeValueType': */
class SOAP_CMAC gml__CompositeValueType : public gml__AbstractGMLType {
      public:
        /// Optional element 'gml:valueComponent' of XML schema type 'gml:ValuePropertyType'
        std::vector<gml__ValuePropertyType *> valueComponent;
        /// Optional element 'gml:valueComponents' of XML schema type 'gml:ValueArrayPropertyType'
        gml__ValueArrayPropertyType *valueComponents;
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CompositeValueType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CompositeValueType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CompositeValueType, default initialized and not managed by a soap context
        virtual gml__CompositeValueType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CompositeValueType); }
      public:
        /// Constructor with default initializations
        gml__CompositeValueType() : valueComponent(), valueComponents(), aggregationType() { }
        virtual ~gml__CompositeValueType() { }
        /// Friend allocator used by soap_new_gml__CompositeValueType(struct soap*, int)
        friend SOAP_FMAC1 gml__CompositeValueType * SOAP_FMAC2 soap_instantiate_gml__CompositeValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:23161 */
#ifndef SOAP_TYPE_plu__gml__union_ParameterValueType
#define SOAP_TYPE_plu__gml__union_ParameterValueType (-1904)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ParameterValueType
{
        #define SOAP_UNION_plu__gml__union_ParameterValueType_value	(1)	/**< union variant selector value for member value */
        gml__MeasureType *value;
        #define SOAP_UNION_plu__gml__union_ParameterValueType_dmsAngleValue	(2)	/**< union variant selector value for member dmsAngleValue */
        gml__DMSAngleType *dmsAngleValue;
        #define SOAP_UNION_plu__gml__union_ParameterValueType_stringValue	(3)	/**< union variant selector value for member stringValue */
        std::string *stringValue;
        #define SOAP_UNION_plu__gml__union_ParameterValueType_integerValue	(4)	/**< union variant selector value for member integerValue */
        ULONG64 *integerValue;
        #define SOAP_UNION_plu__gml__union_ParameterValueType_booleanValue	(5)	/**< union variant selector value for member booleanValue */
        bool booleanValue;
        #define SOAP_UNION_plu__gml__union_ParameterValueType_valueList	(6)	/**< union variant selector value for member valueList */
        gml__MeasureListType *valueList;
        #define SOAP_UNION_plu__gml__union_ParameterValueType_integerValueList	(7)	/**< union variant selector value for member integerValueList */
        std::string *integerValueList;
        #define SOAP_UNION_plu__gml__union_ParameterValueType_valueFile	(8)	/**< union variant selector value for member valueFile */
        char **valueFile;
};
#endif

/* PlannedLandUse_v3.0.h:23208 */
#ifndef SOAP_TYPE_plu__gml__union_ParameterValueType_
#define SOAP_TYPE_plu__gml__union_ParameterValueType_ (-1906)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ParameterValueType_
{
        #define SOAP_UNION_plu__gml__union_ParameterValueType__operationParameter	(1)	/**< union variant selector value for member operationParameter */
        gml__OperationParameterPropertyType *operationParameter;
        #define SOAP_UNION_plu__gml__union_ParameterValueType__valueOfParameter	(2)	/**< union variant selector value for member valueOfParameter */
        gml__OperationParameterPropertyType *valueOfParameter;
};
#endif

/* PlannedLandUse_v3.0.h:1253 */
#ifndef SOAP_TYPE_plu_gml__ParameterValueType
#define SOAP_TYPE_plu_gml__ParameterValueType (-372)
/* complex XML schema type 'gml:ParameterValueType': */
class SOAP_CMAC gml__ParameterValueType : public gml__AbstractGeneralParameterValueType {
      public:
        /// Union with union _gml__union_ParameterValueType variant selector __union_ParameterValueType set to one of: SOAP_UNION_plu__gml__union_ParameterValueType_value SOAP_UNION_plu__gml__union_ParameterValueType_dmsAngleValue SOAP_UNION_plu__gml__union_ParameterValueType_stringValue SOAP_UNION_plu__gml__union_ParameterValueType_integerValue SOAP_UNION_plu__gml__union_ParameterValueType_booleanValue SOAP_UNION_plu__gml__union_ParameterValueType_valueList SOAP_UNION_plu__gml__union_ParameterValueType_integerValueList SOAP_UNION_plu__gml__union_ParameterValueType_valueFile
        int __union_ParameterValueType;
        union _gml__union_ParameterValueType union_ParameterValueType;
        /// Union with union _gml__union_ParameterValueType_ variant selector __unionoperationParameter set to one of: SOAP_UNION_plu__gml__union_ParameterValueType__operationParameter SOAP_UNION_plu__gml__union_ParameterValueType__valueOfParameter
        int __unionoperationParameter;
        union _gml__union_ParameterValueType_ union_ParameterValueType_;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ParameterValueType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ParameterValueType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ParameterValueType, default initialized and not managed by a soap context
        virtual gml__ParameterValueType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ParameterValueType); }
      public:
        /// Constructor with default initializations
        gml__ParameterValueType() : __union_ParameterValueType(), __unionoperationParameter() { }
        virtual ~gml__ParameterValueType() { }
        /// Friend allocator used by soap_new_gml__ParameterValueType(struct soap*, int)
        friend SOAP_FMAC1 gml__ParameterValueType * SOAP_FMAC2 soap_instantiate_gml__ParameterValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:23246 */
#ifndef SOAP_TYPE_plu__gml__union_ParameterValueGroupType
#define SOAP_TYPE_plu__gml__union_ParameterValueGroupType (-1909)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ParameterValueGroupType
{
        #define SOAP_UNION_plu__gml__union_ParameterValueGroupType_parameterValue	(1)	/**< union variant selector value for member parameterValue */
        std::vector<gml__AbstractGeneralParameterValuePropertyType *> *parameterValue;
        #define SOAP_UNION_plu__gml__union_ParameterValueGroupType_usesValue	(2)	/**< union variant selector value for member usesValue */
        gml__AbstractGeneralParameterValuePropertyType *usesValue;
        #define SOAP_UNION_plu__gml__union_ParameterValueGroupType_includesValue	(3)	/**< union variant selector value for member includesValue */
        gml__AbstractGeneralParameterValuePropertyType *includesValue;
};
#endif

/* PlannedLandUse_v3.0.h:23241 */
#ifndef SOAP_TYPE_plu___gml__union_ParameterValueGroupType
#define SOAP_TYPE_plu___gml__union_ParameterValueGroupType (-1908)
/* Wrapper: */
class SOAP_CMAC __gml__union_ParameterValueGroupType {
      public:
        /// Union with union _gml__union_ParameterValueGroupType variant selector __unionparameterValue set to one of: SOAP_UNION_plu__gml__union_ParameterValueGroupType_parameterValue SOAP_UNION_plu__gml__union_ParameterValueGroupType_usesValue SOAP_UNION_plu__gml__union_ParameterValueGroupType_includesValue
        int __unionparameterValue;
        union _gml__union_ParameterValueGroupType union_ParameterValueGroupType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_ParameterValueGroupType
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_ParameterValueGroupType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_ParameterValueGroupType, default initialized and not managed by a soap context
        virtual __gml__union_ParameterValueGroupType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_ParameterValueGroupType); }
      public:
        /// Constructor with default initializations
        __gml__union_ParameterValueGroupType() : __unionparameterValue() { }
        virtual ~__gml__union_ParameterValueGroupType() { }
        /// Friend allocator used by soap_new___gml__union_ParameterValueGroupType(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_ParameterValueGroupType * SOAP_FMAC2 soap_instantiate___gml__union_ParameterValueGroupType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:23266 */
#ifndef SOAP_TYPE_plu__gml__union_ParameterValueGroupType_
#define SOAP_TYPE_plu__gml__union_ParameterValueGroupType_ (-1914)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ParameterValueGroupType_
{
        #define SOAP_UNION_plu__gml__union_ParameterValueGroupType__group	(1)	/**< union variant selector value for member group */
        gml__OperationParameterGroupPropertyType *group;
        #define SOAP_UNION_plu__gml__union_ParameterValueGroupType__valuesOfGroup	(2)	/**< union variant selector value for member valuesOfGroup */
        gml__OperationParameterGroupPropertyType *valuesOfGroup;
};
#endif

/* PlannedLandUse_v3.0.h:1256 */
#ifndef SOAP_TYPE_plu_gml__ParameterValueGroupType
#define SOAP_TYPE_plu_gml__ParameterValueGroupType (-373)
/* complex XML schema type 'gml:ParameterValueGroupType': */
class SOAP_CMAC gml__ParameterValueGroupType : public gml__AbstractGeneralParameterValueType {
      public:
        /// Sequence of at least 2 elements '-union-ParameterValueGroupType' of XML schema type '-gml:union-ParameterValueGroupType' stored in dynamic array __union_ParameterValueGroupType of length __sizeparameterValue
        int __sizeparameterValue;
        __gml__union_ParameterValueGroupType *__union_ParameterValueGroupType;
        /// Union with union _gml__union_ParameterValueGroupType_ variant selector __uniongroup set to one of: SOAP_UNION_plu__gml__union_ParameterValueGroupType__group SOAP_UNION_plu__gml__union_ParameterValueGroupType__valuesOfGroup
        int __uniongroup;
        union _gml__union_ParameterValueGroupType_ union_ParameterValueGroupType_;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ParameterValueGroupType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ParameterValueGroupType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ParameterValueGroupType, default initialized and not managed by a soap context
        virtual gml__ParameterValueGroupType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ParameterValueGroupType); }
      public:
        /// Constructor with default initializations
        gml__ParameterValueGroupType() : __sizeparameterValue(), __union_ParameterValueGroupType(), __uniongroup() { }
        virtual ~gml__ParameterValueGroupType() { }
        /// Friend allocator used by soap_new_gml__ParameterValueGroupType(struct soap*, int)
        friend SOAP_FMAC1 gml__ParameterValueGroupType * SOAP_FMAC2 soap_instantiate_gml__ParameterValueGroupType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1406 */
#ifndef SOAP_TYPE_plu_gml__StringOrRefType
#define SOAP_TYPE_plu_gml__StringOrRefType (-423)
/* simple XML schema type 'gml:StringOrRefType': */
class SOAP_CMAC gml__StringOrRefType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__StringOrRefType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__StringOrRefType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__StringOrRefType, default initialized and not managed by a soap context
        virtual gml__StringOrRefType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__StringOrRefType); }
      public:
        /// Constructor with default initializations
        gml__StringOrRefType() : __item(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gml__StringOrRefType() { }
        /// Friend allocator used by soap_new_gml__StringOrRefType(struct soap*, int)
        friend SOAP_FMAC1 gml__StringOrRefType * SOAP_FMAC2 soap_instantiate_gml__StringOrRefType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1409 */
#ifndef SOAP_TYPE_plu_gml__BagType
#define SOAP_TYPE_plu_gml__BagType (-424)
/* complex XML schema type 'gml:BagType': */
class SOAP_CMAC gml__BagType : public gml__AbstractGMLType {
      public:
        /// Optional element 'gml:member' of XML schema type 'gml:AssociationRoleType'
        std::vector<gml__AssociationRoleType *> member;
        /// Optional element 'gml:members' of XML schema type 'gml:ArrayAssociationType'
        gml__ArrayAssociationType *members;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__BagType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__BagType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__BagType, default initialized and not managed by a soap context
        virtual gml__BagType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__BagType); }
      public:
        /// Constructor with default initializations
        gml__BagType() : member(), members() { }
        virtual ~gml__BagType() { }
        /// Friend allocator used by soap_new_gml__BagType(struct soap*, int)
        friend SOAP_FMAC1 gml__BagType * SOAP_FMAC2 soap_instantiate_gml__BagType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1412 */
#ifndef SOAP_TYPE_plu_gml__ArrayType
#define SOAP_TYPE_plu_gml__ArrayType (-425)
/* complex XML schema type 'gml:ArrayType': */
class SOAP_CMAC gml__ArrayType : public gml__AbstractGMLType {
      public:
        /// Optional element 'gml:members' of XML schema type 'gml:ArrayAssociationType'
        gml__ArrayAssociationType *members;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ArrayType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ArrayType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ArrayType, default initialized and not managed by a soap context
        virtual gml__ArrayType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ArrayType); }
      public:
        /// Constructor with default initializations
        gml__ArrayType() : members() { }
        virtual ~gml__ArrayType() { }
        /// Friend allocator used by soap_new_gml__ArrayType(struct soap*, int)
        friend SOAP_FMAC1 gml__ArrayType * SOAP_FMAC2 soap_instantiate_gml__ArrayType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1421 */
#ifndef SOAP_TYPE_plu_gml__GenericMetaDataType
#define SOAP_TYPE_plu_gml__GenericMetaDataType (-428)
/* complex XML schema type 'gml:GenericMetaDataType': */
class SOAP_CMAC gml__GenericMetaDataType : public gml__AbstractMetaDataType {
      public:
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GenericMetaDataType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GenericMetaDataType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GenericMetaDataType, default initialized and not managed by a soap context
        virtual gml__GenericMetaDataType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GenericMetaDataType); }
      public:
        /// Constructor with default initializations
        gml__GenericMetaDataType() : __mixed() { }
        virtual ~gml__GenericMetaDataType() { }
        /// Friend allocator used by soap_new_gml__GenericMetaDataType(struct soap*, int)
        friend SOAP_FMAC1 gml__GenericMetaDataType * SOAP_FMAC2 soap_instantiate_gml__GenericMetaDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1427 */
#ifndef SOAP_TYPE_plu_gml__PriorityLocationPropertyType
#define SOAP_TYPE_plu_gml__PriorityLocationPropertyType (-430)
/* complex XML schema type 'gml:PriorityLocationPropertyType': */
class SOAP_CMAC gml__PriorityLocationPropertyType : public gml__LocationPropertyType {
      public:
        /// Optional attribute 'priority' of XML schema type 'xsd:string'
        std::string *priority;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__PriorityLocationPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__PriorityLocationPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__PriorityLocationPropertyType, default initialized and not managed by a soap context
        virtual gml__PriorityLocationPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__PriorityLocationPropertyType); }
      public:
        /// Constructor with default initializations
        gml__PriorityLocationPropertyType() : priority() { }
        virtual ~gml__PriorityLocationPropertyType() { }
        /// Friend allocator used by soap_new_gml__PriorityLocationPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__PriorityLocationPropertyType * SOAP_FMAC2 soap_instantiate_gml__PriorityLocationPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1451 */
#ifndef SOAP_TYPE_plu__gml__Boolean
#define SOAP_TYPE_plu__gml__Boolean (-438)
/* simple XML schema type 'gml:Boolean': */
class SOAP_CMAC _gml__Boolean {
      public:
        /// Simple content of XML schema type 'xsd:boolean' wrapped by this struct
        bool __item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_plu__gml__Boolean
        virtual long soap_type(void) const { return SOAP_TYPE_plu__gml__Boolean; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _gml__Boolean, default initialized and not managed by a soap context
        virtual _gml__Boolean *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_gml__Boolean); }
      public:
        /// Constructor with default initializations
        _gml__Boolean() : __item(), nilReason(), soap() { }
        virtual ~_gml__Boolean() { }
        /// Friend allocator used by soap_new__gml__Boolean(struct soap*, int)
        friend SOAP_FMAC1 _gml__Boolean * SOAP_FMAC2 soap_instantiate__gml__Boolean(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1457 */
#ifndef SOAP_TYPE_plu__gml__Count
#define SOAP_TYPE_plu__gml__Count (-440)
/* simple XML schema type 'gml:Count': */
class SOAP_CMAC _gml__Count {
      public:
        /// Simple content of XML schema type 'xsd:long' wrapped by this struct
        long __item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_plu__gml__Count
        virtual long soap_type(void) const { return SOAP_TYPE_plu__gml__Count; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _gml__Count, default initialized and not managed by a soap context
        virtual _gml__Count *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_gml__Count); }
      public:
        /// Constructor with default initializations
        _gml__Count() : __item(), nilReason(), soap() { }
        virtual ~_gml__Count() { }
        /// Friend allocator used by soap_new__gml__Count(struct soap*, int)
        friend SOAP_FMAC1 _gml__Count * SOAP_FMAC2 soap_instantiate__gml__Count(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1478 */
#ifndef SOAP_TYPE_plu_gmd__AbstractDS_x005fAggregate_x005fType
#define SOAP_TYPE_plu_gmd__AbstractDS_x005fAggregate_x005fType (-447)
/* complex XML schema type 'gmd:AbstractDS_Aggregate_Type': */
class SOAP_CMAC gmd__AbstractDS_x005fAggregate_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:composedOf' of XML schema type 'gmd:DS_DataSet_PropertyType'
        std::vector<gmd__DS_x005fDataSet_x005fPropertyType *> composedOf;
        /// Required element 'gmd:seriesMetadata' of XML schema type 'gmd:MD_Metadata_PropertyType'
        std::vector<gmd__MD_x005fMetadata_x005fPropertyType *> seriesMetadata;
        /// Optional element 'gmd:subset' of XML schema type 'gmd:DS_Aggregate_PropertyType'
        std::vector<gmd__DS_x005fAggregate_x005fPropertyType *> subset;
        /// Optional element 'gmd:superset' of XML schema type 'gmd:DS_Aggregate_PropertyType'
        std::vector<gmd__DS_x005fAggregate_x005fPropertyType *> superset;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__AbstractDS_x005fAggregate_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__AbstractDS_x005fAggregate_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__AbstractDS_x005fAggregate_x005fType, default initialized and not managed by a soap context
        virtual gmd__AbstractDS_x005fAggregate_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__AbstractDS_x005fAggregate_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__AbstractDS_x005fAggregate_x005fType() : composedOf(), seriesMetadata(), subset(), superset() { }
        virtual ~gmd__AbstractDS_x005fAggregate_x005fType() { }
        /// Friend allocator used by soap_new_gmd__AbstractDS_x005fAggregate_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__AbstractDS_x005fAggregate_x005fType * SOAP_FMAC2 soap_instantiate_gmd__AbstractDS_x005fAggregate_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1484 */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fDataSet_x005fType
#define SOAP_TYPE_plu_gmd__DS_x005fDataSet_x005fType (-449)
/* complex XML schema type 'gmd:DS_DataSet_Type': */
class SOAP_CMAC gmd__DS_x005fDataSet_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:has' of XML schema type 'gmd:MD_Metadata_PropertyType'
        std::vector<gmd__MD_x005fMetadata_x005fPropertyType *> has;
        /// Optional element 'gmd:partOf' of XML schema type 'gmd:DS_Aggregate_PropertyType'
        std::vector<gmd__DS_x005fAggregate_x005fPropertyType *> partOf;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DS_x005fDataSet_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DS_x005fDataSet_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DS_x005fDataSet_x005fType, default initialized and not managed by a soap context
        virtual gmd__DS_x005fDataSet_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DS_x005fDataSet_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DS_x005fDataSet_x005fType() : has(), partOf() { }
        virtual ~gmd__DS_x005fDataSet_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DS_x005fDataSet_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DS_x005fDataSet_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DS_x005fDataSet_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1532 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMetadata_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fMetadata_x005fType (-465)
/* Type gmd__MD_x005fMetadata_x005fType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gmd:MD_Metadata_Type': */
class SOAP_CMAC gmd__MD_x005fMetadata_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Optional element 'gmd:fileIdentifier' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *fileIdentifier;
        /// Optional element 'gmd:language' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *language;
        /// Optional element 'gmd:characterSet' of XML schema type 'gmd:MD_CharacterSetCode_PropertyType'
        gmd__MD_x005fCharacterSetCode_x005fPropertyType *characterSet;
        /// Optional element 'gmd:parentIdentifier' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *parentIdentifier;
        /// Optional element 'gmd:hierarchyLevel' of XML schema type 'gmd:MD_ScopeCode_PropertyType'
        std::vector<gmd__MD_x005fScopeCode_x005fPropertyType *> hierarchyLevel;
        /// Optional element 'gmd:hierarchyLevelName' of XML schema type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_x005fPropertyType *> hierarchyLevelName;
        /// Required element 'gmd:contact' of XML schema type 'gmd:CI_ResponsibleParty_PropertyType'
        std::vector<gmd__CI_x005fResponsibleParty_x005fPropertyType *> contact;
        /// Required element 'gmd:dateStamp' of XML schema type 'gco:Date_PropertyType'
        gco__Date_x005fPropertyType *dateStamp;
        /// Optional element 'gmd:metadataStandardName' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *metadataStandardName;
        /// Optional element 'gmd:metadataStandardVersion' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *metadataStandardVersion;
        /// Optional element 'gmd:dataSetURI' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *dataSetURI;
        /// Optional element 'gmd:locale' of XML schema type 'gmd:PT_Locale_PropertyType'
        std::vector<gmd__PT_x005fLocale_x005fPropertyType *> locale;
        /// Optional element 'gmd:spatialRepresentationInfo' of XML schema type 'gmd:MD_SpatialRepresentation_PropertyType'
        std::vector<gmd__MD_x005fSpatialRepresentation_x005fPropertyType *> spatialRepresentationInfo;
        /// Optional element 'gmd:referenceSystemInfo' of XML schema type 'gmd:MD_ReferenceSystem_PropertyType'
        std::vector<gmd__MD_x005fReferenceSystem_x005fPropertyType *> referenceSystemInfo;
        /// Optional element 'gmd:metadataExtensionInfo' of XML schema type 'gmd:MD_MetadataExtensionInformation_PropertyType'
        std::vector<gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType *> metadataExtensionInfo;
        /// Required element 'gmd:identificationInfo' of XML schema type 'gmd:MD_Identification_PropertyType'
        std::vector<gmd__MD_x005fIdentification_x005fPropertyType *> identificationInfo;
        /// Optional element 'gmd:contentInfo' of XML schema type 'gmd:MD_ContentInformation_PropertyType'
        std::vector<gmd__MD_x005fContentInformation_x005fPropertyType *> contentInfo;
        /// Optional element 'gmd:distributionInfo' of XML schema type 'gmd:MD_Distribution_PropertyType'
        gmd__MD_x005fDistribution_x005fPropertyType *distributionInfo;
        /// Optional element 'gmd:dataQualityInfo' of XML schema type 'gmd:DQ_DataQuality_PropertyType'
        std::vector<gmd__DQ_x005fDataQuality_x005fPropertyType *> dataQualityInfo;
        /// Optional element 'gmd:portrayalCatalogueInfo' of XML schema type 'gmd:MD_PortrayalCatalogueReference_PropertyType'
        std::vector<gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType *> portrayalCatalogueInfo;
        /// Optional element 'gmd:metadataConstraints' of XML schema type 'gmd:MD_Constraints_PropertyType'
        std::vector<gmd__MD_x005fConstraints_x005fPropertyType *> metadataConstraints;
        /// Optional element 'gmd:applicationSchemaInfo' of XML schema type 'gmd:MD_ApplicationSchemaInformation_PropertyType'
        std::vector<gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType *> applicationSchemaInfo;
        /// Optional element 'gmd:metadataMaintenance' of XML schema type 'gmd:MD_MaintenanceInformation_PropertyType'
        gmd__MD_x005fMaintenanceInformation_x005fPropertyType *metadataMaintenance;
        /// Optional element 'gmd:series' of XML schema type 'gmd:DS_Aggregate_PropertyType'
        std::vector<gmd__DS_x005fAggregate_x005fPropertyType *> series;
        /// Optional element 'gmd:describes' of XML schema type 'gmd:DS_DataSet_PropertyType'
        std::vector<gmd__DS_x005fDataSet_x005fPropertyType *> describes;
        /// Optional element 'gmd:propertyType' of XML schema type 'gco:ObjectReference_PropertyType'
        std::vector<gco__ObjectReference_x005fPropertyType *> propertyType;
        /// Optional element 'gmd:featureType' of XML schema type 'gco:ObjectReference_PropertyType'
        std::vector<gco__ObjectReference_x005fPropertyType *> featureType;
        /// Optional element 'gmd:featureAttribute' of XML schema type 'gco:ObjectReference_PropertyType'
        std::vector<gco__ObjectReference_x005fPropertyType *> featureAttribute;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fMetadata_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fMetadata_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fMetadata_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fMetadata_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fMetadata_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fMetadata_x005fType() : fileIdentifier(), language(), characterSet(), parentIdentifier(), hierarchyLevel(), hierarchyLevelName(), contact(), dateStamp(), metadataStandardName(), metadataStandardVersion(), dataSetURI(), locale(), spatialRepresentationInfo(), referenceSystemInfo(), metadataExtensionInfo(), identificationInfo(), contentInfo(), distributionInfo(), dataQualityInfo(), portrayalCatalogueInfo(), metadataConstraints(), applicationSchemaInfo(), metadataMaintenance(), series(), describes(), propertyType(), featureType(), featureAttribute() { }
        virtual ~gmd__MD_x005fMetadata_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fMetadata_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fMetadata_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fMetadata_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1550 */
#ifndef SOAP_TYPE_plu_gmd__AbstractMD_x005fSpatialRepresentation_x005fType
#define SOAP_TYPE_plu_gmd__AbstractMD_x005fSpatialRepresentation_x005fType (-471)
/* simple XML schema type 'gmd:AbstractMD_SpatialRepresentation_Type': */
class SOAP_CMAC gmd__AbstractMD_x005fSpatialRepresentation_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__AbstractMD_x005fSpatialRepresentation_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__AbstractMD_x005fSpatialRepresentation_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__AbstractMD_x005fSpatialRepresentation_x005fType, default initialized and not managed by a soap context
        virtual gmd__AbstractMD_x005fSpatialRepresentation_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__AbstractMD_x005fSpatialRepresentation_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__AbstractMD_x005fSpatialRepresentation_x005fType() { }
        virtual ~gmd__AbstractMD_x005fSpatialRepresentation_x005fType() { }
        /// Friend allocator used by soap_new_gmd__AbstractMD_x005fSpatialRepresentation_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__AbstractMD_x005fSpatialRepresentation_x005fType * SOAP_FMAC2 soap_instantiate_gmd__AbstractMD_x005fSpatialRepresentation_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1562 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDimension_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fDimension_x005fType (-475)
/* complex XML schema type 'gmd:MD_Dimension_Type': */
class SOAP_CMAC gmd__MD_x005fDimension_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:dimensionName' of XML schema type 'gmd:MD_DimensionNameTypeCode_PropertyType'
        gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType *dimensionName;
        /// Required element 'gmd:dimensionSize' of XML schema type 'gco:Integer_PropertyType'
        gco__Integer_x005fPropertyType *dimensionSize;
        /// Optional element 'gmd:resolution' of XML schema type 'gco:Measure_PropertyType'
        gco__Measure_x005fPropertyType *resolution;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fDimension_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fDimension_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fDimension_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fDimension_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fDimension_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fDimension_x005fType() : dimensionName(), dimensionSize(), resolution() { }
        virtual ~gmd__MD_x005fDimension_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fDimension_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fDimension_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fDimension_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1574 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fGeometricObjects_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fGeometricObjects_x005fType (-479)
/* complex XML schema type 'gmd:MD_GeometricObjects_Type': */
class SOAP_CMAC gmd__MD_x005fGeometricObjects_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:geometricObjectType' of XML schema type 'gmd:MD_GeometricObjectTypeCode_PropertyType'
        gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType *geometricObjectType;
        /// Optional element 'gmd:geometricObjectCount' of XML schema type 'gco:Integer_PropertyType'
        gco__Integer_x005fPropertyType *geometricObjectCount;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fGeometricObjects_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fGeometricObjects_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fGeometricObjects_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fGeometricObjects_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fGeometricObjects_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fGeometricObjects_x005fType() : geometricObjectType(), geometricObjectCount() { }
        virtual ~gmd__MD_x005fGeometricObjects_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fGeometricObjects_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fGeometricObjects_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fGeometricObjects_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1595 */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fResponsibleParty_x005fType
#define SOAP_TYPE_plu_gmd__CI_x005fResponsibleParty_x005fType (-486)
/* complex XML schema type 'gmd:CI_ResponsibleParty_Type': */
class SOAP_CMAC gmd__CI_x005fResponsibleParty_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Optional element 'gmd:individualName' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *individualName;
        /// Optional element 'gmd:organisationName' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *organisationName;
        /// Optional element 'gmd:positionName' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *positionName;
        /// Optional element 'gmd:contactInfo' of XML schema type 'gmd:CI_Contact_PropertyType'
        gmd__CI_x005fContact_x005fPropertyType *contactInfo;
        /// Required element 'gmd:role' of XML schema type 'gmd:CI_RoleCode_PropertyType'
        gmd__CI_x005fRoleCode_x005fPropertyType *role;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__CI_x005fResponsibleParty_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__CI_x005fResponsibleParty_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_x005fResponsibleParty_x005fType, default initialized and not managed by a soap context
        virtual gmd__CI_x005fResponsibleParty_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__CI_x005fResponsibleParty_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__CI_x005fResponsibleParty_x005fType() : individualName(), organisationName(), positionName(), contactInfo(), role() { }
        virtual ~gmd__CI_x005fResponsibleParty_x005fType() { }
        /// Friend allocator used by soap_new_gmd__CI_x005fResponsibleParty_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_x005fResponsibleParty_x005fType * SOAP_FMAC2 soap_instantiate_gmd__CI_x005fResponsibleParty_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1601 */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fCitation_x005fType
#define SOAP_TYPE_plu_gmd__CI_x005fCitation_x005fType (-488)
/* complex XML schema type 'gmd:CI_Citation_Type': */
class SOAP_CMAC gmd__CI_x005fCitation_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:title' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *title;
        /// Optional element 'gmd:alternateTitle' of XML schema type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_x005fPropertyType *> alternateTitle;
        /// Required element 'gmd:date' of XML schema type 'gmd:CI_Date_PropertyType'
        std::vector<gmd__CI_x005fDate_x005fPropertyType *> date;
        /// Optional element 'gmd:edition' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *edition;
        /// Optional element 'gmd:editionDate' of XML schema type 'gco:Date_PropertyType'
        gco__Date_x005fPropertyType *editionDate;
        /// Optional element 'gmd:identifier' of XML schema type 'gmd:MD_Identifier_PropertyType'
        std::vector<gmd__MD_x005fIdentifier_x005fPropertyType *> identifier;
        /// Optional element 'gmd:citedResponsibleParty' of XML schema type 'gmd:CI_ResponsibleParty_PropertyType'
        std::vector<gmd__CI_x005fResponsibleParty_x005fPropertyType *> citedResponsibleParty;
        /// Optional element 'gmd:presentationForm' of XML schema type 'gmd:CI_PresentationFormCode_PropertyType'
        std::vector<gmd__CI_x005fPresentationFormCode_x005fPropertyType *> presentationForm;
        /// Optional element 'gmd:series' of XML schema type 'gmd:CI_Series_PropertyType'
        gmd__CI_x005fSeries_x005fPropertyType *series;
        /// Optional element 'gmd:otherCitationDetails' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *otherCitationDetails;
        /// Optional element 'gmd:collectiveTitle' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *collectiveTitle;
        /// Optional element 'gmd:ISBN' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *ISBN;
        /// Optional element 'gmd:ISSN' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *ISSN;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__CI_x005fCitation_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__CI_x005fCitation_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_x005fCitation_x005fType, default initialized and not managed by a soap context
        virtual gmd__CI_x005fCitation_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__CI_x005fCitation_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__CI_x005fCitation_x005fType() : title(), alternateTitle(), date(), edition(), editionDate(), identifier(), citedResponsibleParty(), presentationForm(), series(), otherCitationDetails(), collectiveTitle(), ISBN(), ISSN() { }
        virtual ~gmd__CI_x005fCitation_x005fType() { }
        /// Friend allocator used by soap_new_gmd__CI_x005fCitation_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_x005fCitation_x005fType * SOAP_FMAC2 soap_instantiate_gmd__CI_x005fCitation_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1607 */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fAddress_x005fType
#define SOAP_TYPE_plu_gmd__CI_x005fAddress_x005fType (-490)
/* complex XML schema type 'gmd:CI_Address_Type': */
class SOAP_CMAC gmd__CI_x005fAddress_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Optional element 'gmd:deliveryPoint' of XML schema type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_x005fPropertyType *> deliveryPoint;
        /// Optional element 'gmd:city' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *city;
        /// Optional element 'gmd:administrativeArea' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *administrativeArea;
        /// Optional element 'gmd:postalCode' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *postalCode;
        /// Optional element 'gmd:country' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *country;
        /// Optional element 'gmd:electronicMailAddress' of XML schema type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_x005fPropertyType *> electronicMailAddress;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__CI_x005fAddress_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__CI_x005fAddress_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_x005fAddress_x005fType, default initialized and not managed by a soap context
        virtual gmd__CI_x005fAddress_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__CI_x005fAddress_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__CI_x005fAddress_x005fType() : deliveryPoint(), city(), administrativeArea(), postalCode(), country(), electronicMailAddress() { }
        virtual ~gmd__CI_x005fAddress_x005fType() { }
        /// Friend allocator used by soap_new_gmd__CI_x005fAddress_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_x005fAddress_x005fType * SOAP_FMAC2 soap_instantiate_gmd__CI_x005fAddress_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1613 */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fOnlineResource_x005fType
#define SOAP_TYPE_plu_gmd__CI_x005fOnlineResource_x005fType (-492)
/* complex XML schema type 'gmd:CI_OnlineResource_Type': */
class SOAP_CMAC gmd__CI_x005fOnlineResource_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:linkage' of XML schema type 'gmd:URL_PropertyType'
        gmd__URL_x005fPropertyType *linkage;
        /// Optional element 'gmd:protocol' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *protocol;
        /// Optional element 'gmd:applicationProfile' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *applicationProfile;
        /// Optional element 'gmd:name' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *name;
        /// Optional element 'gmd:description' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *description;
        /// Optional element 'gmd:function' of XML schema type 'gmd:CI_OnLineFunctionCode_PropertyType'
        gmd__CI_x005fOnLineFunctionCode_x005fPropertyType *function;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__CI_x005fOnlineResource_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__CI_x005fOnlineResource_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_x005fOnlineResource_x005fType, default initialized and not managed by a soap context
        virtual gmd__CI_x005fOnlineResource_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__CI_x005fOnlineResource_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__CI_x005fOnlineResource_x005fType() : linkage(), protocol(), applicationProfile(), name(), description(), function() { }
        virtual ~gmd__CI_x005fOnlineResource_x005fType() { }
        /// Friend allocator used by soap_new_gmd__CI_x005fOnlineResource_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_x005fOnlineResource_x005fType * SOAP_FMAC2 soap_instantiate_gmd__CI_x005fOnlineResource_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1619 */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fContact_x005fType
#define SOAP_TYPE_plu_gmd__CI_x005fContact_x005fType (-494)
/* complex XML schema type 'gmd:CI_Contact_Type': */
class SOAP_CMAC gmd__CI_x005fContact_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Optional element 'gmd:phone' of XML schema type 'gmd:CI_Telephone_PropertyType'
        gmd__CI_x005fTelephone_x005fPropertyType *phone;
        /// Optional element 'gmd:address' of XML schema type 'gmd:CI_Address_PropertyType'
        gmd__CI_x005fAddress_x005fPropertyType *address;
        /// Optional element 'gmd:onlineResource' of XML schema type 'gmd:CI_OnlineResource_PropertyType'
        gmd__CI_x005fOnlineResource_x005fPropertyType *onlineResource;
        /// Optional element 'gmd:hoursOfService' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *hoursOfService;
        /// Optional element 'gmd:contactInstructions' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *contactInstructions;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__CI_x005fContact_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__CI_x005fContact_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_x005fContact_x005fType, default initialized and not managed by a soap context
        virtual gmd__CI_x005fContact_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__CI_x005fContact_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__CI_x005fContact_x005fType() : phone(), address(), onlineResource(), hoursOfService(), contactInstructions() { }
        virtual ~gmd__CI_x005fContact_x005fType() { }
        /// Friend allocator used by soap_new_gmd__CI_x005fContact_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_x005fContact_x005fType * SOAP_FMAC2 soap_instantiate_gmd__CI_x005fContact_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1625 */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fTelephone_x005fType
#define SOAP_TYPE_plu_gmd__CI_x005fTelephone_x005fType (-496)
/* complex XML schema type 'gmd:CI_Telephone_Type': */
class SOAP_CMAC gmd__CI_x005fTelephone_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Optional element 'gmd:voice' of XML schema type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_x005fPropertyType *> voice;
        /// Optional element 'gmd:facsimile' of XML schema type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_x005fPropertyType *> facsimile;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__CI_x005fTelephone_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__CI_x005fTelephone_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_x005fTelephone_x005fType, default initialized and not managed by a soap context
        virtual gmd__CI_x005fTelephone_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__CI_x005fTelephone_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__CI_x005fTelephone_x005fType() : voice(), facsimile() { }
        virtual ~gmd__CI_x005fTelephone_x005fType() { }
        /// Friend allocator used by soap_new_gmd__CI_x005fTelephone_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_x005fTelephone_x005fType * SOAP_FMAC2 soap_instantiate_gmd__CI_x005fTelephone_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1631 */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fDate_x005fType
#define SOAP_TYPE_plu_gmd__CI_x005fDate_x005fType (-498)
/* complex XML schema type 'gmd:CI_Date_Type': */
class SOAP_CMAC gmd__CI_x005fDate_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:date' of XML schema type 'gco:Date_PropertyType'
        gco__Date_x005fPropertyType *date;
        /// Required element 'gmd:dateType' of XML schema type 'gmd:CI_DateTypeCode_PropertyType'
        gmd__CI_x005fDateTypeCode_x005fPropertyType *dateType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__CI_x005fDate_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__CI_x005fDate_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_x005fDate_x005fType, default initialized and not managed by a soap context
        virtual gmd__CI_x005fDate_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__CI_x005fDate_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__CI_x005fDate_x005fType() : date(), dateType() { }
        virtual ~gmd__CI_x005fDate_x005fType() { }
        /// Friend allocator used by soap_new_gmd__CI_x005fDate_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_x005fDate_x005fType * SOAP_FMAC2 soap_instantiate_gmd__CI_x005fDate_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1637 */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fSeries_x005fType
#define SOAP_TYPE_plu_gmd__CI_x005fSeries_x005fType (-500)
/* complex XML schema type 'gmd:CI_Series_Type': */
class SOAP_CMAC gmd__CI_x005fSeries_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Optional element 'gmd:name' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *name;
        /// Optional element 'gmd:issueIdentification' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *issueIdentification;
        /// Optional element 'gmd:page' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *page;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__CI_x005fSeries_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__CI_x005fSeries_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_x005fSeries_x005fType, default initialized and not managed by a soap context
        virtual gmd__CI_x005fSeries_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__CI_x005fSeries_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__CI_x005fSeries_x005fType() : name(), issueIdentification(), page() { }
        virtual ~gmd__CI_x005fSeries_x005fType() { }
        /// Friend allocator used by soap_new_gmd__CI_x005fSeries_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_x005fSeries_x005fType * SOAP_FMAC2 soap_instantiate_gmd__CI_x005fSeries_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1664 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fReferenceSystem_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fReferenceSystem_x005fType (-509)
/* complex XML schema type 'gmd:MD_ReferenceSystem_Type': */
class SOAP_CMAC gmd__MD_x005fReferenceSystem_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Optional element 'gmd:referenceSystemIdentifier' of XML schema type 'gmd:RS_Identifier_PropertyType'
        gmd__RS_x005fIdentifier_x005fPropertyType *referenceSystemIdentifier;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fReferenceSystem_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fReferenceSystem_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fReferenceSystem_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fReferenceSystem_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fReferenceSystem_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fReferenceSystem_x005fType() : referenceSystemIdentifier() { }
        virtual ~gmd__MD_x005fReferenceSystem_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fReferenceSystem_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fReferenceSystem_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fReferenceSystem_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1670 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fIdentifier_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fIdentifier_x005fType (-511)
/* complex XML schema type 'gmd:MD_Identifier_Type': */
class SOAP_CMAC gmd__MD_x005fIdentifier_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Optional element 'gmd:authority' of XML schema type 'gmd:CI_Citation_PropertyType'
        gmd__CI_x005fCitation_x005fPropertyType *authority;
        /// Required element 'gmd:code' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *code;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fIdentifier_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fIdentifier_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fIdentifier_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fIdentifier_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fIdentifier_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fIdentifier_x005fType() : authority(), code() { }
        virtual ~gmd__MD_x005fIdentifier_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fIdentifier_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fIdentifier_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fIdentifier_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1676 */
#ifndef SOAP_TYPE_plu_gmd__AbstractRS_x005fReferenceSystem_x005fType
#define SOAP_TYPE_plu_gmd__AbstractRS_x005fReferenceSystem_x005fType (-513)
/* complex XML schema type 'gmd:AbstractRS_ReferenceSystem_Type': */
class SOAP_CMAC gmd__AbstractRS_x005fReferenceSystem_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:name' of XML schema type 'gmd:RS_Identifier_PropertyType'
        gmd__RS_x005fIdentifier_x005fPropertyType *name;
        /// Optional element 'gmd:domainOfValidity' of XML schema type 'gmd:EX_Extent_PropertyType'
        std::vector<gmd__EX_x005fExtent_x005fPropertyType *> domainOfValidity;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__AbstractRS_x005fReferenceSystem_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__AbstractRS_x005fReferenceSystem_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__AbstractRS_x005fReferenceSystem_x005fType, default initialized and not managed by a soap context
        virtual gmd__AbstractRS_x005fReferenceSystem_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__AbstractRS_x005fReferenceSystem_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__AbstractRS_x005fReferenceSystem_x005fType() : name(), domainOfValidity() { }
        virtual ~gmd__AbstractRS_x005fReferenceSystem_x005fType() { }
        /// Friend allocator used by soap_new_gmd__AbstractRS_x005fReferenceSystem_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__AbstractRS_x005fReferenceSystem_x005fType * SOAP_FMAC2 soap_instantiate_gmd__AbstractRS_x005fReferenceSystem_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1682 */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fTemporalExtent_x005fType
#define SOAP_TYPE_plu_gmd__EX_x005fTemporalExtent_x005fType (-515)
/* complex XML schema type 'gmd:EX_TemporalExtent_Type': */
class SOAP_CMAC gmd__EX_x005fTemporalExtent_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:extent' of XML schema type 'gts:TM_Primitive_PropertyType'
        gts__TM_x005fPrimitive_x005fPropertyType *extent;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__EX_x005fTemporalExtent_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__EX_x005fTemporalExtent_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_x005fTemporalExtent_x005fType, default initialized and not managed by a soap context
        virtual gmd__EX_x005fTemporalExtent_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__EX_x005fTemporalExtent_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__EX_x005fTemporalExtent_x005fType() : extent() { }
        virtual ~gmd__EX_x005fTemporalExtent_x005fType() { }
        /// Friend allocator used by soap_new_gmd__EX_x005fTemporalExtent_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_x005fTemporalExtent_x005fType * SOAP_FMAC2 soap_instantiate_gmd__EX_x005fTemporalExtent_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1688 */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fVerticalExtent_x005fType
#define SOAP_TYPE_plu_gmd__EX_x005fVerticalExtent_x005fType (-517)
/* complex XML schema type 'gmd:EX_VerticalExtent_Type': */
class SOAP_CMAC gmd__EX_x005fVerticalExtent_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:minimumValue' of XML schema type 'gco:Real_PropertyType'
        gco__Real_x005fPropertyType *minimumValue;
        /// Required element 'gmd:maximumValue' of XML schema type 'gco:Real_PropertyType'
        gco__Real_x005fPropertyType *maximumValue;
        /// Required element 'gmd:verticalCRS' of XML schema type 'gsr:SC_CRS_PropertyType'
        gsr__SC_x005fCRS_x005fPropertyType *verticalCRS;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__EX_x005fVerticalExtent_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__EX_x005fVerticalExtent_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_x005fVerticalExtent_x005fType, default initialized and not managed by a soap context
        virtual gmd__EX_x005fVerticalExtent_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__EX_x005fVerticalExtent_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__EX_x005fVerticalExtent_x005fType() : minimumValue(), maximumValue(), verticalCRS() { }
        virtual ~gmd__EX_x005fVerticalExtent_x005fType() { }
        /// Friend allocator used by soap_new_gmd__EX_x005fVerticalExtent_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_x005fVerticalExtent_x005fType * SOAP_FMAC2 soap_instantiate_gmd__EX_x005fVerticalExtent_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1700 */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fExtent_x005fType
#define SOAP_TYPE_plu_gmd__EX_x005fExtent_x005fType (-521)
/* complex XML schema type 'gmd:EX_Extent_Type': */
class SOAP_CMAC gmd__EX_x005fExtent_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Optional element 'gmd:description' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *description;
        /// Optional element 'gmd:geographicElement' of XML schema type 'gmd:EX_GeographicExtent_PropertyType'
        std::vector<gmd__EX_x005fGeographicExtent_x005fPropertyType *> geographicElement;
        /// Optional element 'gmd:temporalElement' of XML schema type 'gmd:EX_TemporalExtent_PropertyType'
        std::vector<gmd__EX_x005fTemporalExtent_x005fPropertyType *> temporalElement;
        /// Optional element 'gmd:verticalElement' of XML schema type 'gmd:EX_VerticalExtent_PropertyType'
        std::vector<gmd__EX_x005fVerticalExtent_x005fPropertyType *> verticalElement;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__EX_x005fExtent_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__EX_x005fExtent_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_x005fExtent_x005fType, default initialized and not managed by a soap context
        virtual gmd__EX_x005fExtent_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__EX_x005fExtent_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__EX_x005fExtent_x005fType() : description(), geographicElement(), temporalElement(), verticalElement() { }
        virtual ~gmd__EX_x005fExtent_x005fType() { }
        /// Friend allocator used by soap_new_gmd__EX_x005fExtent_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_x005fExtent_x005fType * SOAP_FMAC2 soap_instantiate_gmd__EX_x005fExtent_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1706 */
#ifndef SOAP_TYPE_plu_gmd__AbstractEX_x005fGeographicExtent_x005fType
#define SOAP_TYPE_plu_gmd__AbstractEX_x005fGeographicExtent_x005fType (-523)
/* complex XML schema type 'gmd:AbstractEX_GeographicExtent_Type': */
class SOAP_CMAC gmd__AbstractEX_x005fGeographicExtent_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Optional element 'gmd:extentTypeCode' of XML schema type 'gco:Boolean_PropertyType'
        gco__Boolean_x005fPropertyType *extentTypeCode;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__AbstractEX_x005fGeographicExtent_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__AbstractEX_x005fGeographicExtent_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__AbstractEX_x005fGeographicExtent_x005fType, default initialized and not managed by a soap context
        virtual gmd__AbstractEX_x005fGeographicExtent_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__AbstractEX_x005fGeographicExtent_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__AbstractEX_x005fGeographicExtent_x005fType() : extentTypeCode() { }
        virtual ~gmd__AbstractEX_x005fGeographicExtent_x005fType() { }
        /// Friend allocator used by soap_new_gmd__AbstractEX_x005fGeographicExtent_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__AbstractEX_x005fGeographicExtent_x005fType * SOAP_FMAC2 soap_instantiate_gmd__AbstractEX_x005fGeographicExtent_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1730 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fExtendedElementInformation_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fExtendedElementInformation_x005fType (-531)
/* complex XML schema type 'gmd:MD_ExtendedElementInformation_Type': */
class SOAP_CMAC gmd__MD_x005fExtendedElementInformation_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:name' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *name;
        /// Optional element 'gmd:shortName' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *shortName;
        /// Optional element 'gmd:domainCode' of XML schema type 'gco:Integer_PropertyType'
        gco__Integer_x005fPropertyType *domainCode;
        /// Required element 'gmd:definition' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *definition;
        /// Optional element 'gmd:obligation' of XML schema type 'gmd:MD_ObligationCode_PropertyType'
        gmd__MD_x005fObligationCode_x005fPropertyType *obligation;
        /// Optional element 'gmd:condition' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *condition;
        /// Required element 'gmd:dataType' of XML schema type 'gmd:MD_DatatypeCode_PropertyType'
        gmd__MD_x005fDatatypeCode_x005fPropertyType *dataType;
        /// Optional element 'gmd:maximumOccurrence' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *maximumOccurrence;
        /// Optional element 'gmd:domainValue' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *domainValue;
        /// Required element 'gmd:parentEntity' of XML schema type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_x005fPropertyType *> parentEntity;
        /// Required element 'gmd:rule' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *rule;
        /// Optional element 'gmd:rationale' of XML schema type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_x005fPropertyType *> rationale;
        /// Required element 'gmd:source' of XML schema type 'gmd:CI_ResponsibleParty_PropertyType'
        std::vector<gmd__CI_x005fResponsibleParty_x005fPropertyType *> source;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fExtendedElementInformation_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fExtendedElementInformation_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fExtendedElementInformation_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fExtendedElementInformation_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fExtendedElementInformation_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fExtendedElementInformation_x005fType() : name(), shortName(), domainCode(), definition(), obligation(), condition(), dataType(), maximumOccurrence(), domainValue(), parentEntity(), rule(), rationale(), source() { }
        virtual ~gmd__MD_x005fExtendedElementInformation_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fExtendedElementInformation_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fExtendedElementInformation_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fExtendedElementInformation_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1736 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMetadataExtensionInformation_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fMetadataExtensionInformation_x005fType (-533)
/* complex XML schema type 'gmd:MD_MetadataExtensionInformation_Type': */
class SOAP_CMAC gmd__MD_x005fMetadataExtensionInformation_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Optional element 'gmd:extensionOnLineResource' of XML schema type 'gmd:CI_OnlineResource_PropertyType'
        gmd__CI_x005fOnlineResource_x005fPropertyType *extensionOnLineResource;
        /// Optional element 'gmd:extendedElementInformation' of XML schema type 'gmd:MD_ExtendedElementInformation_PropertyType'
        std::vector<gmd__MD_x005fExtendedElementInformation_x005fPropertyType *> extendedElementInformation;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fMetadataExtensionInformation_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fMetadataExtensionInformation_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fMetadataExtensionInformation_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fMetadataExtensionInformation_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fMetadataExtensionInformation_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fMetadataExtensionInformation_x005fType() : extensionOnLineResource(), extendedElementInformation() { }
        virtual ~gmd__MD_x005fMetadataExtensionInformation_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fMetadataExtensionInformation_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fMetadataExtensionInformation_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fMetadataExtensionInformation_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1766 */
#ifndef SOAP_TYPE_plu_gmd__AbstractMD_x005fContentInformation_x005fType
#define SOAP_TYPE_plu_gmd__AbstractMD_x005fContentInformation_x005fType (-543)
/* simple XML schema type 'gmd:AbstractMD_ContentInformation_Type': */
class SOAP_CMAC gmd__AbstractMD_x005fContentInformation_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__AbstractMD_x005fContentInformation_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__AbstractMD_x005fContentInformation_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__AbstractMD_x005fContentInformation_x005fType, default initialized and not managed by a soap context
        virtual gmd__AbstractMD_x005fContentInformation_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__AbstractMD_x005fContentInformation_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__AbstractMD_x005fContentInformation_x005fType() { }
        virtual ~gmd__AbstractMD_x005fContentInformation_x005fType() { }
        /// Friend allocator used by soap_new_gmd__AbstractMD_x005fContentInformation_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__AbstractMD_x005fContentInformation_x005fType * SOAP_FMAC2 soap_instantiate_gmd__AbstractMD_x005fContentInformation_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1772 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fRangeDimension_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fRangeDimension_x005fType (-545)
/* complex XML schema type 'gmd:MD_RangeDimension_Type': */
class SOAP_CMAC gmd__MD_x005fRangeDimension_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Optional element 'gmd:sequenceIdentifier' of XML schema type 'gco:MemberName_PropertyType'
        gco__MemberName_x005fPropertyType *sequenceIdentifier;
        /// Optional element 'gmd:descriptor' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *descriptor;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fRangeDimension_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fRangeDimension_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fRangeDimension_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fRangeDimension_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fRangeDimension_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fRangeDimension_x005fType() : sequenceIdentifier(), descriptor() { }
        virtual ~gmd__MD_x005fRangeDimension_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fRangeDimension_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fRangeDimension_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fRangeDimension_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1790 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fApplicationSchemaInformation_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fApplicationSchemaInformation_x005fType (-551)
/* complex XML schema type 'gmd:MD_ApplicationSchemaInformation_Type': */
class SOAP_CMAC gmd__MD_x005fApplicationSchemaInformation_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:name' of XML schema type 'gmd:CI_Citation_PropertyType'
        gmd__CI_x005fCitation_x005fPropertyType *name;
        /// Required element 'gmd:schemaLanguage' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *schemaLanguage;
        /// Required element 'gmd:constraintLanguage' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *constraintLanguage;
        /// Optional element 'gmd:schemaAscii' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *schemaAscii;
        /// Optional element 'gmd:graphicsFile' of XML schema type 'gco:Binary_PropertyType'
        gco__Binary_x005fPropertyType *graphicsFile;
        /// Optional element 'gmd:softwareDevelopmentFile' of XML schema type 'gco:Binary_PropertyType'
        gco__Binary_x005fPropertyType *softwareDevelopmentFile;
        /// Optional element 'gmd:softwareDevelopmentFileFormat' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *softwareDevelopmentFileFormat;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fApplicationSchemaInformation_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fApplicationSchemaInformation_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fApplicationSchemaInformation_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fApplicationSchemaInformation_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fApplicationSchemaInformation_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fApplicationSchemaInformation_x005fType() : name(), schemaLanguage(), constraintLanguage(), schemaAscii(), graphicsFile(), softwareDevelopmentFile(), softwareDevelopmentFileFormat() { }
        virtual ~gmd__MD_x005fApplicationSchemaInformation_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fApplicationSchemaInformation_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fApplicationSchemaInformation_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fApplicationSchemaInformation_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1796 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fPortrayalCatalogueReference_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fPortrayalCatalogueReference_x005fType (-553)
/* complex XML schema type 'gmd:MD_PortrayalCatalogueReference_Type': */
class SOAP_CMAC gmd__MD_x005fPortrayalCatalogueReference_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:portrayalCatalogueCitation' of XML schema type 'gmd:CI_Citation_PropertyType'
        std::vector<gmd__CI_x005fCitation_x005fPropertyType *> portrayalCatalogueCitation;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fPortrayalCatalogueReference_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fPortrayalCatalogueReference_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fPortrayalCatalogueReference_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fPortrayalCatalogueReference_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fPortrayalCatalogueReference_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fPortrayalCatalogueReference_x005fType() : portrayalCatalogueCitation() { }
        virtual ~gmd__MD_x005fPortrayalCatalogueReference_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fPortrayalCatalogueReference_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fPortrayalCatalogueReference_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fPortrayalCatalogueReference_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1802 */
#ifndef SOAP_TYPE_plu_gmd__LI_x005fProcessStep_x005fType
#define SOAP_TYPE_plu_gmd__LI_x005fProcessStep_x005fType (-555)
/* complex XML schema type 'gmd:LI_ProcessStep_Type': */
class SOAP_CMAC gmd__LI_x005fProcessStep_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:description' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *description;
        /// Optional element 'gmd:rationale' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *rationale;
        /// Optional element 'gmd:dateTime' of XML schema type 'gco:DateTime_PropertyType'
        gco__DateTime_x005fPropertyType *dateTime;
        /// Optional element 'gmd:processor' of XML schema type 'gmd:CI_ResponsibleParty_PropertyType'
        std::vector<gmd__CI_x005fResponsibleParty_x005fPropertyType *> processor;
        /// Optional element 'gmd:source' of XML schema type 'gmd:LI_Source_PropertyType'
        std::vector<gmd__LI_x005fSource_x005fPropertyType *> source;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__LI_x005fProcessStep_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__LI_x005fProcessStep_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__LI_x005fProcessStep_x005fType, default initialized and not managed by a soap context
        virtual gmd__LI_x005fProcessStep_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__LI_x005fProcessStep_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__LI_x005fProcessStep_x005fType() : description(), rationale(), dateTime(), processor(), source() { }
        virtual ~gmd__LI_x005fProcessStep_x005fType() { }
        /// Friend allocator used by soap_new_gmd__LI_x005fProcessStep_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__LI_x005fProcessStep_x005fType * SOAP_FMAC2 soap_instantiate_gmd__LI_x005fProcessStep_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1808 */
#ifndef SOAP_TYPE_plu_gmd__LI_x005fSource_x005fType
#define SOAP_TYPE_plu_gmd__LI_x005fSource_x005fType (-557)
/* complex XML schema type 'gmd:LI_Source_Type': */
class SOAP_CMAC gmd__LI_x005fSource_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Optional element 'gmd:description' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *description;
        /// Optional element 'gmd:scaleDenominator' of XML schema type 'gmd:MD_RepresentativeFraction_PropertyType'
        gmd__MD_x005fRepresentativeFraction_x005fPropertyType *scaleDenominator;
        /// Optional element 'gmd:sourceReferenceSystem' of XML schema type 'gmd:MD_ReferenceSystem_PropertyType'
        gmd__MD_x005fReferenceSystem_x005fPropertyType *sourceReferenceSystem;
        /// Optional element 'gmd:sourceCitation' of XML schema type 'gmd:CI_Citation_PropertyType'
        gmd__CI_x005fCitation_x005fPropertyType *sourceCitation;
        /// Optional element 'gmd:sourceExtent' of XML schema type 'gmd:EX_Extent_PropertyType'
        std::vector<gmd__EX_x005fExtent_x005fPropertyType *> sourceExtent;
        /// Optional element 'gmd:sourceStep' of XML schema type 'gmd:LI_ProcessStep_PropertyType'
        std::vector<gmd__LI_x005fProcessStep_x005fPropertyType *> sourceStep;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__LI_x005fSource_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__LI_x005fSource_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__LI_x005fSource_x005fType, default initialized and not managed by a soap context
        virtual gmd__LI_x005fSource_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__LI_x005fSource_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__LI_x005fSource_x005fType() : description(), scaleDenominator(), sourceReferenceSystem(), sourceCitation(), sourceExtent(), sourceStep() { }
        virtual ~gmd__LI_x005fSource_x005fType() { }
        /// Friend allocator used by soap_new_gmd__LI_x005fSource_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__LI_x005fSource_x005fType * SOAP_FMAC2 soap_instantiate_gmd__LI_x005fSource_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1814 */
#ifndef SOAP_TYPE_plu_gmd__LI_x005fLineage_x005fType
#define SOAP_TYPE_plu_gmd__LI_x005fLineage_x005fType (-559)
/* complex XML schema type 'gmd:LI_Lineage_Type': */
class SOAP_CMAC gmd__LI_x005fLineage_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Optional element 'gmd:statement' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *statement;
        /// Optional element 'gmd:processStep' of XML schema type 'gmd:LI_ProcessStep_PropertyType'
        std::vector<gmd__LI_x005fProcessStep_x005fPropertyType *> processStep;
        /// Optional element 'gmd:source' of XML schema type 'gmd:LI_Source_PropertyType'
        std::vector<gmd__LI_x005fSource_x005fPropertyType *> source;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__LI_x005fLineage_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__LI_x005fLineage_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__LI_x005fLineage_x005fType, default initialized and not managed by a soap context
        virtual gmd__LI_x005fLineage_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__LI_x005fLineage_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__LI_x005fLineage_x005fType() : statement(), processStep(), source() { }
        virtual ~gmd__LI_x005fLineage_x005fType() { }
        /// Friend allocator used by soap_new_gmd__LI_x005fLineage_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__LI_x005fLineage_x005fType * SOAP_FMAC2 soap_instantiate_gmd__LI_x005fLineage_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1832 */
#ifndef SOAP_TYPE_plu_gmd__AbstractDQ_x005fResult_x005fType
#define SOAP_TYPE_plu_gmd__AbstractDQ_x005fResult_x005fType (-565)
/* simple XML schema type 'gmd:AbstractDQ_Result_Type': */
class SOAP_CMAC gmd__AbstractDQ_x005fResult_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__AbstractDQ_x005fResult_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__AbstractDQ_x005fResult_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__AbstractDQ_x005fResult_x005fType, default initialized and not managed by a soap context
        virtual gmd__AbstractDQ_x005fResult_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__AbstractDQ_x005fResult_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__AbstractDQ_x005fResult_x005fType() { }
        virtual ~gmd__AbstractDQ_x005fResult_x005fType() { }
        /// Friend allocator used by soap_new_gmd__AbstractDQ_x005fResult_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__AbstractDQ_x005fResult_x005fType * SOAP_FMAC2 soap_instantiate_gmd__AbstractDQ_x005fResult_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1958 */
#ifndef SOAP_TYPE_plu_gmd__AbstractDQ_x005fElement_x005fType
#define SOAP_TYPE_plu_gmd__AbstractDQ_x005fElement_x005fType (-607)
/* complex XML schema type 'gmd:AbstractDQ_Element_Type': */
class SOAP_CMAC gmd__AbstractDQ_x005fElement_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Optional element 'gmd:nameOfMeasure' of XML schema type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_x005fPropertyType *> nameOfMeasure;
        /// Optional element 'gmd:measureIdentification' of XML schema type 'gmd:MD_Identifier_PropertyType'
        gmd__MD_x005fIdentifier_x005fPropertyType *measureIdentification;
        /// Optional element 'gmd:measureDescription' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *measureDescription;
        /// Optional element 'gmd:evaluationMethodType' of XML schema type 'gmd:DQ_EvaluationMethodTypeCode_PropertyType'
        gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType *evaluationMethodType;
        /// Optional element 'gmd:evaluationMethodDescription' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *evaluationMethodDescription;
        /// Optional element 'gmd:evaluationProcedure' of XML schema type 'gmd:CI_Citation_PropertyType'
        gmd__CI_x005fCitation_x005fPropertyType *evaluationProcedure;
        /// Optional element 'gmd:dateTime' of XML schema type 'gco:DateTime_PropertyType'
        std::vector<gco__DateTime_x005fPropertyType *> dateTime;
        /// Sequence of 1 to 2 elements 'gmd:result' of XML schema type 'gmd:DQ_Result_PropertyType'
        std::vector<gmd__DQ_x005fResult_x005fPropertyType *> result;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__AbstractDQ_x005fElement_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__AbstractDQ_x005fElement_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__AbstractDQ_x005fElement_x005fType, default initialized and not managed by a soap context
        virtual gmd__AbstractDQ_x005fElement_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__AbstractDQ_x005fElement_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__AbstractDQ_x005fElement_x005fType() : nameOfMeasure(), measureIdentification(), measureDescription(), evaluationMethodType(), evaluationMethodDescription(), evaluationProcedure(), dateTime(), result() { }
        virtual ~gmd__AbstractDQ_x005fElement_x005fType() { }
        /// Friend allocator used by soap_new_gmd__AbstractDQ_x005fElement_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__AbstractDQ_x005fElement_x005fType * SOAP_FMAC2 soap_instantiate_gmd__AbstractDQ_x005fElement_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1964 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fDataQuality_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fDataQuality_x005fType (-609)
/* complex XML schema type 'gmd:DQ_DataQuality_Type': */
class SOAP_CMAC gmd__DQ_x005fDataQuality_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:scope' of XML schema type 'gmd:DQ_Scope_PropertyType'
        gmd__DQ_x005fScope_x005fPropertyType *scope;
        /// Optional element 'gmd:report' of XML schema type 'gmd:DQ_Element_PropertyType'
        std::vector<gmd__DQ_x005fElement_x005fPropertyType *> report;
        /// Optional element 'gmd:lineage' of XML schema type 'gmd:LI_Lineage_PropertyType'
        gmd__LI_x005fLineage_x005fPropertyType *lineage;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fDataQuality_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fDataQuality_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fDataQuality_x005fType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fDataQuality_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fDataQuality_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fDataQuality_x005fType() : scope(), report(), lineage() { }
        virtual ~gmd__DQ_x005fDataQuality_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fDataQuality_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fDataQuality_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fDataQuality_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1970 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fScope_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fScope_x005fType (-611)
/* complex XML schema type 'gmd:DQ_Scope_Type': */
class SOAP_CMAC gmd__DQ_x005fScope_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:level' of XML schema type 'gmd:MD_ScopeCode_PropertyType'
        gmd__MD_x005fScopeCode_x005fPropertyType *level;
        /// Optional element 'gmd:extent' of XML schema type 'gmd:EX_Extent_PropertyType'
        gmd__EX_x005fExtent_x005fPropertyType *extent;
        /// Optional element 'gmd:levelDescription' of XML schema type 'gmd:MD_ScopeDescription_PropertyType'
        std::vector<gmd__MD_x005fScopeDescription_x005fPropertyType *> levelDescription;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fScope_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fScope_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fScope_x005fType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fScope_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fScope_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fScope_x005fType() : level(), extent(), levelDescription() { }
        virtual ~gmd__DQ_x005fScope_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fScope_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fScope_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fScope_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1979 */
#ifndef SOAP_TYPE_plu_gmd__AbstractMD_x005fIdentification_x005fType
#define SOAP_TYPE_plu_gmd__AbstractMD_x005fIdentification_x005fType (-614)
/* complex XML schema type 'gmd:AbstractMD_Identification_Type': */
class SOAP_CMAC gmd__AbstractMD_x005fIdentification_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:citation' of XML schema type 'gmd:CI_Citation_PropertyType'
        gmd__CI_x005fCitation_x005fPropertyType *citation;
        /// Required element 'gmd:abstract' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *abstract;
        /// Optional element 'gmd:purpose' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *purpose;
        /// Optional element 'gmd:credit' of XML schema type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_x005fPropertyType *> credit;
        /// Optional element 'gmd:status' of XML schema type 'gmd:MD_ProgressCode_PropertyType'
        std::vector<gmd__MD_x005fProgressCode_x005fPropertyType *> status;
        /// Optional element 'gmd:pointOfContact' of XML schema type 'gmd:CI_ResponsibleParty_PropertyType'
        std::vector<gmd__CI_x005fResponsibleParty_x005fPropertyType *> pointOfContact;
        /// Optional element 'gmd:resourceMaintenance' of XML schema type 'gmd:MD_MaintenanceInformation_PropertyType'
        std::vector<gmd__MD_x005fMaintenanceInformation_x005fPropertyType *> resourceMaintenance;
        /// Optional element 'gmd:graphicOverview' of XML schema type 'gmd:MD_BrowseGraphic_PropertyType'
        std::vector<gmd__MD_x005fBrowseGraphic_x005fPropertyType *> graphicOverview;
        /// Optional element 'gmd:resourceFormat' of XML schema type 'gmd:MD_Format_PropertyType'
        std::vector<gmd__MD_x005fFormat_x005fPropertyType *> resourceFormat;
        /// Optional element 'gmd:descriptiveKeywords' of XML schema type 'gmd:MD_Keywords_PropertyType'
        std::vector<gmd__MD_x005fKeywords_x005fPropertyType *> descriptiveKeywords;
        /// Optional element 'gmd:resourceSpecificUsage' of XML schema type 'gmd:MD_Usage_PropertyType'
        std::vector<gmd__MD_x005fUsage_x005fPropertyType *> resourceSpecificUsage;
        /// Optional element 'gmd:resourceConstraints' of XML schema type 'gmd:MD_Constraints_PropertyType'
        std::vector<gmd__MD_x005fConstraints_x005fPropertyType *> resourceConstraints;
        /// Optional element 'gmd:aggregationInfo' of XML schema type 'gmd:MD_AggregateInformation_PropertyType'
        std::vector<gmd__MD_x005fAggregateInformation_x005fPropertyType *> aggregationInfo;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__AbstractMD_x005fIdentification_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__AbstractMD_x005fIdentification_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__AbstractMD_x005fIdentification_x005fType, default initialized and not managed by a soap context
        virtual gmd__AbstractMD_x005fIdentification_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__AbstractMD_x005fIdentification_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__AbstractMD_x005fIdentification_x005fType() : citation(), abstract(), purpose(), credit(), status(), pointOfContact(), resourceMaintenance(), graphicOverview(), resourceFormat(), descriptiveKeywords(), resourceSpecificUsage(), resourceConstraints(), aggregationInfo() { }
        virtual ~gmd__AbstractMD_x005fIdentification_x005fType() { }
        /// Friend allocator used by soap_new_gmd__AbstractMD_x005fIdentification_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__AbstractMD_x005fIdentification_x005fType * SOAP_FMAC2 soap_instantiate_gmd__AbstractMD_x005fIdentification_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1985 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fBrowseGraphic_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fBrowseGraphic_x005fType (-616)
/* complex XML schema type 'gmd:MD_BrowseGraphic_Type': */
class SOAP_CMAC gmd__MD_x005fBrowseGraphic_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:fileName' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *fileName;
        /// Optional element 'gmd:fileDescription' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *fileDescription;
        /// Optional element 'gmd:fileType' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *fileType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fBrowseGraphic_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fBrowseGraphic_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fBrowseGraphic_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fBrowseGraphic_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fBrowseGraphic_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fBrowseGraphic_x005fType() : fileName(), fileDescription(), fileType() { }
        virtual ~gmd__MD_x005fBrowseGraphic_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fBrowseGraphic_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fBrowseGraphic_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fBrowseGraphic_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2003 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fRepresentativeFraction_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fRepresentativeFraction_x005fType (-622)
/* complex XML schema type 'gmd:MD_RepresentativeFraction_Type': */
class SOAP_CMAC gmd__MD_x005fRepresentativeFraction_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:denominator' of XML schema type 'gco:Integer_PropertyType'
        gco__Integer_x005fPropertyType *denominator;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fRepresentativeFraction_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fRepresentativeFraction_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fRepresentativeFraction_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fRepresentativeFraction_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fRepresentativeFraction_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fRepresentativeFraction_x005fType() : denominator() { }
        virtual ~gmd__MD_x005fRepresentativeFraction_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fRepresentativeFraction_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fRepresentativeFraction_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fRepresentativeFraction_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2009 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fUsage_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fUsage_x005fType (-624)
/* complex XML schema type 'gmd:MD_Usage_Type': */
class SOAP_CMAC gmd__MD_x005fUsage_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:specificUsage' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *specificUsage;
        /// Optional element 'gmd:usageDateTime' of XML schema type 'gco:DateTime_PropertyType'
        gco__DateTime_x005fPropertyType *usageDateTime;
        /// Optional element 'gmd:userDeterminedLimitations' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *userDeterminedLimitations;
        /// Required element 'gmd:userContactInfo' of XML schema type 'gmd:CI_ResponsibleParty_PropertyType'
        std::vector<gmd__CI_x005fResponsibleParty_x005fPropertyType *> userContactInfo;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fUsage_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fUsage_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fUsage_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fUsage_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fUsage_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fUsage_x005fType() : specificUsage(), usageDateTime(), userDeterminedLimitations(), userContactInfo() { }
        virtual ~gmd__MD_x005fUsage_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fUsage_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fUsage_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fUsage_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2015 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fKeywords_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fKeywords_x005fType (-626)
/* complex XML schema type 'gmd:MD_Keywords_Type': */
class SOAP_CMAC gmd__MD_x005fKeywords_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:keyword' of XML schema type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_x005fPropertyType *> keyword;
        /// Optional element 'gmd:type' of XML schema type 'gmd:MD_KeywordTypeCode_PropertyType'
        gmd__MD_x005fKeywordTypeCode_x005fPropertyType *type;
        /// Optional element 'gmd:thesaurusName' of XML schema type 'gmd:CI_Citation_PropertyType'
        gmd__CI_x005fCitation_x005fPropertyType *thesaurusName;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fKeywords_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fKeywords_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fKeywords_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fKeywords_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fKeywords_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fKeywords_x005fType() : keyword(), type(), thesaurusName() { }
        virtual ~gmd__MD_x005fKeywords_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fKeywords_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fKeywords_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fKeywords_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2021 */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fAssociation_x005fType
#define SOAP_TYPE_plu_gmd__DS_x005fAssociation_x005fType (-628)
/* simple XML schema type 'gmd:DS_Association_Type': */
class SOAP_CMAC gmd__DS_x005fAssociation_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DS_x005fAssociation_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DS_x005fAssociation_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DS_x005fAssociation_x005fType, default initialized and not managed by a soap context
        virtual gmd__DS_x005fAssociation_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DS_x005fAssociation_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DS_x005fAssociation_x005fType() { }
        virtual ~gmd__DS_x005fAssociation_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DS_x005fAssociation_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DS_x005fAssociation_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DS_x005fAssociation_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2027 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fAggregateInformation_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fAggregateInformation_x005fType (-630)
/* complex XML schema type 'gmd:MD_AggregateInformation_Type': */
class SOAP_CMAC gmd__MD_x005fAggregateInformation_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Optional element 'gmd:aggregateDataSetName' of XML schema type 'gmd:CI_Citation_PropertyType'
        gmd__CI_x005fCitation_x005fPropertyType *aggregateDataSetName;
        /// Optional element 'gmd:aggregateDataSetIdentifier' of XML schema type 'gmd:MD_Identifier_PropertyType'
        gmd__MD_x005fIdentifier_x005fPropertyType *aggregateDataSetIdentifier;
        /// Required element 'gmd:associationType' of XML schema type 'gmd:DS_AssociationTypeCode_PropertyType'
        gmd__DS_x005fAssociationTypeCode_x005fPropertyType *associationType;
        /// Optional element 'gmd:initiativeType' of XML schema type 'gmd:DS_InitiativeTypeCode_PropertyType'
        gmd__DS_x005fInitiativeTypeCode_x005fPropertyType *initiativeType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fAggregateInformation_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fAggregateInformation_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fAggregateInformation_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fAggregateInformation_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fAggregateInformation_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fAggregateInformation_x005fType() : aggregateDataSetName(), aggregateDataSetIdentifier(), associationType(), initiativeType() { }
        virtual ~gmd__MD_x005fAggregateInformation_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fAggregateInformation_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fAggregateInformation_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fAggregateInformation_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2060 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fConstraints_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fConstraints_x005fType (-641)
/* complex XML schema type 'gmd:MD_Constraints_Type': */
class SOAP_CMAC gmd__MD_x005fConstraints_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Optional element 'gmd:useLimitation' of XML schema type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_x005fPropertyType *> useLimitation;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fConstraints_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fConstraints_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fConstraints_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fConstraints_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fConstraints_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fConstraints_x005fType() : useLimitation() { }
        virtual ~gmd__MD_x005fConstraints_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fConstraints_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fConstraints_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fConstraints_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2084 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMedium_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fMedium_x005fType (-649)
/* complex XML schema type 'gmd:MD_Medium_Type': */
class SOAP_CMAC gmd__MD_x005fMedium_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Optional element 'gmd:name' of XML schema type 'gmd:MD_MediumNameCode_PropertyType'
        gmd__MD_x005fMediumNameCode_x005fPropertyType *name;
        /// Optional element 'gmd:density' of XML schema type 'gco:Real_PropertyType'
        std::vector<gco__Real_x005fPropertyType *> density;
        /// Optional element 'gmd:densityUnits' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *densityUnits;
        /// Optional element 'gmd:volumes' of XML schema type 'gco:Integer_PropertyType'
        gco__Integer_x005fPropertyType *volumes;
        /// Optional element 'gmd:mediumFormat' of XML schema type 'gmd:MD_MediumFormatCode_PropertyType'
        std::vector<gmd__MD_x005fMediumFormatCode_x005fPropertyType *> mediumFormat;
        /// Optional element 'gmd:mediumNote' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *mediumNote;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fMedium_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fMedium_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fMedium_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fMedium_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fMedium_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fMedium_x005fType() : name(), density(), densityUnits(), volumes(), mediumFormat(), mediumNote() { }
        virtual ~gmd__MD_x005fMedium_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fMedium_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fMedium_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fMedium_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2090 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDigitalTransferOptions_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fDigitalTransferOptions_x005fType (-651)
/* complex XML schema type 'gmd:MD_DigitalTransferOptions_Type': */
class SOAP_CMAC gmd__MD_x005fDigitalTransferOptions_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Optional element 'gmd:unitsOfDistribution' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *unitsOfDistribution;
        /// Optional element 'gmd:transferSize' of XML schema type 'gco:Real_PropertyType'
        gco__Real_x005fPropertyType *transferSize;
        /// Optional element 'gmd:onLine' of XML schema type 'gmd:CI_OnlineResource_PropertyType'
        std::vector<gmd__CI_x005fOnlineResource_x005fPropertyType *> onLine;
        /// Optional element 'gmd:offLine' of XML schema type 'gmd:MD_Medium_PropertyType'
        gmd__MD_x005fMedium_x005fPropertyType *offLine;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fDigitalTransferOptions_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fDigitalTransferOptions_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fDigitalTransferOptions_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fDigitalTransferOptions_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fDigitalTransferOptions_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fDigitalTransferOptions_x005fType() : unitsOfDistribution(), transferSize(), onLine(), offLine() { }
        virtual ~gmd__MD_x005fDigitalTransferOptions_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fDigitalTransferOptions_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fDigitalTransferOptions_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fDigitalTransferOptions_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2096 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fStandardOrderProcess_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fStandardOrderProcess_x005fType (-653)
/* complex XML schema type 'gmd:MD_StandardOrderProcess_Type': */
class SOAP_CMAC gmd__MD_x005fStandardOrderProcess_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Optional element 'gmd:fees' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *fees;
        /// Optional element 'gmd:plannedAvailableDateTime' of XML schema type 'gco:DateTime_PropertyType'
        gco__DateTime_x005fPropertyType *plannedAvailableDateTime;
        /// Optional element 'gmd:orderingInstructions' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *orderingInstructions;
        /// Optional element 'gmd:turnaround' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *turnaround;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fStandardOrderProcess_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fStandardOrderProcess_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fStandardOrderProcess_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fStandardOrderProcess_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fStandardOrderProcess_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fStandardOrderProcess_x005fType() : fees(), plannedAvailableDateTime(), orderingInstructions(), turnaround() { }
        virtual ~gmd__MD_x005fStandardOrderProcess_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fStandardOrderProcess_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fStandardOrderProcess_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fStandardOrderProcess_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2102 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDistributor_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fDistributor_x005fType (-655)
/* complex XML schema type 'gmd:MD_Distributor_Type': */
class SOAP_CMAC gmd__MD_x005fDistributor_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:distributorContact' of XML schema type 'gmd:CI_ResponsibleParty_PropertyType'
        gmd__CI_x005fResponsibleParty_x005fPropertyType *distributorContact;
        /// Optional element 'gmd:distributionOrderProcess' of XML schema type 'gmd:MD_StandardOrderProcess_PropertyType'
        std::vector<gmd__MD_x005fStandardOrderProcess_x005fPropertyType *> distributionOrderProcess;
        /// Optional element 'gmd:distributorFormat' of XML schema type 'gmd:MD_Format_PropertyType'
        std::vector<gmd__MD_x005fFormat_x005fPropertyType *> distributorFormat;
        /// Optional element 'gmd:distributorTransferOptions' of XML schema type 'gmd:MD_DigitalTransferOptions_PropertyType'
        std::vector<gmd__MD_x005fDigitalTransferOptions_x005fPropertyType *> distributorTransferOptions;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fDistributor_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fDistributor_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fDistributor_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fDistributor_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fDistributor_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fDistributor_x005fType() : distributorContact(), distributionOrderProcess(), distributorFormat(), distributorTransferOptions() { }
        virtual ~gmd__MD_x005fDistributor_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fDistributor_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fDistributor_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fDistributor_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2108 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDistribution_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fDistribution_x005fType (-657)
/* complex XML schema type 'gmd:MD_Distribution_Type': */
class SOAP_CMAC gmd__MD_x005fDistribution_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Optional element 'gmd:distributionFormat' of XML schema type 'gmd:MD_Format_PropertyType'
        std::vector<gmd__MD_x005fFormat_x005fPropertyType *> distributionFormat;
        /// Optional element 'gmd:distributor' of XML schema type 'gmd:MD_Distributor_PropertyType'
        std::vector<gmd__MD_x005fDistributor_x005fPropertyType *> distributor;
        /// Optional element 'gmd:transferOptions' of XML schema type 'gmd:MD_DigitalTransferOptions_PropertyType'
        std::vector<gmd__MD_x005fDigitalTransferOptions_x005fPropertyType *> transferOptions;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fDistribution_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fDistribution_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fDistribution_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fDistribution_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fDistribution_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fDistribution_x005fType() : distributionFormat(), distributor(), transferOptions() { }
        virtual ~gmd__MD_x005fDistribution_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fDistribution_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fDistribution_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fDistribution_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2114 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fFormat_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fFormat_x005fType (-659)
/* complex XML schema type 'gmd:MD_Format_Type': */
class SOAP_CMAC gmd__MD_x005fFormat_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:name' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *name;
        /// Required element 'gmd:version' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *version;
        /// Optional element 'gmd:amendmentNumber' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *amendmentNumber;
        /// Optional element 'gmd:specification' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *specification;
        /// Optional element 'gmd:fileDecompressionTechnique' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *fileDecompressionTechnique;
        /// Optional element 'gmd:formatDistributor' of XML schema type 'gmd:MD_Distributor_PropertyType'
        std::vector<gmd__MD_x005fDistributor_x005fPropertyType *> formatDistributor;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fFormat_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fFormat_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fFormat_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fFormat_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fFormat_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fFormat_x005fType() : name(), version(), amendmentNumber(), specification(), fileDecompressionTechnique(), formatDistributor() { }
        virtual ~gmd__MD_x005fFormat_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fFormat_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fFormat_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fFormat_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2129 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMaintenanceInformation_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fMaintenanceInformation_x005fType (-664)
/* complex XML schema type 'gmd:MD_MaintenanceInformation_Type': */
class SOAP_CMAC gmd__MD_x005fMaintenanceInformation_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:maintenanceAndUpdateFrequency' of XML schema type 'gmd:MD_MaintenanceFrequencyCode_PropertyType'
        gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType *maintenanceAndUpdateFrequency;
        /// Optional element 'gmd:dateOfNextUpdate' of XML schema type 'gco:Date_PropertyType'
        gco__Date_x005fPropertyType *dateOfNextUpdate;
        /// Optional element 'gmd:userDefinedMaintenanceFrequency' of XML schema type 'gts:TM_PeriodDuration_PropertyType'
        gts__TM_x005fPeriodDuration_x005fPropertyType *userDefinedMaintenanceFrequency;
        /// Optional element 'gmd:updateScope' of XML schema type 'gmd:MD_ScopeCode_PropertyType'
        std::vector<gmd__MD_x005fScopeCode_x005fPropertyType *> updateScope;
        /// Optional element 'gmd:updateScopeDescription' of XML schema type 'gmd:MD_ScopeDescription_PropertyType'
        std::vector<gmd__MD_x005fScopeDescription_x005fPropertyType *> updateScopeDescription;
        /// Optional element 'gmd:maintenanceNote' of XML schema type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_x005fPropertyType *> maintenanceNote;
        /// Optional element 'gmd:contact' of XML schema type 'gmd:CI_ResponsibleParty_PropertyType'
        std::vector<gmd__CI_x005fResponsibleParty_x005fPropertyType *> contact;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fMaintenanceInformation_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fMaintenanceInformation_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fMaintenanceInformation_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fMaintenanceInformation_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fMaintenanceInformation_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fMaintenanceInformation_x005fType() : maintenanceAndUpdateFrequency(), dateOfNextUpdate(), userDefinedMaintenanceFrequency(), updateScope(), updateScopeDescription(), maintenanceNote(), contact() { }
        virtual ~gmd__MD_x005fMaintenanceInformation_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fMaintenanceInformation_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fMaintenanceInformation_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fMaintenanceInformation_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2147 */
#ifndef SOAP_TYPE_plu_gmd__PT_x005fFreeText_x005fType
#define SOAP_TYPE_plu_gmd__PT_x005fFreeText_x005fType (-670)
/* complex XML schema type 'gmd:PT_FreeText_Type': */
class SOAP_CMAC gmd__PT_x005fFreeText_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:textGroup' of XML schema type 'gmd:LocalisedCharacterString_PropertyType'
        std::vector<gmd__LocalisedCharacterString_x005fPropertyType *> textGroup;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__PT_x005fFreeText_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__PT_x005fFreeText_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__PT_x005fFreeText_x005fType, default initialized and not managed by a soap context
        virtual gmd__PT_x005fFreeText_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__PT_x005fFreeText_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__PT_x005fFreeText_x005fType() : textGroup() { }
        virtual ~gmd__PT_x005fFreeText_x005fType() { }
        /// Friend allocator used by soap_new_gmd__PT_x005fFreeText_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__PT_x005fFreeText_x005fType * SOAP_FMAC2 soap_instantiate_gmd__PT_x005fFreeText_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:25439 */
#ifndef SOAP_TYPE_plu___gmd__PT_x005fFreeText_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__PT_x005fFreeText_x005fPropertyType_sequence (-2033)
/* Wrapper: */
class SOAP_CMAC __gmd__PT_x005fFreeText_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:PT_FreeText' of XML schema type 'gmd:PT_FreeText_Type'
        gmd__PT_x005fFreeText_x005fType *PT_x005fFreeText;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__PT_x005fFreeText_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__PT_x005fFreeText_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__PT_x005fFreeText_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__PT_x005fFreeText_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__PT_x005fFreeText_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__PT_x005fFreeText_x005fPropertyType_sequence() : PT_x005fFreeText() { }
        virtual ~__gmd__PT_x005fFreeText_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__PT_x005fFreeText_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__PT_x005fFreeText_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__PT_x005fFreeText_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2150 */
#ifndef SOAP_TYPE_plu_gmd__PT_x005fFreeText_x005fPropertyType
#define SOAP_TYPE_plu_gmd__PT_x005fFreeText_x005fPropertyType (-671)
/* complex XML schema type 'gmd:PT_FreeText_PropertyType': */
class SOAP_CMAC gmd__PT_x005fFreeText_x005fPropertyType : public gco__CharacterString_x005fPropertyType {
      public:
        __gmd__PT_x005fFreeText_x005fPropertyType_sequence *__PT_x005fFreeText_x005fPropertyType_sequence;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__PT_x005fFreeText_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__PT_x005fFreeText_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__PT_x005fFreeText_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__PT_x005fFreeText_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__PT_x005fFreeText_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__PT_x005fFreeText_x005fPropertyType() : __PT_x005fFreeText_x005fPropertyType_sequence() { }
        virtual ~gmd__PT_x005fFreeText_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__PT_x005fFreeText_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__PT_x005fFreeText_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__PT_x005fFreeText_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2153 */
#ifndef SOAP_TYPE_plu_gmd__PT_x005fLocale_x005fType
#define SOAP_TYPE_plu_gmd__PT_x005fLocale_x005fType (-672)
/* complex XML schema type 'gmd:PT_Locale_Type': */
class SOAP_CMAC gmd__PT_x005fLocale_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gmd:languageCode' of XML schema type 'gmd:LanguageCode_PropertyType'
        gmd__LanguageCode_x005fPropertyType *languageCode;
        /// Optional element 'gmd:country' of XML schema type 'gmd:Country_PropertyType'
        gmd__Country_x005fPropertyType *country;
        /// Required element 'gmd:characterEncoding' of XML schema type 'gmd:MD_CharacterSetCode_PropertyType'
        gmd__MD_x005fCharacterSetCode_x005fPropertyType *characterEncoding;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__PT_x005fLocale_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__PT_x005fLocale_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__PT_x005fLocale_x005fType, default initialized and not managed by a soap context
        virtual gmd__PT_x005fLocale_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__PT_x005fLocale_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__PT_x005fLocale_x005fType() : languageCode(), country(), characterEncoding() { }
        virtual ~gmd__PT_x005fLocale_x005fType() { }
        /// Friend allocator used by soap_new_gmd__PT_x005fLocale_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__PT_x005fLocale_x005fType * SOAP_FMAC2 soap_instantiate_gmd__PT_x005fLocale_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2159 */
#ifndef SOAP_TYPE_plu_gmd__LocalisedCharacterString_x005fType
#define SOAP_TYPE_plu_gmd__LocalisedCharacterString_x005fType (-674)
/* simple XML schema type 'gmd:LocalisedCharacterString_Type': */
class SOAP_CMAC gmd__LocalisedCharacterString_x005fType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'id' of XML schema type 'xsd:ID'
        char **id;
        /// Optional attribute 'locale' of XML schema type 'xsd:anyURI'
        char **locale;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__LocalisedCharacterString_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__LocalisedCharacterString_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__LocalisedCharacterString_x005fType, default initialized and not managed by a soap context
        virtual gmd__LocalisedCharacterString_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__LocalisedCharacterString_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__LocalisedCharacterString_x005fType() : __item(), id(), locale() { }
        virtual ~gmd__LocalisedCharacterString_x005fType() { }
        /// Friend allocator used by soap_new_gmd__LocalisedCharacterString_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__LocalisedCharacterString_x005fType * SOAP_FMAC2 soap_instantiate_gmd__LocalisedCharacterString_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:25538 */
#ifndef SOAP_TYPE_plu___gmd__LocalisedCharacterString_x005fPropertyType_sequence
#define SOAP_TYPE_plu___gmd__LocalisedCharacterString_x005fPropertyType_sequence (-2038)
/* Wrapper: */
class SOAP_CMAC __gmd__LocalisedCharacterString_x005fPropertyType_sequence {
      public:
        /// Required element 'gmd:LocalisedCharacterString' of XML schema type 'gmd:LocalisedCharacterString_Type'
        gmd__LocalisedCharacterString_x005fType *LocalisedCharacterString;
      public:
        /// Return unique type id SOAP_TYPE_plu___gmd__LocalisedCharacterString_x005fPropertyType_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gmd__LocalisedCharacterString_x005fPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__LocalisedCharacterString_x005fPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__LocalisedCharacterString_x005fPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gmd__LocalisedCharacterString_x005fPropertyType_sequence); }
      public:
        /// Constructor with default initializations
        __gmd__LocalisedCharacterString_x005fPropertyType_sequence() : LocalisedCharacterString() { }
        virtual ~__gmd__LocalisedCharacterString_x005fPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__LocalisedCharacterString_x005fPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__LocalisedCharacterString_x005fPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__LocalisedCharacterString_x005fPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2162 */
#ifndef SOAP_TYPE_plu_gmd__LocalisedCharacterString_x005fPropertyType
#define SOAP_TYPE_plu_gmd__LocalisedCharacterString_x005fPropertyType (-675)
/* complex XML schema type 'gmd:LocalisedCharacterString_PropertyType': */
class SOAP_CMAC gmd__LocalisedCharacterString_x005fPropertyType : public gco__ObjectReference_x005fPropertyType {
      public:
        __gmd__LocalisedCharacterString_x005fPropertyType_sequence *__LocalisedCharacterString_x005fPropertyType_sequence;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__LocalisedCharacterString_x005fPropertyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__LocalisedCharacterString_x005fPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__LocalisedCharacterString_x005fPropertyType, default initialized and not managed by a soap context
        virtual gmd__LocalisedCharacterString_x005fPropertyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__LocalisedCharacterString_x005fPropertyType); }
      public:
        /// Constructor with default initializations
        gmd__LocalisedCharacterString_x005fPropertyType() : __LocalisedCharacterString_x005fPropertyType_sequence() { }
        virtual ~gmd__LocalisedCharacterString_x005fPropertyType() { }
        /// Friend allocator used by soap_new_gmd__LocalisedCharacterString_x005fPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__LocalisedCharacterString_x005fPropertyType * SOAP_FMAC2 soap_instantiate_gmd__LocalisedCharacterString_x005fPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2195 */
#ifndef SOAP_TYPE_plu_gco__TypeName_x005fType
#define SOAP_TYPE_plu_gco__TypeName_x005fType (-686)
/* complex XML schema type 'gco:TypeName_Type': */
class SOAP_CMAC gco__TypeName_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gco:aName' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *aName;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__TypeName_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__TypeName_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__TypeName_x005fType, default initialized and not managed by a soap context
        virtual gco__TypeName_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__TypeName_x005fType); }
      public:
        /// Constructor with default initializations
        gco__TypeName_x005fType() : aName() { }
        virtual ~gco__TypeName_x005fType() { }
        /// Friend allocator used by soap_new_gco__TypeName_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gco__TypeName_x005fType * SOAP_FMAC2 soap_instantiate_gco__TypeName_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2201 */
#ifndef SOAP_TYPE_plu_gco__MemberName_x005fType
#define SOAP_TYPE_plu_gco__MemberName_x005fType (-688)
/* complex XML schema type 'gco:MemberName_Type': */
class SOAP_CMAC gco__MemberName_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gco:aName' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *aName;
        /// Required element 'gco:attributeType' of XML schema type 'gco:TypeName_PropertyType'
        gco__TypeName_x005fPropertyType *attributeType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__MemberName_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__MemberName_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__MemberName_x005fType, default initialized and not managed by a soap context
        virtual gco__MemberName_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__MemberName_x005fType); }
      public:
        /// Constructor with default initializations
        gco__MemberName_x005fType() : aName(), attributeType() { }
        virtual ~gco__MemberName_x005fType() { }
        /// Friend allocator used by soap_new_gco__MemberName_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gco__MemberName_x005fType * SOAP_FMAC2 soap_instantiate_gco__MemberName_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2207 */
#ifndef SOAP_TYPE_plu_gco__Multiplicity_x005fType
#define SOAP_TYPE_plu_gco__Multiplicity_x005fType (-690)
/* complex XML schema type 'gco:Multiplicity_Type': */
class SOAP_CMAC gco__Multiplicity_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gco:range' of XML schema type 'gco:MultiplicityRange_PropertyType'
        std::vector<gco__MultiplicityRange_x005fPropertyType *> range;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__Multiplicity_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__Multiplicity_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Multiplicity_x005fType, default initialized and not managed by a soap context
        virtual gco__Multiplicity_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__Multiplicity_x005fType); }
      public:
        /// Constructor with default initializations
        gco__Multiplicity_x005fType() : range() { }
        virtual ~gco__Multiplicity_x005fType() { }
        /// Friend allocator used by soap_new_gco__Multiplicity_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gco__Multiplicity_x005fType * SOAP_FMAC2 soap_instantiate_gco__Multiplicity_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2213 */
#ifndef SOAP_TYPE_plu_gco__MultiplicityRange_x005fType
#define SOAP_TYPE_plu_gco__MultiplicityRange_x005fType (-692)
/* complex XML schema type 'gco:MultiplicityRange_Type': */
class SOAP_CMAC gco__MultiplicityRange_x005fType : public gco__AbstractObject_x005fType {
      public:
        /// Required element 'gco:lower' of XML schema type 'gco:Integer_PropertyType'
        gco__Integer_x005fPropertyType *lower;
        /// Required element 'gco:upper' of XML schema type 'gco:UnlimitedInteger_PropertyType'
        gco__UnlimitedInteger_x005fPropertyType *upper;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__MultiplicityRange_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__MultiplicityRange_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__MultiplicityRange_x005fType, default initialized and not managed by a soap context
        virtual gco__MultiplicityRange_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__MultiplicityRange_x005fType); }
      public:
        /// Constructor with default initializations
        gco__MultiplicityRange_x005fType() : lower(), upper() { }
        virtual ~gco__MultiplicityRange_x005fType() { }
        /// Friend allocator used by soap_new_gco__MultiplicityRange_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gco__MultiplicityRange_x005fType * SOAP_FMAC2 soap_instantiate_gco__MultiplicityRange_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2291 */
#ifndef SOAP_TYPE_plu_gco__UnlimitedInteger_x005fType
#define SOAP_TYPE_plu_gco__UnlimitedInteger_x005fType (-718)
/* simple XML schema type 'gco:UnlimitedInteger_Type': */
class SOAP_CMAC gco__UnlimitedInteger_x005fType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:nonNegativeInteger' wrapped by this struct
        ULONG64 __item;
        /// Optional attribute 'isInfinite' of XML schema type 'xsd:boolean'
        bool *isInfinite;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__UnlimitedInteger_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__UnlimitedInteger_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__UnlimitedInteger_x005fType, default initialized and not managed by a soap context
        virtual gco__UnlimitedInteger_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__UnlimitedInteger_x005fType); }
      public:
        /// Constructor with default initializations
        gco__UnlimitedInteger_x005fType() : __item(), isInfinite() { }
        virtual ~gco__UnlimitedInteger_x005fType() { }
        /// Friend allocator used by soap_new_gco__UnlimitedInteger_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gco__UnlimitedInteger_x005fType * SOAP_FMAC2 soap_instantiate_gco__UnlimitedInteger_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2300 */
#ifndef SOAP_TYPE_plu_gco__RecordType_x005fType
#define SOAP_TYPE_plu_gco__RecordType_x005fType (-721)
/* simple XML schema type 'gco:RecordType_Type': */
class SOAP_CMAC gco__RecordType_x005fType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__RecordType_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__RecordType_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__RecordType_x005fType, default initialized and not managed by a soap context
        virtual gco__RecordType_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__RecordType_x005fType); }
      public:
        /// Constructor with default initializations
        gco__RecordType_x005fType() : __item(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~gco__RecordType_x005fType() { }
        /// Friend allocator used by soap_new_gco__RecordType_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gco__RecordType_x005fType * SOAP_FMAC2 soap_instantiate_gco__RecordType_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2306 */
#ifndef SOAP_TYPE_plu_gco__Binary_x005fType
#define SOAP_TYPE_plu_gco__Binary_x005fType (-723)
/* simple XML schema type 'gco:Binary_Type': */
class SOAP_CMAC gco__Binary_x005fType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'src' of XML schema type 'xsd:anyURI'
        char **src;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__Binary_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__Binary_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Binary_x005fType, default initialized and not managed by a soap context
        virtual gco__Binary_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__Binary_x005fType); }
      public:
        /// Constructor with default initializations
        gco__Binary_x005fType() : __item(), src() { }
        virtual ~gco__Binary_x005fType() { }
        /// Friend allocator used by soap_new_gco__Binary_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gco__Binary_x005fType * SOAP_FMAC2 soap_instantiate_gco__Binary_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2318 */
#ifndef SOAP_TYPE_plu_gco__CodeListValue_x005fType
#define SOAP_TYPE_plu_gco__CodeListValue_x005fType (-727)
/* simple XML schema type 'gco:CodeListValue_Type': */
class SOAP_CMAC gco__CodeListValue_x005fType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Required attribute 'codeList' of XML schema type 'xsd:anyURI'
        char *codeList;
        /// Required attribute 'codeListValue' of XML schema type 'xsd:anyURI'
        char *codeListValue;
        /// Optional attribute 'codeSpace' of XML schema type 'xsd:anyURI'
        char **codeSpace;
      public:
        /// Return unique type id SOAP_TYPE_plu_gco__CodeListValue_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gco__CodeListValue_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__CodeListValue_x005fType, default initialized and not managed by a soap context
        virtual gco__CodeListValue_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gco__CodeListValue_x005fType); }
      public:
        /// Constructor with default initializations
        gco__CodeListValue_x005fType() : __item(), codeList(), codeListValue(), codeSpace() { }
        virtual ~gco__CodeListValue_x005fType() { }
        /// Friend allocator used by soap_new_gco__CodeListValue_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gco__CodeListValue_x005fType * SOAP_FMAC2 soap_instantiate_gco__CodeListValue_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:25855 */
#ifndef SOAP_TYPE_plu__plu__ZoningElementType_validFrom
#define SOAP_TYPE_plu__plu__ZoningElementType_validFrom (-2046)
/* simple XML schema type 'plu:ZoningElementType-validFrom': */
class SOAP_CMAC _plu__ZoningElementType_validFrom {
      public:
        /// Simple content of XML schema type 'xsd:date' wrapped by this struct
        char *__item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__ZoningElementType_validFrom
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__ZoningElementType_validFrom; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__ZoningElementType_validFrom, default initialized and not managed by a soap context
        virtual _plu__ZoningElementType_validFrom *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__ZoningElementType_validFrom); }
      public:
        /// Constructor with default initializations
        _plu__ZoningElementType_validFrom() : __item(), nilReason() { }
        virtual ~_plu__ZoningElementType_validFrom() { }
        /// Friend allocator used by soap_new__plu__ZoningElementType_validFrom(struct soap*, int)
        friend SOAP_FMAC1 _plu__ZoningElementType_validFrom * SOAP_FMAC2 soap_instantiate__plu__ZoningElementType_validFrom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:25876 */
#ifndef SOAP_TYPE_plu__plu__ZoningElementType_validTo
#define SOAP_TYPE_plu__plu__ZoningElementType_validTo (-2048)
/* simple XML schema type 'plu:ZoningElementType-validTo': */
class SOAP_CMAC _plu__ZoningElementType_validTo {
      public:
        /// Simple content of XML schema type 'xsd:date' wrapped by this struct
        char *__item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__ZoningElementType_validTo
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__ZoningElementType_validTo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__ZoningElementType_validTo, default initialized and not managed by a soap context
        virtual _plu__ZoningElementType_validTo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__ZoningElementType_validTo); }
      public:
        /// Constructor with default initializations
        _plu__ZoningElementType_validTo() : __item(), nilReason() { }
        virtual ~_plu__ZoningElementType_validTo() { }
        /// Friend allocator used by soap_new__plu__ZoningElementType_validTo(struct soap*, int)
        friend SOAP_FMAC1 _plu__ZoningElementType_validTo * SOAP_FMAC2 soap_instantiate__plu__ZoningElementType_validTo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:25903 */
#ifndef SOAP_TYPE_plu__plu__ZoningElementType_beginLifespanVersion
#define SOAP_TYPE_plu__plu__ZoningElementType_beginLifespanVersion (-2050)
/* simple XML schema type 'plu:ZoningElementType-beginLifespanVersion': */
class SOAP_CMAC _plu__ZoningElementType_beginLifespanVersion {
      public:
        /// Simple content of XML schema type 'xsd:dateTime' wrapped by this struct
        time_t __item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__ZoningElementType_beginLifespanVersion
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__ZoningElementType_beginLifespanVersion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__ZoningElementType_beginLifespanVersion, default initialized and not managed by a soap context
        virtual _plu__ZoningElementType_beginLifespanVersion *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__ZoningElementType_beginLifespanVersion); }
      public:
        /// Constructor with default initializations
        _plu__ZoningElementType_beginLifespanVersion() : __item(), nilReason() { }
        virtual ~_plu__ZoningElementType_beginLifespanVersion() { }
        /// Friend allocator used by soap_new__plu__ZoningElementType_beginLifespanVersion(struct soap*, int)
        friend SOAP_FMAC1 _plu__ZoningElementType_beginLifespanVersion * SOAP_FMAC2 soap_instantiate__plu__ZoningElementType_beginLifespanVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:25926 */
#ifndef SOAP_TYPE_plu__plu__ZoningElementType_hilucsPresence
#define SOAP_TYPE_plu__plu__ZoningElementType_hilucsPresence (-2052)
/* complex XML schema type 'plu:ZoningElementType-hilucsPresence': */
class SOAP_CMAC _plu__ZoningElementType_hilucsPresence {
      public:
        /// Required element 'lunom:HILUCSPresence' of XML schema type 'lunom:HILUCSPresenceType'
        lunom__HILUCSPresenceType *lunom__HILUCSPresence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__ZoningElementType_hilucsPresence
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__ZoningElementType_hilucsPresence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__ZoningElementType_hilucsPresence, default initialized and not managed by a soap context
        virtual _plu__ZoningElementType_hilucsPresence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__ZoningElementType_hilucsPresence); }
      public:
        /// Constructor with default initializations
        _plu__ZoningElementType_hilucsPresence() : lunom__HILUCSPresence(), nilReason() { }
        virtual ~_plu__ZoningElementType_hilucsPresence() { }
        /// Friend allocator used by soap_new__plu__ZoningElementType_hilucsPresence(struct soap*, int)
        friend SOAP_FMAC1 _plu__ZoningElementType_hilucsPresence * SOAP_FMAC2 soap_instantiate__plu__ZoningElementType_hilucsPresence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:25966 */
#ifndef SOAP_TYPE_plu__plu__ZoningElementType_specificPresence
#define SOAP_TYPE_plu__plu__ZoningElementType_specificPresence (-2054)
/* complex XML schema type 'plu:ZoningElementType-specificPresence': */
class SOAP_CMAC _plu__ZoningElementType_specificPresence {
      public:
        /// Required element 'lunom:SpecificPresence' of XML schema type 'lunom:SpecificPresenceType'
        lunom__SpecificPresenceType *lunom__SpecificPresence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__ZoningElementType_specificPresence
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__ZoningElementType_specificPresence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__ZoningElementType_specificPresence, default initialized and not managed by a soap context
        virtual _plu__ZoningElementType_specificPresence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__ZoningElementType_specificPresence); }
      public:
        /// Constructor with default initializations
        _plu__ZoningElementType_specificPresence() : lunom__SpecificPresence(), nilReason() { }
        virtual ~_plu__ZoningElementType_specificPresence() { }
        /// Friend allocator used by soap_new__plu__ZoningElementType_specificPresence(struct soap*, int)
        friend SOAP_FMAC1 _plu__ZoningElementType_specificPresence * SOAP_FMAC2 soap_instantiate__plu__ZoningElementType_specificPresence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26006 */
#ifndef SOAP_TYPE_plu__plu__ZoningElementType_endLifespanVersion
#define SOAP_TYPE_plu__plu__ZoningElementType_endLifespanVersion (-2056)
/* simple XML schema type 'plu:ZoningElementType-endLifespanVersion': */
class SOAP_CMAC _plu__ZoningElementType_endLifespanVersion {
      public:
        /// Simple content of XML schema type 'xsd:dateTime' wrapped by this struct
        time_t __item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__ZoningElementType_endLifespanVersion
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__ZoningElementType_endLifespanVersion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__ZoningElementType_endLifespanVersion, default initialized and not managed by a soap context
        virtual _plu__ZoningElementType_endLifespanVersion *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__ZoningElementType_endLifespanVersion); }
      public:
        /// Constructor with default initializations
        _plu__ZoningElementType_endLifespanVersion() : __item(), nilReason() { }
        virtual ~_plu__ZoningElementType_endLifespanVersion() { }
        /// Friend allocator used by soap_new__plu__ZoningElementType_endLifespanVersion(struct soap*, int)
        friend SOAP_FMAC1 _plu__ZoningElementType_endLifespanVersion * SOAP_FMAC2 soap_instantiate__plu__ZoningElementType_endLifespanVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26037 */
#ifndef SOAP_TYPE_plu__plu__ZoningElementType_backgroundMap
#define SOAP_TYPE_plu__plu__ZoningElementType_backgroundMap (-2058)
/* complex XML schema type 'plu:ZoningElementType-backgroundMap': */
class SOAP_CMAC _plu__ZoningElementType_backgroundMap {
      public:
        /// Required element 'plu:BackgroundMapValue' of XML schema type 'plu:BackgroundMapValueType'
        plu__BackgroundMapValueType *BackgroundMapValue;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__ZoningElementType_backgroundMap
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__ZoningElementType_backgroundMap; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__ZoningElementType_backgroundMap, default initialized and not managed by a soap context
        virtual _plu__ZoningElementType_backgroundMap *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__ZoningElementType_backgroundMap); }
      public:
        /// Constructor with default initializations
        _plu__ZoningElementType_backgroundMap() : BackgroundMapValue(), nilReason() { }
        virtual ~_plu__ZoningElementType_backgroundMap() { }
        /// Friend allocator used by soap_new__plu__ZoningElementType_backgroundMap(struct soap*, int)
        friend SOAP_FMAC1 _plu__ZoningElementType_backgroundMap * SOAP_FMAC2 soap_instantiate__plu__ZoningElementType_backgroundMap(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26076 */
#ifndef SOAP_TYPE_plu__plu__union_ZoningElementType_dimensioningIndication
#define SOAP_TYPE_plu__plu__union_ZoningElementType_dimensioningIndication (-2061)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _plu__union_ZoningElementType_dimensioningIndication
{
        #define SOAP_UNION_plu__plu__union_ZoningElementType_dimensioningIndication_DimensioningIndicationValue	(1)	/**< union variant selector value for member DimensioningIndicationValue */
        plu__DimensioningIndicationValueType *DimensioningIndicationValue;
        #define SOAP_UNION_plu__plu__union_ZoningElementType_dimensioningIndication_DimensioningIndicationMeasureValue	(2)	/**< union variant selector value for member DimensioningIndicationMeasureValue */
        plu__DimensioningIndicationMeasureValueType *DimensioningIndicationMeasureValue;
        #define SOAP_UNION_plu__plu__union_ZoningElementType_dimensioningIndication_DimensioningIndicationIntegerValue	(3)	/**< union variant selector value for member DimensioningIndicationIntegerValue */
        plu__DimensioningIndicationIntegerValueType *DimensioningIndicationIntegerValue;
        #define SOAP_UNION_plu__plu__union_ZoningElementType_dimensioningIndication_DimensioningIndicationCharacterValue	(4)	/**< union variant selector value for member DimensioningIndicationCharacterValue */
        plu__DimensioningIndicationCharacterValueType *DimensioningIndicationCharacterValue;
        #define SOAP_UNION_plu__plu__union_ZoningElementType_dimensioningIndication_DimensioningIndicationRealValue	(5)	/**< union variant selector value for member DimensioningIndicationRealValue */
        plu__DimensioningIndicationRealValueType *DimensioningIndicationRealValue;
};
#endif

/* PlannedLandUse_v3.0.h:26064 */
#ifndef SOAP_TYPE_plu__plu__ZoningElementType_dimensioningIndication
#define SOAP_TYPE_plu__plu__ZoningElementType_dimensioningIndication (-2060)
/* complex XML schema type 'plu:ZoningElementType-dimensioningIndication': */
class SOAP_CMAC _plu__ZoningElementType_dimensioningIndication {
      public:
        /// Union with union _plu__union_ZoningElementType_dimensioningIndication variant selector __unionDimensioningIndicationValue set to one of: SOAP_UNION_plu__plu__union_ZoningElementType_dimensioningIndication_DimensioningIndicationValue SOAP_UNION_plu__plu__union_ZoningElementType_dimensioningIndication_DimensioningIndicationMeasureValue SOAP_UNION_plu__plu__union_ZoningElementType_dimensioningIndication_DimensioningIndicationIntegerValue SOAP_UNION_plu__plu__union_ZoningElementType_dimensioningIndication_DimensioningIndicationCharacterValue SOAP_UNION_plu__plu__union_ZoningElementType_dimensioningIndication_DimensioningIndicationRealValue
        int __unionDimensioningIndicationValue;
        union _plu__union_ZoningElementType_dimensioningIndication union_ZoningElementType_dimensioningIndication;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__ZoningElementType_dimensioningIndication
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__ZoningElementType_dimensioningIndication; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__ZoningElementType_dimensioningIndication, default initialized and not managed by a soap context
        virtual _plu__ZoningElementType_dimensioningIndication *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__ZoningElementType_dimensioningIndication); }
      public:
        /// Constructor with default initializations
        _plu__ZoningElementType_dimensioningIndication() : __unionDimensioningIndicationValue(), nilReason() { }
        virtual ~_plu__ZoningElementType_dimensioningIndication() { }
        /// Friend allocator used by soap_new__plu__ZoningElementType_dimensioningIndication(struct soap*, int)
        friend SOAP_FMAC1 _plu__ZoningElementType_dimensioningIndication * SOAP_FMAC2 soap_instantiate__plu__ZoningElementType_dimensioningIndication(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:302 */
#ifndef SOAP_TYPE_plu_plu__ZoningElementType
#define SOAP_TYPE_plu_plu__ZoningElementType (-55)
/* complex XML schema type 'plu:ZoningElementType': */
class SOAP_CMAC plu__ZoningElementType : public gml__AbstractFeatureType {
      public:
        /// Required element 'plu:inspireId' of XML schema type 'base:IdentifierPropertyType'
        base__IdentifierPropertyType *inspireId;
        /// Required element 'plu:geometry' of XML schema type 'gml:MultiSurfacePropertyType'
        gml__MultiSurfacePropertyType *geometry;
        /// Optional element 'plu:validFrom' of XML schema type 'plu:ZoningElementType-validFrom'
        _plu__ZoningElementType_validFrom *validFrom;
        /// Optional element 'plu:validTo' of XML schema type 'plu:ZoningElementType-validTo'
        _plu__ZoningElementType_validTo *validTo;
        /// Required element 'plu:hilucsLandUse' of XML schema type 'gml:ReferenceType'
        std::vector<gml__ReferenceType *> hilucsLandUse;
        /// Required nillable (xsi:nil when NULL) element 'plu:beginLifespanVersion' of XML schema type 'plu:ZoningElementType-beginLifespanVersion'
        _plu__ZoningElementType_beginLifespanVersion *beginLifespanVersion;
        /// Required nillable (xsi:nil when NULL) element 'plu:hilucsPresence' of XML schema type 'plu:ZoningElementType-hilucsPresence'
        _plu__ZoningElementType_hilucsPresence *hilucsPresence;
        /// Required element 'plu:specificLandUse' of XML schema type 'gml:ReferenceType'
        std::vector<gml__ReferenceType *> specificLandUse;
        /// Required nillable (xsi:nil when NULL) element 'plu:specificPresence' of XML schema type 'plu:ZoningElementType-specificPresence'
        _plu__ZoningElementType_specificPresence *specificPresence;
        /// Required element 'plu:regulationNature' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *regulationNature;
        /// Optional element 'plu:endLifespanVersion' of XML schema type 'plu:ZoningElementType-endLifespanVersion'
        _plu__ZoningElementType_endLifespanVersion *endLifespanVersion;
        /// Required nillable (xsi:nil when NULL) element 'plu:processStepGeneral' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *processStepGeneral;
        /// Required nillable (xsi:nil when NULL) element 'plu:backgroundMap' of XML schema type 'plu:ZoningElementType-backgroundMap'
        _plu__ZoningElementType_backgroundMap *backgroundMap;
        /// Optional element 'plu:dimensioningIndication' of XML schema type 'plu:ZoningElementType-dimensioningIndication'
        std::vector<_plu__ZoningElementType_dimensioningIndication> *dimensioningIndication;
        /// Required element 'plu:officialDocument' of XML schema type 'gml:ReferenceType'
        std::vector<gml__ReferenceType *> officialDocument;
        /// Required element 'plu:plan' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *plan;
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__ZoningElementType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__ZoningElementType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__ZoningElementType, default initialized and not managed by a soap context
        virtual plu__ZoningElementType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__ZoningElementType); }
      public:
        /// Constructor with default initializations
        plu__ZoningElementType() : inspireId(), geometry(), validFrom(), validTo(), hilucsLandUse(), beginLifespanVersion(), hilucsPresence(), specificLandUse(), specificPresence(), regulationNature(), endLifespanVersion(), processStepGeneral(), backgroundMap(), dimensioningIndication(), officialDocument(), plan() { }
        virtual ~plu__ZoningElementType() { }
        /// Friend allocator used by soap_new_plu__ZoningElementType(struct soap*, int)
        friend SOAP_FMAC1 plu__ZoningElementType * SOAP_FMAC2 soap_instantiate_plu__ZoningElementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26230 */
#ifndef SOAP_TYPE_plu___plu__OfficialDocumentationType_legislationCitation_sequence
#define SOAP_TYPE_plu___plu__OfficialDocumentationType_legislationCitation_sequence (-2065)
/* Wrapper: */
class SOAP_CMAC __plu__OfficialDocumentationType_legislationCitation_sequence {
      public:
        /// Required element 'base2:LegislationCitation' of XML schema type 'base2:LegislationCitationType'
        base2__LegislationCitationType *base2__LegislationCitation;
      public:
        /// Return unique type id SOAP_TYPE_plu___plu__OfficialDocumentationType_legislationCitation_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___plu__OfficialDocumentationType_legislationCitation_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __plu__OfficialDocumentationType_legislationCitation_sequence, default initialized and not managed by a soap context
        virtual __plu__OfficialDocumentationType_legislationCitation_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__plu__OfficialDocumentationType_legislationCitation_sequence); }
      public:
        /// Constructor with default initializations
        __plu__OfficialDocumentationType_legislationCitation_sequence() : base2__LegislationCitation() { }
        virtual ~__plu__OfficialDocumentationType_legislationCitation_sequence() { }
        /// Friend allocator used by soap_new___plu__OfficialDocumentationType_legislationCitation_sequence(struct soap*, int)
        friend SOAP_FMAC1 __plu__OfficialDocumentationType_legislationCitation_sequence * SOAP_FMAC2 soap_instantiate___plu__OfficialDocumentationType_legislationCitation_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26221 */
#ifndef SOAP_TYPE_plu__plu__OfficialDocumentationType_legislationCitation
#define SOAP_TYPE_plu__plu__OfficialDocumentationType_legislationCitation (-2064)
/* complex XML schema type 'plu:OfficialDocumentationType-legislationCitation': */
class SOAP_CMAC _plu__OfficialDocumentationType_legislationCitation {
      public:
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
        __plu__OfficialDocumentationType_legislationCitation_sequence *__OfficialDocumentationType_legislationCitation_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__OfficialDocumentationType_legislationCitation
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__OfficialDocumentationType_legislationCitation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__OfficialDocumentationType_legislationCitation, default initialized and not managed by a soap context
        virtual _plu__OfficialDocumentationType_legislationCitation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__OfficialDocumentationType_legislationCitation); }
      public:
        /// Constructor with default initializations
        _plu__OfficialDocumentationType_legislationCitation() : owns((bool)0), __OfficialDocumentationType_legislationCitation_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~_plu__OfficialDocumentationType_legislationCitation() { }
        /// Friend allocator used by soap_new__plu__OfficialDocumentationType_legislationCitation(struct soap*, int)
        friend SOAP_FMAC1 _plu__OfficialDocumentationType_legislationCitation * SOAP_FMAC2 soap_instantiate__plu__OfficialDocumentationType_legislationCitation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26279 */
#ifndef SOAP_TYPE_plu__plu__OfficialDocumentationType_regulationText
#define SOAP_TYPE_plu__plu__OfficialDocumentationType_regulationText (-2068)
/* simple XML schema type 'plu:OfficialDocumentationType-regulationText': */
class SOAP_CMAC _plu__OfficialDocumentationType_regulationText {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__OfficialDocumentationType_regulationText
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__OfficialDocumentationType_regulationText; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__OfficialDocumentationType_regulationText, default initialized and not managed by a soap context
        virtual _plu__OfficialDocumentationType_regulationText *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__OfficialDocumentationType_regulationText); }
      public:
        /// Constructor with default initializations
        _plu__OfficialDocumentationType_regulationText() : __item(), nilReason() { }
        virtual ~_plu__OfficialDocumentationType_regulationText() { }
        /// Friend allocator used by soap_new__plu__OfficialDocumentationType_regulationText(struct soap*, int)
        friend SOAP_FMAC1 _plu__OfficialDocumentationType_regulationText * SOAP_FMAC2 soap_instantiate__plu__OfficialDocumentationType_regulationText(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26321 */
#ifndef SOAP_TYPE_plu__plu__union_OfficialDocumentationType_planDocument
#define SOAP_TYPE_plu__plu__union_OfficialDocumentationType_planDocument (-2072)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _plu__union_OfficialDocumentationType_planDocument
{
        #define SOAP_UNION_plu__plu__union_OfficialDocumentationType_planDocument_base2__DocumentCitation	(1)	/**< union variant selector value for member base2__DocumentCitation */
        base2__DocumentCitationType *base2__DocumentCitation;
        #define SOAP_UNION_plu__plu__union_OfficialDocumentationType_planDocument_base2__LegislationCitation	(2)	/**< union variant selector value for member base2__LegislationCitation */
        base2__LegislationCitationType *base2__LegislationCitation;
};
#endif

/* PlannedLandUse_v3.0.h:26309 */
#ifndef SOAP_TYPE_plu___plu__OfficialDocumentationType_planDocument_sequence
#define SOAP_TYPE_plu___plu__OfficialDocumentationType_planDocument_sequence (-2071)
/* Wrapper: */
class SOAP_CMAC __plu__OfficialDocumentationType_planDocument_sequence {
      public:
        /// Union with union _plu__union_OfficialDocumentationType_planDocument variant selector __unionDocumentCitation set to one of: SOAP_UNION_plu__plu__union_OfficialDocumentationType_planDocument_base2__DocumentCitation SOAP_UNION_plu__plu__union_OfficialDocumentationType_planDocument_base2__LegislationCitation
        int __unionDocumentCitation;
        union _plu__union_OfficialDocumentationType_planDocument union_OfficialDocumentationType_planDocument;
      public:
        /// Return unique type id SOAP_TYPE_plu___plu__OfficialDocumentationType_planDocument_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___plu__OfficialDocumentationType_planDocument_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __plu__OfficialDocumentationType_planDocument_sequence, default initialized and not managed by a soap context
        virtual __plu__OfficialDocumentationType_planDocument_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__plu__OfficialDocumentationType_planDocument_sequence); }
      public:
        /// Constructor with default initializations
        __plu__OfficialDocumentationType_planDocument_sequence() : __unionDocumentCitation() { }
        virtual ~__plu__OfficialDocumentationType_planDocument_sequence() { }
        /// Friend allocator used by soap_new___plu__OfficialDocumentationType_planDocument_sequence(struct soap*, int)
        friend SOAP_FMAC1 __plu__OfficialDocumentationType_planDocument_sequence * SOAP_FMAC2 soap_instantiate___plu__OfficialDocumentationType_planDocument_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26300 */
#ifndef SOAP_TYPE_plu__plu__OfficialDocumentationType_planDocument
#define SOAP_TYPE_plu__plu__OfficialDocumentationType_planDocument (-2070)
/* complex XML schema type 'plu:OfficialDocumentationType-planDocument': */
class SOAP_CMAC _plu__OfficialDocumentationType_planDocument {
      public:
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
        __plu__OfficialDocumentationType_planDocument_sequence *__OfficialDocumentationType_planDocument_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__OfficialDocumentationType_planDocument
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__OfficialDocumentationType_planDocument; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__OfficialDocumentationType_planDocument, default initialized and not managed by a soap context
        virtual _plu__OfficialDocumentationType_planDocument *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__OfficialDocumentationType_planDocument); }
      public:
        /// Constructor with default initializations
        _plu__OfficialDocumentationType_planDocument() : owns((bool)0), __OfficialDocumentationType_planDocument_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~_plu__OfficialDocumentationType_planDocument() { }
        /// Friend allocator used by soap_new__plu__OfficialDocumentationType_planDocument(struct soap*, int)
        friend SOAP_FMAC1 _plu__OfficialDocumentationType_planDocument * SOAP_FMAC2 soap_instantiate__plu__OfficialDocumentationType_planDocument(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:308 */
#ifndef SOAP_TYPE_plu_plu__OfficialDocumentationType
#define SOAP_TYPE_plu_plu__OfficialDocumentationType (-57)
/* complex XML schema type 'plu:OfficialDocumentationType': */
class SOAP_CMAC plu__OfficialDocumentationType : public gml__AbstractFeatureType {
      public:
        /// Required element 'plu:inspireId' of XML schema type 'base:IdentifierPropertyType'
        base__IdentifierPropertyType *inspireId;
        /// Optional element 'plu:legislationCitation' of XML schema type 'plu:OfficialDocumentationType-legislationCitation'
        _plu__OfficialDocumentationType_legislationCitation *legislationCitation;
        /// Optional element 'plu:regulationText' of XML schema type 'plu:OfficialDocumentationType-regulationText'
        _plu__OfficialDocumentationType_regulationText *regulationText;
        /// Optional element 'plu:planDocument' of XML schema type 'plu:OfficialDocumentationType-planDocument'
        _plu__OfficialDocumentationType_planDocument *planDocument;
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__OfficialDocumentationType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__OfficialDocumentationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__OfficialDocumentationType, default initialized and not managed by a soap context
        virtual plu__OfficialDocumentationType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__OfficialDocumentationType); }
      public:
        /// Constructor with default initializations
        plu__OfficialDocumentationType() : inspireId(), legislationCitation(), regulationText(), planDocument() { }
        virtual ~plu__OfficialDocumentationType() { }
        /// Friend allocator used by soap_new_plu__OfficialDocumentationType(struct soap*, int)
        friend SOAP_FMAC1 plu__OfficialDocumentationType * SOAP_FMAC2 soap_instantiate_plu__OfficialDocumentationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26444 */
#ifndef SOAP_TYPE_plu__plu__SupplementaryRegulationType_validFrom
#define SOAP_TYPE_plu__plu__SupplementaryRegulationType_validFrom (-2075)
/* simple XML schema type 'plu:SupplementaryRegulationType-validFrom': */
class SOAP_CMAC _plu__SupplementaryRegulationType_validFrom {
      public:
        /// Simple content of XML schema type 'xsd:date' wrapped by this struct
        char *__item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__SupplementaryRegulationType_validFrom
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__SupplementaryRegulationType_validFrom; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__SupplementaryRegulationType_validFrom, default initialized and not managed by a soap context
        virtual _plu__SupplementaryRegulationType_validFrom *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__SupplementaryRegulationType_validFrom); }
      public:
        /// Constructor with default initializations
        _plu__SupplementaryRegulationType_validFrom() : __item(), nilReason() { }
        virtual ~_plu__SupplementaryRegulationType_validFrom() { }
        /// Friend allocator used by soap_new__plu__SupplementaryRegulationType_validFrom(struct soap*, int)
        friend SOAP_FMAC1 _plu__SupplementaryRegulationType_validFrom * SOAP_FMAC2 soap_instantiate__plu__SupplementaryRegulationType_validFrom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26465 */
#ifndef SOAP_TYPE_plu__plu__SupplementaryRegulationType_validTo
#define SOAP_TYPE_plu__plu__SupplementaryRegulationType_validTo (-2077)
/* simple XML schema type 'plu:SupplementaryRegulationType-validTo': */
class SOAP_CMAC _plu__SupplementaryRegulationType_validTo {
      public:
        /// Simple content of XML schema type 'xsd:date' wrapped by this struct
        char *__item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__SupplementaryRegulationType_validTo
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__SupplementaryRegulationType_validTo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__SupplementaryRegulationType_validTo, default initialized and not managed by a soap context
        virtual _plu__SupplementaryRegulationType_validTo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__SupplementaryRegulationType_validTo); }
      public:
        /// Constructor with default initializations
        _plu__SupplementaryRegulationType_validTo() : __item(), nilReason() { }
        virtual ~_plu__SupplementaryRegulationType_validTo() { }
        /// Friend allocator used by soap_new__plu__SupplementaryRegulationType_validTo(struct soap*, int)
        friend SOAP_FMAC1 _plu__SupplementaryRegulationType_validTo * SOAP_FMAC2 soap_instantiate__plu__SupplementaryRegulationType_validTo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26502 */
#ifndef SOAP_TYPE_plu__plu__SupplementaryRegulationType_backgroundMap
#define SOAP_TYPE_plu__plu__SupplementaryRegulationType_backgroundMap (-2079)
/* complex XML schema type 'plu:SupplementaryRegulationType-backgroundMap': */
class SOAP_CMAC _plu__SupplementaryRegulationType_backgroundMap {
      public:
        /// Required element 'plu:BackgroundMapValue' of XML schema type 'plu:BackgroundMapValueType'
        plu__BackgroundMapValueType *BackgroundMapValue;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__SupplementaryRegulationType_backgroundMap
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__SupplementaryRegulationType_backgroundMap; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__SupplementaryRegulationType_backgroundMap, default initialized and not managed by a soap context
        virtual _plu__SupplementaryRegulationType_backgroundMap *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__SupplementaryRegulationType_backgroundMap); }
      public:
        /// Constructor with default initializations
        _plu__SupplementaryRegulationType_backgroundMap() : BackgroundMapValue(), nilReason() { }
        virtual ~_plu__SupplementaryRegulationType_backgroundMap() { }
        /// Friend allocator used by soap_new__plu__SupplementaryRegulationType_backgroundMap(struct soap*, int)
        friend SOAP_FMAC1 _plu__SupplementaryRegulationType_backgroundMap * SOAP_FMAC2 soap_instantiate__plu__SupplementaryRegulationType_backgroundMap(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26527 */
#ifndef SOAP_TYPE_plu__plu__SupplementaryRegulationType_beginLifespanVersion
#define SOAP_TYPE_plu__plu__SupplementaryRegulationType_beginLifespanVersion (-2081)
/* simple XML schema type 'plu:SupplementaryRegulationType-beginLifespanVersion': */
class SOAP_CMAC _plu__SupplementaryRegulationType_beginLifespanVersion {
      public:
        /// Simple content of XML schema type 'xsd:dateTime' wrapped by this struct
        time_t __item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__SupplementaryRegulationType_beginLifespanVersion
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__SupplementaryRegulationType_beginLifespanVersion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__SupplementaryRegulationType_beginLifespanVersion, default initialized and not managed by a soap context
        virtual _plu__SupplementaryRegulationType_beginLifespanVersion *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__SupplementaryRegulationType_beginLifespanVersion); }
      public:
        /// Constructor with default initializations
        _plu__SupplementaryRegulationType_beginLifespanVersion() : __item(), nilReason() { }
        virtual ~_plu__SupplementaryRegulationType_beginLifespanVersion() { }
        /// Friend allocator used by soap_new__plu__SupplementaryRegulationType_beginLifespanVersion(struct soap*, int)
        friend SOAP_FMAC1 _plu__SupplementaryRegulationType_beginLifespanVersion * SOAP_FMAC2 soap_instantiate__plu__SupplementaryRegulationType_beginLifespanVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26562 */
#ifndef SOAP_TYPE_plu__plu__union_SupplementaryRegulationType_dimensioningIndication
#define SOAP_TYPE_plu__plu__union_SupplementaryRegulationType_dimensioningIndication (-2084)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _plu__union_SupplementaryRegulationType_dimensioningIndication
{
        #define SOAP_UNION_plu__plu__union_SupplementaryRegulationType_dimensioningIndication_DimensioningIndicationValue	(1)	/**< union variant selector value for member DimensioningIndicationValue */
        plu__DimensioningIndicationValueType *DimensioningIndicationValue;
        #define SOAP_UNION_plu__plu__union_SupplementaryRegulationType_dimensioningIndication_DimensioningIndicationMeasureValue	(2)	/**< union variant selector value for member DimensioningIndicationMeasureValue */
        plu__DimensioningIndicationMeasureValueType *DimensioningIndicationMeasureValue;
        #define SOAP_UNION_plu__plu__union_SupplementaryRegulationType_dimensioningIndication_DimensioningIndicationIntegerValue	(3)	/**< union variant selector value for member DimensioningIndicationIntegerValue */
        plu__DimensioningIndicationIntegerValueType *DimensioningIndicationIntegerValue;
        #define SOAP_UNION_plu__plu__union_SupplementaryRegulationType_dimensioningIndication_DimensioningIndicationCharacterValue	(4)	/**< union variant selector value for member DimensioningIndicationCharacterValue */
        plu__DimensioningIndicationCharacterValueType *DimensioningIndicationCharacterValue;
        #define SOAP_UNION_plu__plu__union_SupplementaryRegulationType_dimensioningIndication_DimensioningIndicationRealValue	(5)	/**< union variant selector value for member DimensioningIndicationRealValue */
        plu__DimensioningIndicationRealValueType *DimensioningIndicationRealValue;
};
#endif

/* PlannedLandUse_v3.0.h:26550 */
#ifndef SOAP_TYPE_plu__plu__SupplementaryRegulationType_dimensioningIndication
#define SOAP_TYPE_plu__plu__SupplementaryRegulationType_dimensioningIndication (-2083)
/* complex XML schema type 'plu:SupplementaryRegulationType-dimensioningIndication': */
class SOAP_CMAC _plu__SupplementaryRegulationType_dimensioningIndication {
      public:
        /// Union with union _plu__union_SupplementaryRegulationType_dimensioningIndication variant selector __unionDimensioningIndicationValue set to one of: SOAP_UNION_plu__plu__union_SupplementaryRegulationType_dimensioningIndication_DimensioningIndicationValue SOAP_UNION_plu__plu__union_SupplementaryRegulationType_dimensioningIndication_DimensioningIndicationMeasureValue SOAP_UNION_plu__plu__union_SupplementaryRegulationType_dimensioningIndication_DimensioningIndicationIntegerValue SOAP_UNION_plu__plu__union_SupplementaryRegulationType_dimensioningIndication_DimensioningIndicationCharacterValue SOAP_UNION_plu__plu__union_SupplementaryRegulationType_dimensioningIndication_DimensioningIndicationRealValue
        int __unionDimensioningIndicationValue;
        union _plu__union_SupplementaryRegulationType_dimensioningIndication union_SupplementaryRegulationType_dimensioningIndication;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__SupplementaryRegulationType_dimensioningIndication
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__SupplementaryRegulationType_dimensioningIndication; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__SupplementaryRegulationType_dimensioningIndication, default initialized and not managed by a soap context
        virtual _plu__SupplementaryRegulationType_dimensioningIndication *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__SupplementaryRegulationType_dimensioningIndication); }
      public:
        /// Constructor with default initializations
        _plu__SupplementaryRegulationType_dimensioningIndication() : __unionDimensioningIndicationValue(), nilReason() { }
        virtual ~_plu__SupplementaryRegulationType_dimensioningIndication() { }
        /// Friend allocator used by soap_new__plu__SupplementaryRegulationType_dimensioningIndication(struct soap*, int)
        friend SOAP_FMAC1 _plu__SupplementaryRegulationType_dimensioningIndication * SOAP_FMAC2 soap_instantiate__plu__SupplementaryRegulationType_dimensioningIndication(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26630 */
#ifndef SOAP_TYPE_plu__plu__SupplementaryRegulationType_endLifespanVersion
#define SOAP_TYPE_plu__plu__SupplementaryRegulationType_endLifespanVersion (-2087)
/* simple XML schema type 'plu:SupplementaryRegulationType-endLifespanVersion': */
class SOAP_CMAC _plu__SupplementaryRegulationType_endLifespanVersion {
      public:
        /// Simple content of XML schema type 'xsd:dateTime' wrapped by this struct
        time_t __item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__SupplementaryRegulationType_endLifespanVersion
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__SupplementaryRegulationType_endLifespanVersion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__SupplementaryRegulationType_endLifespanVersion, default initialized and not managed by a soap context
        virtual _plu__SupplementaryRegulationType_endLifespanVersion *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__SupplementaryRegulationType_endLifespanVersion); }
      public:
        /// Constructor with default initializations
        _plu__SupplementaryRegulationType_endLifespanVersion() : __item(), nilReason() { }
        virtual ~_plu__SupplementaryRegulationType_endLifespanVersion() { }
        /// Friend allocator used by soap_new__plu__SupplementaryRegulationType_endLifespanVersion(struct soap*, int)
        friend SOAP_FMAC1 _plu__SupplementaryRegulationType_endLifespanVersion * SOAP_FMAC2 soap_instantiate__plu__SupplementaryRegulationType_endLifespanVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26659 */
#ifndef SOAP_TYPE_plu__plu__SupplementaryRegulationType_inheritedFromOtherPlans
#define SOAP_TYPE_plu__plu__SupplementaryRegulationType_inheritedFromOtherPlans (-2090)
/* simple XML schema type 'plu:SupplementaryRegulationType-inheritedFromOtherPlans': */
class SOAP_CMAC _plu__SupplementaryRegulationType_inheritedFromOtherPlans {
      public:
        /// Simple content of XML schema type 'xsd:boolean' wrapped by this struct
        bool __item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__SupplementaryRegulationType_inheritedFromOtherPlans
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__SupplementaryRegulationType_inheritedFromOtherPlans; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__SupplementaryRegulationType_inheritedFromOtherPlans, default initialized and not managed by a soap context
        virtual _plu__SupplementaryRegulationType_inheritedFromOtherPlans *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__SupplementaryRegulationType_inheritedFromOtherPlans); }
      public:
        /// Constructor with default initializations
        _plu__SupplementaryRegulationType_inheritedFromOtherPlans() : __item(), nilReason() { }
        virtual ~_plu__SupplementaryRegulationType_inheritedFromOtherPlans() { }
        /// Friend allocator used by soap_new__plu__SupplementaryRegulationType_inheritedFromOtherPlans(struct soap*, int)
        friend SOAP_FMAC1 _plu__SupplementaryRegulationType_inheritedFromOtherPlans * SOAP_FMAC2 soap_instantiate__plu__SupplementaryRegulationType_inheritedFromOtherPlans(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26685 */
#ifndef SOAP_TYPE_plu__plu__SupplementaryRegulationType_specificRegulationNature
#define SOAP_TYPE_plu__plu__SupplementaryRegulationType_specificRegulationNature (-2092)
/* simple XML schema type 'plu:SupplementaryRegulationType-specificRegulationNature': */
class SOAP_CMAC _plu__SupplementaryRegulationType_specificRegulationNature {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__SupplementaryRegulationType_specificRegulationNature
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__SupplementaryRegulationType_specificRegulationNature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__SupplementaryRegulationType_specificRegulationNature, default initialized and not managed by a soap context
        virtual _plu__SupplementaryRegulationType_specificRegulationNature *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__SupplementaryRegulationType_specificRegulationNature); }
      public:
        /// Constructor with default initializations
        _plu__SupplementaryRegulationType_specificRegulationNature() : __item(), nilReason() { }
        virtual ~_plu__SupplementaryRegulationType_specificRegulationNature() { }
        /// Friend allocator used by soap_new__plu__SupplementaryRegulationType_specificRegulationNature(struct soap*, int)
        friend SOAP_FMAC1 _plu__SupplementaryRegulationType_specificRegulationNature * SOAP_FMAC2 soap_instantiate__plu__SupplementaryRegulationType_specificRegulationNature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26708 */
#ifndef SOAP_TYPE_plu__plu__SupplementaryRegulationType_name
#define SOAP_TYPE_plu__plu__SupplementaryRegulationType_name (-2094)
/* simple XML schema type 'plu:SupplementaryRegulationType-name': */
class SOAP_CMAC _plu__SupplementaryRegulationType_name {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__SupplementaryRegulationType_name
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__SupplementaryRegulationType_name; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__SupplementaryRegulationType_name, default initialized and not managed by a soap context
        virtual _plu__SupplementaryRegulationType_name *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__SupplementaryRegulationType_name); }
      public:
        /// Constructor with default initializations
        _plu__SupplementaryRegulationType_name() : __item(), nilReason() { }
        virtual ~_plu__SupplementaryRegulationType_name() { }
        /// Friend allocator used by soap_new__plu__SupplementaryRegulationType_name(struct soap*, int)
        friend SOAP_FMAC1 _plu__SupplementaryRegulationType_name * SOAP_FMAC2 soap_instantiate__plu__SupplementaryRegulationType_name(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:332 */
#ifndef SOAP_TYPE_plu_plu__SupplementaryRegulationType
#define SOAP_TYPE_plu_plu__SupplementaryRegulationType (-65)
/* complex XML schema type 'plu:SupplementaryRegulationType': */
class SOAP_CMAC plu__SupplementaryRegulationType : public gml__AbstractFeatureType {
      public:
        /// Optional element 'plu:validFrom' of XML schema type 'plu:SupplementaryRegulationType-validFrom'
        _plu__SupplementaryRegulationType_validFrom *validFrom;
        /// Optional element 'plu:validTo' of XML schema type 'plu:SupplementaryRegulationType-validTo'
        _plu__SupplementaryRegulationType_validTo *validTo;
        /// Required element 'plu:specificSupplementaryRegulation' of XML schema type 'gml:ReferenceType'
        std::vector<gml__ReferenceType *> specificSupplementaryRegulation;
        /// Required nillable (xsi:nil when NULL) element 'plu:processStepGeneral' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *processStepGeneral;
        /// Required nillable (xsi:nil when NULL) element 'plu:backgroundMap' of XML schema type 'plu:SupplementaryRegulationType-backgroundMap'
        _plu__SupplementaryRegulationType_backgroundMap *backgroundMap;
        /// Required nillable (xsi:nil when NULL) element 'plu:beginLifespanVersion' of XML schema type 'plu:SupplementaryRegulationType-beginLifespanVersion'
        _plu__SupplementaryRegulationType_beginLifespanVersion *beginLifespanVersion;
        /// Optional element 'plu:dimensioningIndication' of XML schema type 'plu:SupplementaryRegulationType-dimensioningIndication'
        std::vector<_plu__SupplementaryRegulationType_dimensioningIndication> *dimensioningIndication;
        /// Required element 'plu:inspireId' of XML schema type 'base:IdentifierPropertyType'
        base__IdentifierPropertyType *inspireId;
        /// Optional element 'plu:endLifespanVersion' of XML schema type 'plu:SupplementaryRegulationType-endLifespanVersion'
        _plu__SupplementaryRegulationType_endLifespanVersion *endLifespanVersion;
        /// Required element 'plu:geometry' of XML schema type 'gml:GeometryPropertyType'
        gml__GeometryPropertyType *geometry;
        /// Required nillable (xsi:nil when NULL) element 'plu:inheritedFromOtherPlans' of XML schema type 'plu:SupplementaryRegulationType-inheritedFromOtherPlans'
        _plu__SupplementaryRegulationType_inheritedFromOtherPlans *inheritedFromOtherPlans;
        /// Required nillable (xsi:nil when NULL) element 'plu:specificRegulationNature' of XML schema type 'plu:SupplementaryRegulationType-specificRegulationNature'
        _plu__SupplementaryRegulationType_specificRegulationNature *specificRegulationNature;
        /// Optional element 'plu:name' of XML schema type 'plu:SupplementaryRegulationType-name'
        std::vector<_plu__SupplementaryRegulationType_name> *name;
        /// Required element 'plu:regulationNature' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *regulationNature;
        /// Required element 'plu:supplementaryRegulation' of XML schema type 'gml:ReferenceType'
        std::vector<gml__ReferenceType *> supplementaryRegulation;
        /// Required element 'plu:officialDocument' of XML schema type 'gml:ReferenceType'
        std::vector<gml__ReferenceType *> officialDocument;
        /// Required element 'plu:plan' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *plan;
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__SupplementaryRegulationType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__SupplementaryRegulationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__SupplementaryRegulationType, default initialized and not managed by a soap context
        virtual plu__SupplementaryRegulationType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__SupplementaryRegulationType); }
      public:
        /// Constructor with default initializations
        plu__SupplementaryRegulationType() : validFrom(), validTo(), specificSupplementaryRegulation(), processStepGeneral(), backgroundMap(), beginLifespanVersion(), dimensioningIndication(), inspireId(), endLifespanVersion(), geometry(), inheritedFromOtherPlans(), specificRegulationNature(), name(), regulationNature(), supplementaryRegulation(), officialDocument(), plan() { }
        virtual ~plu__SupplementaryRegulationType() { }
        /// Friend allocator used by soap_new_plu__SupplementaryRegulationType(struct soap*, int)
        friend SOAP_FMAC1 plu__SupplementaryRegulationType * SOAP_FMAC2 soap_instantiate_plu__SupplementaryRegulationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26834 */
#ifndef SOAP_TYPE_plu__plu__SpatialPlanType_beginLifespanVersion
#define SOAP_TYPE_plu__plu__SpatialPlanType_beginLifespanVersion (-2097)
/* simple XML schema type 'plu:SpatialPlanType-beginLifespanVersion': */
class SOAP_CMAC _plu__SpatialPlanType_beginLifespanVersion {
      public:
        /// Simple content of XML schema type 'xsd:dateTime' wrapped by this struct
        time_t __item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__SpatialPlanType_beginLifespanVersion
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__SpatialPlanType_beginLifespanVersion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__SpatialPlanType_beginLifespanVersion, default initialized and not managed by a soap context
        virtual _plu__SpatialPlanType_beginLifespanVersion *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__SpatialPlanType_beginLifespanVersion); }
      public:
        /// Constructor with default initializations
        _plu__SpatialPlanType_beginLifespanVersion() : __item(), nilReason() { }
        virtual ~_plu__SpatialPlanType_beginLifespanVersion() { }
        /// Friend allocator used by soap_new__plu__SpatialPlanType_beginLifespanVersion(struct soap*, int)
        friend SOAP_FMAC1 _plu__SpatialPlanType_beginLifespanVersion * SOAP_FMAC2 soap_instantiate__plu__SpatialPlanType_beginLifespanVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26871 */
#ifndef SOAP_TYPE_plu__plu__SpatialPlanType_endLifespanVersion
#define SOAP_TYPE_plu__plu__SpatialPlanType_endLifespanVersion (-2099)
/* simple XML schema type 'plu:SpatialPlanType-endLifespanVersion': */
class SOAP_CMAC _plu__SpatialPlanType_endLifespanVersion {
      public:
        /// Simple content of XML schema type 'xsd:dateTime' wrapped by this struct
        time_t __item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__SpatialPlanType_endLifespanVersion
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__SpatialPlanType_endLifespanVersion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__SpatialPlanType_endLifespanVersion, default initialized and not managed by a soap context
        virtual _plu__SpatialPlanType_endLifespanVersion *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__SpatialPlanType_endLifespanVersion); }
      public:
        /// Constructor with default initializations
        _plu__SpatialPlanType_endLifespanVersion() : __item(), nilReason() { }
        virtual ~_plu__SpatialPlanType_endLifespanVersion() { }
        /// Friend allocator used by soap_new__plu__SpatialPlanType_endLifespanVersion(struct soap*, int)
        friend SOAP_FMAC1 _plu__SpatialPlanType_endLifespanVersion * SOAP_FMAC2 soap_instantiate__plu__SpatialPlanType_endLifespanVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26892 */
#ifndef SOAP_TYPE_plu__plu__SpatialPlanType_validFrom
#define SOAP_TYPE_plu__plu__SpatialPlanType_validFrom (-2101)
/* simple XML schema type 'plu:SpatialPlanType-validFrom': */
class SOAP_CMAC _plu__SpatialPlanType_validFrom {
      public:
        /// Simple content of XML schema type 'xsd:date' wrapped by this struct
        char *__item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__SpatialPlanType_validFrom
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__SpatialPlanType_validFrom; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__SpatialPlanType_validFrom, default initialized and not managed by a soap context
        virtual _plu__SpatialPlanType_validFrom *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__SpatialPlanType_validFrom); }
      public:
        /// Constructor with default initializations
        _plu__SpatialPlanType_validFrom() : __item(), nilReason() { }
        virtual ~_plu__SpatialPlanType_validFrom() { }
        /// Friend allocator used by soap_new__plu__SpatialPlanType_validFrom(struct soap*, int)
        friend SOAP_FMAC1 _plu__SpatialPlanType_validFrom * SOAP_FMAC2 soap_instantiate__plu__SpatialPlanType_validFrom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26913 */
#ifndef SOAP_TYPE_plu__plu__SpatialPlanType_validTo
#define SOAP_TYPE_plu__plu__SpatialPlanType_validTo (-2103)
/* simple XML schema type 'plu:SpatialPlanType-validTo': */
class SOAP_CMAC _plu__SpatialPlanType_validTo {
      public:
        /// Simple content of XML schema type 'xsd:date' wrapped by this struct
        char *__item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__SpatialPlanType_validTo
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__SpatialPlanType_validTo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__SpatialPlanType_validTo, default initialized and not managed by a soap context
        virtual _plu__SpatialPlanType_validTo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__SpatialPlanType_validTo); }
      public:
        /// Constructor with default initializations
        _plu__SpatialPlanType_validTo() : __item(), nilReason() { }
        virtual ~_plu__SpatialPlanType_validTo() { }
        /// Friend allocator used by soap_new__plu__SpatialPlanType_validTo(struct soap*, int)
        friend SOAP_FMAC1 _plu__SpatialPlanType_validTo * SOAP_FMAC2 soap_instantiate__plu__SpatialPlanType_validTo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26934 */
#ifndef SOAP_TYPE_plu__plu__SpatialPlanType_alternativeTitle
#define SOAP_TYPE_plu__plu__SpatialPlanType_alternativeTitle (-2105)
/* simple XML schema type 'plu:SpatialPlanType-alternativeTitle': */
class SOAP_CMAC _plu__SpatialPlanType_alternativeTitle {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__SpatialPlanType_alternativeTitle
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__SpatialPlanType_alternativeTitle; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__SpatialPlanType_alternativeTitle, default initialized and not managed by a soap context
        virtual _plu__SpatialPlanType_alternativeTitle *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__SpatialPlanType_alternativeTitle); }
      public:
        /// Constructor with default initializations
        _plu__SpatialPlanType_alternativeTitle() : __item(), nilReason() { }
        virtual ~_plu__SpatialPlanType_alternativeTitle() { }
        /// Friend allocator used by soap_new__plu__SpatialPlanType_alternativeTitle(struct soap*, int)
        friend SOAP_FMAC1 _plu__SpatialPlanType_alternativeTitle * SOAP_FMAC2 soap_instantiate__plu__SpatialPlanType_alternativeTitle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:26975 */
#ifndef SOAP_TYPE_plu__plu__SpatialPlanType_backgroundMap
#define SOAP_TYPE_plu__plu__SpatialPlanType_backgroundMap (-2107)
/* complex XML schema type 'plu:SpatialPlanType-backgroundMap': */
class SOAP_CMAC _plu__SpatialPlanType_backgroundMap {
      public:
        /// Required element 'plu:BackgroundMapValue' of XML schema type 'plu:BackgroundMapValueType'
        plu__BackgroundMapValueType *BackgroundMapValue;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__SpatialPlanType_backgroundMap
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__SpatialPlanType_backgroundMap; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__SpatialPlanType_backgroundMap, default initialized and not managed by a soap context
        virtual _plu__SpatialPlanType_backgroundMap *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__SpatialPlanType_backgroundMap); }
      public:
        /// Constructor with default initializations
        _plu__SpatialPlanType_backgroundMap() : BackgroundMapValue(), nilReason() { }
        virtual ~_plu__SpatialPlanType_backgroundMap() { }
        /// Friend allocator used by soap_new__plu__SpatialPlanType_backgroundMap(struct soap*, int)
        friend SOAP_FMAC1 _plu__SpatialPlanType_backgroundMap * SOAP_FMAC2 soap_instantiate__plu__SpatialPlanType_backgroundMap(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:27004 */
#ifndef SOAP_TYPE_plu__plu__SpatialPlanType_ordinance
#define SOAP_TYPE_plu__plu__SpatialPlanType_ordinance (-2109)
/* complex XML schema type 'plu:SpatialPlanType-ordinance': */
class SOAP_CMAC _plu__SpatialPlanType_ordinance {
      public:
        /// Required element 'plu:OrdinanceValue' of XML schema type 'plu:OrdinanceValueType'
        plu__OrdinanceValueType *OrdinanceValue;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__plu__SpatialPlanType_ordinance
        virtual long soap_type(void) const { return SOAP_TYPE_plu__plu__SpatialPlanType_ordinance; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _plu__SpatialPlanType_ordinance, default initialized and not managed by a soap context
        virtual _plu__SpatialPlanType_ordinance *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_plu__SpatialPlanType_ordinance); }
      public:
        /// Constructor with default initializations
        _plu__SpatialPlanType_ordinance() : OrdinanceValue(), nilReason() { }
        virtual ~_plu__SpatialPlanType_ordinance() { }
        /// Friend allocator used by soap_new__plu__SpatialPlanType_ordinance(struct soap*, int)
        friend SOAP_FMAC1 _plu__SpatialPlanType_ordinance * SOAP_FMAC2 soap_instantiate__plu__SpatialPlanType_ordinance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:344 */
#ifndef SOAP_TYPE_plu_plu__SpatialPlanType
#define SOAP_TYPE_plu_plu__SpatialPlanType (-69)
/* complex XML schema type 'plu:SpatialPlanType': */
class SOAP_CMAC plu__SpatialPlanType : public gml__AbstractFeatureType {
      public:
        /// Required element 'plu:inspireId' of XML schema type 'base:IdentifierPropertyType'
        base__IdentifierPropertyType *inspireId;
        /// Required element 'plu:extent' of XML schema type 'gml:MultiSurfacePropertyType'
        gml__MultiSurfacePropertyType *extent;
        /// Required nillable (xsi:nil when NULL) element 'plu:beginLifespanVersion' of XML schema type 'plu:SpatialPlanType-beginLifespanVersion'
        _plu__SpatialPlanType_beginLifespanVersion *beginLifespanVersion;
        /// Required element 'plu:officialTitle' of XML schema type 'xsd:string'
        std::string officialTitle;
        /// Required element 'plu:levelOfSpatialPlan' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *levelOfSpatialPlan;
        /// Optional element 'plu:endLifespanVersion' of XML schema type 'plu:SpatialPlanType-endLifespanVersion'
        _plu__SpatialPlanType_endLifespanVersion *endLifespanVersion;
        /// Optional element 'plu:validFrom' of XML schema type 'plu:SpatialPlanType-validFrom'
        _plu__SpatialPlanType_validFrom *validFrom;
        /// Optional element 'plu:validTo' of XML schema type 'plu:SpatialPlanType-validTo'
        _plu__SpatialPlanType_validTo *validTo;
        /// Required nillable (xsi:nil when NULL) element 'plu:alternativeTitle' of XML schema type 'plu:SpatialPlanType-alternativeTitle'
        _plu__SpatialPlanType_alternativeTitle *alternativeTitle;
        /// Required element 'plu:planTypeName' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *planTypeName;
        /// Required nillable (xsi:nil when NULL) element 'plu:processStepGeneral' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *processStepGeneral;
        /// Required nillable (xsi:nil when NULL) element 'plu:backgroundMap' of XML schema type 'plu:SpatialPlanType-backgroundMap'
        _plu__SpatialPlanType_backgroundMap *backgroundMap;
        /// Required element 'plu:ordinance' of XML schema type 'plu:SpatialPlanType-ordinance'
        std::vector<_plu__SpatialPlanType_ordinance> *ordinance;
        /// Required element 'plu:officialDocument' of XML schema type 'gml:ReferenceType'
        std::vector<gml__ReferenceType *> officialDocument;
        /// Optional element 'plu:member' of XML schema type 'gml:ReferenceType'
        std::vector<gml__ReferenceType *> member;
        /// Optional element 'plu:restriction' of XML schema type 'gml:ReferenceType'
        std::vector<gml__ReferenceType *> restriction;
      public:
        /// Return unique type id SOAP_TYPE_plu_plu__SpatialPlanType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_plu__SpatialPlanType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plu__SpatialPlanType, default initialized and not managed by a soap context
        virtual plu__SpatialPlanType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plu__SpatialPlanType); }
      public:
        /// Constructor with default initializations
        plu__SpatialPlanType() : inspireId(), extent(), beginLifespanVersion(), officialTitle(), levelOfSpatialPlan(), endLifespanVersion(), validFrom(), validTo(), alternativeTitle(), planTypeName(), processStepGeneral(), backgroundMap(), ordinance(), officialDocument(), member(), restriction() { }
        virtual ~plu__SpatialPlanType() { }
        /// Friend allocator used by soap_new_plu__SpatialPlanType(struct soap*, int)
        friend SOAP_FMAC1 plu__SpatialPlanType * SOAP_FMAC2 soap_instantiate_plu__SpatialPlanType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:27127 */
#ifndef SOAP_TYPE_plu___base__SpatialDataSetType_metadata_sequence
#define SOAP_TYPE_plu___base__SpatialDataSetType_metadata_sequence (-2113)
/* Wrapper: */
class SOAP_CMAC __base__SpatialDataSetType_metadata_sequence {
      public:
        /// Required element 'gmd:MD_Metadata' of XML schema type 'gmd:MD_Metadata_Type'
        gmd__MD_x005fMetadata_x005fType *gmd__MD_x005fMetadata;
      public:
        /// Return unique type id SOAP_TYPE_plu___base__SpatialDataSetType_metadata_sequence
        virtual long soap_type(void) const { return SOAP_TYPE_plu___base__SpatialDataSetType_metadata_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __base__SpatialDataSetType_metadata_sequence, default initialized and not managed by a soap context
        virtual __base__SpatialDataSetType_metadata_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__base__SpatialDataSetType_metadata_sequence); }
      public:
        /// Constructor with default initializations
        __base__SpatialDataSetType_metadata_sequence() : gmd__MD_x005fMetadata() { }
        virtual ~__base__SpatialDataSetType_metadata_sequence() { }
        /// Friend allocator used by soap_new___base__SpatialDataSetType_metadata_sequence(struct soap*, int)
        friend SOAP_FMAC1 __base__SpatialDataSetType_metadata_sequence * SOAP_FMAC2 soap_instantiate___base__SpatialDataSetType_metadata_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:27118 */
#ifndef SOAP_TYPE_plu__base__SpatialDataSetType_metadata
#define SOAP_TYPE_plu__base__SpatialDataSetType_metadata (-2112)
/* complex XML schema type 'base:SpatialDataSetType-metadata': */
class SOAP_CMAC _base__SpatialDataSetType_metadata {
      public:
        /// Optional attribute 'owns' of XML schema type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
        __base__SpatialDataSetType_metadata_sequence *__SpatialDataSetType_metadata_sequence;
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
        /// Optional attribute 'gml:remoteSchema' of XML schema type 'xsd:anyURI'
        char **gml__remoteSchema;
        /// Optional attribute 'xlink:type' of XML schema type 'xlink:typeType'
        enum xlink__typeType *xlink__type;
        /// Optional attribute 'xlink:href' of XML schema type 'xlink:hrefType'
        char **xlink__href;
        /// Optional attribute 'xlink:role' of XML schema type 'xlink:roleType'
        char **xlink__role;
        /// Optional attribute 'xlink:arcrole' of XML schema type 'xlink:arcroleType'
        char **xlink__arcrole;
        /// Optional attribute 'xlink:title' of XML schema type 'xlink:titleAttrType'
        std::string *xlink__title;
        /// Optional attribute 'xlink:show' of XML schema type 'xlink:showType'
        enum xlink__showType *xlink__show;
        /// Optional attribute 'xlink:actuate' of XML schema type 'xlink:actuateType'
        enum xlink__actuateType *xlink__actuate;
      public:
        /// Return unique type id SOAP_TYPE_plu__base__SpatialDataSetType_metadata
        virtual long soap_type(void) const { return SOAP_TYPE_plu__base__SpatialDataSetType_metadata; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _base__SpatialDataSetType_metadata, default initialized and not managed by a soap context
        virtual _base__SpatialDataSetType_metadata *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_base__SpatialDataSetType_metadata); }
      public:
        /// Constructor with default initializations
        _base__SpatialDataSetType_metadata() : owns((bool)0), __SpatialDataSetType_metadata_sequence(), nilReason(), gml__remoteSchema(), xlink__type(), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate() { }
        virtual ~_base__SpatialDataSetType_metadata() { }
        /// Friend allocator used by soap_new__base__SpatialDataSetType_metadata(struct soap*, int)
        friend SOAP_FMAC1 _base__SpatialDataSetType_metadata * SOAP_FMAC2 soap_instantiate__base__SpatialDataSetType_metadata(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:368 */
#ifndef SOAP_TYPE_plu_base__SpatialDataSetType
#define SOAP_TYPE_plu_base__SpatialDataSetType (-77)
/* complex XML schema type 'base:SpatialDataSetType': */
class SOAP_CMAC base__SpatialDataSetType : public gml__AbstractFeatureType {
      public:
        /// Required element 'base:identifier' of XML schema type 'base:IdentifierPropertyType'
        base__IdentifierPropertyType *identifier;
        /// Required nillable (xsi:nil when NULL) element 'base:metadata' of XML schema type 'base:SpatialDataSetType-metadata'
        _base__SpatialDataSetType_metadata *metadata;
        /// Optional element 'base:member' of XML schema type 'gml:FeaturePropertyType'
        std::vector<gml__FeaturePropertyType *> member;
      public:
        /// Return unique type id SOAP_TYPE_plu_base__SpatialDataSetType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_base__SpatialDataSetType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type base__SpatialDataSetType, default initialized and not managed by a soap context
        virtual base__SpatialDataSetType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(base__SpatialDataSetType); }
      public:
        /// Constructor with default initializations
        base__SpatialDataSetType() : identifier(), metadata(), member() { }
        virtual ~base__SpatialDataSetType() { }
        /// Friend allocator used by soap_new_base__SpatialDataSetType(struct soap*, int)
        friend SOAP_FMAC1 base__SpatialDataSetType * SOAP_FMAC2 soap_instantiate_base__SpatialDataSetType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:386 */
#ifndef SOAP_TYPE_plu_base2__LegislationCitationType
#define SOAP_TYPE_plu_base2__LegislationCitationType (-83)
/* complex XML schema type 'base2:LegislationCitationType': */
class SOAP_CMAC base2__LegislationCitationType : public base2__DocumentCitationType {
      public:
        /// Optional element 'base2:identificationNumber' of XML schema type 'xsd:string'
        std::string *identificationNumber;
        /// Optional element 'base2:officialDocumentNumber' of XML schema type 'xsd:string'
        std::string *officialDocumentNumber;
        /// Optional element 'base2:dateEnteredIntoForce' of XML schema type 'gml:TimePositionType'
        gml__TimePositionType *dateEnteredIntoForce;
        /// Optional element 'base2:dateRepealed' of XML schema type 'gml:TimePositionType'
        gml__TimePositionType *dateRepealed;
        /// Required element 'base2:level' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *level;
        /// Optional element 'base2:journalCitation' of XML schema type 'base2:OfficialJournalInformationPropertyType'
        base2__OfficialJournalInformationPropertyType *journalCitation;
      public:
        /// Return unique type id SOAP_TYPE_plu_base2__LegislationCitationType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_base2__LegislationCitationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type base2__LegislationCitationType, default initialized and not managed by a soap context
        virtual base2__LegislationCitationType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(base2__LegislationCitationType); }
      public:
        /// Constructor with default initializations
        base2__LegislationCitationType() : identificationNumber(), officialDocumentNumber(), dateEnteredIntoForce(), dateRepealed(), level(), journalCitation() { }
        virtual ~base2__LegislationCitationType() { }
        /// Friend allocator used by soap_new_base2__LegislationCitationType(struct soap*, int)
        friend SOAP_FMAC1 base2__LegislationCitationType * SOAP_FMAC2 soap_instantiate_base2__LegislationCitationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:27466 */
#ifndef SOAP_TYPE_plu__gml__union_DynamicFeatureType_
#define SOAP_TYPE_plu__gml__union_DynamicFeatureType_ (-2119)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_DynamicFeatureType_
{
        #define SOAP_UNION_plu__gml__union_DynamicFeatureType__history	(1)	/**< union variant selector value for member history */
        gml__HistoryPropertyType *history;
        #define SOAP_UNION_plu__gml__union_DynamicFeatureType__track	(2)	/**< union variant selector value for member track */
        gml__HistoryPropertyType *track;
};
#endif

/* PlannedLandUse_v3.0.h:443 */
#ifndef SOAP_TYPE_plu_gml__DynamicFeatureType
#define SOAP_TYPE_plu_gml__DynamicFeatureType (-102)
/* complex XML schema type 'gml:DynamicFeatureType': */
class SOAP_CMAC gml__DynamicFeatureType : public gml__AbstractFeatureType {
      public:
        /// Optional element 'gml:validTime' of XML schema type 'gml:TimePrimitivePropertyType'
        gml__TimePrimitivePropertyType *validTime;
        /// Union with union _gml__union_DynamicFeatureType_ variant selector __unionhistory set to one of: SOAP_UNION_plu__gml__union_DynamicFeatureType__history SOAP_UNION_plu__gml__union_DynamicFeatureType__track
        int __unionhistory;
        union _gml__union_DynamicFeatureType_ union_DynamicFeatureType_;
        /// Optional element 'gml:dataSource' of XML schema type 'gml:StringOrRefType'
        gml__StringOrRefType *dataSource;
        /// Optional element 'gml:dataSourceReference' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *dataSourceReference;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DynamicFeatureType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DynamicFeatureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DynamicFeatureType, default initialized and not managed by a soap context
        virtual gml__DynamicFeatureType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DynamicFeatureType); }
      public:
        /// Constructor with default initializations
        gml__DynamicFeatureType() : validTime(), __unionhistory(), dataSource(), dataSourceReference() { }
        virtual ~gml__DynamicFeatureType() { }
        /// Friend allocator used by soap_new_gml__DynamicFeatureType(struct soap*, int)
        friend SOAP_FMAC1 gml__DynamicFeatureType * SOAP_FMAC2 soap_instantiate_gml__DynamicFeatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:461 */
#ifndef SOAP_TYPE_plu_gml__AbstractTopoPrimitiveType
#define SOAP_TYPE_plu_gml__AbstractTopoPrimitiveType (-108)
/* complex XML schema type 'gml:AbstractTopoPrimitiveType': */
class SOAP_CMAC gml__AbstractTopoPrimitiveType : public gml__AbstractTopologyType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractTopoPrimitiveType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractTopoPrimitiveType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractTopoPrimitiveType, default initialized and not managed by a soap context
        virtual gml__AbstractTopoPrimitiveType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractTopoPrimitiveType); }
      public:
        /// Constructor with default initializations
        gml__AbstractTopoPrimitiveType() { }
        virtual ~gml__AbstractTopoPrimitiveType() { }
        /// Friend allocator used by soap_new_gml__AbstractTopoPrimitiveType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractTopoPrimitiveType * SOAP_FMAC2 soap_instantiate_gml__AbstractTopoPrimitiveType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:500 */
#ifndef SOAP_TYPE_plu_gml__TopoPointType
#define SOAP_TYPE_plu_gml__TopoPointType (-121)
/* complex XML schema type 'gml:TopoPointType': */
class SOAP_CMAC gml__TopoPointType : public gml__AbstractTopologyType {
      public:
        /// Required element 'gml:directedNode' of XML schema type 'gml:DirectedNodePropertyType'
        gml__DirectedNodePropertyType *directedNode;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TopoPointType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TopoPointType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TopoPointType, default initialized and not managed by a soap context
        virtual gml__TopoPointType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TopoPointType); }
      public:
        /// Constructor with default initializations
        gml__TopoPointType() : directedNode() { }
        virtual ~gml__TopoPointType() { }
        /// Friend allocator used by soap_new_gml__TopoPointType(struct soap*, int)
        friend SOAP_FMAC1 gml__TopoPointType * SOAP_FMAC2 soap_instantiate_gml__TopoPointType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:506 */
#ifndef SOAP_TYPE_plu_gml__TopoCurveType
#define SOAP_TYPE_plu_gml__TopoCurveType (-123)
/* complex XML schema type 'gml:TopoCurveType': */
class SOAP_CMAC gml__TopoCurveType : public gml__AbstractTopologyType {
      public:
        /// Required element 'gml:directedEdge' of XML schema type 'gml:DirectedEdgePropertyType'
        std::vector<gml__DirectedEdgePropertyType *> directedEdge;
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TopoCurveType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TopoCurveType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TopoCurveType, default initialized and not managed by a soap context
        virtual gml__TopoCurveType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TopoCurveType); }
      public:
        /// Constructor with default initializations
        gml__TopoCurveType() : directedEdge(), aggregationType() { }
        virtual ~gml__TopoCurveType() { }
        /// Friend allocator used by soap_new_gml__TopoCurveType(struct soap*, int)
        friend SOAP_FMAC1 gml__TopoCurveType * SOAP_FMAC2 soap_instantiate_gml__TopoCurveType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:512 */
#ifndef SOAP_TYPE_plu_gml__TopoSurfaceType
#define SOAP_TYPE_plu_gml__TopoSurfaceType (-125)
/* complex XML schema type 'gml:TopoSurfaceType': */
class SOAP_CMAC gml__TopoSurfaceType : public gml__AbstractTopologyType {
      public:
        /// Required element 'gml:directedFace' of XML schema type 'gml:DirectedFacePropertyType'
        std::vector<gml__DirectedFacePropertyType *> directedFace;
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TopoSurfaceType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TopoSurfaceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TopoSurfaceType, default initialized and not managed by a soap context
        virtual gml__TopoSurfaceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TopoSurfaceType); }
      public:
        /// Constructor with default initializations
        gml__TopoSurfaceType() : directedFace(), aggregationType() { }
        virtual ~gml__TopoSurfaceType() { }
        /// Friend allocator used by soap_new_gml__TopoSurfaceType(struct soap*, int)
        friend SOAP_FMAC1 gml__TopoSurfaceType * SOAP_FMAC2 soap_instantiate_gml__TopoSurfaceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:518 */
#ifndef SOAP_TYPE_plu_gml__TopoVolumeType
#define SOAP_TYPE_plu_gml__TopoVolumeType (-127)
/* complex XML schema type 'gml:TopoVolumeType': */
class SOAP_CMAC gml__TopoVolumeType : public gml__AbstractTopologyType {
      public:
        /// Required element 'gml:directedTopoSolid' of XML schema type 'gml:DirectedTopoSolidPropertyType'
        std::vector<gml__DirectedTopoSolidPropertyType *> directedTopoSolid;
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TopoVolumeType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TopoVolumeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TopoVolumeType, default initialized and not managed by a soap context
        virtual gml__TopoVolumeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TopoVolumeType); }
      public:
        /// Constructor with default initializations
        gml__TopoVolumeType() : directedTopoSolid(), aggregationType() { }
        virtual ~gml__TopoVolumeType() { }
        /// Friend allocator used by soap_new_gml__TopoVolumeType(struct soap*, int)
        friend SOAP_FMAC1 gml__TopoVolumeType * SOAP_FMAC2 soap_instantiate_gml__TopoVolumeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:524 */
#ifndef SOAP_TYPE_plu_gml__TopoComplexType
#define SOAP_TYPE_plu_gml__TopoComplexType (-129)
/* complex XML schema type 'gml:TopoComplexType': */
class SOAP_CMAC gml__TopoComplexType : public gml__AbstractTopologyType {
      public:
        /// Required element 'gml:maximalComplex' of XML schema type 'gml:TopoComplexPropertyType'
        gml__TopoComplexPropertyType *maximalComplex;
        /// Optional element 'gml:superComplex' of XML schema type 'gml:TopoComplexPropertyType'
        std::vector<gml__TopoComplexPropertyType *> superComplex;
        /// Optional element 'gml:subComplex' of XML schema type 'gml:TopoComplexPropertyType'
        std::vector<gml__TopoComplexPropertyType *> subComplex;
        /// Optional element 'gml:topoPrimitiveMember' of XML schema type 'gml:TopoPrimitiveMemberType'
        std::vector<gml__TopoPrimitiveMemberType *> topoPrimitiveMember;
        /// Optional element 'gml:topoPrimitiveMembers' of XML schema type 'gml:TopoPrimitiveArrayAssociationType'
        gml__TopoPrimitiveArrayAssociationType *topoPrimitiveMembers;
        /// Optional attribute 'isMaximal' of XML schema type 'xsd:boolean'
        bool isMaximal;	///< initialized with default value = (bool)0
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TopoComplexType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TopoComplexType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TopoComplexType, default initialized and not managed by a soap context
        virtual gml__TopoComplexType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TopoComplexType); }
      public:
        /// Constructor with default initializations
        gml__TopoComplexType() : maximalComplex(), superComplex(), subComplex(), topoPrimitiveMember(), topoPrimitiveMembers(), isMaximal((bool)0), aggregationType() { }
        virtual ~gml__TopoComplexType() { }
        /// Friend allocator used by soap_new_gml__TopoComplexType(struct soap*, int)
        friend SOAP_FMAC1 gml__TopoComplexType * SOAP_FMAC2 soap_instantiate_gml__TopoComplexType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:536 */
#ifndef SOAP_TYPE_plu_gml__GeometricComplexType
#define SOAP_TYPE_plu_gml__GeometricComplexType (-133)
/* complex XML schema type 'gml:GeometricComplexType': */
class SOAP_CMAC gml__GeometricComplexType : public gml__AbstractGeometryType {
      public:
        /// Required element 'gml:element' of XML schema type 'gml:GeometricPrimitivePropertyType'
        std::vector<gml__GeometricPrimitivePropertyType *> element;
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GeometricComplexType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GeometricComplexType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeometricComplexType, default initialized and not managed by a soap context
        virtual gml__GeometricComplexType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GeometricComplexType); }
      public:
        /// Constructor with default initializations
        gml__GeometricComplexType() : element(), aggregationType() { }
        virtual ~gml__GeometricComplexType() { }
        /// Friend allocator used by soap_new_gml__GeometricComplexType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeometricComplexType * SOAP_FMAC2 soap_instantiate_gml__GeometricComplexType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:551 */
#ifndef SOAP_TYPE_plu_gml__AbstractGeometricAggregateType
#define SOAP_TYPE_plu_gml__AbstractGeometricAggregateType (-138)
/* complex XML schema type 'gml:AbstractGeometricAggregateType': */
class SOAP_CMAC gml__AbstractGeometricAggregateType : public gml__AbstractGeometryType {
      public:
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractGeometricAggregateType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractGeometricAggregateType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractGeometricAggregateType, default initialized and not managed by a soap context
        virtual gml__AbstractGeometricAggregateType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractGeometricAggregateType); }
      public:
        /// Constructor with default initializations
        gml__AbstractGeometricAggregateType() : aggregationType() { }
        virtual ~gml__AbstractGeometricAggregateType() { }
        /// Friend allocator used by soap_new_gml__AbstractGeometricAggregateType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractGeometricAggregateType * SOAP_FMAC2 soap_instantiate_gml__AbstractGeometricAggregateType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:28005 */
#ifndef SOAP_TYPE_plu__gml__union_ArcType_
#define SOAP_TYPE_plu__gml__union_ArcType_ (-2138)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ArcType_
{
        #define SOAP_UNION_plu__gml__union_ArcType__pos	(1)	/**< union variant selector value for member pos */
        gml__DirectPositionType *pos;
        #define SOAP_UNION_plu__gml__union_ArcType__pointProperty	(2)	/**< union variant selector value for member pointProperty */
        gml__PointPropertyType *pointProperty;
        #define SOAP_UNION_plu__gml__union_ArcType__pointRep	(3)	/**< union variant selector value for member pointRep */
        gml__PointPropertyType *pointRep;
};
#endif

/* PlannedLandUse_v3.0.h:28001 */
#ifndef SOAP_TYPE_plu___gml__union_ArcType_
#define SOAP_TYPE_plu___gml__union_ArcType_ (-2137)
/* Wrapper: */
class SOAP_CMAC __gml__union_ArcType_ {
      public:
        /// Union with union _gml__union_ArcType_ variant selector __union_ArcType_ set to one of: SOAP_UNION_plu__gml__union_ArcType__pos SOAP_UNION_plu__gml__union_ArcType__pointProperty SOAP_UNION_plu__gml__union_ArcType__pointRep
        int __union_ArcType_;
        union _gml__union_ArcType_ union_ArcType_;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_ArcType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_ArcType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_ArcType_, default initialized and not managed by a soap context
        virtual __gml__union_ArcType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_ArcType_); }
      public:
        /// Constructor with default initializations
        __gml__union_ArcType_() : __union_ArcType_() { }
        virtual ~__gml__union_ArcType_() { }
        /// Friend allocator used by soap_new___gml__union_ArcType_(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_ArcType_ * SOAP_FMAC2 soap_instantiate___gml__union_ArcType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:27999 */
#ifndef SOAP_TYPE_plu____gml__union_ArcType_
#define SOAP_TYPE_plu____gml__union_ArcType_ (-2136)
/* Wrapper: */
struct SOAP_CMAC ___gml__union_ArcType_ {
      public:
        /** Sequence of 3 to 3 elements '-union-ArcType' of XML schema type '-gml:union-ArcType' stored in dynamic array __union_ArcType_ of length __size_ArcType_ */
        int __size_ArcType_;
        __gml__union_ArcType_ *__union_ArcType_;
      public:
        /** Return unique type id SOAP_TYPE_plu____gml__union_ArcType_ */
        long soap_type() const { return SOAP_TYPE_plu____gml__union_ArcType_; }
        /** Friend allocator */
        friend SOAP_FMAC1 ___gml__union_ArcType_ * SOAP_FMAC2 soap_instantiate____gml__union_ArcType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:27996 */
#ifndef SOAP_TYPE_plu__gml__union_ArcType
#define SOAP_TYPE_plu__gml__union_ArcType (-2135)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ArcType
{
        #define SOAP_UNION_plu__gml__union_ArcType___union_ArcType_	(1)	/**< union variant selector value for member __union_ArcType_ */
        struct ___gml__union_ArcType_ __union_ArcType_;
        #define SOAP_UNION_plu__gml__union_ArcType_posList	(2)	/**< union variant selector value for member posList */
        gml__DirectPositionListType *posList;
        #define SOAP_UNION_plu__gml__union_ArcType_coordinates	(3)	/**< union variant selector value for member coordinates */
        gml__CoordinatesType *coordinates;
};
#endif

/* PlannedLandUse_v3.0.h:602 */
#ifndef SOAP_TYPE_plu_gml__ArcType
#define SOAP_TYPE_plu_gml__ArcType (-155)
/* complex XML schema type 'gml:ArcType': */
class SOAP_CMAC gml__ArcType : public xsd__anyType {
      public:
        /// Union with union _gml__union_ArcType variant selector __union_ArcType set to one of: SOAP_UNION_plu__gml__union_ArcType___union_ArcType_ SOAP_UNION_plu__gml__union_ArcType_posList SOAP_UNION_plu__gml__union_ArcType_coordinates
        int __union_ArcType;
        union _gml__union_ArcType union_ArcType;
        /// Optional attribute 'numArc' of XML schema type 'xsd:long'
        long *numArc;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ArcType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ArcType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ArcType, default initialized and not managed by a soap context
        virtual gml__ArcType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ArcType); }
      public:
        /// Constructor with default initializations
        gml__ArcType() : __union_ArcType(), numArc() { }
        virtual ~gml__ArcType() { }
        /// Friend allocator used by soap_new_gml__ArcType(struct soap*, int)
        friend SOAP_FMAC1 gml__ArcType * SOAP_FMAC2 soap_instantiate_gml__ArcType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:28069 */
#ifndef SOAP_TYPE_plu__gml__union_ArcByBulgeType_
#define SOAP_TYPE_plu__gml__union_ArcByBulgeType_ (-2143)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ArcByBulgeType_
{
        #define SOAP_UNION_plu__gml__union_ArcByBulgeType__pos	(1)	/**< union variant selector value for member pos */
        gml__DirectPositionType *pos;
        #define SOAP_UNION_plu__gml__union_ArcByBulgeType__pointProperty	(2)	/**< union variant selector value for member pointProperty */
        gml__PointPropertyType *pointProperty;
        #define SOAP_UNION_plu__gml__union_ArcByBulgeType__pointRep	(3)	/**< union variant selector value for member pointRep */
        gml__PointPropertyType *pointRep;
};
#endif

/* PlannedLandUse_v3.0.h:28065 */
#ifndef SOAP_TYPE_plu___gml__union_ArcByBulgeType_
#define SOAP_TYPE_plu___gml__union_ArcByBulgeType_ (-2142)
/* Wrapper: */
class SOAP_CMAC __gml__union_ArcByBulgeType_ {
      public:
        /// Union with union _gml__union_ArcByBulgeType_ variant selector __union_ArcByBulgeType_ set to one of: SOAP_UNION_plu__gml__union_ArcByBulgeType__pos SOAP_UNION_plu__gml__union_ArcByBulgeType__pointProperty SOAP_UNION_plu__gml__union_ArcByBulgeType__pointRep
        int __union_ArcByBulgeType_;
        union _gml__union_ArcByBulgeType_ union_ArcByBulgeType_;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_ArcByBulgeType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_ArcByBulgeType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_ArcByBulgeType_, default initialized and not managed by a soap context
        virtual __gml__union_ArcByBulgeType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_ArcByBulgeType_); }
      public:
        /// Constructor with default initializations
        __gml__union_ArcByBulgeType_() : __union_ArcByBulgeType_() { }
        virtual ~__gml__union_ArcByBulgeType_() { }
        /// Friend allocator used by soap_new___gml__union_ArcByBulgeType_(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_ArcByBulgeType_ * SOAP_FMAC2 soap_instantiate___gml__union_ArcByBulgeType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:28063 */
#ifndef SOAP_TYPE_plu____gml__union_ArcByBulgeType_
#define SOAP_TYPE_plu____gml__union_ArcByBulgeType_ (-2141)
/* Wrapper: */
struct SOAP_CMAC ___gml__union_ArcByBulgeType_ {
      public:
        /** Sequence of 2 to 2 elements '-union-ArcByBulgeType' of XML schema type '-gml:union-ArcByBulgeType' stored in dynamic array __union_ArcByBulgeType_ of length __size_ArcByBulgeType_ */
        int __size_ArcByBulgeType_;
        __gml__union_ArcByBulgeType_ *__union_ArcByBulgeType_;
      public:
        /** Return unique type id SOAP_TYPE_plu____gml__union_ArcByBulgeType_ */
        long soap_type() const { return SOAP_TYPE_plu____gml__union_ArcByBulgeType_; }
        /** Friend allocator */
        friend SOAP_FMAC1 ___gml__union_ArcByBulgeType_ * SOAP_FMAC2 soap_instantiate____gml__union_ArcByBulgeType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:28060 */
#ifndef SOAP_TYPE_plu__gml__union_ArcByBulgeType
#define SOAP_TYPE_plu__gml__union_ArcByBulgeType (-2140)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ArcByBulgeType
{
        #define SOAP_UNION_plu__gml__union_ArcByBulgeType___union_ArcByBulgeType_	(1)	/**< union variant selector value for member __union_ArcByBulgeType_ */
        struct ___gml__union_ArcByBulgeType_ __union_ArcByBulgeType_;
        #define SOAP_UNION_plu__gml__union_ArcByBulgeType_posList	(2)	/**< union variant selector value for member posList */
        gml__DirectPositionListType *posList;
        #define SOAP_UNION_plu__gml__union_ArcByBulgeType_coordinates	(3)	/**< union variant selector value for member coordinates */
        gml__CoordinatesType *coordinates;
};
#endif

/* PlannedLandUse_v3.0.h:611 */
#ifndef SOAP_TYPE_plu_gml__ArcByBulgeType
#define SOAP_TYPE_plu_gml__ArcByBulgeType (-158)
/* complex XML schema type 'gml:ArcByBulgeType': */
class SOAP_CMAC gml__ArcByBulgeType : public xsd__anyType {
      public:
        /// Union with union _gml__union_ArcByBulgeType variant selector __union_ArcByBulgeType set to one of: SOAP_UNION_plu__gml__union_ArcByBulgeType___union_ArcByBulgeType_ SOAP_UNION_plu__gml__union_ArcByBulgeType_posList SOAP_UNION_plu__gml__union_ArcByBulgeType_coordinates
        int __union_ArcByBulgeType;
        union _gml__union_ArcByBulgeType union_ArcByBulgeType;
        /// Required element 'gml:bulge' of XML schema type 'xsd:double'
        double bulge;
        /// Required element 'gml:normal' of XML schema type 'gml:VectorType'
        gml__VectorType *normal;
        /// Optional attribute 'numArc' of XML schema type 'xsd:long'
        long *numArc;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ArcByBulgeType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ArcByBulgeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ArcByBulgeType, default initialized and not managed by a soap context
        virtual gml__ArcByBulgeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ArcByBulgeType); }
      public:
        /// Constructor with default initializations
        gml__ArcByBulgeType() : __union_ArcByBulgeType(), bulge(), normal(), numArc() { }
        virtual ~gml__ArcByBulgeType() { }
        /// Friend allocator used by soap_new_gml__ArcByBulgeType(struct soap*, int)
        friend SOAP_FMAC1 gml__ArcByBulgeType * SOAP_FMAC2 soap_instantiate_gml__ArcByBulgeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:28128 */
#ifndef SOAP_TYPE_plu__gml__union_CircleByCenterPointType
#define SOAP_TYPE_plu__gml__union_CircleByCenterPointType (-2145)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_CircleByCenterPointType
{
        #define SOAP_UNION_plu__gml__union_CircleByCenterPointType_pos	(1)	/**< union variant selector value for member pos */
        gml__DirectPositionType *pos;
        #define SOAP_UNION_plu__gml__union_CircleByCenterPointType_pointProperty	(2)	/**< union variant selector value for member pointProperty */
        gml__PointPropertyType *pointProperty;
        #define SOAP_UNION_plu__gml__union_CircleByCenterPointType_pointRep	(3)	/**< union variant selector value for member pointRep */
        gml__PointPropertyType *pointRep;
        #define SOAP_UNION_plu__gml__union_CircleByCenterPointType_posList	(4)	/**< union variant selector value for member posList */
        gml__DirectPositionListType *posList;
        #define SOAP_UNION_plu__gml__union_CircleByCenterPointType_coordinates	(5)	/**< union variant selector value for member coordinates */
        gml__CoordinatesType *coordinates;
};
#endif

/* PlannedLandUse_v3.0.h:617 */
#ifndef SOAP_TYPE_plu_gml__CircleByCenterPointType
#define SOAP_TYPE_plu_gml__CircleByCenterPointType (-160)
/* complex XML schema type 'gml:CircleByCenterPointType': */
class SOAP_CMAC gml__CircleByCenterPointType : public xsd__anyType {
      public:
        /// Union with union _gml__union_CircleByCenterPointType variant selector __union_CircleByCenterPointType set to one of: SOAP_UNION_plu__gml__union_CircleByCenterPointType_pos SOAP_UNION_plu__gml__union_CircleByCenterPointType_pointProperty SOAP_UNION_plu__gml__union_CircleByCenterPointType_pointRep SOAP_UNION_plu__gml__union_CircleByCenterPointType_posList SOAP_UNION_plu__gml__union_CircleByCenterPointType_coordinates
        int __union_CircleByCenterPointType;
        union _gml__union_CircleByCenterPointType union_CircleByCenterPointType;
        /// Required element 'gml:radius' of XML schema type 'gml:LengthType'
        gml__LengthType *radius;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CircleByCenterPointType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CircleByCenterPointType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CircleByCenterPointType, default initialized and not managed by a soap context
        virtual gml__CircleByCenterPointType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CircleByCenterPointType); }
      public:
        /// Constructor with default initializations
        gml__CircleByCenterPointType() : __union_CircleByCenterPointType(), radius() { }
        virtual ~gml__CircleByCenterPointType() { }
        /// Friend allocator used by soap_new_gml__CircleByCenterPointType(struct soap*, int)
        friend SOAP_FMAC1 gml__CircleByCenterPointType * SOAP_FMAC2 soap_instantiate_gml__CircleByCenterPointType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:28190 */
#ifndef SOAP_TYPE_plu__gml__union_BezierType_
#define SOAP_TYPE_plu__gml__union_BezierType_ (-2149)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_BezierType_
{
        #define SOAP_UNION_plu__gml__union_BezierType__pos	(1)	/**< union variant selector value for member pos */
        gml__DirectPositionType *pos;
        #define SOAP_UNION_plu__gml__union_BezierType__pointProperty	(2)	/**< union variant selector value for member pointProperty */
        gml__PointPropertyType *pointProperty;
        #define SOAP_UNION_plu__gml__union_BezierType__pointRep	(3)	/**< union variant selector value for member pointRep */
        gml__PointPropertyType *pointRep;
};
#endif

/* PlannedLandUse_v3.0.h:28186 */
#ifndef SOAP_TYPE_plu___gml__union_BezierType_
#define SOAP_TYPE_plu___gml__union_BezierType_ (-2148)
/* Wrapper: */
class SOAP_CMAC __gml__union_BezierType_ {
      public:
        /// Union with union _gml__union_BezierType_ variant selector __union_BezierType_ set to one of: SOAP_UNION_plu__gml__union_BezierType__pos SOAP_UNION_plu__gml__union_BezierType__pointProperty SOAP_UNION_plu__gml__union_BezierType__pointRep
        int __union_BezierType_;
        union _gml__union_BezierType_ union_BezierType_;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_BezierType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_BezierType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_BezierType_, default initialized and not managed by a soap context
        virtual __gml__union_BezierType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_BezierType_); }
      public:
        /// Constructor with default initializations
        __gml__union_BezierType_() : __union_BezierType_() { }
        virtual ~__gml__union_BezierType_() { }
        /// Friend allocator used by soap_new___gml__union_BezierType_(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_BezierType_ * SOAP_FMAC2 soap_instantiate___gml__union_BezierType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:28184 */
#ifndef SOAP_TYPE_plu____gml__union_BezierType_
#define SOAP_TYPE_plu____gml__union_BezierType_ (-2147)
/* Wrapper: */
struct SOAP_CMAC ___gml__union_BezierType_ {
      public:
        /** Sequence of elements '-union-BezierType' of XML schema type '-gml:union-BezierType' stored in dynamic array __union_BezierType_ of length __size_BezierType_ */
        int __size_BezierType_;
        __gml__union_BezierType_ *__union_BezierType_;
      public:
        /** Return unique type id SOAP_TYPE_plu____gml__union_BezierType_ */
        long soap_type() const { return SOAP_TYPE_plu____gml__union_BezierType_; }
        /** Friend allocator */
        friend SOAP_FMAC1 ___gml__union_BezierType_ * SOAP_FMAC2 soap_instantiate____gml__union_BezierType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:28181 */
#ifndef SOAP_TYPE_plu__gml__union_BezierType
#define SOAP_TYPE_plu__gml__union_BezierType (-2146)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_BezierType
{
        #define SOAP_UNION_plu__gml__union_BezierType___union_BezierType_	(1)	/**< union variant selector value for member __union_BezierType_ */
        struct ___gml__union_BezierType_ __union_BezierType_;
        #define SOAP_UNION_plu__gml__union_BezierType_posList	(2)	/**< union variant selector value for member posList */
        gml__DirectPositionListType *posList;
        #define SOAP_UNION_plu__gml__union_BezierType_coordinates	(3)	/**< union variant selector value for member coordinates */
        gml__CoordinatesType *coordinates;
};
#endif

/* PlannedLandUse_v3.0.h:632 */
#ifndef SOAP_TYPE_plu_gml__BezierType
#define SOAP_TYPE_plu_gml__BezierType (-165)
/* complex XML schema type 'gml:BezierType': */
class SOAP_CMAC gml__BezierType : public xsd__anyType {
      public:
        /// Union with union _gml__union_BezierType variant selector __union_BezierType set to one of: SOAP_UNION_plu__gml__union_BezierType___union_BezierType_ SOAP_UNION_plu__gml__union_BezierType_posList SOAP_UNION_plu__gml__union_BezierType_coordinates
        int __union_BezierType;
        union _gml__union_BezierType union_BezierType;
        /// Required element 'gml:degree' of XML schema type 'xsd:nonNegativeInteger'
        ULONG64 degree;
        /// Sequence of 2 to 2 elements 'gml:knot' of XML schema type 'gml:KnotPropertyType'
        std::vector<gml__KnotPropertyType *> knot;
        /// Optional attribute 'interpolation' of XML schema type 'gml:CurveInterpolationType'
        enum gml__CurveInterpolationType *interpolation;
        /// Optional attribute 'isPolynomial' of XML schema type 'xsd:boolean'
        bool *isPolynomial;
        /// Optional attribute 'knotType' of XML schema type 'gml:KnotTypesType'
        enum gml__KnotTypesType *knotType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__BezierType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__BezierType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__BezierType, default initialized and not managed by a soap context
        virtual gml__BezierType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__BezierType); }
      public:
        /// Constructor with default initializations
        gml__BezierType() : __union_BezierType(), degree(), knot(), interpolation(), isPolynomial(), knotType() { }
        virtual ~gml__BezierType() { }
        /// Friend allocator used by soap_new_gml__BezierType(struct soap*, int)
        friend SOAP_FMAC1 gml__BezierType * SOAP_FMAC2 soap_instantiate_gml__BezierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:647 */
#ifndef SOAP_TYPE_plu_gml__GeodesicType
#define SOAP_TYPE_plu_gml__GeodesicType (-170)
/* complex XML schema type 'gml:GeodesicType': */
class SOAP_CMAC gml__GeodesicType : public gml__GeodesicStringType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GeodesicType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GeodesicType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeodesicType, default initialized and not managed by a soap context
        virtual gml__GeodesicType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GeodesicType); }
      public:
        /// Constructor with default initializations
        gml__GeodesicType() { }
        virtual ~gml__GeodesicType() { }
        /// Friend allocator used by soap_new_gml__GeodesicType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeodesicType * SOAP_FMAC2 soap_instantiate_gml__GeodesicType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:28367 */
#ifndef SOAP_TYPE_plu__gml__union_AbstractGriddedSurfaceType_rows_Row_
#define SOAP_TYPE_plu__gml__union_AbstractGriddedSurfaceType_rows_Row_ (-2154)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_AbstractGriddedSurfaceType_rows_Row_
{
        #define SOAP_UNION_plu__gml__union_AbstractGriddedSurfaceType_rows_Row__pos	(1)	/**< union variant selector value for member pos */
        gml__DirectPositionType *pos;
        #define SOAP_UNION_plu__gml__union_AbstractGriddedSurfaceType_rows_Row__pointProperty	(2)	/**< union variant selector value for member pointProperty */
        gml__PointPropertyType *pointProperty;
};
#endif

/* PlannedLandUse_v3.0.h:28363 */
#ifndef SOAP_TYPE_plu___gml__union_AbstractGriddedSurfaceType_rows_Row_
#define SOAP_TYPE_plu___gml__union_AbstractGriddedSurfaceType_rows_Row_ (-2153)
/* Wrapper: */
class SOAP_CMAC __gml__union_AbstractGriddedSurfaceType_rows_Row_ {
      public:
        /// Union with union _gml__union_AbstractGriddedSurfaceType_rows_Row_ variant selector __union_AbstractGriddedSurfaceType_rows_Row_ set to one of: SOAP_UNION_plu__gml__union_AbstractGriddedSurfaceType_rows_Row__pos SOAP_UNION_plu__gml__union_AbstractGriddedSurfaceType_rows_Row__pointProperty
        int __union_AbstractGriddedSurfaceType_rows_Row_;
        union _gml__union_AbstractGriddedSurfaceType_rows_Row_ union_AbstractGriddedSurfaceType_rows_Row_;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_AbstractGriddedSurfaceType_rows_Row_
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_AbstractGriddedSurfaceType_rows_Row_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_AbstractGriddedSurfaceType_rows_Row_, default initialized and not managed by a soap context
        virtual __gml__union_AbstractGriddedSurfaceType_rows_Row_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_AbstractGriddedSurfaceType_rows_Row_); }
      public:
        /// Constructor with default initializations
        __gml__union_AbstractGriddedSurfaceType_rows_Row_() : __union_AbstractGriddedSurfaceType_rows_Row_() { }
        virtual ~__gml__union_AbstractGriddedSurfaceType_rows_Row_() { }
        /// Friend allocator used by soap_new___gml__union_AbstractGriddedSurfaceType_rows_Row_(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_AbstractGriddedSurfaceType_rows_Row_ * SOAP_FMAC2 soap_instantiate___gml__union_AbstractGriddedSurfaceType_rows_Row_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:28345 */
#ifndef SOAP_TYPE_plu__gml__AbstractGriddedSurfaceType_rows_Row
#define SOAP_TYPE_plu__gml__AbstractGriddedSurfaceType_rows_Row (-2152)
/* complex XML schema type 'gml:AbstractGriddedSurfaceType-rows-Row': */
class SOAP_CMAC _gml__AbstractGriddedSurfaceType_rows_Row {
      public:
        /// Optional element 'gml:posList' of XML schema type 'gml:DirectPositionListType'
        gml__DirectPositionListType *posList;
        /// Sequence of elements '-union-AbstractGriddedSurfaceType-rows-Row' of XML schema type '-gml:union-AbstractGriddedSurfaceType-rows-Row' stored in dynamic array __union_AbstractGriddedSurfaceType_rows_Row_ of length __size_AbstractGriddedSurfaceType_rows_Row_
        int __size_AbstractGriddedSurfaceType_rows_Row_;
        __gml__union_AbstractGriddedSurfaceType_rows_Row_ *__union_AbstractGriddedSurfaceType_rows_Row_;
      public:
        /// Return unique type id SOAP_TYPE_plu__gml__AbstractGriddedSurfaceType_rows_Row
        virtual long soap_type(void) const { return SOAP_TYPE_plu__gml__AbstractGriddedSurfaceType_rows_Row; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _gml__AbstractGriddedSurfaceType_rows_Row, default initialized and not managed by a soap context
        virtual _gml__AbstractGriddedSurfaceType_rows_Row *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_gml__AbstractGriddedSurfaceType_rows_Row); }
      public:
        /// Constructor with default initializations
        _gml__AbstractGriddedSurfaceType_rows_Row() : posList(), __size_AbstractGriddedSurfaceType_rows_Row_(), __union_AbstractGriddedSurfaceType_rows_Row_() { }
        virtual ~_gml__AbstractGriddedSurfaceType_rows_Row() { }
        /// Friend allocator used by soap_new__gml__AbstractGriddedSurfaceType_rows_Row(struct soap*, int)
        friend SOAP_FMAC1 _gml__AbstractGriddedSurfaceType_rows_Row * SOAP_FMAC2 soap_instantiate__gml__AbstractGriddedSurfaceType_rows_Row(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:28331 */
#ifndef SOAP_TYPE_plu__gml__AbstractGriddedSurfaceType_rows
#define SOAP_TYPE_plu__gml__AbstractGriddedSurfaceType_rows (-2151)
/* complex XML schema type 'gml:AbstractGriddedSurfaceType-rows': */
class SOAP_CMAC _gml__AbstractGriddedSurfaceType_rows {
      public:
        /// Required element 'gml:Row' of XML schema type 'gml:AbstractGriddedSurfaceType-rows-Row'
        std::vector<_gml__AbstractGriddedSurfaceType_rows_Row> Row;
      public:
        /// Return unique type id SOAP_TYPE_plu__gml__AbstractGriddedSurfaceType_rows
        virtual long soap_type(void) const { return SOAP_TYPE_plu__gml__AbstractGriddedSurfaceType_rows; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _gml__AbstractGriddedSurfaceType_rows, default initialized and not managed by a soap context
        virtual _gml__AbstractGriddedSurfaceType_rows *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_gml__AbstractGriddedSurfaceType_rows); }
      public:
        /// Constructor with default initializations
        _gml__AbstractGriddedSurfaceType_rows() : Row() { }
        virtual ~_gml__AbstractGriddedSurfaceType_rows() { }
        /// Friend allocator used by soap_new__gml__AbstractGriddedSurfaceType_rows(struct soap*, int)
        friend SOAP_FMAC1 _gml__AbstractGriddedSurfaceType_rows * SOAP_FMAC2 soap_instantiate__gml__AbstractGriddedSurfaceType_rows(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:680 */
#ifndef SOAP_TYPE_plu_gml__AbstractGriddedSurfaceType
#define SOAP_TYPE_plu_gml__AbstractGriddedSurfaceType (-181)
/* complex XML schema type 'gml:AbstractGriddedSurfaceType': */
class SOAP_CMAC gml__AbstractGriddedSurfaceType : public gml__AbstractParametricCurveSurfaceType {
      public:
        /// Required element 'gml:rows' of XML schema type 'gml:AbstractGriddedSurfaceType-rows'
        _gml__AbstractGriddedSurfaceType_rows rows;
        /// Optional attribute 'rows' of XML schema type 'xsd:long'
        long *rows_;
        /// Optional attribute 'columns' of XML schema type 'xsd:long'
        long *columns;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractGriddedSurfaceType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractGriddedSurfaceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractGriddedSurfaceType, default initialized and not managed by a soap context
        virtual gml__AbstractGriddedSurfaceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractGriddedSurfaceType); }
      public:
        /// Constructor with default initializations
        gml__AbstractGriddedSurfaceType() : rows(), rows_(), columns() { }
        virtual ~gml__AbstractGriddedSurfaceType() { }
        /// Friend allocator used by soap_new_gml__AbstractGriddedSurfaceType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractGriddedSurfaceType * SOAP_FMAC2 soap_instantiate_gml__AbstractGriddedSurfaceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:755 */
#ifndef SOAP_TYPE_plu_gml__VectorType
#define SOAP_TYPE_plu_gml__VectorType (-206)
/* simple XML schema type 'gml:VectorType': */
class SOAP_CMAC gml__VectorType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:doubleList' wrapped by this struct
        std::string __item;
        /// Optional attribute 'srsName' of XML schema type 'xsd:anyURI'
        char **srsName;
        /// Optional attribute 'srsDimension' of XML schema type 'xsd:positiveInteger'
        ULONG64 *srsDimension;
        /// Optional attribute 'axisLabels' of XML schema type 'gml:NCNameList'
        std::string *axisLabels;
        /// Optional attribute 'uomLabels' of XML schema type 'gml:NCNameList'
        std::string *uomLabels;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__VectorType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__VectorType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__VectorType, default initialized and not managed by a soap context
        virtual gml__VectorType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__VectorType); }
      public:
        /// Constructor with default initializations
        gml__VectorType() : __item(), srsName(), srsDimension(), axisLabels(), uomLabels() { }
        virtual ~gml__VectorType() { }
        /// Friend allocator used by soap_new_gml__VectorType(struct soap*, int)
        friend SOAP_FMAC1 gml__VectorType * SOAP_FMAC2 soap_instantiate_gml__VectorType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:761 */
#ifndef SOAP_TYPE_plu_gml__AbstractGeometricPrimitiveType
#define SOAP_TYPE_plu_gml__AbstractGeometricPrimitiveType (-208)
/* complex XML schema type 'gml:AbstractGeometricPrimitiveType': */
class SOAP_CMAC gml__AbstractGeometricPrimitiveType : public gml__AbstractGeometryType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractGeometricPrimitiveType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractGeometricPrimitiveType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractGeometricPrimitiveType, default initialized and not managed by a soap context
        virtual gml__AbstractGeometricPrimitiveType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractGeometricPrimitiveType); }
      public:
        /// Constructor with default initializations
        gml__AbstractGeometricPrimitiveType() { }
        virtual ~gml__AbstractGeometricPrimitiveType() { }
        /// Friend allocator used by soap_new_gml__AbstractGeometricPrimitiveType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractGeometricPrimitiveType * SOAP_FMAC2 soap_instantiate_gml__AbstractGeometricPrimitiveType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:788 */
#ifndef SOAP_TYPE_plu_gml__LengthType
#define SOAP_TYPE_plu_gml__LengthType (-217)
/* simple XML schema type 'gml:LengthType': */
class SOAP_CMAC gml__LengthType : public gml__MeasureType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__LengthType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__LengthType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__LengthType, default initialized and not managed by a soap context
        virtual gml__LengthType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__LengthType); }
      public:
        /// Constructor with default initializations
        gml__LengthType() { }
        virtual ~gml__LengthType() { }
        /// Friend allocator used by soap_new_gml__LengthType(struct soap*, int)
        friend SOAP_FMAC1 gml__LengthType * SOAP_FMAC2 soap_instantiate_gml__LengthType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:791 */
#ifndef SOAP_TYPE_plu_gml__ScaleType
#define SOAP_TYPE_plu_gml__ScaleType (-218)
/* simple XML schema type 'gml:ScaleType': */
class SOAP_CMAC gml__ScaleType : public gml__MeasureType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ScaleType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ScaleType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ScaleType, default initialized and not managed by a soap context
        virtual gml__ScaleType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ScaleType); }
      public:
        /// Constructor with default initializations
        gml__ScaleType() { }
        virtual ~gml__ScaleType() { }
        /// Friend allocator used by soap_new_gml__ScaleType(struct soap*, int)
        friend SOAP_FMAC1 gml__ScaleType * SOAP_FMAC2 soap_instantiate_gml__ScaleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:794 */
#ifndef SOAP_TYPE_plu_gml__TimeType
#define SOAP_TYPE_plu_gml__TimeType (-219)
/* simple XML schema type 'gml:TimeType': */
class SOAP_CMAC gml__TimeType : public gml__MeasureType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeType, default initialized and not managed by a soap context
        virtual gml__TimeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeType); }
      public:
        /// Constructor with default initializations
        gml__TimeType() { }
        virtual ~gml__TimeType() { }
        /// Friend allocator used by soap_new_gml__TimeType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeType * SOAP_FMAC2 soap_instantiate_gml__TimeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:797 */
#ifndef SOAP_TYPE_plu_gml__GridLengthType
#define SOAP_TYPE_plu_gml__GridLengthType (-220)
/* simple XML schema type 'gml:GridLengthType': */
class SOAP_CMAC gml__GridLengthType : public gml__MeasureType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GridLengthType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GridLengthType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GridLengthType, default initialized and not managed by a soap context
        virtual gml__GridLengthType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GridLengthType); }
      public:
        /// Constructor with default initializations
        gml__GridLengthType() { }
        virtual ~gml__GridLengthType() { }
        /// Friend allocator used by soap_new_gml__GridLengthType(struct soap*, int)
        friend SOAP_FMAC1 gml__GridLengthType * SOAP_FMAC2 soap_instantiate_gml__GridLengthType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:800 */
#ifndef SOAP_TYPE_plu_gml__AreaType
#define SOAP_TYPE_plu_gml__AreaType (-221)
/* simple XML schema type 'gml:AreaType': */
class SOAP_CMAC gml__AreaType : public gml__MeasureType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AreaType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AreaType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AreaType, default initialized and not managed by a soap context
        virtual gml__AreaType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AreaType); }
      public:
        /// Constructor with default initializations
        gml__AreaType() { }
        virtual ~gml__AreaType() { }
        /// Friend allocator used by soap_new_gml__AreaType(struct soap*, int)
        friend SOAP_FMAC1 gml__AreaType * SOAP_FMAC2 soap_instantiate_gml__AreaType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:803 */
#ifndef SOAP_TYPE_plu_gml__VolumeType
#define SOAP_TYPE_plu_gml__VolumeType (-222)
/* simple XML schema type 'gml:VolumeType': */
class SOAP_CMAC gml__VolumeType : public gml__MeasureType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__VolumeType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__VolumeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__VolumeType, default initialized and not managed by a soap context
        virtual gml__VolumeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__VolumeType); }
      public:
        /// Constructor with default initializations
        gml__VolumeType() { }
        virtual ~gml__VolumeType() { }
        /// Friend allocator used by soap_new_gml__VolumeType(struct soap*, int)
        friend SOAP_FMAC1 gml__VolumeType * SOAP_FMAC2 soap_instantiate_gml__VolumeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:806 */
#ifndef SOAP_TYPE_plu_gml__SpeedType
#define SOAP_TYPE_plu_gml__SpeedType (-223)
/* simple XML schema type 'gml:SpeedType': */
class SOAP_CMAC gml__SpeedType : public gml__MeasureType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__SpeedType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__SpeedType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SpeedType, default initialized and not managed by a soap context
        virtual gml__SpeedType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__SpeedType); }
      public:
        /// Constructor with default initializations
        gml__SpeedType() { }
        virtual ~gml__SpeedType() { }
        /// Friend allocator used by soap_new_gml__SpeedType(struct soap*, int)
        friend SOAP_FMAC1 gml__SpeedType * SOAP_FMAC2 soap_instantiate_gml__SpeedType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:809 */
#ifndef SOAP_TYPE_plu_gml__AngleType
#define SOAP_TYPE_plu_gml__AngleType (-224)
/* simple XML schema type 'gml:AngleType': */
class SOAP_CMAC gml__AngleType : public gml__MeasureType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AngleType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AngleType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AngleType, default initialized and not managed by a soap context
        virtual gml__AngleType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AngleType); }
      public:
        /// Constructor with default initializations
        gml__AngleType() { }
        virtual ~gml__AngleType() { }
        /// Friend allocator used by soap_new_gml__AngleType(struct soap*, int)
        friend SOAP_FMAC1 gml__AngleType * SOAP_FMAC2 soap_instantiate_gml__AngleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:839 */
#ifndef SOAP_TYPE_plu_gml__DefinitionType
#define SOAP_TYPE_plu_gml__DefinitionType (-234)
/* complex XML schema type 'gml:DefinitionType': */
class SOAP_CMAC gml__DefinitionType : public gml__DefinitionBaseType {
      public:
        /// Optional element 'gml:remarks' of XML schema type 'xsd:string'
        std::string *remarks;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DefinitionType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DefinitionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DefinitionType, default initialized and not managed by a soap context
        virtual gml__DefinitionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DefinitionType); }
      public:
        /// Constructor with default initializations
        gml__DefinitionType() : remarks() { }
        virtual ~gml__DefinitionType() { }
        /// Friend allocator used by soap_new_gml__DefinitionType(struct soap*, int)
        friend SOAP_FMAC1 gml__DefinitionType * SOAP_FMAC2 soap_instantiate_gml__DefinitionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:869 */
#ifndef SOAP_TYPE_plu_gml__CodeWithAuthorityType
#define SOAP_TYPE_plu_gml__CodeWithAuthorityType (-244)
/* simple XML schema type 'gml:CodeWithAuthorityType': */
class SOAP_CMAC gml__CodeWithAuthorityType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Required attribute 'codeSpace' of XML schema type 'xsd:anyURI'
        char *codeSpace;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CodeWithAuthorityType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CodeWithAuthorityType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CodeWithAuthorityType, default initialized and not managed by a soap context
        virtual gml__CodeWithAuthorityType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CodeWithAuthorityType); }
      public:
        /// Constructor with default initializations
        gml__CodeWithAuthorityType() : __item(), codeSpace() { }
        virtual ~gml__CodeWithAuthorityType() { }
        /// Friend allocator used by soap_new_gml__CodeWithAuthorityType(struct soap*, int)
        friend SOAP_FMAC1 gml__CodeWithAuthorityType * SOAP_FMAC2 soap_instantiate_gml__CodeWithAuthorityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:28737 */
#ifndef SOAP_TYPE_plu__gml__union_AbstractCoverageType_
#define SOAP_TYPE_plu__gml__union_AbstractCoverageType_ (-2157)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_AbstractCoverageType_
{
        #define SOAP_UNION_plu__gml__union_AbstractCoverageType__domainSet	(1)	/**< union variant selector value for member domainSet */
        gml__DomainSetType *domainSet;
        #define SOAP_UNION_plu__gml__union_AbstractCoverageType__multiPointDomain	(2)	/**< union variant selector value for member multiPointDomain */
        gml__DomainSetType *multiPointDomain;
        #define SOAP_UNION_plu__gml__union_AbstractCoverageType__multiCurveDomain	(3)	/**< union variant selector value for member multiCurveDomain */
        gml__DomainSetType *multiCurveDomain;
        #define SOAP_UNION_plu__gml__union_AbstractCoverageType__multiSurfaceDomain	(4)	/**< union variant selector value for member multiSurfaceDomain */
        gml__DomainSetType *multiSurfaceDomain;
        #define SOAP_UNION_plu__gml__union_AbstractCoverageType__multiSolidDomain	(5)	/**< union variant selector value for member multiSolidDomain */
        gml__DomainSetType *multiSolidDomain;
        #define SOAP_UNION_plu__gml__union_AbstractCoverageType__gridDomain	(6)	/**< union variant selector value for member gridDomain */
        gml__DomainSetType *gridDomain;
        #define SOAP_UNION_plu__gml__union_AbstractCoverageType__rectifiedGridDomain	(7)	/**< union variant selector value for member rectifiedGridDomain */
        gml__DomainSetType *rectifiedGridDomain;
};
#endif

/* PlannedLandUse_v3.0.h:890 */
#ifndef SOAP_TYPE_plu_gml__AbstractCoverageType
#define SOAP_TYPE_plu_gml__AbstractCoverageType (-251)
/* complex XML schema type 'gml:AbstractCoverageType': */
class SOAP_CMAC gml__AbstractCoverageType : public gml__AbstractFeatureType {
      public:
        /// Union with union _gml__union_AbstractCoverageType_ variant selector __uniondomainSet set to one of: SOAP_UNION_plu__gml__union_AbstractCoverageType__domainSet SOAP_UNION_plu__gml__union_AbstractCoverageType__multiPointDomain SOAP_UNION_plu__gml__union_AbstractCoverageType__multiCurveDomain SOAP_UNION_plu__gml__union_AbstractCoverageType__multiSurfaceDomain SOAP_UNION_plu__gml__union_AbstractCoverageType__multiSolidDomain SOAP_UNION_plu__gml__union_AbstractCoverageType__gridDomain SOAP_UNION_plu__gml__union_AbstractCoverageType__rectifiedGridDomain
        int __uniondomainSet;
        union _gml__union_AbstractCoverageType_ union_AbstractCoverageType_;
        /// Required element 'gml:rangeSet' of XML schema type 'gml:RangeSetType'
        gml__RangeSetType *rangeSet;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractCoverageType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractCoverageType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractCoverageType, default initialized and not managed by a soap context
        virtual gml__AbstractCoverageType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractCoverageType); }
      public:
        /// Constructor with default initializations
        gml__AbstractCoverageType() : __uniondomainSet(), rangeSet() { }
        virtual ~gml__AbstractCoverageType() { }
        /// Friend allocator used by soap_new_gml__AbstractCoverageType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractCoverageType * SOAP_FMAC2 soap_instantiate_gml__AbstractCoverageType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:920 */
#ifndef SOAP_TYPE_plu_gml__SequenceRuleType
#define SOAP_TYPE_plu_gml__SequenceRuleType (-261)
/* simple XML schema type 'gml:SequenceRuleType': */
class SOAP_CMAC gml__SequenceRuleType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:SequenceRuleEnumeration' wrapped by this struct
        enum gml__SequenceRuleEnumeration __item;
        /// Optional attribute 'order' of XML schema type 'gml:IncrementOrder'
        enum gml__IncrementOrder *order;
        /// Optional attribute 'axisOrder' of XML schema type 'gml:AxisDirectionList'
        std::string *axisOrder;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__SequenceRuleType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__SequenceRuleType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SequenceRuleType, default initialized and not managed by a soap context
        virtual gml__SequenceRuleType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__SequenceRuleType); }
      public:
        /// Constructor with default initializations
        gml__SequenceRuleType() : __item(), order(), axisOrder() { }
        virtual ~gml__SequenceRuleType() { }
        /// Friend allocator used by soap_new_gml__SequenceRuleType(struct soap*, int)
        friend SOAP_FMAC1 gml__SequenceRuleType * SOAP_FMAC2 soap_instantiate_gml__SequenceRuleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:941 */
#ifndef SOAP_TYPE_plu_gml__AbstractTimePrimitiveType
#define SOAP_TYPE_plu_gml__AbstractTimePrimitiveType (-268)
/* complex XML schema type 'gml:AbstractTimePrimitiveType': */
class SOAP_CMAC gml__AbstractTimePrimitiveType : public gml__AbstractTimeObjectType {
      public:
        /// Optional element 'gml:relatedTime' of XML schema type 'gml:RelatedTimeType'
        std::vector<gml__RelatedTimeType *> relatedTime;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractTimePrimitiveType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractTimePrimitiveType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractTimePrimitiveType, default initialized and not managed by a soap context
        virtual gml__AbstractTimePrimitiveType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractTimePrimitiveType); }
      public:
        /// Constructor with default initializations
        gml__AbstractTimePrimitiveType() : relatedTime() { }
        virtual ~gml__AbstractTimePrimitiveType() { }
        /// Friend allocator used by soap_new_gml__AbstractTimePrimitiveType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractTimePrimitiveType * SOAP_FMAC2 soap_instantiate_gml__AbstractTimePrimitiveType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:950 */
#ifndef SOAP_TYPE_plu_gml__AbstractTimeComplexType
#define SOAP_TYPE_plu_gml__AbstractTimeComplexType (-271)
/* complex XML schema type 'gml:AbstractTimeComplexType': */
class SOAP_CMAC gml__AbstractTimeComplexType : public gml__AbstractTimeObjectType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractTimeComplexType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractTimeComplexType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractTimeComplexType, default initialized and not managed by a soap context
        virtual gml__AbstractTimeComplexType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractTimeComplexType); }
      public:
        /// Constructor with default initializations
        gml__AbstractTimeComplexType() { }
        virtual ~gml__AbstractTimeComplexType() { }
        /// Friend allocator used by soap_new_gml__AbstractTimeComplexType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractTimeComplexType * SOAP_FMAC2 soap_instantiate_gml__AbstractTimeComplexType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:983 */
#ifndef SOAP_TYPE_plu_gml__ValueArrayType
#define SOAP_TYPE_plu_gml__ValueArrayType (-282)
/* Type gml__ValueArrayType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gml:ValueArrayType': */
class SOAP_CMAC gml__ValueArrayType : public gml__CompositeValueType {
      public:
        /// Optional attribute 'codeSpace' of XML schema type 'xsd:anyURI'
        char **codeSpace;
        /// Optional attribute 'uom' of XML schema type 'gml:UomIdentifier'
        std::string *uom;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ValueArrayType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ValueArrayType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ValueArrayType, default initialized and not managed by a soap context
        virtual gml__ValueArrayType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ValueArrayType); }
      public:
        /// Constructor with default initializations
        gml__ValueArrayType() : codeSpace(), uom() { }
        virtual ~gml__ValueArrayType() { }
        /// Friend allocator used by soap_new_gml__ValueArrayType(struct soap*, int)
        friend SOAP_FMAC1 gml__ValueArrayType * SOAP_FMAC2 soap_instantiate_gml__ValueArrayType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:986 */
#ifndef SOAP_TYPE_plu_gml__CategoryExtentType
#define SOAP_TYPE_plu_gml__CategoryExtentType (-283)
/* simple XML schema type 'gml:CategoryExtentType': */
class SOAP_CMAC gml__CategoryExtentType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:NameOrNilReasonList' wrapped by this struct
        std::string __item;
        /// Optional attribute 'codeSpace' of XML schema type 'xsd:anyURI'
        char **codeSpace;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CategoryExtentType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CategoryExtentType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CategoryExtentType, default initialized and not managed by a soap context
        virtual gml__CategoryExtentType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CategoryExtentType); }
      public:
        /// Constructor with default initializations
        gml__CategoryExtentType() : __item(), codeSpace() { }
        virtual ~gml__CategoryExtentType() { }
        /// Friend allocator used by soap_new_gml__CategoryExtentType(struct soap*, int)
        friend SOAP_FMAC1 gml__CategoryExtentType * SOAP_FMAC2 soap_instantiate_gml__CategoryExtentType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:989 */
#ifndef SOAP_TYPE_plu_gml__QuantityExtentType
#define SOAP_TYPE_plu_gml__QuantityExtentType (-284)
/* simple XML schema type 'gml:QuantityExtentType': */
class SOAP_CMAC gml__QuantityExtentType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:doubleOrNilReasonList' wrapped by this struct
        std::string __item;
        /// Required attribute 'uom' of XML schema type 'gml:UomIdentifier'
        std::string uom;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__QuantityExtentType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__QuantityExtentType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__QuantityExtentType, default initialized and not managed by a soap context
        virtual gml__QuantityExtentType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__QuantityExtentType); }
      public:
        /// Constructor with default initializations
        gml__QuantityExtentType() : __item(), uom() { }
        virtual ~gml__QuantityExtentType() { }
        /// Friend allocator used by soap_new_gml__QuantityExtentType(struct soap*, int)
        friend SOAP_FMAC1 gml__QuantityExtentType * SOAP_FMAC2 soap_instantiate_gml__QuantityExtentType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:29065 */
#ifndef SOAP_TYPE_plu__gml__union_GridType
#define SOAP_TYPE_plu__gml__union_GridType (-2166)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_GridType
{
        #define SOAP_UNION_plu__gml__union_GridType_axisLabels	(1)	/**< union variant selector value for member axisLabels */
        std::string *axisLabels;
        #define SOAP_UNION_plu__gml__union_GridType_axisName	(2)	/**< union variant selector value for member axisName */
        std::vector<std::string> *axisName;
};
#endif

/* PlannedLandUse_v3.0.h:1004 */
#ifndef SOAP_TYPE_plu_gml__GridType
#define SOAP_TYPE_plu_gml__GridType (-289)
/* complex XML schema type 'gml:GridType': */
class SOAP_CMAC gml__GridType : public gml__AbstractGeometryType {
      public:
        /// Required element 'gml:limits' of XML schema type 'gml:GridLimitsType'
        gml__GridLimitsType *limits;
        /// Union with union _gml__union_GridType variant selector __union_GridType set to one of: SOAP_UNION_plu__gml__union_GridType_axisLabels SOAP_UNION_plu__gml__union_GridType_axisName
        int __union_GridType;
        union _gml__union_GridType union_GridType;
        /// Required attribute 'dimension' of XML schema type 'xsd:positiveInteger'
        ULONG64 dimension;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GridType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GridType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GridType, default initialized and not managed by a soap context
        virtual gml__GridType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GridType); }
      public:
        /// Constructor with default initializations
        gml__GridType() : limits(), __union_GridType(), dimension() { }
        virtual ~gml__GridType() { }
        /// Friend allocator used by soap_new_gml__GridType(struct soap*, int)
        friend SOAP_FMAC1 gml__GridType * SOAP_FMAC2 soap_instantiate_gml__GridType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:29150 */
#ifndef SOAP_TYPE_plu__gml__union_ObservationType_
#define SOAP_TYPE_plu__gml__union_ObservationType_ (-2170)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ObservationType_
{
        #define SOAP_UNION_plu__gml__union_ObservationType__target	(1)	/**< union variant selector value for member target */
        gml__TargetPropertyType *target;
        #define SOAP_UNION_plu__gml__union_ObservationType__subject	(2)	/**< union variant selector value for member subject */
        gml__TargetPropertyType *subject;
};
#endif

/* PlannedLandUse_v3.0.h:1283 */
#ifndef SOAP_TYPE_plu_gml__ObservationType
#define SOAP_TYPE_plu_gml__ObservationType (-382)
/* Type gml__ObservationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gml:ObservationType': */
class SOAP_CMAC gml__ObservationType : public gml__AbstractFeatureType {
      public:
        /// Required element 'gml:validTime' of XML schema type 'gml:TimePrimitivePropertyType'
        gml__TimePrimitivePropertyType *validTime;
        /// Optional element 'gml:using' of XML schema type 'gml:ProcedurePropertyType'
        gml__ProcedurePropertyType *using_;
        /// Union with union _gml__union_ObservationType_ variant selector __uniontarget set to one of: SOAP_UNION_plu__gml__union_ObservationType__target SOAP_UNION_plu__gml__union_ObservationType__subject
        int __uniontarget;
        union _gml__union_ObservationType_ union_ObservationType_;
        /// Required element 'gml:resultOf' of XML schema type 'gml:ResultType'
        gml__ResultType *resultOf;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ObservationType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ObservationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ObservationType, default initialized and not managed by a soap context
        virtual gml__ObservationType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ObservationType); }
      public:
        /// Constructor with default initializations
        gml__ObservationType() : validTime(), using_(), __uniontarget(), resultOf() { }
        virtual ~gml__ObservationType() { }
        /// Friend allocator used by soap_new_gml__ObservationType(struct soap*, int)
        friend SOAP_FMAC1 gml__ObservationType * SOAP_FMAC2 soap_instantiate_gml__ObservationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1397 */
#ifndef SOAP_TYPE_plu_gml__DegreesType
#define SOAP_TYPE_plu_gml__DegreesType (-420)
/* simple XML schema type 'gml:DegreesType': */
class SOAP_CMAC gml__DegreesType : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'gml:DegreeValueType' wrapped by this struct
        ULONG64 __item;
        /// Optional attribute 'direction' of XML schema type 'gml:DegreesType-direction'
        enum _gml__DegreesType_direction *direction;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DegreesType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DegreesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DegreesType, default initialized and not managed by a soap context
        virtual gml__DegreesType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DegreesType); }
      public:
        /// Constructor with default initializations
        gml__DegreesType() : __item(), direction() { }
        virtual ~gml__DegreesType() { }
        /// Friend allocator used by soap_new_gml__DegreesType(struct soap*, int)
        friend SOAP_FMAC1 gml__DegreesType * SOAP_FMAC2 soap_instantiate_gml__DegreesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:29236 */
#ifndef SOAP_TYPE_plu__gml__union_BoundedFeatureType
#define SOAP_TYPE_plu__gml__union_BoundedFeatureType (-2175)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_BoundedFeatureType
{
        #define SOAP_UNION_plu__gml__union_BoundedFeatureType_location	(1)	/**< union variant selector value for member location */
        gml__LocationPropertyType *location;
        #define SOAP_UNION_plu__gml__union_BoundedFeatureType_priorityLocation	(2)	/**< union variant selector value for member priorityLocation */
        gml__PriorityLocationPropertyType *priorityLocation;
};
#endif

/* PlannedLandUse_v3.0.h:1433 */
#ifndef SOAP_TYPE_plu_gml__BoundedFeatureType
#define SOAP_TYPE_plu_gml__BoundedFeatureType (-432)
/* complex XML schema type 'gml:BoundedFeatureType': */
class SOAP_CMAC gml__BoundedFeatureType : public xsd__anyType {
      public:
        /// Optional element 'gml:metaDataProperty' of XML schema type 'gml:MetaDataPropertyType'
        std::vector<gml__MetaDataPropertyType *> metaDataProperty;
        /// Optional element 'gml:description' of XML schema type 'gml:StringOrRefType'
        gml__StringOrRefType *description;
        /// Optional element 'gml:descriptionReference' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *descriptionReference;
        /// Optional element 'gml:identifier' of XML schema type 'gml:CodeWithAuthorityType'
        gml__CodeWithAuthorityType *identifier;
        /// Optional element 'gml:name' of XML schema type 'gml:CodeType'
        std::vector<gml__CodeType *> name;
        /// Required element 'gml:boundedBy' of XML schema type 'gml:BoundingShapeType'
        gml__BoundingShapeType *boundedBy;
        /// Union with union _gml__union_BoundedFeatureType variant selector __unionlocation set to one of: SOAP_UNION_plu__gml__union_BoundedFeatureType_location SOAP_UNION_plu__gml__union_BoundedFeatureType_priorityLocation
        int __unionlocation;
        union _gml__union_BoundedFeatureType union_BoundedFeatureType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__BoundedFeatureType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__BoundedFeatureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__BoundedFeatureType, default initialized and not managed by a soap context
        virtual gml__BoundedFeatureType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__BoundedFeatureType); }
      public:
        /// Constructor with default initializations
        gml__BoundedFeatureType() : metaDataProperty(), description(), descriptionReference(), identifier(), name(), boundedBy(), __unionlocation() { }
        virtual ~gml__BoundedFeatureType() { }
        /// Friend allocator used by soap_new_gml__BoundedFeatureType(struct soap*, int)
        friend SOAP_FMAC1 gml__BoundedFeatureType * SOAP_FMAC2 soap_instantiate_gml__BoundedFeatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1436 */
#ifndef SOAP_TYPE_plu_gml__AbstractFeatureCollectionType
#define SOAP_TYPE_plu_gml__AbstractFeatureCollectionType (-433)
/* complex XML schema type 'gml:AbstractFeatureCollectionType': */
class SOAP_CMAC gml__AbstractFeatureCollectionType : public gml__AbstractFeatureType {
      public:
        /// Optional element 'gml:featureMember' of XML schema type 'gml:FeaturePropertyType'
        std::vector<gml__FeaturePropertyType *> featureMember;
        /// Optional element 'gml:featureMembers' of XML schema type 'gml:FeatureArrayPropertyType'
        gml__FeatureArrayPropertyType *featureMembers;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractFeatureCollectionType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractFeatureCollectionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractFeatureCollectionType, default initialized and not managed by a soap context
        virtual gml__AbstractFeatureCollectionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractFeatureCollectionType); }
      public:
        /// Constructor with default initializations
        gml__AbstractFeatureCollectionType() : featureMember(), featureMembers() { }
        virtual ~gml__AbstractFeatureCollectionType() { }
        /// Friend allocator used by soap_new_gml__AbstractFeatureCollectionType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractFeatureCollectionType * SOAP_FMAC2 soap_instantiate_gml__AbstractFeatureCollectionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:29383 */
#ifndef SOAP_TYPE_plu__gml__union_MovingObjectStatusType
#define SOAP_TYPE_plu__gml__union_MovingObjectStatusType (-2177)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_MovingObjectStatusType
{
        #define SOAP_UNION_plu__gml__union_MovingObjectStatusType_position	(1)	/**< union variant selector value for member position */
        gml__GeometryPropertyType *position;
        #define SOAP_UNION_plu__gml__union_MovingObjectStatusType_pos	(2)	/**< union variant selector value for member pos */
        gml__DirectPositionType *pos;
        #define SOAP_UNION_plu__gml__union_MovingObjectStatusType_locationName	(3)	/**< union variant selector value for member locationName */
        gml__CodeType *locationName;
        #define SOAP_UNION_plu__gml__union_MovingObjectStatusType_locationReference	(4)	/**< union variant selector value for member locationReference */
        gml__ReferenceType *locationReference;
        #define SOAP_UNION_plu__gml__union_MovingObjectStatusType_location	(5)	/**< union variant selector value for member location */
        gml__LocationPropertyType *location;
        #define SOAP_UNION_plu__gml__union_MovingObjectStatusType_priorityLocation	(6)	/**< union variant selector value for member priorityLocation */
        gml__PriorityLocationPropertyType *priorityLocation;
};
#endif

/* PlannedLandUse_v3.0.h:1448 */
#ifndef SOAP_TYPE_plu_gml__MovingObjectStatusType
#define SOAP_TYPE_plu_gml__MovingObjectStatusType (-437)
/* complex XML schema type 'gml:MovingObjectStatusType': */
class SOAP_CMAC gml__MovingObjectStatusType : public gml__AbstractTimeSliceType {
      public:
        /// Union with union _gml__union_MovingObjectStatusType variant selector __union_MovingObjectStatusType set to one of: SOAP_UNION_plu__gml__union_MovingObjectStatusType_position SOAP_UNION_plu__gml__union_MovingObjectStatusType_pos SOAP_UNION_plu__gml__union_MovingObjectStatusType_locationName SOAP_UNION_plu__gml__union_MovingObjectStatusType_locationReference SOAP_UNION_plu__gml__union_MovingObjectStatusType_location SOAP_UNION_plu__gml__union_MovingObjectStatusType_priorityLocation
        int __union_MovingObjectStatusType;
        union _gml__union_MovingObjectStatusType union_MovingObjectStatusType;
        /// Optional element 'gml:speed' of XML schema type 'gml:MeasureType'
        gml__MeasureType *speed;
        /// Optional element 'gml:bearing' of XML schema type 'gml:DirectionPropertyType'
        gml__DirectionPropertyType *bearing;
        /// Optional element 'gml:acceleration' of XML schema type 'gml:MeasureType'
        gml__MeasureType *acceleration;
        /// Optional element 'gml:elevation' of XML schema type 'gml:MeasureType'
        gml__MeasureType *elevation;
        /// Optional element 'gml:status' of XML schema type 'gml:StringOrRefType'
        gml__StringOrRefType *status;
        /// Optional element 'gml:statusReference' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *statusReference;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__MovingObjectStatusType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__MovingObjectStatusType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__MovingObjectStatusType, default initialized and not managed by a soap context
        virtual gml__MovingObjectStatusType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__MovingObjectStatusType); }
      public:
        /// Constructor with default initializations
        gml__MovingObjectStatusType() : __union_MovingObjectStatusType(), speed(), bearing(), acceleration(), elevation(), status(), statusReference() { }
        virtual ~gml__MovingObjectStatusType() { }
        /// Friend allocator used by soap_new_gml__MovingObjectStatusType(struct soap*, int)
        friend SOAP_FMAC1 gml__MovingObjectStatusType * SOAP_FMAC2 soap_instantiate_gml__MovingObjectStatusType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1454 */
#ifndef SOAP_TYPE_plu__gml__Category
#define SOAP_TYPE_plu__gml__Category (-439)
/* simple XML schema type 'gml:Category': */
class SOAP_CMAC _gml__Category : public gml__CodeType {
      public:
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__gml__Category
        virtual long soap_type(void) const { return SOAP_TYPE_plu__gml__Category; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _gml__Category, default initialized and not managed by a soap context
        virtual _gml__Category *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_gml__Category); }
      public:
        /// Constructor with default initializations
        _gml__Category() : nilReason() { }
        virtual ~_gml__Category() { }
        /// Friend allocator used by soap_new__gml__Category(struct soap*, int)
        friend SOAP_FMAC1 _gml__Category * SOAP_FMAC2 soap_instantiate__gml__Category(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1460 */
#ifndef SOAP_TYPE_plu__gml__Quantity
#define SOAP_TYPE_plu__gml__Quantity (-441)
/* simple XML schema type 'gml:Quantity': */
class SOAP_CMAC _gml__Quantity : public gml__MeasureType {
      public:
        /// Optional attribute 'nilReason' of XML schema type 'gml:NilReasonType'
        std::string *nilReason;
      public:
        /// Return unique type id SOAP_TYPE_plu__gml__Quantity
        virtual long soap_type(void) const { return SOAP_TYPE_plu__gml__Quantity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _gml__Quantity, default initialized and not managed by a soap context
        virtual _gml__Quantity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_gml__Quantity); }
      public:
        /// Constructor with default initializations
        _gml__Quantity() : nilReason() { }
        virtual ~_gml__Quantity() { }
        /// Friend allocator used by soap_new__gml__Quantity(struct soap*, int)
        friend SOAP_FMAC1 _gml__Quantity * SOAP_FMAC2 soap_instantiate__gml__Quantity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1490 */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fOtherAggregate_x005fType
#define SOAP_TYPE_plu_gmd__DS_x005fOtherAggregate_x005fType (-451)
/* complex XML schema type 'gmd:DS_OtherAggregate_Type': */
class SOAP_CMAC gmd__DS_x005fOtherAggregate_x005fType : public gmd__AbstractDS_x005fAggregate_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DS_x005fOtherAggregate_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DS_x005fOtherAggregate_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DS_x005fOtherAggregate_x005fType, default initialized and not managed by a soap context
        virtual gmd__DS_x005fOtherAggregate_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DS_x005fOtherAggregate_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DS_x005fOtherAggregate_x005fType() { }
        virtual ~gmd__DS_x005fOtherAggregate_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DS_x005fOtherAggregate_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DS_x005fOtherAggregate_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DS_x005fOtherAggregate_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1496 */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fSeries_x005fType
#define SOAP_TYPE_plu_gmd__DS_x005fSeries_x005fType (-453)
/* complex XML schema type 'gmd:DS_Series_Type': */
class SOAP_CMAC gmd__DS_x005fSeries_x005fType : public gmd__AbstractDS_x005fAggregate_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DS_x005fSeries_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DS_x005fSeries_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DS_x005fSeries_x005fType, default initialized and not managed by a soap context
        virtual gmd__DS_x005fSeries_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DS_x005fSeries_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DS_x005fSeries_x005fType() { }
        virtual ~gmd__DS_x005fSeries_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DS_x005fSeries_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DS_x005fSeries_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DS_x005fSeries_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1502 */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fInitiative_x005fType
#define SOAP_TYPE_plu_gmd__DS_x005fInitiative_x005fType (-455)
/* complex XML schema type 'gmd:DS_Initiative_Type': */
class SOAP_CMAC gmd__DS_x005fInitiative_x005fType : public gmd__AbstractDS_x005fAggregate_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DS_x005fInitiative_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DS_x005fInitiative_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DS_x005fInitiative_x005fType, default initialized and not managed by a soap context
        virtual gmd__DS_x005fInitiative_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DS_x005fInitiative_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DS_x005fInitiative_x005fType() { }
        virtual ~gmd__DS_x005fInitiative_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DS_x005fInitiative_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DS_x005fInitiative_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DS_x005fInitiative_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1538 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fGridSpatialRepresentation_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fGridSpatialRepresentation_x005fType (-467)
/* complex XML schema type 'gmd:MD_GridSpatialRepresentation_Type': */
class SOAP_CMAC gmd__MD_x005fGridSpatialRepresentation_x005fType : public gmd__AbstractMD_x005fSpatialRepresentation_x005fType {
      public:
        /// Required element 'gmd:numberOfDimensions' of XML schema type 'gco:Integer_PropertyType'
        gco__Integer_x005fPropertyType *numberOfDimensions;
        /// Optional element 'gmd:axisDimensionProperties' of XML schema type 'gmd:MD_Dimension_PropertyType'
        std::vector<gmd__MD_x005fDimension_x005fPropertyType *> axisDimensionProperties;
        /// Required element 'gmd:cellGeometry' of XML schema type 'gmd:MD_CellGeometryCode_PropertyType'
        gmd__MD_x005fCellGeometryCode_x005fPropertyType *cellGeometry;
        /// Required element 'gmd:transformationParameterAvailability' of XML schema type 'gco:Boolean_PropertyType'
        gco__Boolean_x005fPropertyType *transformationParameterAvailability;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fGridSpatialRepresentation_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fGridSpatialRepresentation_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fGridSpatialRepresentation_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fGridSpatialRepresentation_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fGridSpatialRepresentation_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fGridSpatialRepresentation_x005fType() : numberOfDimensions(), axisDimensionProperties(), cellGeometry(), transformationParameterAvailability() { }
        virtual ~gmd__MD_x005fGridSpatialRepresentation_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fGridSpatialRepresentation_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fGridSpatialRepresentation_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fGridSpatialRepresentation_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1544 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fVectorSpatialRepresentation_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fVectorSpatialRepresentation_x005fType (-469)
/* complex XML schema type 'gmd:MD_VectorSpatialRepresentation_Type': */
class SOAP_CMAC gmd__MD_x005fVectorSpatialRepresentation_x005fType : public gmd__AbstractMD_x005fSpatialRepresentation_x005fType {
      public:
        /// Optional element 'gmd:topologyLevel' of XML schema type 'gmd:MD_TopologyLevelCode_PropertyType'
        gmd__MD_x005fTopologyLevelCode_x005fPropertyType *topologyLevel;
        /// Optional element 'gmd:geometricObjects' of XML schema type 'gmd:MD_GeometricObjects_PropertyType'
        std::vector<gmd__MD_x005fGeometricObjects_x005fPropertyType *> geometricObjects;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fVectorSpatialRepresentation_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fVectorSpatialRepresentation_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fVectorSpatialRepresentation_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fVectorSpatialRepresentation_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fVectorSpatialRepresentation_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fVectorSpatialRepresentation_x005fType() : topologyLevel(), geometricObjects() { }
        virtual ~gmd__MD_x005fVectorSpatialRepresentation_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fVectorSpatialRepresentation_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fVectorSpatialRepresentation_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fVectorSpatialRepresentation_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1658 */
#ifndef SOAP_TYPE_plu_gmd__RS_x005fIdentifier_x005fType
#define SOAP_TYPE_plu_gmd__RS_x005fIdentifier_x005fType (-507)
/* complex XML schema type 'gmd:RS_Identifier_Type': */
class SOAP_CMAC gmd__RS_x005fIdentifier_x005fType : public gmd__MD_x005fIdentifier_x005fType {
      public:
        /// Optional element 'gmd:codeSpace' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *codeSpace;
        /// Optional element 'gmd:version' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *version;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__RS_x005fIdentifier_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__RS_x005fIdentifier_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__RS_x005fIdentifier_x005fType, default initialized and not managed by a soap context
        virtual gmd__RS_x005fIdentifier_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__RS_x005fIdentifier_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__RS_x005fIdentifier_x005fType() : codeSpace(), version() { }
        virtual ~gmd__RS_x005fIdentifier_x005fType() { }
        /// Friend allocator used by soap_new_gmd__RS_x005fIdentifier_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__RS_x005fIdentifier_x005fType * SOAP_FMAC2 soap_instantiate_gmd__RS_x005fIdentifier_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1694 */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fBoundingPolygon_x005fType
#define SOAP_TYPE_plu_gmd__EX_x005fBoundingPolygon_x005fType (-519)
/* complex XML schema type 'gmd:EX_BoundingPolygon_Type': */
class SOAP_CMAC gmd__EX_x005fBoundingPolygon_x005fType : public gmd__AbstractEX_x005fGeographicExtent_x005fType {
      public:
        /// Required element 'gmd:polygon' of XML schema type 'gss:GM_Object_PropertyType'
        std::vector<gss__GM_x005fObject_x005fPropertyType *> polygon;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__EX_x005fBoundingPolygon_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__EX_x005fBoundingPolygon_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_x005fBoundingPolygon_x005fType, default initialized and not managed by a soap context
        virtual gmd__EX_x005fBoundingPolygon_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__EX_x005fBoundingPolygon_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__EX_x005fBoundingPolygon_x005fType() : polygon() { }
        virtual ~gmd__EX_x005fBoundingPolygon_x005fType() { }
        /// Friend allocator used by soap_new_gmd__EX_x005fBoundingPolygon_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_x005fBoundingPolygon_x005fType * SOAP_FMAC2 soap_instantiate_gmd__EX_x005fBoundingPolygon_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1712 */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fGeographicBoundingBox_x005fType
#define SOAP_TYPE_plu_gmd__EX_x005fGeographicBoundingBox_x005fType (-525)
/* complex XML schema type 'gmd:EX_GeographicBoundingBox_Type': */
class SOAP_CMAC gmd__EX_x005fGeographicBoundingBox_x005fType : public gmd__AbstractEX_x005fGeographicExtent_x005fType {
      public:
        /// Required element 'gmd:westBoundLongitude' of XML schema type 'gco:Decimal_PropertyType'
        gco__Decimal_x005fPropertyType *westBoundLongitude;
        /// Required element 'gmd:eastBoundLongitude' of XML schema type 'gco:Decimal_PropertyType'
        gco__Decimal_x005fPropertyType *eastBoundLongitude;
        /// Required element 'gmd:southBoundLatitude' of XML schema type 'gco:Decimal_PropertyType'
        gco__Decimal_x005fPropertyType *southBoundLatitude;
        /// Required element 'gmd:northBoundLatitude' of XML schema type 'gco:Decimal_PropertyType'
        gco__Decimal_x005fPropertyType *northBoundLatitude;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__EX_x005fGeographicBoundingBox_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__EX_x005fGeographicBoundingBox_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_x005fGeographicBoundingBox_x005fType, default initialized and not managed by a soap context
        virtual gmd__EX_x005fGeographicBoundingBox_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__EX_x005fGeographicBoundingBox_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__EX_x005fGeographicBoundingBox_x005fType() : westBoundLongitude(), eastBoundLongitude(), southBoundLatitude(), northBoundLatitude() { }
        virtual ~gmd__EX_x005fGeographicBoundingBox_x005fType() { }
        /// Friend allocator used by soap_new_gmd__EX_x005fGeographicBoundingBox_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_x005fGeographicBoundingBox_x005fType * SOAP_FMAC2 soap_instantiate_gmd__EX_x005fGeographicBoundingBox_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1718 */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fSpatialTemporalExtent_x005fType
#define SOAP_TYPE_plu_gmd__EX_x005fSpatialTemporalExtent_x005fType (-527)
/* complex XML schema type 'gmd:EX_SpatialTemporalExtent_Type': */
class SOAP_CMAC gmd__EX_x005fSpatialTemporalExtent_x005fType : public gmd__EX_x005fTemporalExtent_x005fType {
      public:
        /// Required element 'gmd:spatialExtent' of XML schema type 'gmd:EX_GeographicExtent_PropertyType'
        std::vector<gmd__EX_x005fGeographicExtent_x005fPropertyType *> spatialExtent;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__EX_x005fSpatialTemporalExtent_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__EX_x005fSpatialTemporalExtent_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_x005fSpatialTemporalExtent_x005fType, default initialized and not managed by a soap context
        virtual gmd__EX_x005fSpatialTemporalExtent_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__EX_x005fSpatialTemporalExtent_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__EX_x005fSpatialTemporalExtent_x005fType() : spatialExtent() { }
        virtual ~gmd__EX_x005fSpatialTemporalExtent_x005fType() { }
        /// Friend allocator used by soap_new_gmd__EX_x005fSpatialTemporalExtent_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_x005fSpatialTemporalExtent_x005fType * SOAP_FMAC2 soap_instantiate_gmd__EX_x005fSpatialTemporalExtent_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1724 */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fGeographicDescription_x005fType
#define SOAP_TYPE_plu_gmd__EX_x005fGeographicDescription_x005fType (-529)
/* complex XML schema type 'gmd:EX_GeographicDescription_Type': */
class SOAP_CMAC gmd__EX_x005fGeographicDescription_x005fType : public gmd__AbstractEX_x005fGeographicExtent_x005fType {
      public:
        /// Required element 'gmd:geographicIdentifier' of XML schema type 'gmd:MD_Identifier_PropertyType'
        gmd__MD_x005fIdentifier_x005fPropertyType *geographicIdentifier;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__EX_x005fGeographicDescription_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__EX_x005fGeographicDescription_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_x005fGeographicDescription_x005fType, default initialized and not managed by a soap context
        virtual gmd__EX_x005fGeographicDescription_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__EX_x005fGeographicDescription_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__EX_x005fGeographicDescription_x005fType() : geographicIdentifier() { }
        virtual ~gmd__EX_x005fGeographicDescription_x005fType() { }
        /// Friend allocator used by soap_new_gmd__EX_x005fGeographicDescription_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_x005fGeographicDescription_x005fType * SOAP_FMAC2 soap_instantiate_gmd__EX_x005fGeographicDescription_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1748 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fFeatureCatalogueDescription_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fFeatureCatalogueDescription_x005fType (-537)
/* complex XML schema type 'gmd:MD_FeatureCatalogueDescription_Type': */
class SOAP_CMAC gmd__MD_x005fFeatureCatalogueDescription_x005fType : public gmd__AbstractMD_x005fContentInformation_x005fType {
      public:
        /// Optional element 'gmd:complianceCode' of XML schema type 'gco:Boolean_PropertyType'
        gco__Boolean_x005fPropertyType *complianceCode;
        /// Optional element 'gmd:language' of XML schema type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_x005fPropertyType *> language;
        /// Required element 'gmd:includedWithDataset' of XML schema type 'gco:Boolean_PropertyType'
        gco__Boolean_x005fPropertyType *includedWithDataset;
        /// Optional element 'gmd:featureTypes' of XML schema type 'gco:GenericName_PropertyType'
        std::vector<gco__GenericName_x005fPropertyType *> featureTypes;
        /// Required element 'gmd:featureCatalogueCitation' of XML schema type 'gmd:CI_Citation_PropertyType'
        std::vector<gmd__CI_x005fCitation_x005fPropertyType *> featureCatalogueCitation;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fFeatureCatalogueDescription_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fFeatureCatalogueDescription_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fFeatureCatalogueDescription_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fFeatureCatalogueDescription_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fFeatureCatalogueDescription_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fFeatureCatalogueDescription_x005fType() : complianceCode(), language(), includedWithDataset(), featureTypes(), featureCatalogueCitation() { }
        virtual ~gmd__MD_x005fFeatureCatalogueDescription_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fFeatureCatalogueDescription_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fFeatureCatalogueDescription_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fFeatureCatalogueDescription_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1754 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fCoverageDescription_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fCoverageDescription_x005fType (-539)
/* complex XML schema type 'gmd:MD_CoverageDescription_Type': */
class SOAP_CMAC gmd__MD_x005fCoverageDescription_x005fType : public gmd__AbstractMD_x005fContentInformation_x005fType {
      public:
        /// Required element 'gmd:attributeDescription' of XML schema type 'gco:RecordType_PropertyType'
        gco__RecordType_x005fPropertyType *attributeDescription;
        /// Required element 'gmd:contentType' of XML schema type 'gmd:MD_CoverageContentTypeCode_PropertyType'
        gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType *contentType;
        /// Optional element 'gmd:dimension' of XML schema type 'gmd:MD_RangeDimension_PropertyType'
        std::vector<gmd__MD_x005fRangeDimension_x005fPropertyType *> dimension;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fCoverageDescription_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fCoverageDescription_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fCoverageDescription_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fCoverageDescription_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fCoverageDescription_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fCoverageDescription_x005fType() : attributeDescription(), contentType(), dimension() { }
        virtual ~gmd__MD_x005fCoverageDescription_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fCoverageDescription_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fCoverageDescription_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fCoverageDescription_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1778 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fBand_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fBand_x005fType (-547)
/* complex XML schema type 'gmd:MD_Band_Type': */
class SOAP_CMAC gmd__MD_x005fBand_x005fType : public gmd__MD_x005fRangeDimension_x005fType {
      public:
        /// Optional element 'gmd:maxValue' of XML schema type 'gco:Real_PropertyType'
        gco__Real_x005fPropertyType *maxValue;
        /// Optional element 'gmd:minValue' of XML schema type 'gco:Real_PropertyType'
        gco__Real_x005fPropertyType *minValue;
        /// Optional element 'gmd:units' of XML schema type 'gco:UomLength_PropertyType'
        gco__UomLength_x005fPropertyType *units;
        /// Optional element 'gmd:peakResponse' of XML schema type 'gco:Real_PropertyType'
        gco__Real_x005fPropertyType *peakResponse;
        /// Optional element 'gmd:bitsPerValue' of XML schema type 'gco:Integer_PropertyType'
        gco__Integer_x005fPropertyType *bitsPerValue;
        /// Optional element 'gmd:toneGradation' of XML schema type 'gco:Integer_PropertyType'
        gco__Integer_x005fPropertyType *toneGradation;
        /// Optional element 'gmd:scaleFactor' of XML schema type 'gco:Real_PropertyType'
        gco__Real_x005fPropertyType *scaleFactor;
        /// Optional element 'gmd:offset' of XML schema type 'gco:Real_PropertyType'
        gco__Real_x005fPropertyType *offset;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fBand_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fBand_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fBand_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fBand_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fBand_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fBand_x005fType() : maxValue(), minValue(), units(), peakResponse(), bitsPerValue(), toneGradation(), scaleFactor(), offset() { }
        virtual ~gmd__MD_x005fBand_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fBand_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fBand_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fBand_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1820 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fConformanceResult_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fConformanceResult_x005fType (-561)
/* complex XML schema type 'gmd:DQ_ConformanceResult_Type': */
class SOAP_CMAC gmd__DQ_x005fConformanceResult_x005fType : public gmd__AbstractDQ_x005fResult_x005fType {
      public:
        /// Required element 'gmd:specification' of XML schema type 'gmd:CI_Citation_PropertyType'
        gmd__CI_x005fCitation_x005fPropertyType *specification;
        /// Required element 'gmd:explanation' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *explanation;
        /// Required element 'gmd:pass' of XML schema type 'gco:Boolean_PropertyType'
        gco__Boolean_x005fPropertyType *pass;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fConformanceResult_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fConformanceResult_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fConformanceResult_x005fType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fConformanceResult_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fConformanceResult_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fConformanceResult_x005fType() : specification(), explanation(), pass() { }
        virtual ~gmd__DQ_x005fConformanceResult_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fConformanceResult_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fConformanceResult_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fConformanceResult_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1826 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeResult_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeResult_x005fType (-563)
/* complex XML schema type 'gmd:DQ_QuantitativeResult_Type': */
class SOAP_CMAC gmd__DQ_x005fQuantitativeResult_x005fType : public gmd__AbstractDQ_x005fResult_x005fType {
      public:
        /// Optional element 'gmd:valueType' of XML schema type 'gco:RecordType_PropertyType'
        gco__RecordType_x005fPropertyType *valueType;
        /// Required element 'gmd:valueUnit' of XML schema type 'gco:UnitOfMeasure_PropertyType'
        gco__UnitOfMeasure_x005fPropertyType *valueUnit;
        /// Optional element 'gmd:errorStatistic' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *errorStatistic;
        /// Required element 'gmd:value' of XML schema type 'gco:Record_PropertyType'
        std::vector<gco__Record_x005fPropertyType *> value;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeResult_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeResult_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fQuantitativeResult_x005fType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fQuantitativeResult_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fQuantitativeResult_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fQuantitativeResult_x005fType() : valueType(), valueUnit(), errorStatistic(), value() { }
        virtual ~gmd__DQ_x005fQuantitativeResult_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fQuantitativeResult_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fQuantitativeResult_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fQuantitativeResult_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1928 */
#ifndef SOAP_TYPE_plu_gmd__AbstractDQ_x005fTemporalAccuracy_x005fType
#define SOAP_TYPE_plu_gmd__AbstractDQ_x005fTemporalAccuracy_x005fType (-597)
/* complex XML schema type 'gmd:AbstractDQ_TemporalAccuracy_Type': */
class SOAP_CMAC gmd__AbstractDQ_x005fTemporalAccuracy_x005fType : public gmd__AbstractDQ_x005fElement_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__AbstractDQ_x005fTemporalAccuracy_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__AbstractDQ_x005fTemporalAccuracy_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__AbstractDQ_x005fTemporalAccuracy_x005fType, default initialized and not managed by a soap context
        virtual gmd__AbstractDQ_x005fTemporalAccuracy_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__AbstractDQ_x005fTemporalAccuracy_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__AbstractDQ_x005fTemporalAccuracy_x005fType() { }
        virtual ~gmd__AbstractDQ_x005fTemporalAccuracy_x005fType() { }
        /// Friend allocator used by soap_new_gmd__AbstractDQ_x005fTemporalAccuracy_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__AbstractDQ_x005fTemporalAccuracy_x005fType * SOAP_FMAC2 soap_instantiate_gmd__AbstractDQ_x005fTemporalAccuracy_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1934 */
#ifndef SOAP_TYPE_plu_gmd__AbstractDQ_x005fThematicAccuracy_x005fType
#define SOAP_TYPE_plu_gmd__AbstractDQ_x005fThematicAccuracy_x005fType (-599)
/* complex XML schema type 'gmd:AbstractDQ_ThematicAccuracy_Type': */
class SOAP_CMAC gmd__AbstractDQ_x005fThematicAccuracy_x005fType : public gmd__AbstractDQ_x005fElement_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__AbstractDQ_x005fThematicAccuracy_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__AbstractDQ_x005fThematicAccuracy_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__AbstractDQ_x005fThematicAccuracy_x005fType, default initialized and not managed by a soap context
        virtual gmd__AbstractDQ_x005fThematicAccuracy_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__AbstractDQ_x005fThematicAccuracy_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__AbstractDQ_x005fThematicAccuracy_x005fType() { }
        virtual ~gmd__AbstractDQ_x005fThematicAccuracy_x005fType() { }
        /// Friend allocator used by soap_new_gmd__AbstractDQ_x005fThematicAccuracy_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__AbstractDQ_x005fThematicAccuracy_x005fType * SOAP_FMAC2 soap_instantiate_gmd__AbstractDQ_x005fThematicAccuracy_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1940 */
#ifndef SOAP_TYPE_plu_gmd__AbstractDQ_x005fPositionalAccuracy_x005fType
#define SOAP_TYPE_plu_gmd__AbstractDQ_x005fPositionalAccuracy_x005fType (-601)
/* complex XML schema type 'gmd:AbstractDQ_PositionalAccuracy_Type': */
class SOAP_CMAC gmd__AbstractDQ_x005fPositionalAccuracy_x005fType : public gmd__AbstractDQ_x005fElement_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__AbstractDQ_x005fPositionalAccuracy_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__AbstractDQ_x005fPositionalAccuracy_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__AbstractDQ_x005fPositionalAccuracy_x005fType, default initialized and not managed by a soap context
        virtual gmd__AbstractDQ_x005fPositionalAccuracy_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__AbstractDQ_x005fPositionalAccuracy_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__AbstractDQ_x005fPositionalAccuracy_x005fType() { }
        virtual ~gmd__AbstractDQ_x005fPositionalAccuracy_x005fType() { }
        /// Friend allocator used by soap_new_gmd__AbstractDQ_x005fPositionalAccuracy_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__AbstractDQ_x005fPositionalAccuracy_x005fType * SOAP_FMAC2 soap_instantiate_gmd__AbstractDQ_x005fPositionalAccuracy_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1946 */
#ifndef SOAP_TYPE_plu_gmd__AbstractDQ_x005fLogicalConsistency_x005fType
#define SOAP_TYPE_plu_gmd__AbstractDQ_x005fLogicalConsistency_x005fType (-603)
/* complex XML schema type 'gmd:AbstractDQ_LogicalConsistency_Type': */
class SOAP_CMAC gmd__AbstractDQ_x005fLogicalConsistency_x005fType : public gmd__AbstractDQ_x005fElement_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__AbstractDQ_x005fLogicalConsistency_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__AbstractDQ_x005fLogicalConsistency_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__AbstractDQ_x005fLogicalConsistency_x005fType, default initialized and not managed by a soap context
        virtual gmd__AbstractDQ_x005fLogicalConsistency_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__AbstractDQ_x005fLogicalConsistency_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__AbstractDQ_x005fLogicalConsistency_x005fType() { }
        virtual ~gmd__AbstractDQ_x005fLogicalConsistency_x005fType() { }
        /// Friend allocator used by soap_new_gmd__AbstractDQ_x005fLogicalConsistency_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__AbstractDQ_x005fLogicalConsistency_x005fType * SOAP_FMAC2 soap_instantiate_gmd__AbstractDQ_x005fLogicalConsistency_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1952 */
#ifndef SOAP_TYPE_plu_gmd__AbstractDQ_x005fCompleteness_x005fType
#define SOAP_TYPE_plu_gmd__AbstractDQ_x005fCompleteness_x005fType (-605)
/* complex XML schema type 'gmd:AbstractDQ_Completeness_Type': */
class SOAP_CMAC gmd__AbstractDQ_x005fCompleteness_x005fType : public gmd__AbstractDQ_x005fElement_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__AbstractDQ_x005fCompleteness_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__AbstractDQ_x005fCompleteness_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__AbstractDQ_x005fCompleteness_x005fType, default initialized and not managed by a soap context
        virtual gmd__AbstractDQ_x005fCompleteness_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__AbstractDQ_x005fCompleteness_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__AbstractDQ_x005fCompleteness_x005fType() { }
        virtual ~gmd__AbstractDQ_x005fCompleteness_x005fType() { }
        /// Friend allocator used by soap_new_gmd__AbstractDQ_x005fCompleteness_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__AbstractDQ_x005fCompleteness_x005fType * SOAP_FMAC2 soap_instantiate_gmd__AbstractDQ_x005fCompleteness_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1991 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDataIdentification_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fDataIdentification_x005fType (-618)
/* complex XML schema type 'gmd:MD_DataIdentification_Type': */
class SOAP_CMAC gmd__MD_x005fDataIdentification_x005fType : public gmd__AbstractMD_x005fIdentification_x005fType {
      public:
        /// Optional element 'gmd:spatialRepresentationType' of XML schema type 'gmd:MD_SpatialRepresentationTypeCode_PropertyType'
        std::vector<gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType *> spatialRepresentationType;
        /// Optional element 'gmd:spatialResolution' of XML schema type 'gmd:MD_Resolution_PropertyType'
        std::vector<gmd__MD_x005fResolution_x005fPropertyType *> spatialResolution;
        /// Required element 'gmd:language' of XML schema type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_x005fPropertyType *> language;
        /// Optional element 'gmd:characterSet' of XML schema type 'gmd:MD_CharacterSetCode_PropertyType'
        std::vector<gmd__MD_x005fCharacterSetCode_x005fPropertyType *> characterSet;
        /// Optional element 'gmd:topicCategory' of XML schema type 'gmd:MD_TopicCategoryCode_PropertyType'
        std::vector<gmd__MD_x005fTopicCategoryCode_x005fPropertyType *> topicCategory;
        /// Optional element 'gmd:environmentDescription' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *environmentDescription;
        /// Optional element 'gmd:extent' of XML schema type 'gmd:EX_Extent_PropertyType'
        std::vector<gmd__EX_x005fExtent_x005fPropertyType *> extent;
        /// Optional element 'gmd:supplementalInformation' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *supplementalInformation;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fDataIdentification_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fDataIdentification_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fDataIdentification_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fDataIdentification_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fDataIdentification_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fDataIdentification_x005fType() : spatialRepresentationType(), spatialResolution(), language(), characterSet(), topicCategory(), environmentDescription(), extent(), supplementalInformation() { }
        virtual ~gmd__MD_x005fDataIdentification_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fDataIdentification_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fDataIdentification_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fDataIdentification_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1997 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fServiceIdentification_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fServiceIdentification_x005fType (-620)
/* complex XML schema type 'gmd:MD_ServiceIdentification_Type': */
class SOAP_CMAC gmd__MD_x005fServiceIdentification_x005fType : public gmd__AbstractMD_x005fIdentification_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fServiceIdentification_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fServiceIdentification_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fServiceIdentification_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fServiceIdentification_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fServiceIdentification_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fServiceIdentification_x005fType() { }
        virtual ~gmd__MD_x005fServiceIdentification_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fServiceIdentification_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fServiceIdentification_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fServiceIdentification_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2066 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fLegalConstraints_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fLegalConstraints_x005fType (-643)
/* complex XML schema type 'gmd:MD_LegalConstraints_Type': */
class SOAP_CMAC gmd__MD_x005fLegalConstraints_x005fType : public gmd__MD_x005fConstraints_x005fType {
      public:
        /// Optional element 'gmd:accessConstraints' of XML schema type 'gmd:MD_RestrictionCode_PropertyType'
        std::vector<gmd__MD_x005fRestrictionCode_x005fPropertyType *> accessConstraints;
        /// Optional element 'gmd:useConstraints' of XML schema type 'gmd:MD_RestrictionCode_PropertyType'
        std::vector<gmd__MD_x005fRestrictionCode_x005fPropertyType *> useConstraints;
        /// Optional element 'gmd:otherConstraints' of XML schema type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_x005fPropertyType *> otherConstraints;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fLegalConstraints_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fLegalConstraints_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fLegalConstraints_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fLegalConstraints_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fLegalConstraints_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fLegalConstraints_x005fType() : accessConstraints(), useConstraints(), otherConstraints() { }
        virtual ~gmd__MD_x005fLegalConstraints_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fLegalConstraints_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fLegalConstraints_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fLegalConstraints_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:2072 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fSecurityConstraints_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fSecurityConstraints_x005fType (-645)
/* complex XML schema type 'gmd:MD_SecurityConstraints_Type': */
class SOAP_CMAC gmd__MD_x005fSecurityConstraints_x005fType : public gmd__MD_x005fConstraints_x005fType {
      public:
        /// Required element 'gmd:classification' of XML schema type 'gmd:MD_ClassificationCode_PropertyType'
        gmd__MD_x005fClassificationCode_x005fPropertyType *classification;
        /// Optional element 'gmd:userNote' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *userNote;
        /// Optional element 'gmd:classificationSystem' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *classificationSystem;
        /// Optional element 'gmd:handlingDescription' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *handlingDescription;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fSecurityConstraints_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fSecurityConstraints_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fSecurityConstraints_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fSecurityConstraints_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fSecurityConstraints_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fSecurityConstraints_x005fType() : classification(), userNote(), classificationSystem(), handlingDescription() { }
        virtual ~gmd__MD_x005fSecurityConstraints_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fSecurityConstraints_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fSecurityConstraints_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fSecurityConstraints_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:446 */
#ifndef SOAP_TYPE_plu_gml__DynamicFeatureCollectionType
#define SOAP_TYPE_plu_gml__DynamicFeatureCollectionType (-103)
/* complex XML schema type 'gml:DynamicFeatureCollectionType': */
class SOAP_CMAC gml__DynamicFeatureCollectionType : public gml__DynamicFeatureType {
      public:
        /// Required element 'gml:dynamicMembers' of XML schema type 'gml:DynamicFeatureMemberType'
        gml__DynamicFeatureMemberType *dynamicMembers;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DynamicFeatureCollectionType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DynamicFeatureCollectionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DynamicFeatureCollectionType, default initialized and not managed by a soap context
        virtual gml__DynamicFeatureCollectionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DynamicFeatureCollectionType); }
      public:
        /// Constructor with default initializations
        gml__DynamicFeatureCollectionType() : dynamicMembers() { }
        virtual ~gml__DynamicFeatureCollectionType() { }
        /// Friend allocator used by soap_new_gml__DynamicFeatureCollectionType(struct soap*, int)
        friend SOAP_FMAC1 gml__DynamicFeatureCollectionType * SOAP_FMAC2 soap_instantiate_gml__DynamicFeatureCollectionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:476 */
#ifndef SOAP_TYPE_plu_gml__NodeType
#define SOAP_TYPE_plu_gml__NodeType (-113)
/* Type gml__NodeType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gml:NodeType': */
class SOAP_CMAC gml__NodeType : public gml__AbstractTopoPrimitiveType {
      public:
        /// Optional element 'gml:container' of XML schema type 'gml:FaceOrTopoSolidPropertyType'
        gml__FaceOrTopoSolidPropertyType *container;
        /// Optional element 'gml:directedEdge' of XML schema type 'gml:DirectedEdgePropertyType'
        std::vector<gml__DirectedEdgePropertyType *> directedEdge;
        /// Optional element 'gml:pointProperty' of XML schema type 'gml:PointPropertyType'
        gml__PointPropertyType *pointProperty;
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__NodeType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__NodeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__NodeType, default initialized and not managed by a soap context
        virtual gml__NodeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__NodeType); }
      public:
        /// Constructor with default initializations
        gml__NodeType() : container(), directedEdge(), pointProperty(), aggregationType() { }
        virtual ~gml__NodeType() { }
        /// Friend allocator used by soap_new_gml__NodeType(struct soap*, int)
        friend SOAP_FMAC1 gml__NodeType * SOAP_FMAC2 soap_instantiate_gml__NodeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:482 */
#ifndef SOAP_TYPE_plu_gml__EdgeType
#define SOAP_TYPE_plu_gml__EdgeType (-115)
/* Type gml__EdgeType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gml:EdgeType': */
class SOAP_CMAC gml__EdgeType : public gml__AbstractTopoPrimitiveType {
      public:
        /// Optional element 'gml:container' of XML schema type 'gml:TopoSolidPropertyType'
        gml__TopoSolidPropertyType *container;
        /// Sequence of 2 to 2 elements 'gml:directedNode' of XML schema type 'gml:DirectedNodePropertyType'
        std::vector<gml__DirectedNodePropertyType *> directedNode;
        /// Optional element 'gml:directedFace' of XML schema type 'gml:DirectedFacePropertyType'
        std::vector<gml__DirectedFacePropertyType *> directedFace;
        /// Optional element 'gml:curveProperty' of XML schema type 'gml:CurvePropertyType'
        gml__CurvePropertyType *curveProperty;
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__EdgeType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__EdgeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__EdgeType, default initialized and not managed by a soap context
        virtual gml__EdgeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__EdgeType); }
      public:
        /// Constructor with default initializations
        gml__EdgeType() : container(), directedNode(), directedFace(), curveProperty(), aggregationType() { }
        virtual ~gml__EdgeType() { }
        /// Friend allocator used by soap_new_gml__EdgeType(struct soap*, int)
        friend SOAP_FMAC1 gml__EdgeType * SOAP_FMAC2 soap_instantiate_gml__EdgeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:488 */
#ifndef SOAP_TYPE_plu_gml__FaceType
#define SOAP_TYPE_plu_gml__FaceType (-117)
/* Type gml__FaceType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gml:FaceType': */
class SOAP_CMAC gml__FaceType : public gml__AbstractTopoPrimitiveType {
      public:
        /// Optional element 'gml:isolated' of XML schema type 'gml:NodePropertyType'
        std::vector<gml__NodePropertyType *> isolated;
        /// Required element 'gml:directedEdge' of XML schema type 'gml:DirectedEdgePropertyType'
        std::vector<gml__DirectedEdgePropertyType *> directedEdge;
        /// Sequence of 0 to 2 elements 'gml:directedTopoSolid' of XML schema type 'gml:DirectedTopoSolidPropertyType'
        std::vector<gml__DirectedTopoSolidPropertyType *> directedTopoSolid;
        /// Optional element 'gml:surfaceProperty' of XML schema type 'gml:SurfacePropertyType'
        gml__SurfacePropertyType *surfaceProperty;
        /// Optional attribute 'universal' of XML schema type 'xsd:boolean'
        bool universal;	///< initialized with default value = (bool)0
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__FaceType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__FaceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__FaceType, default initialized and not managed by a soap context
        virtual gml__FaceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__FaceType); }
      public:
        /// Constructor with default initializations
        gml__FaceType() : isolated(), directedEdge(), directedTopoSolid(), surfaceProperty(), universal((bool)0), aggregationType() { }
        virtual ~gml__FaceType() { }
        /// Friend allocator used by soap_new_gml__FaceType(struct soap*, int)
        friend SOAP_FMAC1 gml__FaceType * SOAP_FMAC2 soap_instantiate_gml__FaceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:494 */
#ifndef SOAP_TYPE_plu_gml__TopoSolidType
#define SOAP_TYPE_plu_gml__TopoSolidType (-119)
/* complex XML schema type 'gml:TopoSolidType': */
class SOAP_CMAC gml__TopoSolidType : public gml__AbstractTopoPrimitiveType {
      public:
        /// Optional element 'gml:isolated' of XML schema type 'gml:NodeOrEdgePropertyType'
        std::vector<gml__NodeOrEdgePropertyType *> isolated;
        /// Required element 'gml:directedFace' of XML schema type 'gml:DirectedFacePropertyType'
        std::vector<gml__DirectedFacePropertyType *> directedFace;
        /// Optional element 'gml:solidProperty' of XML schema type 'gml:SolidPropertyType'
        gml__SolidPropertyType *solidProperty;
        /// Optional attribute 'universal' of XML schema type 'xsd:boolean'
        bool universal;	///< initialized with default value = (bool)0
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TopoSolidType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TopoSolidType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TopoSolidType, default initialized and not managed by a soap context
        virtual gml__TopoSolidType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TopoSolidType); }
      public:
        /// Constructor with default initializations
        gml__TopoSolidType() : isolated(), directedFace(), solidProperty(), universal((bool)0), aggregationType() { }
        virtual ~gml__TopoSolidType() { }
        /// Friend allocator used by soap_new_gml__TopoSolidType(struct soap*, int)
        friend SOAP_FMAC1 gml__TopoSolidType * SOAP_FMAC2 soap_instantiate_gml__TopoSolidType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:554 */
#ifndef SOAP_TYPE_plu_gml__MultiGeometryType
#define SOAP_TYPE_plu_gml__MultiGeometryType (-139)
/* complex XML schema type 'gml:MultiGeometryType': */
class SOAP_CMAC gml__MultiGeometryType : public gml__AbstractGeometricAggregateType {
      public:
        /// Optional element 'gml:geometryMember' of XML schema type 'gml:GeometryPropertyType'
        std::vector<gml__GeometryPropertyType *> geometryMember;
        /// Optional element 'gml:geometryMembers' of XML schema type 'gml:GeometryArrayPropertyType'
        gml__GeometryArrayPropertyType *geometryMembers;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__MultiGeometryType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__MultiGeometryType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__MultiGeometryType, default initialized and not managed by a soap context
        virtual gml__MultiGeometryType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__MultiGeometryType); }
      public:
        /// Constructor with default initializations
        gml__MultiGeometryType() : geometryMember(), geometryMembers() { }
        virtual ~gml__MultiGeometryType() { }
        /// Friend allocator used by soap_new_gml__MultiGeometryType(struct soap*, int)
        friend SOAP_FMAC1 gml__MultiGeometryType * SOAP_FMAC2 soap_instantiate_gml__MultiGeometryType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:560 */
#ifndef SOAP_TYPE_plu_gml__MultiPointType
#define SOAP_TYPE_plu_gml__MultiPointType (-141)
/* complex XML schema type 'gml:MultiPointType': */
class SOAP_CMAC gml__MultiPointType : public gml__AbstractGeometricAggregateType {
      public:
        /// Optional element 'gml:pointMember' of XML schema type 'gml:PointPropertyType'
        std::vector<gml__PointPropertyType *> pointMember;
        /// Optional element 'gml:pointMembers' of XML schema type 'gml:PointArrayPropertyType'
        gml__PointArrayPropertyType *pointMembers;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__MultiPointType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__MultiPointType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__MultiPointType, default initialized and not managed by a soap context
        virtual gml__MultiPointType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__MultiPointType); }
      public:
        /// Constructor with default initializations
        gml__MultiPointType() : pointMember(), pointMembers() { }
        virtual ~gml__MultiPointType() { }
        /// Friend allocator used by soap_new_gml__MultiPointType(struct soap*, int)
        friend SOAP_FMAC1 gml__MultiPointType * SOAP_FMAC2 soap_instantiate_gml__MultiPointType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:566 */
#ifndef SOAP_TYPE_plu_gml__MultiCurveType
#define SOAP_TYPE_plu_gml__MultiCurveType (-143)
/* complex XML schema type 'gml:MultiCurveType': */
class SOAP_CMAC gml__MultiCurveType : public gml__AbstractGeometricAggregateType {
      public:
        /// Optional element 'gml:curveMember' of XML schema type 'gml:CurvePropertyType'
        std::vector<gml__CurvePropertyType *> curveMember;
        /// Optional element 'gml:curveMembers' of XML schema type 'gml:CurveArrayPropertyType'
        gml__CurveArrayPropertyType *curveMembers;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__MultiCurveType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__MultiCurveType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__MultiCurveType, default initialized and not managed by a soap context
        virtual gml__MultiCurveType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__MultiCurveType); }
      public:
        /// Constructor with default initializations
        gml__MultiCurveType() : curveMember(), curveMembers() { }
        virtual ~gml__MultiCurveType() { }
        /// Friend allocator used by soap_new_gml__MultiCurveType(struct soap*, int)
        friend SOAP_FMAC1 gml__MultiCurveType * SOAP_FMAC2 soap_instantiate_gml__MultiCurveType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:572 */
#ifndef SOAP_TYPE_plu_gml__MultiSurfaceType
#define SOAP_TYPE_plu_gml__MultiSurfaceType (-145)
/* complex XML schema type 'gml:MultiSurfaceType': */
class SOAP_CMAC gml__MultiSurfaceType : public gml__AbstractGeometricAggregateType {
      public:
        /// Optional element 'gml:surfaceMember' of XML schema type 'gml:SurfacePropertyType'
        std::vector<gml__SurfacePropertyType *> surfaceMember;
        /// Optional element 'gml:surfaceMembers' of XML schema type 'gml:SurfaceArrayPropertyType'
        gml__SurfaceArrayPropertyType *surfaceMembers;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__MultiSurfaceType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__MultiSurfaceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__MultiSurfaceType, default initialized and not managed by a soap context
        virtual gml__MultiSurfaceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__MultiSurfaceType); }
      public:
        /// Constructor with default initializations
        gml__MultiSurfaceType() : surfaceMember(), surfaceMembers() { }
        virtual ~gml__MultiSurfaceType() { }
        /// Friend allocator used by soap_new_gml__MultiSurfaceType(struct soap*, int)
        friend SOAP_FMAC1 gml__MultiSurfaceType * SOAP_FMAC2 soap_instantiate_gml__MultiSurfaceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:578 */
#ifndef SOAP_TYPE_plu_gml__MultiSolidType
#define SOAP_TYPE_plu_gml__MultiSolidType (-147)
/* complex XML schema type 'gml:MultiSolidType': */
class SOAP_CMAC gml__MultiSolidType : public gml__AbstractGeometricAggregateType {
      public:
        /// Optional element 'gml:solidMember' of XML schema type 'gml:SolidPropertyType'
        std::vector<gml__SolidPropertyType *> solidMember;
        /// Optional element 'gml:solidMembers' of XML schema type 'gml:SolidArrayPropertyType'
        gml__SolidArrayPropertyType *solidMembers;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__MultiSolidType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__MultiSolidType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__MultiSolidType, default initialized and not managed by a soap context
        virtual gml__MultiSolidType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__MultiSolidType); }
      public:
        /// Constructor with default initializations
        gml__MultiSolidType() : solidMember(), solidMembers() { }
        virtual ~gml__MultiSolidType() { }
        /// Friend allocator used by soap_new_gml__MultiSolidType(struct soap*, int)
        friend SOAP_FMAC1 gml__MultiSolidType * SOAP_FMAC2 soap_instantiate_gml__MultiSolidType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:605 */
#ifndef SOAP_TYPE_plu_gml__CircleType
#define SOAP_TYPE_plu_gml__CircleType (-156)
/* complex XML schema type 'gml:CircleType': */
class SOAP_CMAC gml__CircleType : public gml__ArcType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CircleType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CircleType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CircleType, default initialized and not managed by a soap context
        virtual gml__CircleType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CircleType); }
      public:
        /// Constructor with default initializations
        gml__CircleType() { }
        virtual ~gml__CircleType() { }
        /// Friend allocator used by soap_new_gml__CircleType(struct soap*, int)
        friend SOAP_FMAC1 gml__CircleType * SOAP_FMAC2 soap_instantiate_gml__CircleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:683 */
#ifndef SOAP_TYPE_plu_gml__ConeType
#define SOAP_TYPE_plu_gml__ConeType (-182)
/* complex XML schema type 'gml:ConeType': */
class SOAP_CMAC gml__ConeType : public gml__AbstractGriddedSurfaceType {
      public:
        /// Optional attribute 'horizontalCurveType' of XML schema type 'gml:CurveInterpolationType'
        enum gml__CurveInterpolationType *horizontalCurveType;
        /// Optional attribute 'verticalCurveType' of XML schema type 'gml:CurveInterpolationType'
        enum gml__CurveInterpolationType *verticalCurveType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ConeType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ConeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ConeType, default initialized and not managed by a soap context
        virtual gml__ConeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ConeType); }
      public:
        /// Constructor with default initializations
        gml__ConeType() : horizontalCurveType(), verticalCurveType() { }
        virtual ~gml__ConeType() { }
        /// Friend allocator used by soap_new_gml__ConeType(struct soap*, int)
        friend SOAP_FMAC1 gml__ConeType * SOAP_FMAC2 soap_instantiate_gml__ConeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:686 */
#ifndef SOAP_TYPE_plu_gml__CylinderType
#define SOAP_TYPE_plu_gml__CylinderType (-183)
/* complex XML schema type 'gml:CylinderType': */
class SOAP_CMAC gml__CylinderType : public gml__AbstractGriddedSurfaceType {
      public:
        /// Optional attribute 'horizontalCurveType' of XML schema type 'gml:CurveInterpolationType'
        enum gml__CurveInterpolationType *horizontalCurveType;
        /// Optional attribute 'verticalCurveType' of XML schema type 'gml:CurveInterpolationType'
        enum gml__CurveInterpolationType *verticalCurveType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CylinderType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CylinderType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CylinderType, default initialized and not managed by a soap context
        virtual gml__CylinderType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CylinderType); }
      public:
        /// Constructor with default initializations
        gml__CylinderType() : horizontalCurveType(), verticalCurveType() { }
        virtual ~gml__CylinderType() { }
        /// Friend allocator used by soap_new_gml__CylinderType(struct soap*, int)
        friend SOAP_FMAC1 gml__CylinderType * SOAP_FMAC2 soap_instantiate_gml__CylinderType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:689 */
#ifndef SOAP_TYPE_plu_gml__SphereType
#define SOAP_TYPE_plu_gml__SphereType (-184)
/* complex XML schema type 'gml:SphereType': */
class SOAP_CMAC gml__SphereType : public gml__AbstractGriddedSurfaceType {
      public:
        /// Optional attribute 'horizontalCurveType' of XML schema type 'gml:CurveInterpolationType'
        enum gml__CurveInterpolationType *horizontalCurveType;
        /// Optional attribute 'verticalCurveType' of XML schema type 'gml:CurveInterpolationType'
        enum gml__CurveInterpolationType *verticalCurveType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__SphereType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__SphereType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SphereType, default initialized and not managed by a soap context
        virtual gml__SphereType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__SphereType); }
      public:
        /// Constructor with default initializations
        gml__SphereType() : horizontalCurveType(), verticalCurveType() { }
        virtual ~gml__SphereType() { }
        /// Friend allocator used by soap_new_gml__SphereType(struct soap*, int)
        friend SOAP_FMAC1 gml__SphereType * SOAP_FMAC2 soap_instantiate_gml__SphereType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:698 */
#ifndef SOAP_TYPE_plu_gml__AbstractSolidType
#define SOAP_TYPE_plu_gml__AbstractSolidType (-187)
/* complex XML schema type 'gml:AbstractSolidType': */
class SOAP_CMAC gml__AbstractSolidType : public gml__AbstractGeometricPrimitiveType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractSolidType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractSolidType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractSolidType, default initialized and not managed by a soap context
        virtual gml__AbstractSolidType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractSolidType); }
      public:
        /// Constructor with default initializations
        gml__AbstractSolidType() { }
        virtual ~gml__AbstractSolidType() { }
        /// Friend allocator used by soap_new_gml__AbstractSolidType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractSolidType * SOAP_FMAC2 soap_instantiate_gml__AbstractSolidType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:716 */
#ifndef SOAP_TYPE_plu_gml__AbstractSurfaceType
#define SOAP_TYPE_plu_gml__AbstractSurfaceType (-193)
/* complex XML schema type 'gml:AbstractSurfaceType': */
class SOAP_CMAC gml__AbstractSurfaceType : public gml__AbstractGeometricPrimitiveType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractSurfaceType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractSurfaceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractSurfaceType, default initialized and not managed by a soap context
        virtual gml__AbstractSurfaceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractSurfaceType); }
      public:
        /// Constructor with default initializations
        gml__AbstractSurfaceType() { }
        virtual ~gml__AbstractSurfaceType() { }
        /// Friend allocator used by soap_new_gml__AbstractSurfaceType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractSurfaceType * SOAP_FMAC2 soap_instantiate_gml__AbstractSurfaceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:31704 */
#ifndef SOAP_TYPE_plu__gml__union_PointType
#define SOAP_TYPE_plu__gml__union_PointType (-2228)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_PointType
{
        #define SOAP_UNION_plu__gml__union_PointType_pos	(1)	/**< union variant selector value for member pos */
        gml__DirectPositionType *pos;
        #define SOAP_UNION_plu__gml__union_PointType_coordinates	(2)	/**< union variant selector value for member coordinates */
        gml__CoordinatesType *coordinates;
};
#endif

/* PlannedLandUse_v3.0.h:767 */
#ifndef SOAP_TYPE_plu_gml__PointType
#define SOAP_TYPE_plu_gml__PointType (-210)
/* complex XML schema type 'gml:PointType': */
class SOAP_CMAC gml__PointType : public gml__AbstractGeometricPrimitiveType {
      public:
        /// Union with union _gml__union_PointType variant selector __union_PointType set to one of: SOAP_UNION_plu__gml__union_PointType_pos SOAP_UNION_plu__gml__union_PointType_coordinates
        int __union_PointType;
        union _gml__union_PointType union_PointType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__PointType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__PointType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__PointType, default initialized and not managed by a soap context
        virtual gml__PointType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__PointType); }
      public:
        /// Constructor with default initializations
        gml__PointType() : __union_PointType() { }
        virtual ~gml__PointType() { }
        /// Friend allocator used by soap_new_gml__PointType(struct soap*, int)
        friend SOAP_FMAC1 gml__PointType * SOAP_FMAC2 soap_instantiate_gml__PointType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:776 */
#ifndef SOAP_TYPE_plu_gml__AbstractCurveType
#define SOAP_TYPE_plu_gml__AbstractCurveType (-213)
/* complex XML schema type 'gml:AbstractCurveType': */
class SOAP_CMAC gml__AbstractCurveType : public gml__AbstractGeometricPrimitiveType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractCurveType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractCurveType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractCurveType, default initialized and not managed by a soap context
        virtual gml__AbstractCurveType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractCurveType); }
      public:
        /// Constructor with default initializations
        gml__AbstractCurveType() { }
        virtual ~gml__AbstractCurveType() { }
        /// Friend allocator used by soap_new_gml__AbstractCurveType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractCurveType * SOAP_FMAC2 soap_instantiate_gml__AbstractCurveType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:815 */
#ifndef SOAP_TYPE_plu_gml__UnitDefinitionType
#define SOAP_TYPE_plu_gml__UnitDefinitionType (-226)
/* complex XML schema type 'gml:UnitDefinitionType': */
class SOAP_CMAC gml__UnitDefinitionType : public gml__DefinitionType {
      public:
        /// Optional element 'gml:quantityType' of XML schema type 'gml:StringOrRefType'
        gml__StringOrRefType *quantityType;
        /// Optional element 'gml:quantityTypeReference' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *quantityTypeReference;
        /// Optional element 'gml:catalogSymbol' of XML schema type 'gml:CodeType'
        gml__CodeType *catalogSymbol;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__UnitDefinitionType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__UnitDefinitionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__UnitDefinitionType, default initialized and not managed by a soap context
        virtual gml__UnitDefinitionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__UnitDefinitionType); }
      public:
        /// Constructor with default initializations
        gml__UnitDefinitionType() : quantityType(), quantityTypeReference(), catalogSymbol() { }
        virtual ~gml__UnitDefinitionType() { }
        /// Friend allocator used by soap_new_gml__UnitDefinitionType(struct soap*, int)
        friend SOAP_FMAC1 gml__UnitDefinitionType * SOAP_FMAC2 soap_instantiate_gml__UnitDefinitionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:31845 */
#ifndef SOAP_TYPE_plu__gml__union_DictionaryType
#define SOAP_TYPE_plu__gml__union_DictionaryType (-2230)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_DictionaryType
{
        #define SOAP_UNION_plu__gml__union_DictionaryType_dictionaryEntry	(1)	/**< union variant selector value for member dictionaryEntry */
        gml__DictionaryEntryType *dictionaryEntry;
        #define SOAP_UNION_plu__gml__union_DictionaryType_definitionMember	(2)	/**< union variant selector value for member definitionMember */
        gml__DictionaryEntryType *definitionMember;
        #define SOAP_UNION_plu__gml__union_DictionaryType_indirectEntry	(3)	/**< union variant selector value for member indirectEntry */
        gml__IndirectEntryType *indirectEntry;
};
#endif

/* PlannedLandUse_v3.0.h:31840 */
#ifndef SOAP_TYPE_plu___gml__union_DictionaryType
#define SOAP_TYPE_plu___gml__union_DictionaryType (-2229)
/* Type __gml__union_DictionaryType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* Wrapper: */
class SOAP_CMAC __gml__union_DictionaryType {
      public:
        /// Union with union _gml__union_DictionaryType variant selector __union_DictionaryType set to one of: SOAP_UNION_plu__gml__union_DictionaryType_dictionaryEntry SOAP_UNION_plu__gml__union_DictionaryType_definitionMember SOAP_UNION_plu__gml__union_DictionaryType_indirectEntry
        int __union_DictionaryType;
        union _gml__union_DictionaryType union_DictionaryType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_DictionaryType
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_DictionaryType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_DictionaryType, default initialized and not managed by a soap context
        virtual __gml__union_DictionaryType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_DictionaryType); }
      public:
        /// Constructor with default initializations
        __gml__union_DictionaryType() : __union_DictionaryType() { }
        virtual ~__gml__union_DictionaryType() { }
        /// Friend allocator used by soap_new___gml__union_DictionaryType(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_DictionaryType * SOAP_FMAC2 soap_instantiate___gml__union_DictionaryType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:842 */
#ifndef SOAP_TYPE_plu_gml__DictionaryType
#define SOAP_TYPE_plu_gml__DictionaryType (-235)
/* complex XML schema type 'gml:DictionaryType': */
class SOAP_CMAC gml__DictionaryType : public gml__DefinitionType {
      public:
        /// Sequence of elements '-union-DictionaryType' of XML schema type '-gml:union-DictionaryType' stored in dynamic array __union_DictionaryType of length __size_DictionaryType
        int __size_DictionaryType;
        __gml__union_DictionaryType *__union_DictionaryType;
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DictionaryType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DictionaryType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DictionaryType, default initialized and not managed by a soap context
        virtual gml__DictionaryType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DictionaryType); }
      public:
        /// Constructor with default initializations
        gml__DictionaryType() : __size_DictionaryType(), __union_DictionaryType(), aggregationType() { }
        virtual ~gml__DictionaryType() { }
        /// Friend allocator used by soap_new_gml__DictionaryType(struct soap*, int)
        friend SOAP_FMAC1 gml__DictionaryType * SOAP_FMAC2 soap_instantiate_gml__DictionaryType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:893 */
#ifndef SOAP_TYPE_plu_gml__DiscreteCoverageType
#define SOAP_TYPE_plu_gml__DiscreteCoverageType (-252)
/* complex XML schema type 'gml:DiscreteCoverageType': */
class SOAP_CMAC gml__DiscreteCoverageType : public gml__AbstractCoverageType {
      public:
        /// Optional element 'gml:coverageFunction' of XML schema type 'gml:CoverageFunctionType'
        gml__CoverageFunctionType *coverageFunction;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DiscreteCoverageType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DiscreteCoverageType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DiscreteCoverageType, default initialized and not managed by a soap context
        virtual gml__DiscreteCoverageType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DiscreteCoverageType); }
      public:
        /// Constructor with default initializations
        gml__DiscreteCoverageType() : coverageFunction() { }
        virtual ~gml__DiscreteCoverageType() { }
        /// Friend allocator used by soap_new_gml__DiscreteCoverageType(struct soap*, int)
        friend SOAP_FMAC1 gml__DiscreteCoverageType * SOAP_FMAC2 soap_instantiate_gml__DiscreteCoverageType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:896 */
#ifndef SOAP_TYPE_plu_gml__AbstractContinuousCoverageType
#define SOAP_TYPE_plu_gml__AbstractContinuousCoverageType (-253)
/* complex XML schema type 'gml:AbstractContinuousCoverageType': */
class SOAP_CMAC gml__AbstractContinuousCoverageType : public gml__AbstractCoverageType {
      public:
        /// Optional element 'gml:coverageFunction' of XML schema type 'gml:CoverageFunctionType'
        gml__CoverageFunctionType *coverageFunction;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractContinuousCoverageType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractContinuousCoverageType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractContinuousCoverageType, default initialized and not managed by a soap context
        virtual gml__AbstractContinuousCoverageType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractContinuousCoverageType); }
      public:
        /// Constructor with default initializations
        gml__AbstractContinuousCoverageType() : coverageFunction() { }
        virtual ~gml__AbstractContinuousCoverageType() { }
        /// Friend allocator used by soap_new_gml__AbstractContinuousCoverageType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractContinuousCoverageType * SOAP_FMAC2 soap_instantiate_gml__AbstractContinuousCoverageType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:953 */
#ifndef SOAP_TYPE_plu_gml__AbstractTimeGeometricPrimitiveType
#define SOAP_TYPE_plu_gml__AbstractTimeGeometricPrimitiveType (-272)
/* complex XML schema type 'gml:AbstractTimeGeometricPrimitiveType': */
class SOAP_CMAC gml__AbstractTimeGeometricPrimitiveType : public gml__AbstractTimePrimitiveType {
      public:
        /// Optional attribute 'frame' of XML schema type 'xsd:anyURI'
        char *frame;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractTimeGeometricPrimitiveType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractTimeGeometricPrimitiveType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractTimeGeometricPrimitiveType, default initialized and not managed by a soap context
        virtual gml__AbstractTimeGeometricPrimitiveType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractTimeGeometricPrimitiveType); }
      public:
        /// Constructor with default initializations
        gml__AbstractTimeGeometricPrimitiveType() : frame() { }
        virtual ~gml__AbstractTimeGeometricPrimitiveType() { }
        /// Friend allocator used by soap_new_gml__AbstractTimeGeometricPrimitiveType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractTimeGeometricPrimitiveType * SOAP_FMAC2 soap_instantiate_gml__AbstractTimeGeometricPrimitiveType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1013 */
#ifndef SOAP_TYPE_plu_gml__RectifiedGridType
#define SOAP_TYPE_plu_gml__RectifiedGridType (-292)
/* complex XML schema type 'gml:RectifiedGridType': */
class SOAP_CMAC gml__RectifiedGridType : public gml__GridType {
      public:
        /// Required element 'gml:origin' of XML schema type 'gml:PointPropertyType'
        gml__PointPropertyType *origin;
        /// Required element 'gml:offsetVector' of XML schema type 'gml:VectorType'
        std::vector<gml__VectorType *> offsetVector;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__RectifiedGridType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__RectifiedGridType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__RectifiedGridType, default initialized and not managed by a soap context
        virtual gml__RectifiedGridType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__RectifiedGridType); }
      public:
        /// Constructor with default initializations
        gml__RectifiedGridType() : origin(), offsetVector() { }
        virtual ~gml__RectifiedGridType() { }
        /// Friend allocator used by soap_new_gml__RectifiedGridType(struct soap*, int)
        friend SOAP_FMAC1 gml__RectifiedGridType * SOAP_FMAC2 soap_instantiate_gml__RectifiedGridType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1142 */
#ifndef SOAP_TYPE_plu_gml__IdentifiedObjectType
#define SOAP_TYPE_plu_gml__IdentifiedObjectType (-335)
/* complex XML schema type 'gml:IdentifiedObjectType': */
class SOAP_CMAC gml__IdentifiedObjectType : public gml__DefinitionType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__IdentifiedObjectType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__IdentifiedObjectType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__IdentifiedObjectType, default initialized and not managed by a soap context
        virtual gml__IdentifiedObjectType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__IdentifiedObjectType); }
      public:
        /// Constructor with default initializations
        gml__IdentifiedObjectType() { }
        virtual ~gml__IdentifiedObjectType() { }
        /// Friend allocator used by soap_new_gml__IdentifiedObjectType(struct soap*, int)
        friend SOAP_FMAC1 gml__IdentifiedObjectType * SOAP_FMAC2 soap_instantiate_gml__IdentifiedObjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1295 */
#ifndef SOAP_TYPE_plu_gml__DirectedObservationType
#define SOAP_TYPE_plu_gml__DirectedObservationType (-386)
/* Type gml__DirectedObservationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gml:DirectedObservationType': */
class SOAP_CMAC gml__DirectedObservationType : public gml__ObservationType {
      public:
        /// Required element 'gml:direction' of XML schema type 'gml:DirectionPropertyType'
        gml__DirectionPropertyType *direction;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DirectedObservationType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DirectedObservationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DirectedObservationType, default initialized and not managed by a soap context
        virtual gml__DirectedObservationType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DirectedObservationType); }
      public:
        /// Constructor with default initializations
        gml__DirectedObservationType() : direction() { }
        virtual ~gml__DirectedObservationType() { }
        /// Friend allocator used by soap_new_gml__DirectedObservationType(struct soap*, int)
        friend SOAP_FMAC1 gml__DirectedObservationType * SOAP_FMAC2 soap_instantiate_gml__DirectedObservationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1310 */
#ifndef SOAP_TYPE_plu_gml__TimeReferenceSystemType
#define SOAP_TYPE_plu_gml__TimeReferenceSystemType (-391)
/* complex XML schema type 'gml:TimeReferenceSystemType': */
class SOAP_CMAC gml__TimeReferenceSystemType : public gml__DefinitionType {
      public:
        /// Required element 'gml:domainOfValidity' of XML schema type 'xsd:string'
        std::string domainOfValidity;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeReferenceSystemType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeReferenceSystemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeReferenceSystemType, default initialized and not managed by a soap context
        virtual gml__TimeReferenceSystemType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeReferenceSystemType); }
      public:
        /// Constructor with default initializations
        gml__TimeReferenceSystemType() : domainOfValidity() { }
        virtual ~gml__TimeReferenceSystemType() { }
        /// Friend allocator used by soap_new_gml__TimeReferenceSystemType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeReferenceSystemType * SOAP_FMAC2 soap_instantiate_gml__TimeReferenceSystemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1319 */
#ifndef SOAP_TYPE_plu_gml__TimeCalendarEraType
#define SOAP_TYPE_plu_gml__TimeCalendarEraType (-394)
/* complex XML schema type 'gml:TimeCalendarEraType': */
class SOAP_CMAC gml__TimeCalendarEraType : public gml__DefinitionType {
      public:
        /// Required element 'gml:referenceEvent' of XML schema type 'gml:StringOrRefType'
        gml__StringOrRefType *referenceEvent;
        /// Required element 'gml:referenceDate' of XML schema type 'gml:CalDate'
        std::string referenceDate;
        /// Required element 'gml:julianReference' of XML schema type 'xsd:decimal'
        double julianReference;
        /// Required element 'gml:epochOfUse' of XML schema type 'gml:TimePeriodPropertyType'
        gml__TimePeriodPropertyType *epochOfUse;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeCalendarEraType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeCalendarEraType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeCalendarEraType, default initialized and not managed by a soap context
        virtual gml__TimeCalendarEraType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeCalendarEraType); }
      public:
        /// Constructor with default initializations
        gml__TimeCalendarEraType() : referenceEvent(), referenceDate(), julianReference(), epochOfUse() { }
        virtual ~gml__TimeCalendarEraType() { }
        /// Friend allocator used by soap_new_gml__TimeCalendarEraType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeCalendarEraType * SOAP_FMAC2 soap_instantiate_gml__TimeCalendarEraType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1337 */
#ifndef SOAP_TYPE_plu_gml__TimeOrdinalEraType
#define SOAP_TYPE_plu_gml__TimeOrdinalEraType (-400)
/* complex XML schema type 'gml:TimeOrdinalEraType': */
class SOAP_CMAC gml__TimeOrdinalEraType : public gml__DefinitionType {
      public:
        /// Optional element 'gml:relatedTime' of XML schema type 'gml:RelatedTimeType'
        std::vector<gml__RelatedTimeType *> relatedTime;
        /// Optional element 'gml:start' of XML schema type 'gml:TimeNodePropertyType'
        gml__TimeNodePropertyType *start;
        /// Optional element 'gml:end' of XML schema type 'gml:TimeNodePropertyType'
        gml__TimeNodePropertyType *end;
        /// Optional element 'gml:extent' of XML schema type 'gml:TimePeriodPropertyType'
        gml__TimePeriodPropertyType *extent;
        /// Optional element 'gml:member' of XML schema type 'gml:TimeOrdinalEraPropertyType'
        std::vector<gml__TimeOrdinalEraPropertyType *> member;
        /// Optional element 'gml:group' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *group;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeOrdinalEraType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeOrdinalEraType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeOrdinalEraType, default initialized and not managed by a soap context
        virtual gml__TimeOrdinalEraType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeOrdinalEraType); }
      public:
        /// Constructor with default initializations
        gml__TimeOrdinalEraType() : relatedTime(), start(), end(), extent(), member(), group() { }
        virtual ~gml__TimeOrdinalEraType() { }
        /// Friend allocator used by soap_new_gml__TimeOrdinalEraType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeOrdinalEraType * SOAP_FMAC2 soap_instantiate_gml__TimeOrdinalEraType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1343 */
#ifndef SOAP_TYPE_plu_gml__AbstractTimeTopologyPrimitiveType
#define SOAP_TYPE_plu_gml__AbstractTimeTopologyPrimitiveType (-402)
/* complex XML schema type 'gml:AbstractTimeTopologyPrimitiveType': */
class SOAP_CMAC gml__AbstractTimeTopologyPrimitiveType : public gml__AbstractTimePrimitiveType {
      public:
        /// Optional element 'gml:complex' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *complex;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractTimeTopologyPrimitiveType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractTimeTopologyPrimitiveType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractTimeTopologyPrimitiveType, default initialized and not managed by a soap context
        virtual gml__AbstractTimeTopologyPrimitiveType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractTimeTopologyPrimitiveType); }
      public:
        /// Constructor with default initializations
        gml__AbstractTimeTopologyPrimitiveType() : complex() { }
        virtual ~gml__AbstractTimeTopologyPrimitiveType() { }
        /// Friend allocator used by soap_new_gml__AbstractTimeTopologyPrimitiveType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractTimeTopologyPrimitiveType * SOAP_FMAC2 soap_instantiate_gml__AbstractTimeTopologyPrimitiveType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1349 */
#ifndef SOAP_TYPE_plu_gml__TimeTopologyComplexType
#define SOAP_TYPE_plu_gml__TimeTopologyComplexType (-404)
/* complex XML schema type 'gml:TimeTopologyComplexType': */
class SOAP_CMAC gml__TimeTopologyComplexType : public gml__AbstractTimeComplexType {
      public:
        /// Required element 'gml:primitive' of XML schema type 'gml:TimeTopologyPrimitivePropertyType'
        std::vector<gml__TimeTopologyPrimitivePropertyType *> primitive;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeTopologyComplexType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeTopologyComplexType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeTopologyComplexType, default initialized and not managed by a soap context
        virtual gml__TimeTopologyComplexType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeTopologyComplexType); }
      public:
        /// Constructor with default initializations
        gml__TimeTopologyComplexType() : primitive() { }
        virtual ~gml__TimeTopologyComplexType() { }
        /// Friend allocator used by soap_new_gml__TimeTopologyComplexType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeTopologyComplexType * SOAP_FMAC2 soap_instantiate_gml__TimeTopologyComplexType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1439 */
#ifndef SOAP_TYPE_plu_gml__FeatureCollectionType
#define SOAP_TYPE_plu_gml__FeatureCollectionType (-434)
/* Type gml__FeatureCollectionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gml:FeatureCollectionType': */
class SOAP_CMAC gml__FeatureCollectionType : public gml__AbstractFeatureCollectionType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__FeatureCollectionType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__FeatureCollectionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__FeatureCollectionType, default initialized and not managed by a soap context
        virtual gml__FeatureCollectionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__FeatureCollectionType); }
      public:
        /// Constructor with default initializations
        gml__FeatureCollectionType() { }
        virtual ~gml__FeatureCollectionType() { }
        /// Friend allocator used by soap_new_gml__FeatureCollectionType(struct soap*, int)
        friend SOAP_FMAC1 gml__FeatureCollectionType * SOAP_FMAC2 soap_instantiate_gml__FeatureCollectionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1445 */
#ifndef SOAP_TYPE_plu_gml__DefinitionProxyType
#define SOAP_TYPE_plu_gml__DefinitionProxyType (-436)
/* complex XML schema type 'gml:DefinitionProxyType': */
class SOAP_CMAC gml__DefinitionProxyType : public gml__DefinitionType {
      public:
        /// Required element 'gml:definitionRef' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *definitionRef;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DefinitionProxyType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DefinitionProxyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DefinitionProxyType, default initialized and not managed by a soap context
        virtual gml__DefinitionProxyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DefinitionProxyType); }
      public:
        /// Constructor with default initializations
        gml__DefinitionProxyType() : definitionRef() { }
        virtual ~gml__DefinitionProxyType() { }
        /// Friend allocator used by soap_new_gml__DefinitionProxyType(struct soap*, int)
        friend SOAP_FMAC1 gml__DefinitionProxyType * SOAP_FMAC2 soap_instantiate_gml__DefinitionProxyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1508 */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fPlatform_x005fType
#define SOAP_TYPE_plu_gmd__DS_x005fPlatform_x005fType (-457)
/* complex XML schema type 'gmd:DS_Platform_Type': */
class SOAP_CMAC gmd__DS_x005fPlatform_x005fType : public gmd__DS_x005fSeries_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DS_x005fPlatform_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DS_x005fPlatform_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DS_x005fPlatform_x005fType, default initialized and not managed by a soap context
        virtual gmd__DS_x005fPlatform_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DS_x005fPlatform_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DS_x005fPlatform_x005fType() { }
        virtual ~gmd__DS_x005fPlatform_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DS_x005fPlatform_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DS_x005fPlatform_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DS_x005fPlatform_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1514 */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fSensor_x005fType
#define SOAP_TYPE_plu_gmd__DS_x005fSensor_x005fType (-459)
/* complex XML schema type 'gmd:DS_Sensor_Type': */
class SOAP_CMAC gmd__DS_x005fSensor_x005fType : public gmd__DS_x005fSeries_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DS_x005fSensor_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DS_x005fSensor_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DS_x005fSensor_x005fType, default initialized and not managed by a soap context
        virtual gmd__DS_x005fSensor_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DS_x005fSensor_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DS_x005fSensor_x005fType() { }
        virtual ~gmd__DS_x005fSensor_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DS_x005fSensor_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DS_x005fSensor_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DS_x005fSensor_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1520 */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fProductionSeries_x005fType
#define SOAP_TYPE_plu_gmd__DS_x005fProductionSeries_x005fType (-461)
/* complex XML schema type 'gmd:DS_ProductionSeries_Type': */
class SOAP_CMAC gmd__DS_x005fProductionSeries_x005fType : public gmd__DS_x005fSeries_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DS_x005fProductionSeries_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DS_x005fProductionSeries_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DS_x005fProductionSeries_x005fType, default initialized and not managed by a soap context
        virtual gmd__DS_x005fProductionSeries_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DS_x005fProductionSeries_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DS_x005fProductionSeries_x005fType() { }
        virtual ~gmd__DS_x005fProductionSeries_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DS_x005fProductionSeries_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DS_x005fProductionSeries_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DS_x005fProductionSeries_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1526 */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fStereoMate_x005fType
#define SOAP_TYPE_plu_gmd__DS_x005fStereoMate_x005fType (-463)
/* complex XML schema type 'gmd:DS_StereoMate_Type': */
class SOAP_CMAC gmd__DS_x005fStereoMate_x005fType : public gmd__DS_x005fOtherAggregate_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DS_x005fStereoMate_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DS_x005fStereoMate_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DS_x005fStereoMate_x005fType, default initialized and not managed by a soap context
        virtual gmd__DS_x005fStereoMate_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DS_x005fStereoMate_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DS_x005fStereoMate_x005fType() { }
        virtual ~gmd__DS_x005fStereoMate_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DS_x005fStereoMate_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DS_x005fStereoMate_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DS_x005fStereoMate_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1556 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fGeoreferenceable_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fGeoreferenceable_x005fType (-473)
/* complex XML schema type 'gmd:MD_Georeferenceable_Type': */
class SOAP_CMAC gmd__MD_x005fGeoreferenceable_x005fType : public gmd__MD_x005fGridSpatialRepresentation_x005fType {
      public:
        /// Required element 'gmd:controlPointAvailability' of XML schema type 'gco:Boolean_PropertyType'
        gco__Boolean_x005fPropertyType *controlPointAvailability;
        /// Required element 'gmd:orientationParameterAvailability' of XML schema type 'gco:Boolean_PropertyType'
        gco__Boolean_x005fPropertyType *orientationParameterAvailability;
        /// Optional element 'gmd:orientationParameterDescription' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *orientationParameterDescription;
        /// Required element 'gmd:georeferencedParameters' of XML schema type 'gco:Record_PropertyType'
        gco__Record_x005fPropertyType *georeferencedParameters;
        /// Optional element 'gmd:parameterCitation' of XML schema type 'gmd:CI_Citation_PropertyType'
        std::vector<gmd__CI_x005fCitation_x005fPropertyType *> parameterCitation;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fGeoreferenceable_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fGeoreferenceable_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fGeoreferenceable_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fGeoreferenceable_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fGeoreferenceable_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fGeoreferenceable_x005fType() : controlPointAvailability(), orientationParameterAvailability(), orientationParameterDescription(), georeferencedParameters(), parameterCitation() { }
        virtual ~gmd__MD_x005fGeoreferenceable_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fGeoreferenceable_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fGeoreferenceable_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fGeoreferenceable_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1568 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fGeorectified_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fGeorectified_x005fType (-477)
/* complex XML schema type 'gmd:MD_Georectified_Type': */
class SOAP_CMAC gmd__MD_x005fGeorectified_x005fType : public gmd__MD_x005fGridSpatialRepresentation_x005fType {
      public:
        /// Required element 'gmd:checkPointAvailability' of XML schema type 'gco:Boolean_PropertyType'
        gco__Boolean_x005fPropertyType *checkPointAvailability;
        /// Optional element 'gmd:checkPointDescription' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *checkPointDescription;
        /// Optional element 'gmd:cornerPoints' of XML schema type 'gss:GM_Point_PropertyType'
        std::vector<gss__GM_x005fPoint_x005fPropertyType *> cornerPoints;
        /// Optional element 'gmd:centerPoint' of XML schema type 'gss:GM_Point_PropertyType'
        gss__GM_x005fPoint_x005fPropertyType *centerPoint;
        /// Required element 'gmd:pointInPixel' of XML schema type 'gmd:MD_PixelOrientationCode_PropertyType'
        gmd__MD_x005fPixelOrientationCode_x005fPropertyType *pointInPixel;
        /// Optional element 'gmd:transformationDimensionDescription' of XML schema type 'gco:CharacterString_PropertyType'
        gco__CharacterString_x005fPropertyType *transformationDimensionDescription;
        /// Sequence of 0 to 2 elements 'gmd:transformationDimensionMapping' of XML schema type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_x005fPropertyType *> transformationDimensionMapping;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fGeorectified_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fGeorectified_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fGeorectified_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fGeorectified_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fGeorectified_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fGeorectified_x005fType() : checkPointAvailability(), checkPointDescription(), cornerPoints(), centerPoint(), pointInPixel(), transformationDimensionDescription(), transformationDimensionMapping() { }
        virtual ~gmd__MD_x005fGeorectified_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fGeorectified_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fGeorectified_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fGeorectified_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1760 */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fImageDescription_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fImageDescription_x005fType (-541)
/* complex XML schema type 'gmd:MD_ImageDescription_Type': */
class SOAP_CMAC gmd__MD_x005fImageDescription_x005fType : public gmd__MD_x005fCoverageDescription_x005fType {
      public:
        /// Optional element 'gmd:illuminationElevationAngle' of XML schema type 'gco:Real_PropertyType'
        gco__Real_x005fPropertyType *illuminationElevationAngle;
        /// Optional element 'gmd:illuminationAzimuthAngle' of XML schema type 'gco:Real_PropertyType'
        gco__Real_x005fPropertyType *illuminationAzimuthAngle;
        /// Optional element 'gmd:imagingCondition' of XML schema type 'gmd:MD_ImagingConditionCode_PropertyType'
        gmd__MD_x005fImagingConditionCode_x005fPropertyType *imagingCondition;
        /// Optional element 'gmd:imageQualityCode' of XML schema type 'gmd:MD_Identifier_PropertyType'
        gmd__MD_x005fIdentifier_x005fPropertyType *imageQualityCode;
        /// Optional element 'gmd:cloudCoverPercentage' of XML schema type 'gco:Real_PropertyType'
        gco__Real_x005fPropertyType *cloudCoverPercentage;
        /// Optional element 'gmd:processingLevelCode' of XML schema type 'gmd:MD_Identifier_PropertyType'
        gmd__MD_x005fIdentifier_x005fPropertyType *processingLevelCode;
        /// Optional element 'gmd:compressionGenerationQuantity' of XML schema type 'gco:Integer_PropertyType'
        gco__Integer_x005fPropertyType *compressionGenerationQuantity;
        /// Optional element 'gmd:triangulationIndicator' of XML schema type 'gco:Boolean_PropertyType'
        gco__Boolean_x005fPropertyType *triangulationIndicator;
        /// Optional element 'gmd:radiometricCalibrationDataAvailability' of XML schema type 'gco:Boolean_PropertyType'
        gco__Boolean_x005fPropertyType *radiometricCalibrationDataAvailability;
        /// Optional element 'gmd:cameraCalibrationInformationAvailability' of XML schema type 'gco:Boolean_PropertyType'
        gco__Boolean_x005fPropertyType *cameraCalibrationInformationAvailability;
        /// Optional element 'gmd:filmDistortionInformationAvailability' of XML schema type 'gco:Boolean_PropertyType'
        gco__Boolean_x005fPropertyType *filmDistortionInformationAvailability;
        /// Optional element 'gmd:lensDistortionInformationAvailability' of XML schema type 'gco:Boolean_PropertyType'
        gco__Boolean_x005fPropertyType *lensDistortionInformationAvailability;
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__MD_x005fImageDescription_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__MD_x005fImageDescription_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_x005fImageDescription_x005fType, default initialized and not managed by a soap context
        virtual gmd__MD_x005fImageDescription_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__MD_x005fImageDescription_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__MD_x005fImageDescription_x005fType() : illuminationElevationAngle(), illuminationAzimuthAngle(), imagingCondition(), imageQualityCode(), cloudCoverPercentage(), processingLevelCode(), compressionGenerationQuantity(), triangulationIndicator(), radiometricCalibrationDataAvailability(), cameraCalibrationInformationAvailability(), filmDistortionInformationAvailability(), lensDistortionInformationAvailability() { }
        virtual ~gmd__MD_x005fImageDescription_x005fType() { }
        /// Friend allocator used by soap_new_gmd__MD_x005fImageDescription_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_x005fImageDescription_x005fType * SOAP_FMAC2 soap_instantiate_gmd__MD_x005fImageDescription_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1838 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fTemporalValidity_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fTemporalValidity_x005fType (-567)
/* complex XML schema type 'gmd:DQ_TemporalValidity_Type': */
class SOAP_CMAC gmd__DQ_x005fTemporalValidity_x005fType : public gmd__AbstractDQ_x005fTemporalAccuracy_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fTemporalValidity_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fTemporalValidity_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fTemporalValidity_x005fType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fTemporalValidity_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fTemporalValidity_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fTemporalValidity_x005fType() { }
        virtual ~gmd__DQ_x005fTemporalValidity_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fTemporalValidity_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fTemporalValidity_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fTemporalValidity_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1844 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fTemporalConsistency_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fTemporalConsistency_x005fType (-569)
/* complex XML schema type 'gmd:DQ_TemporalConsistency_Type': */
class SOAP_CMAC gmd__DQ_x005fTemporalConsistency_x005fType : public gmd__AbstractDQ_x005fTemporalAccuracy_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fTemporalConsistency_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fTemporalConsistency_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fTemporalConsistency_x005fType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fTemporalConsistency_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fTemporalConsistency_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fTemporalConsistency_x005fType() { }
        virtual ~gmd__DQ_x005fTemporalConsistency_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fTemporalConsistency_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fTemporalConsistency_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fTemporalConsistency_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1850 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType (-571)
/* complex XML schema type 'gmd:DQ_AccuracyOfATimeMeasurement_Type': */
class SOAP_CMAC gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType : public gmd__AbstractDQ_x005fTemporalAccuracy_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType() { }
        virtual ~gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1856 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType (-573)
/* complex XML schema type 'gmd:DQ_QuantitativeAttributeAccuracy_Type': */
class SOAP_CMAC gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType : public gmd__AbstractDQ_x005fThematicAccuracy_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType() { }
        virtual ~gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1862 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType (-575)
/* complex XML schema type 'gmd:DQ_NonQuantitativeAttributeAccuracy_Type': */
class SOAP_CMAC gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType : public gmd__AbstractDQ_x005fThematicAccuracy_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType() { }
        virtual ~gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1868 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fThematicClassificationCorrectness_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fThematicClassificationCorrectness_x005fType (-577)
/* complex XML schema type 'gmd:DQ_ThematicClassificationCorrectness_Type': */
class SOAP_CMAC gmd__DQ_x005fThematicClassificationCorrectness_x005fType : public gmd__AbstractDQ_x005fThematicAccuracy_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fThematicClassificationCorrectness_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fThematicClassificationCorrectness_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fThematicClassificationCorrectness_x005fType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fThematicClassificationCorrectness_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fThematicClassificationCorrectness_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fThematicClassificationCorrectness_x005fType() { }
        virtual ~gmd__DQ_x005fThematicClassificationCorrectness_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fThematicClassificationCorrectness_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fThematicClassificationCorrectness_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fThematicClassificationCorrectness_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1874 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType (-579)
/* complex XML schema type 'gmd:DQ_RelativeInternalPositionalAccuracy_Type': */
class SOAP_CMAC gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType : public gmd__AbstractDQ_x005fPositionalAccuracy_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType() { }
        virtual ~gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1880 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType (-581)
/* complex XML schema type 'gmd:DQ_GriddedDataPositionalAccuracy_Type': */
class SOAP_CMAC gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType : public gmd__AbstractDQ_x005fPositionalAccuracy_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType() { }
        virtual ~gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1886 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType (-583)
/* complex XML schema type 'gmd:DQ_AbsoluteExternalPositionalAccuracy_Type': */
class SOAP_CMAC gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType : public gmd__AbstractDQ_x005fPositionalAccuracy_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType() { }
        virtual ~gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1892 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fTopologicalConsistency_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fTopologicalConsistency_x005fType (-585)
/* complex XML schema type 'gmd:DQ_TopologicalConsistency_Type': */
class SOAP_CMAC gmd__DQ_x005fTopologicalConsistency_x005fType : public gmd__AbstractDQ_x005fLogicalConsistency_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fTopologicalConsistency_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fTopologicalConsistency_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fTopologicalConsistency_x005fType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fTopologicalConsistency_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fTopologicalConsistency_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fTopologicalConsistency_x005fType() { }
        virtual ~gmd__DQ_x005fTopologicalConsistency_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fTopologicalConsistency_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fTopologicalConsistency_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fTopologicalConsistency_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1898 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fFormatConsistency_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fFormatConsistency_x005fType (-587)
/* complex XML schema type 'gmd:DQ_FormatConsistency_Type': */
class SOAP_CMAC gmd__DQ_x005fFormatConsistency_x005fType : public gmd__AbstractDQ_x005fLogicalConsistency_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fFormatConsistency_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fFormatConsistency_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fFormatConsistency_x005fType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fFormatConsistency_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fFormatConsistency_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fFormatConsistency_x005fType() { }
        virtual ~gmd__DQ_x005fFormatConsistency_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fFormatConsistency_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fFormatConsistency_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fFormatConsistency_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1904 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fDomainConsistency_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fDomainConsistency_x005fType (-589)
/* complex XML schema type 'gmd:DQ_DomainConsistency_Type': */
class SOAP_CMAC gmd__DQ_x005fDomainConsistency_x005fType : public gmd__AbstractDQ_x005fLogicalConsistency_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fDomainConsistency_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fDomainConsistency_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fDomainConsistency_x005fType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fDomainConsistency_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fDomainConsistency_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fDomainConsistency_x005fType() { }
        virtual ~gmd__DQ_x005fDomainConsistency_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fDomainConsistency_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fDomainConsistency_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fDomainConsistency_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1910 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fConceptualConsistency_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fConceptualConsistency_x005fType (-591)
/* complex XML schema type 'gmd:DQ_ConceptualConsistency_Type': */
class SOAP_CMAC gmd__DQ_x005fConceptualConsistency_x005fType : public gmd__AbstractDQ_x005fLogicalConsistency_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fConceptualConsistency_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fConceptualConsistency_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fConceptualConsistency_x005fType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fConceptualConsistency_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fConceptualConsistency_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fConceptualConsistency_x005fType() { }
        virtual ~gmd__DQ_x005fConceptualConsistency_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fConceptualConsistency_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fConceptualConsistency_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fConceptualConsistency_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1916 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fCompletenessOmission_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fCompletenessOmission_x005fType (-593)
/* complex XML schema type 'gmd:DQ_CompletenessOmission_Type': */
class SOAP_CMAC gmd__DQ_x005fCompletenessOmission_x005fType : public gmd__AbstractDQ_x005fCompleteness_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fCompletenessOmission_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fCompletenessOmission_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fCompletenessOmission_x005fType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fCompletenessOmission_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fCompletenessOmission_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fCompletenessOmission_x005fType() { }
        virtual ~gmd__DQ_x005fCompletenessOmission_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fCompletenessOmission_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fCompletenessOmission_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fCompletenessOmission_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1922 */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fCompletenessCommission_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fCompletenessCommission_x005fType (-595)
/* complex XML schema type 'gmd:DQ_CompletenessCommission_Type': */
class SOAP_CMAC gmd__DQ_x005fCompletenessCommission_x005fType : public gmd__AbstractDQ_x005fCompleteness_x005fType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gmd__DQ_x005fCompletenessCommission_x005fType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gmd__DQ_x005fCompletenessCommission_x005fType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_x005fCompletenessCommission_x005fType, default initialized and not managed by a soap context
        virtual gmd__DQ_x005fCompletenessCommission_x005fType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gmd__DQ_x005fCompletenessCommission_x005fType); }
      public:
        /// Constructor with default initializations
        gmd__DQ_x005fCompletenessCommission_x005fType() { }
        virtual ~gmd__DQ_x005fCompletenessCommission_x005fType() { }
        /// Friend allocator used by soap_new_gmd__DQ_x005fCompletenessCommission_x005fType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_x005fCompletenessCommission_x005fType * SOAP_FMAC2 soap_instantiate_gmd__DQ_x005fCompletenessCommission_x005fType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:542 */
#ifndef SOAP_TYPE_plu_gml__CompositeCurveType
#define SOAP_TYPE_plu_gml__CompositeCurveType (-135)
/* complex XML schema type 'gml:CompositeCurveType': */
class SOAP_CMAC gml__CompositeCurveType : public gml__AbstractCurveType {
      public:
        /// Required element 'gml:curveMember' of XML schema type 'gml:CurvePropertyType'
        std::vector<gml__CurvePropertyType *> curveMember;
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CompositeCurveType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CompositeCurveType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CompositeCurveType, default initialized and not managed by a soap context
        virtual gml__CompositeCurveType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CompositeCurveType); }
      public:
        /// Constructor with default initializations
        gml__CompositeCurveType() : curveMember(), aggregationType() { }
        virtual ~gml__CompositeCurveType() { }
        /// Friend allocator used by soap_new_gml__CompositeCurveType(struct soap*, int)
        friend SOAP_FMAC1 gml__CompositeCurveType * SOAP_FMAC2 soap_instantiate_gml__CompositeCurveType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:545 */
#ifndef SOAP_TYPE_plu_gml__CompositeSurfaceType
#define SOAP_TYPE_plu_gml__CompositeSurfaceType (-136)
/* complex XML schema type 'gml:CompositeSurfaceType': */
class SOAP_CMAC gml__CompositeSurfaceType : public gml__AbstractSurfaceType {
      public:
        /// Required element 'gml:surfaceMember' of XML schema type 'gml:SurfacePropertyType'
        std::vector<gml__SurfacePropertyType *> surfaceMember;
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CompositeSurfaceType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CompositeSurfaceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CompositeSurfaceType, default initialized and not managed by a soap context
        virtual gml__CompositeSurfaceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CompositeSurfaceType); }
      public:
        /// Constructor with default initializations
        gml__CompositeSurfaceType() : surfaceMember(), aggregationType() { }
        virtual ~gml__CompositeSurfaceType() { }
        /// Friend allocator used by soap_new_gml__CompositeSurfaceType(struct soap*, int)
        friend SOAP_FMAC1 gml__CompositeSurfaceType * SOAP_FMAC2 soap_instantiate_gml__CompositeSurfaceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:548 */
#ifndef SOAP_TYPE_plu_gml__CompositeSolidType
#define SOAP_TYPE_plu_gml__CompositeSolidType (-137)
/* Type gml__CompositeSolidType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gml:CompositeSolidType': */
class SOAP_CMAC gml__CompositeSolidType : public gml__AbstractSolidType {
      public:
        /// Required element 'gml:solidMember' of XML schema type 'gml:SolidPropertyType'
        std::vector<gml__SolidPropertyType *> solidMember;
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CompositeSolidType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CompositeSolidType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CompositeSolidType, default initialized and not managed by a soap context
        virtual gml__CompositeSolidType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CompositeSolidType); }
      public:
        /// Constructor with default initializations
        gml__CompositeSolidType() : solidMember(), aggregationType() { }
        virtual ~gml__CompositeSolidType() { }
        /// Friend allocator used by soap_new_gml__CompositeSolidType(struct soap*, int)
        friend SOAP_FMAC1 gml__CompositeSolidType * SOAP_FMAC2 soap_instantiate_gml__CompositeSolidType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:584 */
#ifndef SOAP_TYPE_plu_gml__CurveType
#define SOAP_TYPE_plu_gml__CurveType (-149)
/* complex XML schema type 'gml:CurveType': */
class SOAP_CMAC gml__CurveType : public gml__AbstractCurveType {
      public:
        /// Required element 'gml:segments' of XML schema type 'gml:CurveSegmentArrayPropertyType'
        gml__CurveSegmentArrayPropertyType *segments;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CurveType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CurveType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CurveType, default initialized and not managed by a soap context
        virtual gml__CurveType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CurveType); }
      public:
        /// Constructor with default initializations
        gml__CurveType() : segments() { }
        virtual ~gml__CurveType() { }
        /// Friend allocator used by soap_new_gml__CurveType(struct soap*, int)
        friend SOAP_FMAC1 gml__CurveType * SOAP_FMAC2 soap_instantiate_gml__CurveType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:587 */
#ifndef SOAP_TYPE_plu_gml__OrientableCurveType
#define SOAP_TYPE_plu_gml__OrientableCurveType (-150)
/* complex XML schema type 'gml:OrientableCurveType': */
class SOAP_CMAC gml__OrientableCurveType : public gml__AbstractCurveType {
      public:
        /// Required element 'gml:baseCurve' of XML schema type 'gml:CurvePropertyType'
        gml__CurvePropertyType *baseCurve;
        /// Optional attribute 'orientation' of XML schema type 'gml:SignType'
        enum gml__SignType orientation;	///< initialized with default value = (enum gml__SignType)1
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__OrientableCurveType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__OrientableCurveType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__OrientableCurveType, default initialized and not managed by a soap context
        virtual gml__OrientableCurveType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__OrientableCurveType); }
      public:
        /// Constructor with default initializations
        gml__OrientableCurveType() : baseCurve(), orientation((enum gml__SignType)1) { }
        virtual ~gml__OrientableCurveType() { }
        /// Friend allocator used by soap_new_gml__OrientableCurveType(struct soap*, int)
        friend SOAP_FMAC1 gml__OrientableCurveType * SOAP_FMAC2 soap_instantiate_gml__OrientableCurveType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:34028 */
#ifndef SOAP_TYPE_plu__gml__union_SurfaceType
#define SOAP_TYPE_plu__gml__union_SurfaceType (-2245)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_SurfaceType
{
        #define SOAP_UNION_plu__gml__union_SurfaceType_patches	(1)	/**< union variant selector value for member patches */
        gml__SurfacePatchArrayPropertyType *patches;
        #define SOAP_UNION_plu__gml__union_SurfaceType_polygonPatches	(2)	/**< union variant selector value for member polygonPatches */
        gml__SurfacePatchArrayPropertyType *polygonPatches;
        #define SOAP_UNION_plu__gml__union_SurfaceType_trianglePatches	(3)	/**< union variant selector value for member trianglePatches */
        gml__SurfacePatchArrayPropertyType *trianglePatches;
};
#endif

/* PlannedLandUse_v3.0.h:650 */
#ifndef SOAP_TYPE_plu_gml__SurfaceType
#define SOAP_TYPE_plu_gml__SurfaceType (-171)
/* complex XML schema type 'gml:SurfaceType': */
class SOAP_CMAC gml__SurfaceType : public gml__AbstractSurfaceType {
      public:
        /// Union with union _gml__union_SurfaceType variant selector __unionpatches set to one of: SOAP_UNION_plu__gml__union_SurfaceType_patches SOAP_UNION_plu__gml__union_SurfaceType_polygonPatches SOAP_UNION_plu__gml__union_SurfaceType_trianglePatches
        int __unionpatches;
        union _gml__union_SurfaceType union_SurfaceType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__SurfaceType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__SurfaceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SurfaceType, default initialized and not managed by a soap context
        virtual gml__SurfaceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__SurfaceType); }
      public:
        /// Constructor with default initializations
        gml__SurfaceType() : __unionpatches() { }
        virtual ~gml__SurfaceType() { }
        /// Friend allocator used by soap_new_gml__SurfaceType(struct soap*, int)
        friend SOAP_FMAC1 gml__SurfaceType * SOAP_FMAC2 soap_instantiate_gml__SurfaceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:653 */
#ifndef SOAP_TYPE_plu_gml__OrientableSurfaceType
#define SOAP_TYPE_plu_gml__OrientableSurfaceType (-172)
/* complex XML schema type 'gml:OrientableSurfaceType': */
class SOAP_CMAC gml__OrientableSurfaceType : public gml__AbstractSurfaceType {
      public:
        /// Required element 'gml:baseSurface' of XML schema type 'gml:SurfacePropertyType'
        gml__SurfacePropertyType *baseSurface;
        /// Optional attribute 'orientation' of XML schema type 'gml:SignType'
        enum gml__SignType orientation;	///< initialized with default value = (enum gml__SignType)1
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__OrientableSurfaceType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__OrientableSurfaceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__OrientableSurfaceType, default initialized and not managed by a soap context
        virtual gml__OrientableSurfaceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__OrientableSurfaceType); }
      public:
        /// Constructor with default initializations
        gml__OrientableSurfaceType() : baseSurface(), orientation((enum gml__SignType)1) { }
        virtual ~gml__OrientableSurfaceType() { }
        /// Friend allocator used by soap_new_gml__OrientableSurfaceType(struct soap*, int)
        friend SOAP_FMAC1 gml__OrientableSurfaceType * SOAP_FMAC2 soap_instantiate_gml__OrientableSurfaceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:707 */
#ifndef SOAP_TYPE_plu_gml__SolidType
#define SOAP_TYPE_plu_gml__SolidType (-190)
/* complex XML schema type 'gml:SolidType': */
class SOAP_CMAC gml__SolidType : public gml__AbstractSolidType {
      public:
        /// Optional element 'gml:exterior' of XML schema type 'gml:ShellPropertyType'
        gml__ShellPropertyType *exterior;
        /// Optional element 'gml:interior' of XML schema type 'gml:ShellPropertyType'
        std::vector<gml__ShellPropertyType *> interior;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__SolidType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__SolidType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SolidType, default initialized and not managed by a soap context
        virtual gml__SolidType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__SolidType); }
      public:
        /// Constructor with default initializations
        gml__SolidType() : exterior(), interior() { }
        virtual ~gml__SolidType() { }
        /// Friend allocator used by soap_new_gml__SolidType(struct soap*, int)
        friend SOAP_FMAC1 gml__SolidType * SOAP_FMAC2 soap_instantiate_gml__SolidType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:710 */
#ifndef SOAP_TYPE_plu_gml__ShellType
#define SOAP_TYPE_plu_gml__ShellType (-191)
/* complex XML schema type 'gml:ShellType': */
class SOAP_CMAC gml__ShellType : public gml__AbstractSurfaceType {
      public:
        /// Required element 'gml:surfaceMember' of XML schema type 'gml:SurfacePropertyType'
        std::vector<gml__SurfacePropertyType *> surfaceMember;
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ShellType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ShellType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ShellType, default initialized and not managed by a soap context
        virtual gml__ShellType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ShellType); }
      public:
        /// Constructor with default initializations
        gml__ShellType() : surfaceMember(), aggregationType() { }
        virtual ~gml__ShellType() { }
        /// Friend allocator used by soap_new_gml__ShellType(struct soap*, int)
        friend SOAP_FMAC1 gml__ShellType * SOAP_FMAC2 soap_instantiate_gml__ShellType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:725 */
#ifndef SOAP_TYPE_plu_gml__PolygonType
#define SOAP_TYPE_plu_gml__PolygonType (-196)
/* complex XML schema type 'gml:PolygonType': */
class SOAP_CMAC gml__PolygonType : public gml__AbstractSurfaceType {
      public:
        /// Optional element 'gml:exterior' of XML schema type 'gml:AbstractRingPropertyType'
        gml__AbstractRingPropertyType *exterior;
        /// Optional element 'gml:interior' of XML schema type 'gml:AbstractRingPropertyType'
        std::vector<gml__AbstractRingPropertyType *> interior;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__PolygonType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__PolygonType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__PolygonType, default initialized and not managed by a soap context
        virtual gml__PolygonType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__PolygonType); }
      public:
        /// Constructor with default initializations
        gml__PolygonType() : exterior(), interior() { }
        virtual ~gml__PolygonType() { }
        /// Friend allocator used by soap_new_gml__PolygonType(struct soap*, int)
        friend SOAP_FMAC1 gml__PolygonType * SOAP_FMAC2 soap_instantiate_gml__PolygonType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:728 */
#ifndef SOAP_TYPE_plu_gml__AbstractRingType
#define SOAP_TYPE_plu_gml__AbstractRingType (-197)
/* complex XML schema type 'gml:AbstractRingType': */
class SOAP_CMAC gml__AbstractRingType : public gml__AbstractCurveType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractRingType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractRingType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractRingType, default initialized and not managed by a soap context
        virtual gml__AbstractRingType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractRingType); }
      public:
        /// Constructor with default initializations
        gml__AbstractRingType() { }
        virtual ~gml__AbstractRingType() { }
        /// Friend allocator used by soap_new_gml__AbstractRingType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractRingType * SOAP_FMAC2 soap_instantiate_gml__AbstractRingType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:34472 */
#ifndef SOAP_TYPE_plu__gml__union_LineStringType_
#define SOAP_TYPE_plu__gml__union_LineStringType_ (-2252)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_LineStringType_
{
        #define SOAP_UNION_plu__gml__union_LineStringType__pos	(1)	/**< union variant selector value for member pos */
        gml__DirectPositionType *pos;
        #define SOAP_UNION_plu__gml__union_LineStringType__pointProperty	(2)	/**< union variant selector value for member pointProperty */
        gml__PointPropertyType *pointProperty;
        #define SOAP_UNION_plu__gml__union_LineStringType__pointRep	(3)	/**< union variant selector value for member pointRep */
        gml__PointPropertyType *pointRep;
};
#endif

/* PlannedLandUse_v3.0.h:34468 */
#ifndef SOAP_TYPE_plu___gml__union_LineStringType_
#define SOAP_TYPE_plu___gml__union_LineStringType_ (-2251)
/* Wrapper: */
class SOAP_CMAC __gml__union_LineStringType_ {
      public:
        /// Union with union _gml__union_LineStringType_ variant selector __union_LineStringType_ set to one of: SOAP_UNION_plu__gml__union_LineStringType__pos SOAP_UNION_plu__gml__union_LineStringType__pointProperty SOAP_UNION_plu__gml__union_LineStringType__pointRep
        int __union_LineStringType_;
        union _gml__union_LineStringType_ union_LineStringType_;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_LineStringType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_LineStringType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_LineStringType_, default initialized and not managed by a soap context
        virtual __gml__union_LineStringType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_LineStringType_); }
      public:
        /// Constructor with default initializations
        __gml__union_LineStringType_() : __union_LineStringType_() { }
        virtual ~__gml__union_LineStringType_() { }
        /// Friend allocator used by soap_new___gml__union_LineStringType_(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_LineStringType_ * SOAP_FMAC2 soap_instantiate___gml__union_LineStringType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:34466 */
#ifndef SOAP_TYPE_plu____gml__union_LineStringType_
#define SOAP_TYPE_plu____gml__union_LineStringType_ (-2250)
/* Wrapper: */
struct SOAP_CMAC ___gml__union_LineStringType_ {
      public:
        /** Sequence of at least 2 elements '-union-LineStringType' of XML schema type '-gml:union-LineStringType' stored in dynamic array __union_LineStringType_ of length __size_LineStringType_ */
        int __size_LineStringType_;
        __gml__union_LineStringType_ *__union_LineStringType_;
      public:
        /** Return unique type id SOAP_TYPE_plu____gml__union_LineStringType_ */
        long soap_type() const { return SOAP_TYPE_plu____gml__union_LineStringType_; }
        /** Friend allocator */
        friend SOAP_FMAC1 ___gml__union_LineStringType_ * SOAP_FMAC2 soap_instantiate____gml__union_LineStringType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:34463 */
#ifndef SOAP_TYPE_plu__gml__union_LineStringType
#define SOAP_TYPE_plu__gml__union_LineStringType (-2249)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_LineStringType
{
        #define SOAP_UNION_plu__gml__union_LineStringType___union_LineStringType_	(1)	/**< union variant selector value for member __union_LineStringType_ */
        struct ___gml__union_LineStringType_ __union_LineStringType_;
        #define SOAP_UNION_plu__gml__union_LineStringType_posList	(2)	/**< union variant selector value for member posList */
        gml__DirectPositionListType *posList;
        #define SOAP_UNION_plu__gml__union_LineStringType_coordinates	(3)	/**< union variant selector value for member coordinates */
        gml__CoordinatesType *coordinates;
};
#endif

/* PlannedLandUse_v3.0.h:785 */
#ifndef SOAP_TYPE_plu_gml__LineStringType
#define SOAP_TYPE_plu_gml__LineStringType (-216)
/* complex XML schema type 'gml:LineStringType': */
class SOAP_CMAC gml__LineStringType : public gml__AbstractCurveType {
      public:
        /// Union with union _gml__union_LineStringType variant selector __union_LineStringType set to one of: SOAP_UNION_plu__gml__union_LineStringType___union_LineStringType_ SOAP_UNION_plu__gml__union_LineStringType_posList SOAP_UNION_plu__gml__union_LineStringType_coordinates
        int __union_LineStringType;
        union _gml__union_LineStringType union_LineStringType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__LineStringType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__LineStringType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__LineStringType, default initialized and not managed by a soap context
        virtual gml__LineStringType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__LineStringType); }
      public:
        /// Constructor with default initializations
        gml__LineStringType() : __union_LineStringType() { }
        virtual ~gml__LineStringType() { }
        /// Friend allocator used by soap_new_gml__LineStringType(struct soap*, int)
        friend SOAP_FMAC1 gml__LineStringType * SOAP_FMAC2 soap_instantiate_gml__LineStringType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:818 */
#ifndef SOAP_TYPE_plu_gml__BaseUnitType
#define SOAP_TYPE_plu_gml__BaseUnitType (-227)
/* complex XML schema type 'gml:BaseUnitType': */
class SOAP_CMAC gml__BaseUnitType : public gml__UnitDefinitionType {
      public:
        /// Required element 'gml:unitsSystem' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *unitsSystem;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__BaseUnitType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__BaseUnitType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__BaseUnitType, default initialized and not managed by a soap context
        virtual gml__BaseUnitType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__BaseUnitType); }
      public:
        /// Constructor with default initializations
        gml__BaseUnitType() : unitsSystem() { }
        virtual ~gml__BaseUnitType() { }
        /// Friend allocator used by soap_new_gml__BaseUnitType(struct soap*, int)
        friend SOAP_FMAC1 gml__BaseUnitType * SOAP_FMAC2 soap_instantiate_gml__BaseUnitType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:821 */
#ifndef SOAP_TYPE_plu_gml__DerivedUnitType
#define SOAP_TYPE_plu_gml__DerivedUnitType (-228)
/* complex XML schema type 'gml:DerivedUnitType': */
class SOAP_CMAC gml__DerivedUnitType : public gml__UnitDefinitionType {
      public:
        /// Required element 'gml:derivationUnitTerm' of XML schema type 'gml:DerivationUnitTermType'
        std::vector<gml__DerivationUnitTermType *> derivationUnitTerm;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DerivedUnitType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DerivedUnitType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DerivedUnitType, default initialized and not managed by a soap context
        virtual gml__DerivedUnitType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DerivedUnitType); }
      public:
        /// Constructor with default initializations
        gml__DerivedUnitType() : derivationUnitTerm() { }
        virtual ~gml__DerivedUnitType() { }
        /// Friend allocator used by soap_new_gml__DerivedUnitType(struct soap*, int)
        friend SOAP_FMAC1 gml__DerivedUnitType * SOAP_FMAC2 soap_instantiate_gml__DerivedUnitType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:34626 */
#ifndef SOAP_TYPE_plu__gml__union_ConventionalUnitType
#define SOAP_TYPE_plu__gml__union_ConventionalUnitType (-2256)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ConventionalUnitType
{
        #define SOAP_UNION_plu__gml__union_ConventionalUnitType_conversionToPreferredUnit	(1)	/**< union variant selector value for member conversionToPreferredUnit */
        gml__ConversionToPreferredUnitType *conversionToPreferredUnit;
        #define SOAP_UNION_plu__gml__union_ConventionalUnitType_roughConversionToPreferredUnit	(2)	/**< union variant selector value for member roughConversionToPreferredUnit */
        gml__ConversionToPreferredUnitType *roughConversionToPreferredUnit;
};
#endif

/* PlannedLandUse_v3.0.h:827 */
#ifndef SOAP_TYPE_plu_gml__ConventionalUnitType
#define SOAP_TYPE_plu_gml__ConventionalUnitType (-230)
/* complex XML schema type 'gml:ConventionalUnitType': */
class SOAP_CMAC gml__ConventionalUnitType : public gml__UnitDefinitionType {
      public:
        /// Union with union _gml__union_ConventionalUnitType variant selector __union_ConventionalUnitType set to one of: SOAP_UNION_plu__gml__union_ConventionalUnitType_conversionToPreferredUnit SOAP_UNION_plu__gml__union_ConventionalUnitType_roughConversionToPreferredUnit
        int __union_ConventionalUnitType;
        union _gml__union_ConventionalUnitType union_ConventionalUnitType;
        /// Optional element 'gml:derivationUnitTerm' of XML schema type 'gml:DerivationUnitTermType'
        std::vector<gml__DerivationUnitTermType *> derivationUnitTerm;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ConventionalUnitType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ConventionalUnitType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ConventionalUnitType, default initialized and not managed by a soap context
        virtual gml__ConventionalUnitType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ConventionalUnitType); }
      public:
        /// Constructor with default initializations
        gml__ConventionalUnitType() : __union_ConventionalUnitType(), derivationUnitTerm() { }
        virtual ~gml__ConventionalUnitType() { }
        /// Friend allocator used by soap_new_gml__ConventionalUnitType(struct soap*, int)
        friend SOAP_FMAC1 gml__ConventionalUnitType * SOAP_FMAC2 soap_instantiate_gml__ConventionalUnitType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:956 */
#ifndef SOAP_TYPE_plu_gml__TimeInstantType
#define SOAP_TYPE_plu_gml__TimeInstantType (-273)
/* complex XML schema type 'gml:TimeInstantType': */
class SOAP_CMAC gml__TimeInstantType : public gml__AbstractTimeGeometricPrimitiveType {
      public:
        /// Required element 'gml:timePosition' of XML schema type 'gml:TimePositionType'
        gml__TimePositionType *timePosition;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeInstantType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeInstantType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeInstantType, default initialized and not managed by a soap context
        virtual gml__TimeInstantType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeInstantType); }
      public:
        /// Constructor with default initializations
        gml__TimeInstantType() : timePosition() { }
        virtual ~gml__TimeInstantType() { }
        /// Friend allocator used by soap_new_gml__TimeInstantType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeInstantType * SOAP_FMAC2 soap_instantiate_gml__TimeInstantType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:34767 */
#ifndef SOAP_TYPE_plu__gml__union_TimePeriodType
#define SOAP_TYPE_plu__gml__union_TimePeriodType (-2258)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_TimePeriodType
{
        #define SOAP_UNION_plu__gml__union_TimePeriodType_beginPosition	(1)	/**< union variant selector value for member beginPosition */
        gml__TimePositionType *beginPosition;
        #define SOAP_UNION_plu__gml__union_TimePeriodType_begin	(2)	/**< union variant selector value for member begin */
        gml__TimeInstantPropertyType *begin;
};
#endif

/* PlannedLandUse_v3.0.h:34777 */
#ifndef SOAP_TYPE_plu__gml__union_TimePeriodType_
#define SOAP_TYPE_plu__gml__union_TimePeriodType_ (-2260)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_TimePeriodType_
{
        #define SOAP_UNION_plu__gml__union_TimePeriodType__endPosition	(1)	/**< union variant selector value for member endPosition */
        gml__TimePositionType *endPosition;
        #define SOAP_UNION_plu__gml__union_TimePeriodType__end	(2)	/**< union variant selector value for member end */
        gml__TimeInstantPropertyType *end;
};
#endif

/* PlannedLandUse_v3.0.h:34791 */
#ifndef SOAP_TYPE_plu__gml__union_TimePeriodType__
#define SOAP_TYPE_plu__gml__union_TimePeriodType__ (-2261)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_TimePeriodType__
{
        #define SOAP_UNION_plu__gml__union_TimePeriodType___duration	(1)	/**< union variant selector value for member duration */
        char **duration;
        #define SOAP_UNION_plu__gml__union_TimePeriodType___timeInterval	(2)	/**< union variant selector value for member timeInterval */
        gml__TimeIntervalLengthType *timeInterval;
};
#endif

/* PlannedLandUse_v3.0.h:962 */
#ifndef SOAP_TYPE_plu_gml__TimePeriodType
#define SOAP_TYPE_plu_gml__TimePeriodType (-275)
/* complex XML schema type 'gml:TimePeriodType': */
class SOAP_CMAC gml__TimePeriodType : public gml__AbstractTimeGeometricPrimitiveType {
      public:
        /// Union with union _gml__union_TimePeriodType variant selector __union_TimePeriodType set to one of: SOAP_UNION_plu__gml__union_TimePeriodType_beginPosition SOAP_UNION_plu__gml__union_TimePeriodType_begin
        int __union_TimePeriodType;
        union _gml__union_TimePeriodType union_TimePeriodType;
        /// Union with union _gml__union_TimePeriodType_ variant selector __union_TimePeriodType_ set to one of: SOAP_UNION_plu__gml__union_TimePeriodType__endPosition SOAP_UNION_plu__gml__union_TimePeriodType__end
        int __union_TimePeriodType_;
        union _gml__union_TimePeriodType_ union_TimePeriodType_;
        /// Union with union _gml__union_TimePeriodType__ variant selector __union_TimePeriodType__ set to one of: SOAP_UNION_plu__gml__union_TimePeriodType___duration SOAP_UNION_plu__gml__union_TimePeriodType___timeInterval
        int __union_TimePeriodType__;
        union _gml__union_TimePeriodType__ union_TimePeriodType__;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimePeriodType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimePeriodType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimePeriodType, default initialized and not managed by a soap context
        virtual gml__TimePeriodType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimePeriodType); }
      public:
        /// Constructor with default initializations
        gml__TimePeriodType() : __union_TimePeriodType(), __union_TimePeriodType_(), __union_TimePeriodType__() { }
        virtual ~gml__TimePeriodType() { }
        /// Friend allocator used by soap_new_gml__TimePeriodType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimePeriodType * SOAP_FMAC2 soap_instantiate_gml__TimePeriodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1070 */
#ifndef SOAP_TYPE_plu_gml__CoordinateSystemAxisType
#define SOAP_TYPE_plu_gml__CoordinateSystemAxisType (-311)
/* complex XML schema type 'gml:CoordinateSystemAxisType': */
class SOAP_CMAC gml__CoordinateSystemAxisType : public gml__IdentifiedObjectType {
      public:
        /// Required element 'gml:axisAbbrev' of XML schema type 'gml:CodeType'
        gml__CodeType *axisAbbrev;
        /// Required element 'gml:axisDirection' of XML schema type 'gml:CodeWithAuthorityType'
        gml__CodeWithAuthorityType *axisDirection;
        /// Optional element 'gml:minimumValue' of XML schema type 'xsd:double'
        double *minimumValue;
        /// Optional element 'gml:maximumValue' of XML schema type 'xsd:double'
        double *maximumValue;
        /// Optional element 'gml:rangeMeaning' of XML schema type 'gml:CodeWithAuthorityType'
        gml__CodeWithAuthorityType *rangeMeaning;
        /// Required attribute 'uom' of XML schema type 'gml:UomIdentifier'
        std::string uom;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CoordinateSystemAxisType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CoordinateSystemAxisType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CoordinateSystemAxisType, default initialized and not managed by a soap context
        virtual gml__CoordinateSystemAxisType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CoordinateSystemAxisType); }
      public:
        /// Constructor with default initializations
        gml__CoordinateSystemAxisType() : axisAbbrev(), axisDirection(), minimumValue(), maximumValue(), rangeMeaning(), uom() { }
        virtual ~gml__CoordinateSystemAxisType() { }
        /// Friend allocator used by soap_new_gml__CoordinateSystemAxisType(struct soap*, int)
        friend SOAP_FMAC1 gml__CoordinateSystemAxisType * SOAP_FMAC2 soap_instantiate_gml__CoordinateSystemAxisType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:34897 */
#ifndef SOAP_TYPE_plu__gml__union_AbstractCoordinateSystemType
#define SOAP_TYPE_plu__gml__union_AbstractCoordinateSystemType (-2265)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_AbstractCoordinateSystemType
{
        #define SOAP_UNION_plu__gml__union_AbstractCoordinateSystemType_axis	(1)	/**< union variant selector value for member axis */
        std::vector<gml__CoordinateSystemAxisPropertyType *> *axis;
        #define SOAP_UNION_plu__gml__union_AbstractCoordinateSystemType_usesAxis	(2)	/**< union variant selector value for member usesAxis */
        gml__CoordinateSystemAxisPropertyType *usesAxis;
};
#endif

/* PlannedLandUse_v3.0.h:34892 */
#ifndef SOAP_TYPE_plu___gml__union_AbstractCoordinateSystemType
#define SOAP_TYPE_plu___gml__union_AbstractCoordinateSystemType (-2264)
/* Wrapper: */
class SOAP_CMAC __gml__union_AbstractCoordinateSystemType {
      public:
        /// Union with union _gml__union_AbstractCoordinateSystemType variant selector __unionaxis set to one of: SOAP_UNION_plu__gml__union_AbstractCoordinateSystemType_axis SOAP_UNION_plu__gml__union_AbstractCoordinateSystemType_usesAxis
        int __unionaxis;
        union _gml__union_AbstractCoordinateSystemType union_AbstractCoordinateSystemType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_AbstractCoordinateSystemType
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_AbstractCoordinateSystemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_AbstractCoordinateSystemType, default initialized and not managed by a soap context
        virtual __gml__union_AbstractCoordinateSystemType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_AbstractCoordinateSystemType); }
      public:
        /// Constructor with default initializations
        __gml__union_AbstractCoordinateSystemType() : __unionaxis() { }
        virtual ~__gml__union_AbstractCoordinateSystemType() { }
        /// Friend allocator used by soap_new___gml__union_AbstractCoordinateSystemType(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_AbstractCoordinateSystemType * SOAP_FMAC2 soap_instantiate___gml__union_AbstractCoordinateSystemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1076 */
#ifndef SOAP_TYPE_plu_gml__AbstractCoordinateSystemType
#define SOAP_TYPE_plu_gml__AbstractCoordinateSystemType (-313)
/* complex XML schema type 'gml:AbstractCoordinateSystemType': */
class SOAP_CMAC gml__AbstractCoordinateSystemType : public gml__IdentifiedObjectType {
      public:
        /// Sequence of elements '-union-AbstractCoordinateSystemType' of XML schema type '-gml:union-AbstractCoordinateSystemType' stored in dynamic array __union_AbstractCoordinateSystemType of length __sizeaxis
        int __sizeaxis;
        __gml__union_AbstractCoordinateSystemType *__union_AbstractCoordinateSystemType;
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractCoordinateSystemType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractCoordinateSystemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractCoordinateSystemType, default initialized and not managed by a soap context
        virtual gml__AbstractCoordinateSystemType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractCoordinateSystemType); }
      public:
        /// Constructor with default initializations
        gml__AbstractCoordinateSystemType() : __sizeaxis(), __union_AbstractCoordinateSystemType(), aggregationType() { }
        virtual ~gml__AbstractCoordinateSystemType() { }
        /// Friend allocator used by soap_new_gml__AbstractCoordinateSystemType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractCoordinateSystemType * SOAP_FMAC2 soap_instantiate_gml__AbstractCoordinateSystemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1145 */
#ifndef SOAP_TYPE_plu_gml__AbstractCRSType
#define SOAP_TYPE_plu_gml__AbstractCRSType (-336)
/* complex XML schema type 'gml:AbstractCRSType': */
class SOAP_CMAC gml__AbstractCRSType : public gml__IdentifiedObjectType {
      public:
        /// Optional element 'gml:domainOfValidity' of XML schema type 'gml:domainOfValidity'
        std::vector<_gml__domainOfValidity *> domainOfValidity;
        /// Required element 'gml:scope' of XML schema type 'xsd:string'
        std::vector<std::string> scope;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractCRSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractCRSType, default initialized and not managed by a soap context
        virtual gml__AbstractCRSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractCRSType); }
      public:
        /// Constructor with default initializations
        gml__AbstractCRSType() : domainOfValidity(), scope() { }
        virtual ~gml__AbstractCRSType() { }
        /// Friend allocator used by soap_new_gml__AbstractCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractCRSType * SOAP_FMAC2 soap_instantiate_gml__AbstractCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:34991 */
#ifndef SOAP_TYPE_plu__gml__union_AbstractDatumType
#define SOAP_TYPE_plu__gml__union_AbstractDatumType (-2272)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_AbstractDatumType
{
        #define SOAP_UNION_plu__gml__union_AbstractDatumType_anchorDefinition	(1)	/**< union variant selector value for member anchorDefinition */
        gml__CodeType *anchorDefinition;
        #define SOAP_UNION_plu__gml__union_AbstractDatumType_anchorPoint	(2)	/**< union variant selector value for member anchorPoint */
        gml__CodeType *anchorPoint;
};
#endif

/* PlannedLandUse_v3.0.h:1151 */
#ifndef SOAP_TYPE_plu_gml__AbstractDatumType
#define SOAP_TYPE_plu_gml__AbstractDatumType (-338)
/* complex XML schema type 'gml:AbstractDatumType': */
class SOAP_CMAC gml__AbstractDatumType : public gml__IdentifiedObjectType {
      public:
        /// Optional element 'gml:domainOfValidity' of XML schema type 'gml:domainOfValidity'
        _gml__domainOfValidity *domainOfValidity;
        /// Required element 'gml:scope' of XML schema type 'xsd:string'
        std::vector<std::string> scope;
        /// Union with union _gml__union_AbstractDatumType variant selector __unionanchorDefinition set to one of: SOAP_UNION_plu__gml__union_AbstractDatumType_anchorDefinition SOAP_UNION_plu__gml__union_AbstractDatumType_anchorPoint
        int __unionanchorDefinition;
        union _gml__union_AbstractDatumType union_AbstractDatumType;
        /// Optional element 'gml:realizationEpoch' of XML schema type 'xsd:date'
        char **realizationEpoch;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractDatumType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractDatumType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractDatumType, default initialized and not managed by a soap context
        virtual gml__AbstractDatumType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractDatumType); }
      public:
        /// Constructor with default initializations
        gml__AbstractDatumType() : domainOfValidity(), scope(), __unionanchorDefinition(), realizationEpoch() { }
        virtual ~gml__AbstractDatumType() { }
        /// Friend allocator used by soap_new_gml__AbstractDatumType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractDatumType * SOAP_FMAC2 soap_instantiate_gml__AbstractDatumType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1163 */
#ifndef SOAP_TYPE_plu_gml__EllipsoidType
#define SOAP_TYPE_plu_gml__EllipsoidType (-342)
/* complex XML schema type 'gml:EllipsoidType': */
class SOAP_CMAC gml__EllipsoidType : public gml__IdentifiedObjectType {
      public:
        /// Required element 'gml:semiMajorAxis' of XML schema type 'gml:MeasureType'
        gml__MeasureType *semiMajorAxis;
        /// Required element 'gml:secondDefiningParameter' of XML schema type 'gml:secondDefiningParameter'
        _gml__secondDefiningParameter *secondDefiningParameter;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__EllipsoidType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__EllipsoidType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__EllipsoidType, default initialized and not managed by a soap context
        virtual gml__EllipsoidType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__EllipsoidType); }
      public:
        /// Constructor with default initializations
        gml__EllipsoidType() : semiMajorAxis(), secondDefiningParameter() { }
        virtual ~gml__EllipsoidType() { }
        /// Friend allocator used by soap_new_gml__EllipsoidType(struct soap*, int)
        friend SOAP_FMAC1 gml__EllipsoidType * SOAP_FMAC2 soap_instantiate_gml__EllipsoidType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1169 */
#ifndef SOAP_TYPE_plu_gml__PrimeMeridianType
#define SOAP_TYPE_plu_gml__PrimeMeridianType (-344)
/* complex XML schema type 'gml:PrimeMeridianType': */
class SOAP_CMAC gml__PrimeMeridianType : public gml__IdentifiedObjectType {
      public:
        /// Required element 'gml:greenwichLongitude' of XML schema type 'gml:AngleType'
        gml__AngleType *greenwichLongitude;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__PrimeMeridianType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__PrimeMeridianType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__PrimeMeridianType, default initialized and not managed by a soap context
        virtual gml__PrimeMeridianType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__PrimeMeridianType); }
      public:
        /// Constructor with default initializations
        gml__PrimeMeridianType() : greenwichLongitude() { }
        virtual ~gml__PrimeMeridianType() { }
        /// Friend allocator used by soap_new_gml__PrimeMeridianType(struct soap*, int)
        friend SOAP_FMAC1 gml__PrimeMeridianType * SOAP_FMAC2 soap_instantiate_gml__PrimeMeridianType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1202 */
#ifndef SOAP_TYPE_plu_gml__AbstractCoordinateOperationType
#define SOAP_TYPE_plu_gml__AbstractCoordinateOperationType (-355)
/* complex XML schema type 'gml:AbstractCoordinateOperationType': */
class SOAP_CMAC gml__AbstractCoordinateOperationType : public gml__IdentifiedObjectType {
      public:
        /// Optional element 'gml:domainOfValidity' of XML schema type 'gml:domainOfValidity'
        _gml__domainOfValidity *domainOfValidity;
        /// Required element 'gml:scope' of XML schema type 'xsd:string'
        std::vector<std::string> scope;
        /// Optional element 'gml:operationVersion' of XML schema type 'xsd:string'
        std::string *operationVersion;
        /// Optional element 'gml:coordinateOperationAccuracy' of XML schema type 'gml:coordinateOperationAccuracy'
        std::vector<_gml__coordinateOperationAccuracy *> coordinateOperationAccuracy;
        /// Optional element 'gml:sourceCRS' of XML schema type 'gml:CRSPropertyType'
        gml__CRSPropertyType *sourceCRS;
        /// Optional element 'gml:targetCRS' of XML schema type 'gml:CRSPropertyType'
        gml__CRSPropertyType *targetCRS;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractCoordinateOperationType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractCoordinateOperationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractCoordinateOperationType, default initialized and not managed by a soap context
        virtual gml__AbstractCoordinateOperationType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractCoordinateOperationType); }
      public:
        /// Constructor with default initializations
        gml__AbstractCoordinateOperationType() : domainOfValidity(), scope(), operationVersion(), coordinateOperationAccuracy(), sourceCRS(), targetCRS() { }
        virtual ~gml__AbstractCoordinateOperationType() { }
        /// Friend allocator used by soap_new_gml__AbstractCoordinateOperationType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractCoordinateOperationType * SOAP_FMAC2 soap_instantiate_gml__AbstractCoordinateOperationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:35156 */
#ifndef SOAP_TYPE_plu__gml__union_OperationMethodType
#define SOAP_TYPE_plu__gml__union_OperationMethodType (-2278)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_OperationMethodType
{
        #define SOAP_UNION_plu__gml__union_OperationMethodType_formulaCitation	(1)	/**< union variant selector value for member formulaCitation */
        _gml__formulaCitation *formulaCitation;
        #define SOAP_UNION_plu__gml__union_OperationMethodType_formula	(2)	/**< union variant selector value for member formula */
        gml__CodeType *formula;
        #define SOAP_UNION_plu__gml__union_OperationMethodType_methodFormula	(3)	/**< union variant selector value for member methodFormula */
        gml__CodeType *methodFormula;
};
#endif

/* PlannedLandUse_v3.0.h:35196 */
#ifndef SOAP_TYPE_plu__gml__union_OperationMethodType__
#define SOAP_TYPE_plu__gml__union_OperationMethodType__ (-2281)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_OperationMethodType__
{
        #define SOAP_UNION_plu__gml__union_OperationMethodType___parameter	(1)	/**< union variant selector value for member parameter */
        std::vector<gml__AbstractGeneralOperationParameterPropertyType *> *parameter;
        #define SOAP_UNION_plu__gml__union_OperationMethodType___includesParameter	(2)	/**< union variant selector value for member includesParameter */
        gml__AbstractGeneralOperationParameterPropertyType *includesParameter;
        #define SOAP_UNION_plu__gml__union_OperationMethodType___generalOperationParameter	(3)	/**< union variant selector value for member generalOperationParameter */
        gml__AbstractGeneralOperationParameterPropertyType *generalOperationParameter;
        #define SOAP_UNION_plu__gml__union_OperationMethodType___usesParameter	(4)	/**< union variant selector value for member usesParameter */
        gml__AbstractGeneralOperationParameterPropertyType *usesParameter;
};
#endif

/* PlannedLandUse_v3.0.h:35191 */
#ifndef SOAP_TYPE_plu___gml__union_OperationMethodType__
#define SOAP_TYPE_plu___gml__union_OperationMethodType__ (-2280)
/* Wrapper: */
class SOAP_CMAC __gml__union_OperationMethodType__ {
      public:
        /// Union with union _gml__union_OperationMethodType__ variant selector __unionparameter set to one of: SOAP_UNION_plu__gml__union_OperationMethodType___parameter SOAP_UNION_plu__gml__union_OperationMethodType___includesParameter SOAP_UNION_plu__gml__union_OperationMethodType___generalOperationParameter SOAP_UNION_plu__gml__union_OperationMethodType___usesParameter
        int __unionparameter;
        union _gml__union_OperationMethodType__ union_OperationMethodType__;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_OperationMethodType__
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_OperationMethodType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_OperationMethodType__, default initialized and not managed by a soap context
        virtual __gml__union_OperationMethodType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_OperationMethodType__); }
      public:
        /// Constructor with default initializations
        __gml__union_OperationMethodType__() : __unionparameter() { }
        virtual ~__gml__union_OperationMethodType__() { }
        /// Friend allocator used by soap_new___gml__union_OperationMethodType__(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_OperationMethodType__ * SOAP_FMAC2 soap_instantiate___gml__union_OperationMethodType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1259 */
#ifndef SOAP_TYPE_plu_gml__OperationMethodType
#define SOAP_TYPE_plu_gml__OperationMethodType (-374)
/* complex XML schema type 'gml:OperationMethodType': */
class SOAP_CMAC gml__OperationMethodType : public gml__IdentifiedObjectType {
      public:
        /// Union with union _gml__union_OperationMethodType variant selector __union_OperationMethodType set to one of: SOAP_UNION_plu__gml__union_OperationMethodType_formulaCitation SOAP_UNION_plu__gml__union_OperationMethodType_formula SOAP_UNION_plu__gml__union_OperationMethodType_methodFormula
        int __union_OperationMethodType;
        union _gml__union_OperationMethodType union_OperationMethodType;
        /// Optional element 'gml:sourceDimensions' of XML schema type 'xsd:positiveInteger'
        ULONG64 *sourceDimensions;
        /// Optional element 'gml:targetDimensions' of XML schema type 'xsd:positiveInteger'
        ULONG64 *targetDimensions;
        /// Sequence of elements '-union-OperationMethodType' of XML schema type '-gml:union-OperationMethodType' stored in dynamic array __union_OperationMethodType__ of length __sizeparameter
        int __sizeparameter;
        __gml__union_OperationMethodType__ *__union_OperationMethodType__;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__OperationMethodType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__OperationMethodType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__OperationMethodType, default initialized and not managed by a soap context
        virtual gml__OperationMethodType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__OperationMethodType); }
      public:
        /// Constructor with default initializations
        gml__OperationMethodType() : __union_OperationMethodType(), sourceDimensions(), targetDimensions(), __sizeparameter(), __union_OperationMethodType__() { }
        virtual ~gml__OperationMethodType() { }
        /// Friend allocator used by soap_new_gml__OperationMethodType(struct soap*, int)
        friend SOAP_FMAC1 gml__OperationMethodType * SOAP_FMAC2 soap_instantiate_gml__OperationMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1265 */
#ifndef SOAP_TYPE_plu_gml__AbstractGeneralOperationParameterType
#define SOAP_TYPE_plu_gml__AbstractGeneralOperationParameterType (-376)
/* complex XML schema type 'gml:AbstractGeneralOperationParameterType': */
class SOAP_CMAC gml__AbstractGeneralOperationParameterType : public gml__IdentifiedObjectType {
      public:
        /// Optional element 'gml:minimumOccurs' of XML schema type 'xsd:nonNegativeInteger'
        ULONG64 *minimumOccurs;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractGeneralOperationParameterType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractGeneralOperationParameterType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractGeneralOperationParameterType, default initialized and not managed by a soap context
        virtual gml__AbstractGeneralOperationParameterType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractGeneralOperationParameterType); }
      public:
        /// Constructor with default initializations
        gml__AbstractGeneralOperationParameterType() : minimumOccurs() { }
        virtual ~gml__AbstractGeneralOperationParameterType() { }
        /// Friend allocator used by soap_new_gml__AbstractGeneralOperationParameterType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractGeneralOperationParameterType * SOAP_FMAC2 soap_instantiate_gml__AbstractGeneralOperationParameterType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1298 */
#ifndef SOAP_TYPE_plu_gml__DirectedObservationAtDistanceType
#define SOAP_TYPE_plu_gml__DirectedObservationAtDistanceType (-387)
/* Type gml__DirectedObservationAtDistanceType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gml:DirectedObservationAtDistanceType': */
class SOAP_CMAC gml__DirectedObservationAtDistanceType : public gml__DirectedObservationType {
      public:
        /// Required element 'gml:distance' of XML schema type 'gml:MeasureType'
        gml__MeasureType *distance;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DirectedObservationAtDistanceType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DirectedObservationAtDistanceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DirectedObservationAtDistanceType, default initialized and not managed by a soap context
        virtual gml__DirectedObservationAtDistanceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DirectedObservationAtDistanceType); }
      public:
        /// Constructor with default initializations
        gml__DirectedObservationAtDistanceType() : distance() { }
        virtual ~gml__DirectedObservationAtDistanceType() { }
        /// Friend allocator used by soap_new_gml__DirectedObservationAtDistanceType(struct soap*, int)
        friend SOAP_FMAC1 gml__DirectedObservationAtDistanceType * SOAP_FMAC2 soap_instantiate_gml__DirectedObservationAtDistanceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:35367 */
#ifndef SOAP_TYPE_plu__gml__union_TimeCoordinateSystemType
#define SOAP_TYPE_plu__gml__union_TimeCoordinateSystemType (-2287)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_TimeCoordinateSystemType
{
        #define SOAP_UNION_plu__gml__union_TimeCoordinateSystemType_originPosition	(1)	/**< union variant selector value for member originPosition */
        gml__TimePositionType *originPosition;
        #define SOAP_UNION_plu__gml__union_TimeCoordinateSystemType_origin	(2)	/**< union variant selector value for member origin */
        gml__TimeInstantPropertyType *origin;
};
#endif

/* PlannedLandUse_v3.0.h:1313 */
#ifndef SOAP_TYPE_plu_gml__TimeCoordinateSystemType
#define SOAP_TYPE_plu_gml__TimeCoordinateSystemType (-392)
/* complex XML schema type 'gml:TimeCoordinateSystemType': */
class SOAP_CMAC gml__TimeCoordinateSystemType : public gml__TimeReferenceSystemType {
      public:
        /// Union with union _gml__union_TimeCoordinateSystemType variant selector __union_TimeCoordinateSystemType set to one of: SOAP_UNION_plu__gml__union_TimeCoordinateSystemType_originPosition SOAP_UNION_plu__gml__union_TimeCoordinateSystemType_origin
        int __union_TimeCoordinateSystemType;
        union _gml__union_TimeCoordinateSystemType union_TimeCoordinateSystemType;
        /// Required element 'gml:interval' of XML schema type 'gml:TimeIntervalLengthType'
        gml__TimeIntervalLengthType *interval;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeCoordinateSystemType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeCoordinateSystemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeCoordinateSystemType, default initialized and not managed by a soap context
        virtual gml__TimeCoordinateSystemType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeCoordinateSystemType); }
      public:
        /// Constructor with default initializations
        gml__TimeCoordinateSystemType() : __union_TimeCoordinateSystemType(), interval() { }
        virtual ~gml__TimeCoordinateSystemType() { }
        /// Friend allocator used by soap_new_gml__TimeCoordinateSystemType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeCoordinateSystemType * SOAP_FMAC2 soap_instantiate_gml__TimeCoordinateSystemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1316 */
#ifndef SOAP_TYPE_plu_gml__TimeCalendarType
#define SOAP_TYPE_plu_gml__TimeCalendarType (-393)
/* complex XML schema type 'gml:TimeCalendarType': */
class SOAP_CMAC gml__TimeCalendarType : public gml__TimeReferenceSystemType {
      public:
        /// Required element 'gml:referenceFrame' of XML schema type 'gml:TimeCalendarEraPropertyType'
        std::vector<gml__TimeCalendarEraPropertyType *> referenceFrame;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeCalendarType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeCalendarType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeCalendarType, default initialized and not managed by a soap context
        virtual gml__TimeCalendarType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeCalendarType); }
      public:
        /// Constructor with default initializations
        gml__TimeCalendarType() : referenceFrame() { }
        virtual ~gml__TimeCalendarType() { }
        /// Friend allocator used by soap_new_gml__TimeCalendarType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeCalendarType * SOAP_FMAC2 soap_instantiate_gml__TimeCalendarType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1328 */
#ifndef SOAP_TYPE_plu_gml__TimeClockType
#define SOAP_TYPE_plu_gml__TimeClockType (-397)
/* complex XML schema type 'gml:TimeClockType': */
class SOAP_CMAC gml__TimeClockType : public gml__TimeReferenceSystemType {
      public:
        /// Required element 'gml:referenceEvent' of XML schema type 'gml:StringOrRefType'
        gml__StringOrRefType *referenceEvent;
        /// Required element 'gml:referenceTime' of XML schema type 'xsd:time'
        char *referenceTime;
        /// Required element 'gml:utcReference' of XML schema type 'xsd:time'
        char *utcReference;
        /// Optional element 'gml:dateBasis' of XML schema type 'gml:TimeCalendarPropertyType'
        std::vector<gml__TimeCalendarPropertyType *> dateBasis;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeClockType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeClockType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeClockType, default initialized and not managed by a soap context
        virtual gml__TimeClockType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeClockType); }
      public:
        /// Constructor with default initializations
        gml__TimeClockType() : referenceEvent(), referenceTime(), utcReference(), dateBasis() { }
        virtual ~gml__TimeClockType() { }
        /// Friend allocator used by soap_new_gml__TimeClockType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeClockType * SOAP_FMAC2 soap_instantiate_gml__TimeClockType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1334 */
#ifndef SOAP_TYPE_plu_gml__TimeOrdinalReferenceSystemType
#define SOAP_TYPE_plu_gml__TimeOrdinalReferenceSystemType (-399)
/* complex XML schema type 'gml:TimeOrdinalReferenceSystemType': */
class SOAP_CMAC gml__TimeOrdinalReferenceSystemType : public gml__TimeReferenceSystemType {
      public:
        /// Required element 'gml:component' of XML schema type 'gml:TimeOrdinalEraPropertyType'
        std::vector<gml__TimeOrdinalEraPropertyType *> component;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeOrdinalReferenceSystemType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeOrdinalReferenceSystemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeOrdinalReferenceSystemType, default initialized and not managed by a soap context
        virtual gml__TimeOrdinalReferenceSystemType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeOrdinalReferenceSystemType); }
      public:
        /// Constructor with default initializations
        gml__TimeOrdinalReferenceSystemType() : component() { }
        virtual ~gml__TimeOrdinalReferenceSystemType() { }
        /// Friend allocator used by soap_new_gml__TimeOrdinalReferenceSystemType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeOrdinalReferenceSystemType * SOAP_FMAC2 soap_instantiate_gml__TimeOrdinalReferenceSystemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1355 */
#ifndef SOAP_TYPE_plu_gml__TimeNodeType
#define SOAP_TYPE_plu_gml__TimeNodeType (-406)
/* complex XML schema type 'gml:TimeNodeType': */
class SOAP_CMAC gml__TimeNodeType : public gml__AbstractTimeTopologyPrimitiveType {
      public:
        /// Optional element 'gml:previousEdge' of XML schema type 'gml:TimeEdgePropertyType'
        std::vector<gml__TimeEdgePropertyType *> previousEdge;
        /// Optional element 'gml:nextEdge' of XML schema type 'gml:TimeEdgePropertyType'
        std::vector<gml__TimeEdgePropertyType *> nextEdge;
        /// Optional element 'gml:position' of XML schema type 'gml:TimeInstantPropertyType'
        gml__TimeInstantPropertyType *position;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeNodeType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeNodeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeNodeType, default initialized and not managed by a soap context
        virtual gml__TimeNodeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeNodeType); }
      public:
        /// Constructor with default initializations
        gml__TimeNodeType() : previousEdge(), nextEdge(), position() { }
        virtual ~gml__TimeNodeType() { }
        /// Friend allocator used by soap_new_gml__TimeNodeType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeNodeType * SOAP_FMAC2 soap_instantiate_gml__TimeNodeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1361 */
#ifndef SOAP_TYPE_plu_gml__TimeEdgeType
#define SOAP_TYPE_plu_gml__TimeEdgeType (-408)
/* complex XML schema type 'gml:TimeEdgeType': */
class SOAP_CMAC gml__TimeEdgeType : public gml__AbstractTimeTopologyPrimitiveType {
      public:
        /// Required element 'gml:start' of XML schema type 'gml:TimeNodePropertyType'
        gml__TimeNodePropertyType *start;
        /// Required element 'gml:end' of XML schema type 'gml:TimeNodePropertyType'
        gml__TimeNodePropertyType *end;
        /// Optional element 'gml:extent' of XML schema type 'gml:TimePeriodPropertyType'
        gml__TimePeriodPropertyType *extent;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeEdgeType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeEdgeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeEdgeType, default initialized and not managed by a soap context
        virtual gml__TimeEdgeType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeEdgeType); }
      public:
        /// Constructor with default initializations
        gml__TimeEdgeType() : start(), end(), extent() { }
        virtual ~gml__TimeEdgeType() { }
        /// Friend allocator used by soap_new_gml__TimeEdgeType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeEdgeType * SOAP_FMAC2 soap_instantiate_gml__TimeEdgeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:671 */
#ifndef SOAP_TYPE_plu_gml__RingType
#define SOAP_TYPE_plu_gml__RingType (-178)
/* complex XML schema type 'gml:RingType': */
class SOAP_CMAC gml__RingType : public gml__AbstractRingType {
      public:
        /// Required element 'gml:curveMember' of XML schema type 'gml:CurvePropertyType'
        std::vector<gml__CurvePropertyType *> curveMember;
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__RingType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__RingType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__RingType, default initialized and not managed by a soap context
        virtual gml__RingType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__RingType); }
      public:
        /// Constructor with default initializations
        gml__RingType() : curveMember(), aggregationType() { }
        virtual ~gml__RingType() { }
        /// Friend allocator used by soap_new_gml__RingType(struct soap*, int)
        friend SOAP_FMAC1 gml__RingType * SOAP_FMAC2 soap_instantiate_gml__RingType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:35785 */
#ifndef SOAP_TYPE_plu__gml__union_TinType_controlPoint_
#define SOAP_TYPE_plu__gml__union_TinType_controlPoint_ (-2298)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_TinType_controlPoint_
{
        #define SOAP_UNION_plu__gml__union_TinType_controlPoint__pos	(1)	/**< union variant selector value for member pos */
        gml__DirectPositionType *pos;
        #define SOAP_UNION_plu__gml__union_TinType_controlPoint__pointProperty	(2)	/**< union variant selector value for member pointProperty */
        gml__PointPropertyType *pointProperty;
};
#endif

/* PlannedLandUse_v3.0.h:35781 */
#ifndef SOAP_TYPE_plu___gml__union_TinType_controlPoint_
#define SOAP_TYPE_plu___gml__union_TinType_controlPoint_ (-2297)
/* Wrapper: */
class SOAP_CMAC __gml__union_TinType_controlPoint_ {
      public:
        /// Union with union _gml__union_TinType_controlPoint_ variant selector __union_TinType_controlPoint_ set to one of: SOAP_UNION_plu__gml__union_TinType_controlPoint__pos SOAP_UNION_plu__gml__union_TinType_controlPoint__pointProperty
        int __union_TinType_controlPoint_;
        union _gml__union_TinType_controlPoint_ union_TinType_controlPoint_;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_TinType_controlPoint_
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_TinType_controlPoint_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_TinType_controlPoint_, default initialized and not managed by a soap context
        virtual __gml__union_TinType_controlPoint_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_TinType_controlPoint_); }
      public:
        /// Constructor with default initializations
        __gml__union_TinType_controlPoint_() : __union_TinType_controlPoint_() { }
        virtual ~__gml__union_TinType_controlPoint_() { }
        /// Friend allocator used by soap_new___gml__union_TinType_controlPoint_(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_TinType_controlPoint_ * SOAP_FMAC2 soap_instantiate___gml__union_TinType_controlPoint_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:35767 */
#ifndef SOAP_TYPE_plu__gml__TinType_controlPoint
#define SOAP_TYPE_plu__gml__TinType_controlPoint (-2296)
/* complex XML schema type 'gml:TinType-controlPoint': */
class SOAP_CMAC _gml__TinType_controlPoint {
      public:
        /// Optional element 'gml:posList' of XML schema type 'gml:DirectPositionListType'
        gml__DirectPositionListType *posList;
        /// Sequence of at least 3 elements '-union-TinType-controlPoint' of XML schema type '-gml:union-TinType-controlPoint' stored in dynamic array __union_TinType_controlPoint_ of length __size_TinType_controlPoint_
        int __size_TinType_controlPoint_;
        __gml__union_TinType_controlPoint_ *__union_TinType_controlPoint_;
      public:
        /// Return unique type id SOAP_TYPE_plu__gml__TinType_controlPoint
        virtual long soap_type(void) const { return SOAP_TYPE_plu__gml__TinType_controlPoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _gml__TinType_controlPoint, default initialized and not managed by a soap context
        virtual _gml__TinType_controlPoint *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_gml__TinType_controlPoint); }
      public:
        /// Constructor with default initializations
        _gml__TinType_controlPoint() : posList(), __size_TinType_controlPoint_(), __union_TinType_controlPoint_() { }
        virtual ~_gml__TinType_controlPoint() { }
        /// Friend allocator used by soap_new__gml__TinType_controlPoint(struct soap*, int)
        friend SOAP_FMAC1 _gml__TinType_controlPoint * SOAP_FMAC2 soap_instantiate__gml__TinType_controlPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:692 */
#ifndef SOAP_TYPE_plu_gml__TinType
#define SOAP_TYPE_plu_gml__TinType (-185)
/* complex XML schema type 'gml:TinType': */
class SOAP_CMAC gml__TinType : public gml__SurfaceType {
      public:
        /// Optional element 'gml:stopLines' of XML schema type 'gml:LineStringSegmentArrayPropertyType'
        std::vector<gml__LineStringSegmentArrayPropertyType *> stopLines;
        /// Optional element 'gml:breakLines' of XML schema type 'gml:LineStringSegmentArrayPropertyType'
        std::vector<gml__LineStringSegmentArrayPropertyType *> breakLines;
        /// Required element 'gml:maxLength' of XML schema type 'gml:LengthType'
        gml__LengthType *maxLength;
        /// Required element 'gml:controlPoint' of XML schema type 'gml:TinType-controlPoint'
        _gml__TinType_controlPoint controlPoint;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TinType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TinType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TinType, default initialized and not managed by a soap context
        virtual gml__TinType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TinType); }
      public:
        /// Constructor with default initializations
        gml__TinType() : stopLines(), breakLines(), maxLength(), controlPoint() { }
        virtual ~gml__TinType() { }
        /// Friend allocator used by soap_new_gml__TinType(struct soap*, int)
        friend SOAP_FMAC1 gml__TinType * SOAP_FMAC2 soap_instantiate_gml__TinType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:35878 */
#ifndef SOAP_TYPE_plu__gml__union_LinearRingType_
#define SOAP_TYPE_plu__gml__union_LinearRingType_ (-2303)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_LinearRingType_
{
        #define SOAP_UNION_plu__gml__union_LinearRingType__pos	(1)	/**< union variant selector value for member pos */
        gml__DirectPositionType *pos;
        #define SOAP_UNION_plu__gml__union_LinearRingType__pointProperty	(2)	/**< union variant selector value for member pointProperty */
        gml__PointPropertyType *pointProperty;
        #define SOAP_UNION_plu__gml__union_LinearRingType__pointRep	(3)	/**< union variant selector value for member pointRep */
        gml__PointPropertyType *pointRep;
};
#endif

/* PlannedLandUse_v3.0.h:35874 */
#ifndef SOAP_TYPE_plu___gml__union_LinearRingType_
#define SOAP_TYPE_plu___gml__union_LinearRingType_ (-2302)
/* Wrapper: */
class SOAP_CMAC __gml__union_LinearRingType_ {
      public:
        /// Union with union _gml__union_LinearRingType_ variant selector __union_LinearRingType_ set to one of: SOAP_UNION_plu__gml__union_LinearRingType__pos SOAP_UNION_plu__gml__union_LinearRingType__pointProperty SOAP_UNION_plu__gml__union_LinearRingType__pointRep
        int __union_LinearRingType_;
        union _gml__union_LinearRingType_ union_LinearRingType_;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_LinearRingType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_LinearRingType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_LinearRingType_, default initialized and not managed by a soap context
        virtual __gml__union_LinearRingType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_LinearRingType_); }
      public:
        /// Constructor with default initializations
        __gml__union_LinearRingType_() : __union_LinearRingType_() { }
        virtual ~__gml__union_LinearRingType_() { }
        /// Friend allocator used by soap_new___gml__union_LinearRingType_(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_LinearRingType_ * SOAP_FMAC2 soap_instantiate___gml__union_LinearRingType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:35872 */
#ifndef SOAP_TYPE_plu____gml__union_LinearRingType_
#define SOAP_TYPE_plu____gml__union_LinearRingType_ (-2301)
/* Wrapper: */
struct SOAP_CMAC ___gml__union_LinearRingType_ {
      public:
        /** Sequence of at least 4 elements '-union-LinearRingType' of XML schema type '-gml:union-LinearRingType' stored in dynamic array __union_LinearRingType_ of length __size_LinearRingType_ */
        int __size_LinearRingType_;
        __gml__union_LinearRingType_ *__union_LinearRingType_;
      public:
        /** Return unique type id SOAP_TYPE_plu____gml__union_LinearRingType_ */
        long soap_type() const { return SOAP_TYPE_plu____gml__union_LinearRingType_; }
        /** Friend allocator */
        friend SOAP_FMAC1 ___gml__union_LinearRingType_ * SOAP_FMAC2 soap_instantiate____gml__union_LinearRingType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:35869 */
#ifndef SOAP_TYPE_plu__gml__union_LinearRingType
#define SOAP_TYPE_plu__gml__union_LinearRingType (-2300)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_LinearRingType
{
        #define SOAP_UNION_plu__gml__union_LinearRingType___union_LinearRingType_	(1)	/**< union variant selector value for member __union_LinearRingType_ */
        struct ___gml__union_LinearRingType_ __union_LinearRingType_;
        #define SOAP_UNION_plu__gml__union_LinearRingType_posList	(2)	/**< union variant selector value for member posList */
        gml__DirectPositionListType *posList;
        #define SOAP_UNION_plu__gml__union_LinearRingType_coordinates	(3)	/**< union variant selector value for member coordinates */
        gml__CoordinatesType *coordinates;
};
#endif

/* PlannedLandUse_v3.0.h:734 */
#ifndef SOAP_TYPE_plu_gml__LinearRingType
#define SOAP_TYPE_plu_gml__LinearRingType (-199)
/* complex XML schema type 'gml:LinearRingType': */
class SOAP_CMAC gml__LinearRingType : public gml__AbstractRingType {
      public:
        /// Union with union _gml__union_LinearRingType variant selector __union_LinearRingType set to one of: SOAP_UNION_plu__gml__union_LinearRingType___union_LinearRingType_ SOAP_UNION_plu__gml__union_LinearRingType_posList SOAP_UNION_plu__gml__union_LinearRingType_coordinates
        int __union_LinearRingType;
        union _gml__union_LinearRingType union_LinearRingType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__LinearRingType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__LinearRingType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__LinearRingType, default initialized and not managed by a soap context
        virtual gml__LinearRingType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__LinearRingType); }
      public:
        /// Constructor with default initializations
        gml__LinearRingType() : __union_LinearRingType() { }
        virtual ~gml__LinearRingType() { }
        /// Friend allocator used by soap_new_gml__LinearRingType(struct soap*, int)
        friend SOAP_FMAC1 gml__LinearRingType * SOAP_FMAC2 soap_instantiate_gml__LinearRingType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:35941 */
#ifndef SOAP_TYPE_plu__gml__union_AbstractGeneralDerivedCRSType
#define SOAP_TYPE_plu__gml__union_AbstractGeneralDerivedCRSType (-2305)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_AbstractGeneralDerivedCRSType
{
        #define SOAP_UNION_plu__gml__union_AbstractGeneralDerivedCRSType_conversion	(1)	/**< union variant selector value for member conversion */
        gml__GeneralConversionPropertyType *conversion;
        #define SOAP_UNION_plu__gml__union_AbstractGeneralDerivedCRSType_definedByConversion	(2)	/**< union variant selector value for member definedByConversion */
        gml__GeneralConversionPropertyType *definedByConversion;
};
#endif

/* PlannedLandUse_v3.0.h:1019 */
#ifndef SOAP_TYPE_plu_gml__AbstractGeneralDerivedCRSType
#define SOAP_TYPE_plu_gml__AbstractGeneralDerivedCRSType (-294)
/* complex XML schema type 'gml:AbstractGeneralDerivedCRSType': */
class SOAP_CMAC gml__AbstractGeneralDerivedCRSType : public gml__AbstractCRSType {
      public:
        /// Union with union _gml__union_AbstractGeneralDerivedCRSType variant selector __unionconversion set to one of: SOAP_UNION_plu__gml__union_AbstractGeneralDerivedCRSType_conversion SOAP_UNION_plu__gml__union_AbstractGeneralDerivedCRSType_definedByConversion
        int __unionconversion;
        union _gml__union_AbstractGeneralDerivedCRSType union_AbstractGeneralDerivedCRSType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractGeneralDerivedCRSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractGeneralDerivedCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractGeneralDerivedCRSType, default initialized and not managed by a soap context
        virtual gml__AbstractGeneralDerivedCRSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractGeneralDerivedCRSType); }
      public:
        /// Constructor with default initializations
        gml__AbstractGeneralDerivedCRSType() : __unionconversion() { }
        virtual ~gml__AbstractGeneralDerivedCRSType() { }
        /// Friend allocator used by soap_new_gml__AbstractGeneralDerivedCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractGeneralDerivedCRSType * SOAP_FMAC2 soap_instantiate_gml__AbstractGeneralDerivedCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:35997 */
#ifndef SOAP_TYPE_plu__gml__union_CompoundCRSType
#define SOAP_TYPE_plu__gml__union_CompoundCRSType (-2308)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_CompoundCRSType
{
        #define SOAP_UNION_plu__gml__union_CompoundCRSType_componentReferenceSystem	(1)	/**< union variant selector value for member componentReferenceSystem */
        std::vector<gml__SingleCRSPropertyType *> *componentReferenceSystem;
        #define SOAP_UNION_plu__gml__union_CompoundCRSType_includesSingleCRS	(2)	/**< union variant selector value for member includesSingleCRS */
        gml__SingleCRSPropertyType *includesSingleCRS;
};
#endif

/* PlannedLandUse_v3.0.h:35992 */
#ifndef SOAP_TYPE_plu___gml__union_CompoundCRSType
#define SOAP_TYPE_plu___gml__union_CompoundCRSType (-2307)
/* Wrapper: */
class SOAP_CMAC __gml__union_CompoundCRSType {
      public:
        /// Union with union _gml__union_CompoundCRSType variant selector __unioncomponentReferenceSystem set to one of: SOAP_UNION_plu__gml__union_CompoundCRSType_componentReferenceSystem SOAP_UNION_plu__gml__union_CompoundCRSType_includesSingleCRS
        int __unioncomponentReferenceSystem;
        union _gml__union_CompoundCRSType union_CompoundCRSType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_CompoundCRSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_CompoundCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_CompoundCRSType, default initialized and not managed by a soap context
        virtual __gml__union_CompoundCRSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_CompoundCRSType); }
      public:
        /// Constructor with default initializations
        __gml__union_CompoundCRSType() : __unioncomponentReferenceSystem() { }
        virtual ~__gml__union_CompoundCRSType() { }
        /// Friend allocator used by soap_new___gml__union_CompoundCRSType(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_CompoundCRSType * SOAP_FMAC2 soap_instantiate___gml__union_CompoundCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1022 */
#ifndef SOAP_TYPE_plu_gml__CompoundCRSType
#define SOAP_TYPE_plu_gml__CompoundCRSType (-295)
/* complex XML schema type 'gml:CompoundCRSType': */
class SOAP_CMAC gml__CompoundCRSType : public gml__AbstractCRSType {
      public:
        /// Sequence of at least 2 elements '-union-CompoundCRSType' of XML schema type '-gml:union-CompoundCRSType' stored in dynamic array __union_CompoundCRSType of length __sizecomponentReferenceSystem
        int __sizecomponentReferenceSystem;
        __gml__union_CompoundCRSType *__union_CompoundCRSType;
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CompoundCRSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CompoundCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CompoundCRSType, default initialized and not managed by a soap context
        virtual gml__CompoundCRSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CompoundCRSType); }
      public:
        /// Constructor with default initializations
        gml__CompoundCRSType() : __sizecomponentReferenceSystem(), __union_CompoundCRSType(), aggregationType() { }
        virtual ~gml__CompoundCRSType() { }
        /// Friend allocator used by soap_new_gml__CompoundCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__CompoundCRSType * SOAP_FMAC2 soap_instantiate_gml__CompoundCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:36054 */
#ifndef SOAP_TYPE_plu__gml__union_GeodeticCRSType
#define SOAP_TYPE_plu__gml__union_GeodeticCRSType (-2313)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_GeodeticCRSType
{
        #define SOAP_UNION_plu__gml__union_GeodeticCRSType_ellipsoidalCS	(1)	/**< union variant selector value for member ellipsoidalCS */
        gml__EllipsoidalCSPropertyType *ellipsoidalCS;
        #define SOAP_UNION_plu__gml__union_GeodeticCRSType_usesEllipsoidalCS	(2)	/**< union variant selector value for member usesEllipsoidalCS */
        gml__EllipsoidalCSPropertyType *usesEllipsoidalCS;
        #define SOAP_UNION_plu__gml__union_GeodeticCRSType_cartesianCS	(3)	/**< union variant selector value for member cartesianCS */
        gml__CartesianCSPropertyType *cartesianCS;
        #define SOAP_UNION_plu__gml__union_GeodeticCRSType_usesCartesianCS	(4)	/**< union variant selector value for member usesCartesianCS */
        gml__CartesianCSPropertyType *usesCartesianCS;
        #define SOAP_UNION_plu__gml__union_GeodeticCRSType_sphericalCS	(5)	/**< union variant selector value for member sphericalCS */
        gml__SphericalCSPropertyType *sphericalCS;
        #define SOAP_UNION_plu__gml__union_GeodeticCRSType_usesSphericalCS	(6)	/**< union variant selector value for member usesSphericalCS */
        gml__SphericalCSPropertyType *usesSphericalCS;
};
#endif

/* PlannedLandUse_v3.0.h:36100 */
#ifndef SOAP_TYPE_plu__gml__union_GeodeticCRSType____
#define SOAP_TYPE_plu__gml__union_GeodeticCRSType____ (-2317)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_GeodeticCRSType____
{
        #define SOAP_UNION_plu__gml__union_GeodeticCRSType_____geodeticDatum	(1)	/**< union variant selector value for member geodeticDatum */
        gml__GeodeticDatumPropertyType *geodeticDatum;
        #define SOAP_UNION_plu__gml__union_GeodeticCRSType_____usesGeodeticDatum	(2)	/**< union variant selector value for member usesGeodeticDatum */
        gml__GeodeticDatumPropertyType *usesGeodeticDatum;
};
#endif

/* PlannedLandUse_v3.0.h:1028 */
#ifndef SOAP_TYPE_plu_gml__GeodeticCRSType
#define SOAP_TYPE_plu_gml__GeodeticCRSType (-297)
/* complex XML schema type 'gml:GeodeticCRSType': */
class SOAP_CMAC gml__GeodeticCRSType : public gml__AbstractCRSType {
      public:
        /// Union with union _gml__union_GeodeticCRSType variant selector __union_GeodeticCRSType set to one of: SOAP_UNION_plu__gml__union_GeodeticCRSType_ellipsoidalCS SOAP_UNION_plu__gml__union_GeodeticCRSType_usesEllipsoidalCS SOAP_UNION_plu__gml__union_GeodeticCRSType_cartesianCS SOAP_UNION_plu__gml__union_GeodeticCRSType_usesCartesianCS SOAP_UNION_plu__gml__union_GeodeticCRSType_sphericalCS SOAP_UNION_plu__gml__union_GeodeticCRSType_usesSphericalCS
        int __union_GeodeticCRSType;
        union _gml__union_GeodeticCRSType union_GeodeticCRSType;
        /// Union with union _gml__union_GeodeticCRSType____ variant selector __uniongeodeticDatum set to one of: SOAP_UNION_plu__gml__union_GeodeticCRSType_____geodeticDatum SOAP_UNION_plu__gml__union_GeodeticCRSType_____usesGeodeticDatum
        int __uniongeodeticDatum;
        union _gml__union_GeodeticCRSType____ union_GeodeticCRSType____;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GeodeticCRSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GeodeticCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeodeticCRSType, default initialized and not managed by a soap context
        virtual gml__GeodeticCRSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GeodeticCRSType); }
      public:
        /// Constructor with default initializations
        gml__GeodeticCRSType() : __union_GeodeticCRSType(), __uniongeodeticDatum() { }
        virtual ~gml__GeodeticCRSType() { }
        /// Friend allocator used by soap_new_gml__GeodeticCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeodeticCRSType * SOAP_FMAC2 soap_instantiate_gml__GeodeticCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:36153 */
#ifndef SOAP_TYPE_plu__gml__union_VerticalCRSType
#define SOAP_TYPE_plu__gml__union_VerticalCRSType (-2319)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_VerticalCRSType
{
        #define SOAP_UNION_plu__gml__union_VerticalCRSType_verticalCS	(1)	/**< union variant selector value for member verticalCS */
        gml__VerticalCSPropertyType *verticalCS;
        #define SOAP_UNION_plu__gml__union_VerticalCRSType_usesVerticalCS	(2)	/**< union variant selector value for member usesVerticalCS */
        gml__VerticalCSPropertyType *usesVerticalCS;
};
#endif

/* PlannedLandUse_v3.0.h:36170 */
#ifndef SOAP_TYPE_plu__gml__union_VerticalCRSType_
#define SOAP_TYPE_plu__gml__union_VerticalCRSType_ (-2321)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_VerticalCRSType_
{
        #define SOAP_UNION_plu__gml__union_VerticalCRSType__verticalDatum	(1)	/**< union variant selector value for member verticalDatum */
        gml__VerticalDatumPropertyType *verticalDatum;
        #define SOAP_UNION_plu__gml__union_VerticalCRSType__usesVerticalDatum	(2)	/**< union variant selector value for member usesVerticalDatum */
        gml__VerticalDatumPropertyType *usesVerticalDatum;
};
#endif

/* PlannedLandUse_v3.0.h:1034 */
#ifndef SOAP_TYPE_plu_gml__VerticalCRSType
#define SOAP_TYPE_plu_gml__VerticalCRSType (-299)
/* complex XML schema type 'gml:VerticalCRSType': */
class SOAP_CMAC gml__VerticalCRSType : public gml__AbstractCRSType {
      public:
        /// Union with union _gml__union_VerticalCRSType variant selector __unionverticalCS set to one of: SOAP_UNION_plu__gml__union_VerticalCRSType_verticalCS SOAP_UNION_plu__gml__union_VerticalCRSType_usesVerticalCS
        int __unionverticalCS;
        union _gml__union_VerticalCRSType union_VerticalCRSType;
        /// Union with union _gml__union_VerticalCRSType_ variant selector __unionverticalDatum set to one of: SOAP_UNION_plu__gml__union_VerticalCRSType__verticalDatum SOAP_UNION_plu__gml__union_VerticalCRSType__usesVerticalDatum
        int __unionverticalDatum;
        union _gml__union_VerticalCRSType_ union_VerticalCRSType_;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__VerticalCRSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__VerticalCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__VerticalCRSType, default initialized and not managed by a soap context
        virtual gml__VerticalCRSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__VerticalCRSType); }
      public:
        /// Constructor with default initializations
        gml__VerticalCRSType() : __unionverticalCS(), __unionverticalDatum() { }
        virtual ~gml__VerticalCRSType() { }
        /// Friend allocator used by soap_new_gml__VerticalCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__VerticalCRSType * SOAP_FMAC2 soap_instantiate_gml__VerticalCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:36219 */
#ifndef SOAP_TYPE_plu__gml__union_EngineeringCRSType
#define SOAP_TYPE_plu__gml__union_EngineeringCRSType (-2323)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_EngineeringCRSType
{
        #define SOAP_UNION_plu__gml__union_EngineeringCRSType_affineCS	(1)	/**< union variant selector value for member affineCS */
        gml__AffineCSPropertyType *affineCS;
        #define SOAP_UNION_plu__gml__union_EngineeringCRSType_usesAffineCS	(2)	/**< union variant selector value for member usesAffineCS */
        gml__AffineCSPropertyType *usesAffineCS;
        #define SOAP_UNION_plu__gml__union_EngineeringCRSType_cartesianCS	(3)	/**< union variant selector value for member cartesianCS */
        gml__CartesianCSPropertyType *cartesianCS;
        #define SOAP_UNION_plu__gml__union_EngineeringCRSType_usesCartesianCS	(4)	/**< union variant selector value for member usesCartesianCS */
        gml__CartesianCSPropertyType *usesCartesianCS;
        #define SOAP_UNION_plu__gml__union_EngineeringCRSType_cylindricalCS	(5)	/**< union variant selector value for member cylindricalCS */
        gml__CylindricalCSPropertyType *cylindricalCS;
        #define SOAP_UNION_plu__gml__union_EngineeringCRSType_linearCS	(6)	/**< union variant selector value for member linearCS */
        gml__LinearCSPropertyType *linearCS;
        #define SOAP_UNION_plu__gml__union_EngineeringCRSType_polarCS	(7)	/**< union variant selector value for member polarCS */
        gml__PolarCSPropertyType *polarCS;
        #define SOAP_UNION_plu__gml__union_EngineeringCRSType_sphericalCS	(8)	/**< union variant selector value for member sphericalCS */
        gml__SphericalCSPropertyType *sphericalCS;
        #define SOAP_UNION_plu__gml__union_EngineeringCRSType_usesSphericalCS	(9)	/**< union variant selector value for member usesSphericalCS */
        gml__SphericalCSPropertyType *usesSphericalCS;
        #define SOAP_UNION_plu__gml__union_EngineeringCRSType_userDefinedCS	(10)	/**< union variant selector value for member userDefinedCS */
        gml__UserDefinedCSPropertyType *userDefinedCS;
        #define SOAP_UNION_plu__gml__union_EngineeringCRSType_coordinateSystem	(11)	/**< union variant selector value for member coordinateSystem */
        gml__CoordinateSystemPropertyType *coordinateSystem;
        #define SOAP_UNION_plu__gml__union_EngineeringCRSType_usesCS	(12)	/**< union variant selector value for member usesCS */
        gml__CoordinateSystemPropertyType *usesCS;
};
#endif

/* PlannedLandUse_v3.0.h:36297 */
#ifndef SOAP_TYPE_plu__gml__union_EngineeringCRSType_____
#define SOAP_TYPE_plu__gml__union_EngineeringCRSType_____ (-2330)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_EngineeringCRSType_____
{
        #define SOAP_UNION_plu__gml__union_EngineeringCRSType______engineeringDatum	(1)	/**< union variant selector value for member engineeringDatum */
        gml__EngineeringDatumPropertyType *engineeringDatum;
        #define SOAP_UNION_plu__gml__union_EngineeringCRSType______usesEngineeringDatum	(2)	/**< union variant selector value for member usesEngineeringDatum */
        gml__EngineeringDatumPropertyType *usesEngineeringDatum;
};
#endif

/* PlannedLandUse_v3.0.h:1052 */
#ifndef SOAP_TYPE_plu_gml__EngineeringCRSType
#define SOAP_TYPE_plu_gml__EngineeringCRSType (-305)
/* complex XML schema type 'gml:EngineeringCRSType': */
class SOAP_CMAC gml__EngineeringCRSType : public gml__AbstractCRSType {
      public:
        /// Union with union _gml__union_EngineeringCRSType variant selector __union_EngineeringCRSType set to one of: SOAP_UNION_plu__gml__union_EngineeringCRSType_affineCS SOAP_UNION_plu__gml__union_EngineeringCRSType_usesAffineCS SOAP_UNION_plu__gml__union_EngineeringCRSType_cartesianCS SOAP_UNION_plu__gml__union_EngineeringCRSType_usesCartesianCS SOAP_UNION_plu__gml__union_EngineeringCRSType_cylindricalCS SOAP_UNION_plu__gml__union_EngineeringCRSType_linearCS SOAP_UNION_plu__gml__union_EngineeringCRSType_polarCS SOAP_UNION_plu__gml__union_EngineeringCRSType_sphericalCS SOAP_UNION_plu__gml__union_EngineeringCRSType_usesSphericalCS SOAP_UNION_plu__gml__union_EngineeringCRSType_userDefinedCS SOAP_UNION_plu__gml__union_EngineeringCRSType_coordinateSystem SOAP_UNION_plu__gml__union_EngineeringCRSType_usesCS
        int __union_EngineeringCRSType;
        union _gml__union_EngineeringCRSType union_EngineeringCRSType;
        /// Union with union _gml__union_EngineeringCRSType_____ variant selector __unionengineeringDatum set to one of: SOAP_UNION_plu__gml__union_EngineeringCRSType______engineeringDatum SOAP_UNION_plu__gml__union_EngineeringCRSType______usesEngineeringDatum
        int __unionengineeringDatum;
        union _gml__union_EngineeringCRSType_____ union_EngineeringCRSType_____;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__EngineeringCRSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__EngineeringCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__EngineeringCRSType, default initialized and not managed by a soap context
        virtual gml__EngineeringCRSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__EngineeringCRSType); }
      public:
        /// Constructor with default initializations
        gml__EngineeringCRSType() : __union_EngineeringCRSType(), __unionengineeringDatum() { }
        virtual ~gml__EngineeringCRSType() { }
        /// Friend allocator used by soap_new_gml__EngineeringCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__EngineeringCRSType * SOAP_FMAC2 soap_instantiate_gml__EngineeringCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:36346 */
#ifndef SOAP_TYPE_plu__gml__union_ImageCRSType
#define SOAP_TYPE_plu__gml__union_ImageCRSType (-2332)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ImageCRSType
{
        #define SOAP_UNION_plu__gml__union_ImageCRSType_cartesianCS	(1)	/**< union variant selector value for member cartesianCS */
        gml__CartesianCSPropertyType *cartesianCS;
        #define SOAP_UNION_plu__gml__union_ImageCRSType_usesCartesianCS	(2)	/**< union variant selector value for member usesCartesianCS */
        gml__CartesianCSPropertyType *usesCartesianCS;
        #define SOAP_UNION_plu__gml__union_ImageCRSType_affineCS	(3)	/**< union variant selector value for member affineCS */
        gml__AffineCSPropertyType *affineCS;
        #define SOAP_UNION_plu__gml__union_ImageCRSType_usesAffineCS	(4)	/**< union variant selector value for member usesAffineCS */
        gml__AffineCSPropertyType *usesAffineCS;
        #define SOAP_UNION_plu__gml__union_ImageCRSType_usesObliqueCartesianCS	(5)	/**< union variant selector value for member usesObliqueCartesianCS */
        gml__ObliqueCartesianCSPropertyType *usesObliqueCartesianCS;
};
#endif

/* PlannedLandUse_v3.0.h:36382 */
#ifndef SOAP_TYPE_plu__gml__union_ImageCRSType___
#define SOAP_TYPE_plu__gml__union_ImageCRSType___ (-2334)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ImageCRSType___
{
        #define SOAP_UNION_plu__gml__union_ImageCRSType____imageDatum	(1)	/**< union variant selector value for member imageDatum */
        gml__ImageDatumPropertyType *imageDatum;
        #define SOAP_UNION_plu__gml__union_ImageCRSType____usesImageDatum	(2)	/**< union variant selector value for member usesImageDatum */
        gml__ImageDatumPropertyType *usesImageDatum;
};
#endif

/* PlannedLandUse_v3.0.h:1058 */
#ifndef SOAP_TYPE_plu_gml__ImageCRSType
#define SOAP_TYPE_plu_gml__ImageCRSType (-307)
/* complex XML schema type 'gml:ImageCRSType': */
class SOAP_CMAC gml__ImageCRSType : public gml__AbstractCRSType {
      public:
        /// Union with union _gml__union_ImageCRSType variant selector __union_ImageCRSType set to one of: SOAP_UNION_plu__gml__union_ImageCRSType_cartesianCS SOAP_UNION_plu__gml__union_ImageCRSType_usesCartesianCS SOAP_UNION_plu__gml__union_ImageCRSType_affineCS SOAP_UNION_plu__gml__union_ImageCRSType_usesAffineCS SOAP_UNION_plu__gml__union_ImageCRSType_usesObliqueCartesianCS
        int __union_ImageCRSType;
        union _gml__union_ImageCRSType union_ImageCRSType;
        /// Union with union _gml__union_ImageCRSType___ variant selector __unionimageDatum set to one of: SOAP_UNION_plu__gml__union_ImageCRSType____imageDatum SOAP_UNION_plu__gml__union_ImageCRSType____usesImageDatum
        int __unionimageDatum;
        union _gml__union_ImageCRSType___ union_ImageCRSType___;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ImageCRSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ImageCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ImageCRSType, default initialized and not managed by a soap context
        virtual gml__ImageCRSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ImageCRSType); }
      public:
        /// Constructor with default initializations
        gml__ImageCRSType() : __union_ImageCRSType(), __unionimageDatum() { }
        virtual ~gml__ImageCRSType() { }
        /// Friend allocator used by soap_new_gml__ImageCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__ImageCRSType * SOAP_FMAC2 soap_instantiate_gml__ImageCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:36431 */
#ifndef SOAP_TYPE_plu__gml__union_TemporalCRSType
#define SOAP_TYPE_plu__gml__union_TemporalCRSType (-2336)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_TemporalCRSType
{
        #define SOAP_UNION_plu__gml__union_TemporalCRSType_timeCS	(1)	/**< union variant selector value for member timeCS */
        gml__TimeCSPropertyType *timeCS;
        #define SOAP_UNION_plu__gml__union_TemporalCRSType_usesTimeCS	(2)	/**< union variant selector value for member usesTimeCS */
        gml__TimeCSPropertyType *usesTimeCS;
        #define SOAP_UNION_plu__gml__union_TemporalCRSType_usesTemporalCS	(3)	/**< union variant selector value for member usesTemporalCS */
        gml__TemporalCSPropertyType *usesTemporalCS;
};
#endif

/* PlannedLandUse_v3.0.h:36455 */
#ifndef SOAP_TYPE_plu__gml__union_TemporalCRSType__
#define SOAP_TYPE_plu__gml__union_TemporalCRSType__ (-2339)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_TemporalCRSType__
{
        #define SOAP_UNION_plu__gml__union_TemporalCRSType___temporalDatum	(1)	/**< union variant selector value for member temporalDatum */
        gml__TemporalDatumPropertyType *temporalDatum;
        #define SOAP_UNION_plu__gml__union_TemporalCRSType___usesTemporalDatum	(2)	/**< union variant selector value for member usesTemporalDatum */
        gml__TemporalDatumPropertyType *usesTemporalDatum;
};
#endif

/* PlannedLandUse_v3.0.h:1064 */
#ifndef SOAP_TYPE_plu_gml__TemporalCRSType
#define SOAP_TYPE_plu_gml__TemporalCRSType (-309)
/* complex XML schema type 'gml:TemporalCRSType': */
class SOAP_CMAC gml__TemporalCRSType : public gml__AbstractCRSType {
      public:
        /// Union with union _gml__union_TemporalCRSType variant selector __union_TemporalCRSType set to one of: SOAP_UNION_plu__gml__union_TemporalCRSType_timeCS SOAP_UNION_plu__gml__union_TemporalCRSType_usesTimeCS SOAP_UNION_plu__gml__union_TemporalCRSType_usesTemporalCS
        int __union_TemporalCRSType;
        union _gml__union_TemporalCRSType union_TemporalCRSType;
        /// Union with union _gml__union_TemporalCRSType__ variant selector __uniontemporalDatum set to one of: SOAP_UNION_plu__gml__union_TemporalCRSType___temporalDatum SOAP_UNION_plu__gml__union_TemporalCRSType___usesTemporalDatum
        int __uniontemporalDatum;
        union _gml__union_TemporalCRSType__ union_TemporalCRSType__;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TemporalCRSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TemporalCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TemporalCRSType, default initialized and not managed by a soap context
        virtual gml__TemporalCRSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TemporalCRSType); }
      public:
        /// Constructor with default initializations
        gml__TemporalCRSType() : __union_TemporalCRSType(), __uniontemporalDatum() { }
        virtual ~gml__TemporalCRSType() { }
        /// Friend allocator used by soap_new_gml__TemporalCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__TemporalCRSType * SOAP_FMAC2 soap_instantiate_gml__TemporalCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1082 */
#ifndef SOAP_TYPE_plu_gml__EllipsoidalCSType
#define SOAP_TYPE_plu_gml__EllipsoidalCSType (-315)
/* complex XML schema type 'gml:EllipsoidalCSType': */
class SOAP_CMAC gml__EllipsoidalCSType : public gml__AbstractCoordinateSystemType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__EllipsoidalCSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__EllipsoidalCSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__EllipsoidalCSType, default initialized and not managed by a soap context
        virtual gml__EllipsoidalCSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__EllipsoidalCSType); }
      public:
        /// Constructor with default initializations
        gml__EllipsoidalCSType() { }
        virtual ~gml__EllipsoidalCSType() { }
        /// Friend allocator used by soap_new_gml__EllipsoidalCSType(struct soap*, int)
        friend SOAP_FMAC1 gml__EllipsoidalCSType * SOAP_FMAC2 soap_instantiate_gml__EllipsoidalCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1088 */
#ifndef SOAP_TYPE_plu_gml__CartesianCSType
#define SOAP_TYPE_plu_gml__CartesianCSType (-317)
/* complex XML schema type 'gml:CartesianCSType': */
class SOAP_CMAC gml__CartesianCSType : public gml__AbstractCoordinateSystemType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CartesianCSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CartesianCSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CartesianCSType, default initialized and not managed by a soap context
        virtual gml__CartesianCSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CartesianCSType); }
      public:
        /// Constructor with default initializations
        gml__CartesianCSType() { }
        virtual ~gml__CartesianCSType() { }
        /// Friend allocator used by soap_new_gml__CartesianCSType(struct soap*, int)
        friend SOAP_FMAC1 gml__CartesianCSType * SOAP_FMAC2 soap_instantiate_gml__CartesianCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1094 */
#ifndef SOAP_TYPE_plu_gml__VerticalCSType
#define SOAP_TYPE_plu_gml__VerticalCSType (-319)
/* complex XML schema type 'gml:VerticalCSType': */
class SOAP_CMAC gml__VerticalCSType : public gml__AbstractCoordinateSystemType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__VerticalCSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__VerticalCSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__VerticalCSType, default initialized and not managed by a soap context
        virtual gml__VerticalCSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__VerticalCSType); }
      public:
        /// Constructor with default initializations
        gml__VerticalCSType() { }
        virtual ~gml__VerticalCSType() { }
        /// Friend allocator used by soap_new_gml__VerticalCSType(struct soap*, int)
        friend SOAP_FMAC1 gml__VerticalCSType * SOAP_FMAC2 soap_instantiate_gml__VerticalCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1100 */
#ifndef SOAP_TYPE_plu_gml__TimeCSType
#define SOAP_TYPE_plu_gml__TimeCSType (-321)
/* complex XML schema type 'gml:TimeCSType': */
class SOAP_CMAC gml__TimeCSType : public gml__AbstractCoordinateSystemType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TimeCSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TimeCSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimeCSType, default initialized and not managed by a soap context
        virtual gml__TimeCSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TimeCSType); }
      public:
        /// Constructor with default initializations
        gml__TimeCSType() { }
        virtual ~gml__TimeCSType() { }
        /// Friend allocator used by soap_new_gml__TimeCSType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimeCSType * SOAP_FMAC2 soap_instantiate_gml__TimeCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1106 */
#ifndef SOAP_TYPE_plu_gml__LinearCSType
#define SOAP_TYPE_plu_gml__LinearCSType (-323)
/* complex XML schema type 'gml:LinearCSType': */
class SOAP_CMAC gml__LinearCSType : public gml__AbstractCoordinateSystemType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__LinearCSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__LinearCSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__LinearCSType, default initialized and not managed by a soap context
        virtual gml__LinearCSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__LinearCSType); }
      public:
        /// Constructor with default initializations
        gml__LinearCSType() { }
        virtual ~gml__LinearCSType() { }
        /// Friend allocator used by soap_new_gml__LinearCSType(struct soap*, int)
        friend SOAP_FMAC1 gml__LinearCSType * SOAP_FMAC2 soap_instantiate_gml__LinearCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1112 */
#ifndef SOAP_TYPE_plu_gml__UserDefinedCSType
#define SOAP_TYPE_plu_gml__UserDefinedCSType (-325)
/* complex XML schema type 'gml:UserDefinedCSType': */
class SOAP_CMAC gml__UserDefinedCSType : public gml__AbstractCoordinateSystemType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__UserDefinedCSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__UserDefinedCSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__UserDefinedCSType, default initialized and not managed by a soap context
        virtual gml__UserDefinedCSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__UserDefinedCSType); }
      public:
        /// Constructor with default initializations
        gml__UserDefinedCSType() { }
        virtual ~gml__UserDefinedCSType() { }
        /// Friend allocator used by soap_new_gml__UserDefinedCSType(struct soap*, int)
        friend SOAP_FMAC1 gml__UserDefinedCSType * SOAP_FMAC2 soap_instantiate_gml__UserDefinedCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1118 */
#ifndef SOAP_TYPE_plu_gml__SphericalCSType
#define SOAP_TYPE_plu_gml__SphericalCSType (-327)
/* complex XML schema type 'gml:SphericalCSType': */
class SOAP_CMAC gml__SphericalCSType : public gml__AbstractCoordinateSystemType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__SphericalCSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__SphericalCSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SphericalCSType, default initialized and not managed by a soap context
        virtual gml__SphericalCSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__SphericalCSType); }
      public:
        /// Constructor with default initializations
        gml__SphericalCSType() { }
        virtual ~gml__SphericalCSType() { }
        /// Friend allocator used by soap_new_gml__SphericalCSType(struct soap*, int)
        friend SOAP_FMAC1 gml__SphericalCSType * SOAP_FMAC2 soap_instantiate_gml__SphericalCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1124 */
#ifndef SOAP_TYPE_plu_gml__PolarCSType
#define SOAP_TYPE_plu_gml__PolarCSType (-329)
/* complex XML schema type 'gml:PolarCSType': */
class SOAP_CMAC gml__PolarCSType : public gml__AbstractCoordinateSystemType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__PolarCSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__PolarCSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__PolarCSType, default initialized and not managed by a soap context
        virtual gml__PolarCSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__PolarCSType); }
      public:
        /// Constructor with default initializations
        gml__PolarCSType() { }
        virtual ~gml__PolarCSType() { }
        /// Friend allocator used by soap_new_gml__PolarCSType(struct soap*, int)
        friend SOAP_FMAC1 gml__PolarCSType * SOAP_FMAC2 soap_instantiate_gml__PolarCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1130 */
#ifndef SOAP_TYPE_plu_gml__CylindricalCSType
#define SOAP_TYPE_plu_gml__CylindricalCSType (-331)
/* complex XML schema type 'gml:CylindricalCSType': */
class SOAP_CMAC gml__CylindricalCSType : public gml__AbstractCoordinateSystemType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__CylindricalCSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__CylindricalCSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CylindricalCSType, default initialized and not managed by a soap context
        virtual gml__CylindricalCSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__CylindricalCSType); }
      public:
        /// Constructor with default initializations
        gml__CylindricalCSType() { }
        virtual ~gml__CylindricalCSType() { }
        /// Friend allocator used by soap_new_gml__CylindricalCSType(struct soap*, int)
        friend SOAP_FMAC1 gml__CylindricalCSType * SOAP_FMAC2 soap_instantiate_gml__CylindricalCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1136 */
#ifndef SOAP_TYPE_plu_gml__AffineCSType
#define SOAP_TYPE_plu_gml__AffineCSType (-333)
/* complex XML schema type 'gml:AffineCSType': */
class SOAP_CMAC gml__AffineCSType : public gml__AbstractCoordinateSystemType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AffineCSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AffineCSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AffineCSType, default initialized and not managed by a soap context
        virtual gml__AffineCSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AffineCSType); }
      public:
        /// Constructor with default initializations
        gml__AffineCSType() { }
        virtual ~gml__AffineCSType() { }
        /// Friend allocator used by soap_new_gml__AffineCSType(struct soap*, int)
        friend SOAP_FMAC1 gml__AffineCSType * SOAP_FMAC2 soap_instantiate_gml__AffineCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:37048 */
#ifndef SOAP_TYPE_plu__gml__union_GeodeticDatumType_
#define SOAP_TYPE_plu__gml__union_GeodeticDatumType_ (-2341)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_GeodeticDatumType_
{
        #define SOAP_UNION_plu__gml__union_GeodeticDatumType__primeMeridian	(1)	/**< union variant selector value for member primeMeridian */
        gml__PrimeMeridianPropertyType *primeMeridian;
        #define SOAP_UNION_plu__gml__union_GeodeticDatumType__usesPrimeMeridian	(2)	/**< union variant selector value for member usesPrimeMeridian */
        gml__PrimeMeridianPropertyType *usesPrimeMeridian;
};
#endif

/* PlannedLandUse_v3.0.h:37065 */
#ifndef SOAP_TYPE_plu__gml__union_GeodeticDatumType__
#define SOAP_TYPE_plu__gml__union_GeodeticDatumType__ (-2343)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_GeodeticDatumType__
{
        #define SOAP_UNION_plu__gml__union_GeodeticDatumType___ellipsoid	(1)	/**< union variant selector value for member ellipsoid */
        gml__EllipsoidPropertyType *ellipsoid;
        #define SOAP_UNION_plu__gml__union_GeodeticDatumType___usesEllipsoid	(2)	/**< union variant selector value for member usesEllipsoid */
        gml__EllipsoidPropertyType *usesEllipsoid;
};
#endif

/* PlannedLandUse_v3.0.h:1157 */
#ifndef SOAP_TYPE_plu_gml__GeodeticDatumType
#define SOAP_TYPE_plu_gml__GeodeticDatumType (-340)
/* complex XML schema type 'gml:GeodeticDatumType': */
class SOAP_CMAC gml__GeodeticDatumType : public gml__AbstractDatumType {
      public:
        /// Union with union _gml__union_GeodeticDatumType_ variant selector __unionprimeMeridian set to one of: SOAP_UNION_plu__gml__union_GeodeticDatumType__primeMeridian SOAP_UNION_plu__gml__union_GeodeticDatumType__usesPrimeMeridian
        int __unionprimeMeridian;
        union _gml__union_GeodeticDatumType_ union_GeodeticDatumType_;
        /// Union with union _gml__union_GeodeticDatumType__ variant selector __unionellipsoid set to one of: SOAP_UNION_plu__gml__union_GeodeticDatumType___ellipsoid SOAP_UNION_plu__gml__union_GeodeticDatumType___usesEllipsoid
        int __unionellipsoid;
        union _gml__union_GeodeticDatumType__ union_GeodeticDatumType__;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GeodeticDatumType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GeodeticDatumType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeodeticDatumType, default initialized and not managed by a soap context
        virtual gml__GeodeticDatumType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GeodeticDatumType); }
      public:
        /// Constructor with default initializations
        gml__GeodeticDatumType() : __unionprimeMeridian(), __unionellipsoid() { }
        virtual ~gml__GeodeticDatumType() { }
        /// Friend allocator used by soap_new_gml__GeodeticDatumType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeodeticDatumType * SOAP_FMAC2 soap_instantiate_gml__GeodeticDatumType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1175 */
#ifndef SOAP_TYPE_plu_gml__EngineeringDatumType
#define SOAP_TYPE_plu_gml__EngineeringDatumType (-346)
/* complex XML schema type 'gml:EngineeringDatumType': */
class SOAP_CMAC gml__EngineeringDatumType : public gml__AbstractDatumType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__EngineeringDatumType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__EngineeringDatumType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__EngineeringDatumType, default initialized and not managed by a soap context
        virtual gml__EngineeringDatumType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__EngineeringDatumType); }
      public:
        /// Constructor with default initializations
        gml__EngineeringDatumType() { }
        virtual ~gml__EngineeringDatumType() { }
        /// Friend allocator used by soap_new_gml__EngineeringDatumType(struct soap*, int)
        friend SOAP_FMAC1 gml__EngineeringDatumType * SOAP_FMAC2 soap_instantiate_gml__EngineeringDatumType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1181 */
#ifndef SOAP_TYPE_plu_gml__ImageDatumType
#define SOAP_TYPE_plu_gml__ImageDatumType (-348)
/* complex XML schema type 'gml:ImageDatumType': */
class SOAP_CMAC gml__ImageDatumType : public gml__AbstractDatumType {
      public:
        /// Required element 'gml:pixelInCell' of XML schema type 'gml:CodeWithAuthorityType'
        gml__CodeWithAuthorityType *pixelInCell;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ImageDatumType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ImageDatumType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ImageDatumType, default initialized and not managed by a soap context
        virtual gml__ImageDatumType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ImageDatumType); }
      public:
        /// Constructor with default initializations
        gml__ImageDatumType() : pixelInCell() { }
        virtual ~gml__ImageDatumType() { }
        /// Friend allocator used by soap_new_gml__ImageDatumType(struct soap*, int)
        friend SOAP_FMAC1 gml__ImageDatumType * SOAP_FMAC2 soap_instantiate_gml__ImageDatumType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1187 */
#ifndef SOAP_TYPE_plu_gml__VerticalDatumType
#define SOAP_TYPE_plu_gml__VerticalDatumType (-350)
/* complex XML schema type 'gml:VerticalDatumType': */
class SOAP_CMAC gml__VerticalDatumType : public gml__AbstractDatumType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__VerticalDatumType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__VerticalDatumType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__VerticalDatumType, default initialized and not managed by a soap context
        virtual gml__VerticalDatumType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__VerticalDatumType); }
      public:
        /// Constructor with default initializations
        gml__VerticalDatumType() { }
        virtual ~gml__VerticalDatumType() { }
        /// Friend allocator used by soap_new_gml__VerticalDatumType(struct soap*, int)
        friend SOAP_FMAC1 gml__VerticalDatumType * SOAP_FMAC2 soap_instantiate_gml__VerticalDatumType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1196 */
#ifndef SOAP_TYPE_plu_gml__TemporalDatumBaseType
#define SOAP_TYPE_plu_gml__TemporalDatumBaseType (-353)
/* complex XML schema type 'gml:TemporalDatumBaseType': */
class SOAP_CMAC gml__TemporalDatumBaseType : public xsd__anyType {
      public:
        /// Optional element 'gml:metaDataProperty' of XML schema type 'gml:MetaDataPropertyType'
        std::vector<gml__MetaDataPropertyType *> metaDataProperty;
        /// Optional element 'gml:description' of XML schema type 'gml:StringOrRefType'
        gml__StringOrRefType *description;
        /// Optional element 'gml:descriptionReference' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *descriptionReference;
        /// Required element 'gml:identifier' of XML schema type 'gml:CodeWithAuthorityType'
        gml__CodeWithAuthorityType *identifier;
        /// Optional element 'gml:name' of XML schema type 'gml:CodeType'
        std::vector<gml__CodeType *> name;
        /// Optional element 'gml:remarks' of XML schema type 'xsd:string'
        std::string *remarks;
        /// Optional element 'gml:domainOfValidity' of XML schema type 'gml:domainOfValidity'
        _gml__domainOfValidity *domainOfValidity;
        /// Required element 'gml:scope' of XML schema type 'xsd:string'
        std::vector<std::string> scope;
        /// Required attribute 'gml:id' of XML schema type 'xsd:ID'
        char *gml__id;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TemporalDatumBaseType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TemporalDatumBaseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TemporalDatumBaseType, default initialized and not managed by a soap context
        virtual gml__TemporalDatumBaseType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TemporalDatumBaseType); }
      public:
        /// Constructor with default initializations
        gml__TemporalDatumBaseType() : metaDataProperty(), description(), descriptionReference(), identifier(), name(), remarks(), domainOfValidity(), scope(), gml__id() { }
        virtual ~gml__TemporalDatumBaseType() { }
        /// Friend allocator used by soap_new_gml__TemporalDatumBaseType(struct soap*, int)
        friend SOAP_FMAC1 gml__TemporalDatumBaseType * SOAP_FMAC2 soap_instantiate_gml__TemporalDatumBaseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1211 */
#ifndef SOAP_TYPE_plu_gml__AbstractGeneralConversionType
#define SOAP_TYPE_plu_gml__AbstractGeneralConversionType (-358)
/* complex XML schema type 'gml:AbstractGeneralConversionType': */
class SOAP_CMAC gml__AbstractGeneralConversionType : public xsd__anyType {
      public:
        /// Optional element 'gml:metaDataProperty' of XML schema type 'gml:MetaDataPropertyType'
        std::vector<gml__MetaDataPropertyType *> metaDataProperty;
        /// Optional element 'gml:description' of XML schema type 'gml:StringOrRefType'
        gml__StringOrRefType *description;
        /// Optional element 'gml:descriptionReference' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *descriptionReference;
        /// Required element 'gml:identifier' of XML schema type 'gml:CodeWithAuthorityType'
        gml__CodeWithAuthorityType *identifier;
        /// Optional element 'gml:name' of XML schema type 'gml:CodeType'
        std::vector<gml__CodeType *> name;
        /// Optional element 'gml:remarks' of XML schema type 'xsd:string'
        std::string *remarks;
        /// Optional element 'gml:domainOfValidity' of XML schema type 'gml:domainOfValidity'
        _gml__domainOfValidity *domainOfValidity;
        /// Required element 'gml:scope' of XML schema type 'xsd:string'
        std::vector<std::string> scope;
        /// Optional element 'gml:coordinateOperationAccuracy' of XML schema type 'gml:coordinateOperationAccuracy'
        std::vector<_gml__coordinateOperationAccuracy *> coordinateOperationAccuracy;
        /// Required attribute 'gml:id' of XML schema type 'xsd:ID'
        char *gml__id;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractGeneralConversionType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractGeneralConversionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractGeneralConversionType, default initialized and not managed by a soap context
        virtual gml__AbstractGeneralConversionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractGeneralConversionType); }
      public:
        /// Constructor with default initializations
        gml__AbstractGeneralConversionType() : metaDataProperty(), description(), descriptionReference(), identifier(), name(), remarks(), domainOfValidity(), scope(), coordinateOperationAccuracy(), gml__id() { }
        virtual ~gml__AbstractGeneralConversionType() { }
        /// Friend allocator used by soap_new_gml__AbstractGeneralConversionType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractGeneralConversionType * SOAP_FMAC2 soap_instantiate_gml__AbstractGeneralConversionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1217 */
#ifndef SOAP_TYPE_plu_gml__AbstractGeneralTransformationType
#define SOAP_TYPE_plu_gml__AbstractGeneralTransformationType (-360)
/* complex XML schema type 'gml:AbstractGeneralTransformationType': */
class SOAP_CMAC gml__AbstractGeneralTransformationType : public xsd__anyType {
      public:
        /// Optional element 'gml:metaDataProperty' of XML schema type 'gml:MetaDataPropertyType'
        std::vector<gml__MetaDataPropertyType *> metaDataProperty;
        /// Optional element 'gml:description' of XML schema type 'gml:StringOrRefType'
        gml__StringOrRefType *description;
        /// Optional element 'gml:descriptionReference' of XML schema type 'gml:ReferenceType'
        gml__ReferenceType *descriptionReference;
        /// Required element 'gml:identifier' of XML schema type 'gml:CodeWithAuthorityType'
        gml__CodeWithAuthorityType *identifier;
        /// Optional element 'gml:name' of XML schema type 'gml:CodeType'
        std::vector<gml__CodeType *> name;
        /// Optional element 'gml:remarks' of XML schema type 'xsd:string'
        std::string *remarks;
        /// Optional element 'gml:domainOfValidity' of XML schema type 'gml:domainOfValidity'
        _gml__domainOfValidity *domainOfValidity;
        /// Required element 'gml:scope' of XML schema type 'xsd:string'
        std::vector<std::string> scope;
        /// Required element 'gml:operationVersion' of XML schema type 'xsd:string'
        std::string operationVersion;
        /// Optional element 'gml:coordinateOperationAccuracy' of XML schema type 'gml:coordinateOperationAccuracy'
        std::vector<_gml__coordinateOperationAccuracy *> coordinateOperationAccuracy;
        /// Required element 'gml:sourceCRS' of XML schema type 'gml:CRSPropertyType'
        gml__CRSPropertyType *sourceCRS;
        /// Required element 'gml:targetCRS' of XML schema type 'gml:CRSPropertyType'
        gml__CRSPropertyType *targetCRS;
        /// Required attribute 'gml:id' of XML schema type 'xsd:ID'
        char *gml__id;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__AbstractGeneralTransformationType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__AbstractGeneralTransformationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractGeneralTransformationType, default initialized and not managed by a soap context
        virtual gml__AbstractGeneralTransformationType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__AbstractGeneralTransformationType); }
      public:
        /// Constructor with default initializations
        gml__AbstractGeneralTransformationType() : metaDataProperty(), description(), descriptionReference(), identifier(), name(), remarks(), domainOfValidity(), scope(), operationVersion(), coordinateOperationAccuracy(), sourceCRS(), targetCRS(), gml__id() { }
        virtual ~gml__AbstractGeneralTransformationType() { }
        /// Friend allocator used by soap_new_gml__AbstractGeneralTransformationType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractGeneralTransformationType * SOAP_FMAC2 soap_instantiate_gml__AbstractGeneralTransformationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:37601 */
#ifndef SOAP_TYPE_plu__gml__union_ConcatenatedOperationType
#define SOAP_TYPE_plu__gml__union_ConcatenatedOperationType (-2346)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ConcatenatedOperationType
{
        #define SOAP_UNION_plu__gml__union_ConcatenatedOperationType_coordOperation	(1)	/**< union variant selector value for member coordOperation */
        std::vector<gml__CoordinateOperationPropertyType *> *coordOperation;
        #define SOAP_UNION_plu__gml__union_ConcatenatedOperationType_usesSingleOperation	(2)	/**< union variant selector value for member usesSingleOperation */
        gml__CoordinateOperationPropertyType *usesSingleOperation;
        #define SOAP_UNION_plu__gml__union_ConcatenatedOperationType_usesOperation	(3)	/**< union variant selector value for member usesOperation */
        gml__CoordinateOperationPropertyType *usesOperation;
};
#endif

/* PlannedLandUse_v3.0.h:37596 */
#ifndef SOAP_TYPE_plu___gml__union_ConcatenatedOperationType
#define SOAP_TYPE_plu___gml__union_ConcatenatedOperationType (-2345)
/* Type __gml__union_ConcatenatedOperationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* Wrapper: */
class SOAP_CMAC __gml__union_ConcatenatedOperationType {
      public:
        /// Union with union _gml__union_ConcatenatedOperationType variant selector __unioncoordOperation set to one of: SOAP_UNION_plu__gml__union_ConcatenatedOperationType_coordOperation SOAP_UNION_plu__gml__union_ConcatenatedOperationType_usesSingleOperation SOAP_UNION_plu__gml__union_ConcatenatedOperationType_usesOperation
        int __unioncoordOperation;
        union _gml__union_ConcatenatedOperationType union_ConcatenatedOperationType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_ConcatenatedOperationType
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_ConcatenatedOperationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_ConcatenatedOperationType, default initialized and not managed by a soap context
        virtual __gml__union_ConcatenatedOperationType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_ConcatenatedOperationType); }
      public:
        /// Constructor with default initializations
        __gml__union_ConcatenatedOperationType() : __unioncoordOperation() { }
        virtual ~__gml__union_ConcatenatedOperationType() { }
        /// Friend allocator used by soap_new___gml__union_ConcatenatedOperationType(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_ConcatenatedOperationType * SOAP_FMAC2 soap_instantiate___gml__union_ConcatenatedOperationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1223 */
#ifndef SOAP_TYPE_plu_gml__ConcatenatedOperationType
#define SOAP_TYPE_plu_gml__ConcatenatedOperationType (-362)
/* complex XML schema type 'gml:ConcatenatedOperationType': */
class SOAP_CMAC gml__ConcatenatedOperationType : public gml__AbstractCoordinateOperationType {
      public:
        /// Sequence of at least 2 elements '-union-ConcatenatedOperationType' of XML schema type '-gml:union-ConcatenatedOperationType' stored in dynamic array __union_ConcatenatedOperationType of length __sizecoordOperation
        int __sizecoordOperation;
        __gml__union_ConcatenatedOperationType *__union_ConcatenatedOperationType;
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ConcatenatedOperationType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ConcatenatedOperationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ConcatenatedOperationType, default initialized and not managed by a soap context
        virtual gml__ConcatenatedOperationType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ConcatenatedOperationType); }
      public:
        /// Constructor with default initializations
        gml__ConcatenatedOperationType() : __sizecoordOperation(), __union_ConcatenatedOperationType(), aggregationType() { }
        virtual ~gml__ConcatenatedOperationType() { }
        /// Friend allocator used by soap_new_gml__ConcatenatedOperationType(struct soap*, int)
        friend SOAP_FMAC1 gml__ConcatenatedOperationType * SOAP_FMAC2 soap_instantiate_gml__ConcatenatedOperationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:37686 */
#ifndef SOAP_TYPE_plu__gml__union_PassThroughOperationType
#define SOAP_TYPE_plu__gml__union_PassThroughOperationType (-2352)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_PassThroughOperationType
{
        #define SOAP_UNION_plu__gml__union_PassThroughOperationType_coordOperation	(1)	/**< union variant selector value for member coordOperation */
        gml__CoordinateOperationPropertyType *coordOperation;
        #define SOAP_UNION_plu__gml__union_PassThroughOperationType_usesSingleOperation	(2)	/**< union variant selector value for member usesSingleOperation */
        gml__CoordinateOperationPropertyType *usesSingleOperation;
        #define SOAP_UNION_plu__gml__union_PassThroughOperationType_usesOperation	(3)	/**< union variant selector value for member usesOperation */
        gml__CoordinateOperationPropertyType *usesOperation;
};
#endif

/* PlannedLandUse_v3.0.h:1229 */
#ifndef SOAP_TYPE_plu_gml__PassThroughOperationType
#define SOAP_TYPE_plu_gml__PassThroughOperationType (-364)
/* complex XML schema type 'gml:PassThroughOperationType': */
class SOAP_CMAC gml__PassThroughOperationType : public gml__AbstractCoordinateOperationType {
      public:
        /// Required element 'gml:modifiedCoordinate' of XML schema type 'xsd:positiveInteger'
        std::vector<ULONG64> modifiedCoordinate;
        /// Union with union _gml__union_PassThroughOperationType variant selector __unioncoordOperation set to one of: SOAP_UNION_plu__gml__union_PassThroughOperationType_coordOperation SOAP_UNION_plu__gml__union_PassThroughOperationType_usesSingleOperation SOAP_UNION_plu__gml__union_PassThroughOperationType_usesOperation
        int __unioncoordOperation;
        union _gml__union_PassThroughOperationType union_PassThroughOperationType;
        /// Optional attribute 'aggregationType' of XML schema type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__PassThroughOperationType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__PassThroughOperationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__PassThroughOperationType, default initialized and not managed by a soap context
        virtual gml__PassThroughOperationType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__PassThroughOperationType); }
      public:
        /// Constructor with default initializations
        gml__PassThroughOperationType() : modifiedCoordinate(), __unioncoordOperation(), aggregationType() { }
        virtual ~gml__PassThroughOperationType() { }
        /// Friend allocator used by soap_new_gml__PassThroughOperationType(struct soap*, int)
        friend SOAP_FMAC1 gml__PassThroughOperationType * SOAP_FMAC2 soap_instantiate_gml__PassThroughOperationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1271 */
#ifndef SOAP_TYPE_plu_gml__OperationParameterType
#define SOAP_TYPE_plu_gml__OperationParameterType (-378)
/* complex XML schema type 'gml:OperationParameterType': */
class SOAP_CMAC gml__OperationParameterType : public gml__AbstractGeneralOperationParameterType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__OperationParameterType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__OperationParameterType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__OperationParameterType, default initialized and not managed by a soap context
        virtual gml__OperationParameterType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__OperationParameterType); }
      public:
        /// Constructor with default initializations
        gml__OperationParameterType() { }
        virtual ~gml__OperationParameterType() { }
        /// Friend allocator used by soap_new_gml__OperationParameterType(struct soap*, int)
        friend SOAP_FMAC1 gml__OperationParameterType * SOAP_FMAC2 soap_instantiate_gml__OperationParameterType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:37779 */
#ifndef SOAP_TYPE_plu__gml__union_OperationParameterGroupType
#define SOAP_TYPE_plu__gml__union_OperationParameterGroupType (-2354)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_OperationParameterGroupType
{
        #define SOAP_UNION_plu__gml__union_OperationParameterGroupType_parameter	(1)	/**< union variant selector value for member parameter */
        std::vector<gml__AbstractGeneralOperationParameterPropertyType *> *parameter;
        #define SOAP_UNION_plu__gml__union_OperationParameterGroupType_includesParameter	(2)	/**< union variant selector value for member includesParameter */
        gml__AbstractGeneralOperationParameterPropertyType *includesParameter;
        #define SOAP_UNION_plu__gml__union_OperationParameterGroupType_generalOperationParameter	(3)	/**< union variant selector value for member generalOperationParameter */
        gml__AbstractGeneralOperationParameterPropertyType *generalOperationParameter;
        #define SOAP_UNION_plu__gml__union_OperationParameterGroupType_usesParameter	(4)	/**< union variant selector value for member usesParameter */
        gml__AbstractGeneralOperationParameterPropertyType *usesParameter;
};
#endif

/* PlannedLandUse_v3.0.h:37774 */
#ifndef SOAP_TYPE_plu___gml__union_OperationParameterGroupType
#define SOAP_TYPE_plu___gml__union_OperationParameterGroupType (-2353)
/* Wrapper: */
class SOAP_CMAC __gml__union_OperationParameterGroupType {
      public:
        /// Union with union _gml__union_OperationParameterGroupType variant selector __unionparameter set to one of: SOAP_UNION_plu__gml__union_OperationParameterGroupType_parameter SOAP_UNION_plu__gml__union_OperationParameterGroupType_includesParameter SOAP_UNION_plu__gml__union_OperationParameterGroupType_generalOperationParameter SOAP_UNION_plu__gml__union_OperationParameterGroupType_usesParameter
        int __unionparameter;
        union _gml__union_OperationParameterGroupType union_OperationParameterGroupType;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_OperationParameterGroupType
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_OperationParameterGroupType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_OperationParameterGroupType, default initialized and not managed by a soap context
        virtual __gml__union_OperationParameterGroupType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_OperationParameterGroupType); }
      public:
        /// Constructor with default initializations
        __gml__union_OperationParameterGroupType() : __unionparameter() { }
        virtual ~__gml__union_OperationParameterGroupType() { }
        /// Friend allocator used by soap_new___gml__union_OperationParameterGroupType(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_OperationParameterGroupType * SOAP_FMAC2 soap_instantiate___gml__union_OperationParameterGroupType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1277 */
#ifndef SOAP_TYPE_plu_gml__OperationParameterGroupType
#define SOAP_TYPE_plu_gml__OperationParameterGroupType (-380)
/* Type gml__OperationParameterGroupType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'gml:OperationParameterGroupType': */
class SOAP_CMAC gml__OperationParameterGroupType : public gml__AbstractGeneralOperationParameterType {
      public:
        /// Optional element 'gml:maximumOccurs' of XML schema type 'xsd:positiveInteger'
        ULONG64 *maximumOccurs;
        /// Sequence of at least 2 elements '-union-OperationParameterGroupType' of XML schema type '-gml:union-OperationParameterGroupType' stored in dynamic array __union_OperationParameterGroupType of length __sizeparameter
        int __sizeparameter;
        __gml__union_OperationParameterGroupType *__union_OperationParameterGroupType;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__OperationParameterGroupType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__OperationParameterGroupType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__OperationParameterGroupType, default initialized and not managed by a soap context
        virtual gml__OperationParameterGroupType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__OperationParameterGroupType); }
      public:
        /// Constructor with default initializations
        gml__OperationParameterGroupType() : maximumOccurs(), __sizeparameter(), __union_OperationParameterGroupType() { }
        virtual ~gml__OperationParameterGroupType() { }
        /// Friend allocator used by soap_new_gml__OperationParameterGroupType(struct soap*, int)
        friend SOAP_FMAC1 gml__OperationParameterGroupType * SOAP_FMAC2 soap_instantiate_gml__OperationParameterGroupType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1370 */
#ifndef SOAP_TYPE_plu_gml__TemporalCSType
#define SOAP_TYPE_plu_gml__TemporalCSType (-411)
/* complex XML schema type 'gml:TemporalCSType': */
class SOAP_CMAC gml__TemporalCSType : public gml__AbstractCoordinateSystemType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TemporalCSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TemporalCSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TemporalCSType, default initialized and not managed by a soap context
        virtual gml__TemporalCSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TemporalCSType); }
      public:
        /// Constructor with default initializations
        gml__TemporalCSType() { }
        virtual ~gml__TemporalCSType() { }
        /// Friend allocator used by soap_new_gml__TemporalCSType(struct soap*, int)
        friend SOAP_FMAC1 gml__TemporalCSType * SOAP_FMAC2 soap_instantiate_gml__TemporalCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1376 */
#ifndef SOAP_TYPE_plu_gml__ObliqueCartesianCSType
#define SOAP_TYPE_plu_gml__ObliqueCartesianCSType (-413)
/* complex XML schema type 'gml:ObliqueCartesianCSType': */
class SOAP_CMAC gml__ObliqueCartesianCSType : public gml__AbstractCoordinateSystemType {
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ObliqueCartesianCSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ObliqueCartesianCSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ObliqueCartesianCSType, default initialized and not managed by a soap context
        virtual gml__ObliqueCartesianCSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ObliqueCartesianCSType); }
      public:
        /// Constructor with default initializations
        gml__ObliqueCartesianCSType() { }
        virtual ~gml__ObliqueCartesianCSType() { }
        /// Friend allocator used by soap_new_gml__ObliqueCartesianCSType(struct soap*, int)
        friend SOAP_FMAC1 gml__ObliqueCartesianCSType * SOAP_FMAC2 soap_instantiate_gml__ObliqueCartesianCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1382 */
#ifndef SOAP_TYPE_plu_gml__GeographicCRSType
#define SOAP_TYPE_plu_gml__GeographicCRSType (-415)
/* complex XML schema type 'gml:GeographicCRSType': */
class SOAP_CMAC gml__GeographicCRSType : public gml__AbstractCRSType {
      public:
        /// Required element 'gml:usesEllipsoidalCS' of XML schema type 'gml:EllipsoidalCSPropertyType'
        gml__EllipsoidalCSPropertyType *usesEllipsoidalCS;
        /// Required element 'gml:usesGeodeticDatum' of XML schema type 'gml:GeodeticDatumPropertyType'
        gml__GeodeticDatumPropertyType *usesGeodeticDatum;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GeographicCRSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GeographicCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeographicCRSType, default initialized and not managed by a soap context
        virtual gml__GeographicCRSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GeographicCRSType); }
      public:
        /// Constructor with default initializations
        gml__GeographicCRSType() : usesEllipsoidalCS(), usesGeodeticDatum() { }
        virtual ~gml__GeographicCRSType() { }
        /// Friend allocator used by soap_new_gml__GeographicCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeographicCRSType * SOAP_FMAC2 soap_instantiate_gml__GeographicCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:37977 */
#ifndef SOAP_TYPE_plu__gml__union_GeocentricCRSType
#define SOAP_TYPE_plu__gml__union_GeocentricCRSType (-2356)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_GeocentricCRSType
{
        #define SOAP_UNION_plu__gml__union_GeocentricCRSType_usesCartesianCS	(1)	/**< union variant selector value for member usesCartesianCS */
        gml__CartesianCSPropertyType *usesCartesianCS;
        #define SOAP_UNION_plu__gml__union_GeocentricCRSType_usesSphericalCS	(2)	/**< union variant selector value for member usesSphericalCS */
        gml__SphericalCSPropertyType *usesSphericalCS;
};
#endif

/* PlannedLandUse_v3.0.h:1388 */
#ifndef SOAP_TYPE_plu_gml__GeocentricCRSType
#define SOAP_TYPE_plu_gml__GeocentricCRSType (-417)
/* complex XML schema type 'gml:GeocentricCRSType': */
class SOAP_CMAC gml__GeocentricCRSType : public gml__AbstractCRSType {
      public:
        /// Union with union _gml__union_GeocentricCRSType variant selector __union_GeocentricCRSType set to one of: SOAP_UNION_plu__gml__union_GeocentricCRSType_usesCartesianCS SOAP_UNION_plu__gml__union_GeocentricCRSType_usesSphericalCS
        int __union_GeocentricCRSType;
        union _gml__union_GeocentricCRSType union_GeocentricCRSType;
        /// Required element 'gml:usesGeodeticDatum' of XML schema type 'gml:GeodeticDatumPropertyType'
        gml__GeodeticDatumPropertyType *usesGeodeticDatum;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__GeocentricCRSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__GeocentricCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeocentricCRSType, default initialized and not managed by a soap context
        virtual gml__GeocentricCRSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__GeocentricCRSType); }
      public:
        /// Constructor with default initializations
        gml__GeocentricCRSType() : __union_GeocentricCRSType(), usesGeodeticDatum() { }
        virtual ~gml__GeocentricCRSType() { }
        /// Friend allocator used by soap_new_gml__GeocentricCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeocentricCRSType * SOAP_FMAC2 soap_instantiate_gml__GeocentricCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:38044 */
#ifndef SOAP_TYPE_plu__gml__union_ProjectedCRSType_
#define SOAP_TYPE_plu__gml__union_ProjectedCRSType_ (-2357)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ProjectedCRSType_
{
        #define SOAP_UNION_plu__gml__union_ProjectedCRSType__baseGeodeticCRS	(1)	/**< union variant selector value for member baseGeodeticCRS */
        gml__GeodeticCRSPropertyType *baseGeodeticCRS;
        #define SOAP_UNION_plu__gml__union_ProjectedCRSType__baseGeographicCRS	(2)	/**< union variant selector value for member baseGeographicCRS */
        gml__GeographicCRSPropertyType *baseGeographicCRS;
};
#endif

/* PlannedLandUse_v3.0.h:38061 */
#ifndef SOAP_TYPE_plu__gml__union_ProjectedCRSType__
#define SOAP_TYPE_plu__gml__union_ProjectedCRSType__ (-2360)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ProjectedCRSType__
{
        #define SOAP_UNION_plu__gml__union_ProjectedCRSType___cartesianCS	(1)	/**< union variant selector value for member cartesianCS */
        gml__CartesianCSPropertyType *cartesianCS;
        #define SOAP_UNION_plu__gml__union_ProjectedCRSType___usesCartesianCS	(2)	/**< union variant selector value for member usesCartesianCS */
        gml__CartesianCSPropertyType *usesCartesianCS;
};
#endif

/* PlannedLandUse_v3.0.h:1040 */
#ifndef SOAP_TYPE_plu_gml__ProjectedCRSType
#define SOAP_TYPE_plu_gml__ProjectedCRSType (-301)
/* complex XML schema type 'gml:ProjectedCRSType': */
class SOAP_CMAC gml__ProjectedCRSType : public gml__AbstractGeneralDerivedCRSType {
      public:
        /// Union with union _gml__union_ProjectedCRSType_ variant selector __union_ProjectedCRSType_ set to one of: SOAP_UNION_plu__gml__union_ProjectedCRSType__baseGeodeticCRS SOAP_UNION_plu__gml__union_ProjectedCRSType__baseGeographicCRS
        int __union_ProjectedCRSType_;
        union _gml__union_ProjectedCRSType_ union_ProjectedCRSType_;
        /// Union with union _gml__union_ProjectedCRSType__ variant selector __unioncartesianCS set to one of: SOAP_UNION_plu__gml__union_ProjectedCRSType___cartesianCS SOAP_UNION_plu__gml__union_ProjectedCRSType___usesCartesianCS
        int __unioncartesianCS;
        union _gml__union_ProjectedCRSType__ union_ProjectedCRSType__;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ProjectedCRSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ProjectedCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ProjectedCRSType, default initialized and not managed by a soap context
        virtual gml__ProjectedCRSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ProjectedCRSType); }
      public:
        /// Constructor with default initializations
        gml__ProjectedCRSType() : __union_ProjectedCRSType_(), __unioncartesianCS() { }
        virtual ~gml__ProjectedCRSType() { }
        /// Friend allocator used by soap_new_gml__ProjectedCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__ProjectedCRSType * SOAP_FMAC2 soap_instantiate_gml__ProjectedCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:38143 */
#ifndef SOAP_TYPE_plu__gml__union_DerivedCRSType_
#define SOAP_TYPE_plu__gml__union_DerivedCRSType_ (-2361)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_DerivedCRSType_
{
        #define SOAP_UNION_plu__gml__union_DerivedCRSType__coordinateSystem	(1)	/**< union variant selector value for member coordinateSystem */
        gml__CoordinateSystemPropertyType *coordinateSystem;
        #define SOAP_UNION_plu__gml__union_DerivedCRSType__usesCS	(2)	/**< union variant selector value for member usesCS */
        gml__CoordinateSystemPropertyType *usesCS;
};
#endif

/* PlannedLandUse_v3.0.h:1046 */
#ifndef SOAP_TYPE_plu_gml__DerivedCRSType
#define SOAP_TYPE_plu_gml__DerivedCRSType (-303)
/* complex XML schema type 'gml:DerivedCRSType': */
class SOAP_CMAC gml__DerivedCRSType : public gml__AbstractGeneralDerivedCRSType {
      public:
        /// Required element 'gml:baseCRS' of XML schema type 'gml:SingleCRSPropertyType'
        gml__SingleCRSPropertyType *baseCRS;
        /// Required element 'gml:derivedCRSType' of XML schema type 'gml:CodeWithAuthorityType'
        gml__CodeWithAuthorityType *derivedCRSType;
        /// Union with union _gml__union_DerivedCRSType_ variant selector __unioncoordinateSystem set to one of: SOAP_UNION_plu__gml__union_DerivedCRSType__coordinateSystem SOAP_UNION_plu__gml__union_DerivedCRSType__usesCS
        int __unioncoordinateSystem;
        union _gml__union_DerivedCRSType_ union_DerivedCRSType_;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__DerivedCRSType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__DerivedCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DerivedCRSType, default initialized and not managed by a soap context
        virtual gml__DerivedCRSType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__DerivedCRSType); }
      public:
        /// Constructor with default initializations
        gml__DerivedCRSType() : baseCRS(), derivedCRSType(), __unioncoordinateSystem() { }
        virtual ~gml__DerivedCRSType() { }
        /// Friend allocator used by soap_new_gml__DerivedCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__DerivedCRSType * SOAP_FMAC2 soap_instantiate_gml__DerivedCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1193 */
#ifndef SOAP_TYPE_plu_gml__TemporalDatumType
#define SOAP_TYPE_plu_gml__TemporalDatumType (-352)
/* complex XML schema type 'gml:TemporalDatumType': */
class SOAP_CMAC gml__TemporalDatumType : public gml__TemporalDatumBaseType {
      public:
        /// Required element 'gml:origin' of XML schema type 'xsd:dateTime'
        time_t origin;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TemporalDatumType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TemporalDatumType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TemporalDatumType, default initialized and not managed by a soap context
        virtual gml__TemporalDatumType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TemporalDatumType); }
      public:
        /// Constructor with default initializations
        gml__TemporalDatumType() : origin() { }
        virtual ~gml__TemporalDatumType() { }
        /// Friend allocator used by soap_new_gml__TemporalDatumType(struct soap*, int)
        friend SOAP_FMAC1 gml__TemporalDatumType * SOAP_FMAC2 soap_instantiate_gml__TemporalDatumType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:38201 */
#ifndef SOAP_TYPE_plu__gml__union_ConversionType
#define SOAP_TYPE_plu__gml__union_ConversionType (-2362)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ConversionType
{
        #define SOAP_UNION_plu__gml__union_ConversionType_method	(1)	/**< union variant selector value for member method */
        gml__OperationMethodPropertyType *method;
        #define SOAP_UNION_plu__gml__union_ConversionType_usesMethod	(2)	/**< union variant selector value for member usesMethod */
        gml__OperationMethodPropertyType *usesMethod;
};
#endif

/* PlannedLandUse_v3.0.h:38221 */
#ifndef SOAP_TYPE_plu__gml__union_ConversionType_
#define SOAP_TYPE_plu__gml__union_ConversionType_ (-2365)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ConversionType_
{
        #define SOAP_UNION_plu__gml__union_ConversionType__parameterValue	(1)	/**< union variant selector value for member parameterValue */
        std::vector<gml__AbstractGeneralParameterValuePropertyType *> *parameterValue;
        #define SOAP_UNION_plu__gml__union_ConversionType__usesValue	(2)	/**< union variant selector value for member usesValue */
        gml__AbstractGeneralParameterValuePropertyType *usesValue;
        #define SOAP_UNION_plu__gml__union_ConversionType__includesValue	(3)	/**< union variant selector value for member includesValue */
        gml__AbstractGeneralParameterValuePropertyType *includesValue;
};
#endif

/* PlannedLandUse_v3.0.h:38216 */
#ifndef SOAP_TYPE_plu___gml__union_ConversionType_
#define SOAP_TYPE_plu___gml__union_ConversionType_ (-2364)
/* Wrapper: */
class SOAP_CMAC __gml__union_ConversionType_ {
      public:
        /// Union with union _gml__union_ConversionType_ variant selector __unionparameterValue set to one of: SOAP_UNION_plu__gml__union_ConversionType__parameterValue SOAP_UNION_plu__gml__union_ConversionType__usesValue SOAP_UNION_plu__gml__union_ConversionType__includesValue
        int __unionparameterValue;
        union _gml__union_ConversionType_ union_ConversionType_;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_ConversionType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_ConversionType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_ConversionType_, default initialized and not managed by a soap context
        virtual __gml__union_ConversionType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_ConversionType_); }
      public:
        /// Constructor with default initializations
        __gml__union_ConversionType_() : __unionparameterValue() { }
        virtual ~__gml__union_ConversionType_() { }
        /// Friend allocator used by soap_new___gml__union_ConversionType_(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_ConversionType_ * SOAP_FMAC2 soap_instantiate___gml__union_ConversionType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1235 */
#ifndef SOAP_TYPE_plu_gml__ConversionType
#define SOAP_TYPE_plu_gml__ConversionType (-366)
/* complex XML schema type 'gml:ConversionType': */
class SOAP_CMAC gml__ConversionType : public gml__AbstractGeneralConversionType {
      public:
        /// Union with union _gml__union_ConversionType variant selector __unionmethod set to one of: SOAP_UNION_plu__gml__union_ConversionType_method SOAP_UNION_plu__gml__union_ConversionType_usesMethod
        int __unionmethod;
        union _gml__union_ConversionType union_ConversionType;
        /// Sequence of elements '-union-ConversionType' of XML schema type '-gml:union-ConversionType' stored in dynamic array __union_ConversionType_ of length __sizeparameterValue
        int __sizeparameterValue;
        __gml__union_ConversionType_ *__union_ConversionType_;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__ConversionType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__ConversionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ConversionType, default initialized and not managed by a soap context
        virtual gml__ConversionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__ConversionType); }
      public:
        /// Constructor with default initializations
        gml__ConversionType() : __unionmethod(), __sizeparameterValue(), __union_ConversionType_() { }
        virtual ~gml__ConversionType() { }
        /// Friend allocator used by soap_new_gml__ConversionType(struct soap*, int)
        friend SOAP_FMAC1 gml__ConversionType * SOAP_FMAC2 soap_instantiate_gml__ConversionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:38259 */
#ifndef SOAP_TYPE_plu__gml__union_TransformationType
#define SOAP_TYPE_plu__gml__union_TransformationType (-2367)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_TransformationType
{
        #define SOAP_UNION_plu__gml__union_TransformationType_method	(1)	/**< union variant selector value for member method */
        gml__OperationMethodPropertyType *method;
        #define SOAP_UNION_plu__gml__union_TransformationType_usesMethod	(2)	/**< union variant selector value for member usesMethod */
        gml__OperationMethodPropertyType *usesMethod;
};
#endif

/* PlannedLandUse_v3.0.h:38279 */
#ifndef SOAP_TYPE_plu__gml__union_TransformationType_
#define SOAP_TYPE_plu__gml__union_TransformationType_ (-2369)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_TransformationType_
{
        #define SOAP_UNION_plu__gml__union_TransformationType__parameterValue	(1)	/**< union variant selector value for member parameterValue */
        std::vector<gml__AbstractGeneralParameterValuePropertyType *> *parameterValue;
        #define SOAP_UNION_plu__gml__union_TransformationType__usesValue	(2)	/**< union variant selector value for member usesValue */
        gml__AbstractGeneralParameterValuePropertyType *usesValue;
        #define SOAP_UNION_plu__gml__union_TransformationType__includesValue	(3)	/**< union variant selector value for member includesValue */
        gml__AbstractGeneralParameterValuePropertyType *includesValue;
};
#endif

/* PlannedLandUse_v3.0.h:38274 */
#ifndef SOAP_TYPE_plu___gml__union_TransformationType_
#define SOAP_TYPE_plu___gml__union_TransformationType_ (-2368)
/* Wrapper: */
class SOAP_CMAC __gml__union_TransformationType_ {
      public:
        /// Union with union _gml__union_TransformationType_ variant selector __unionparameterValue set to one of: SOAP_UNION_plu__gml__union_TransformationType__parameterValue SOAP_UNION_plu__gml__union_TransformationType__usesValue SOAP_UNION_plu__gml__union_TransformationType__includesValue
        int __unionparameterValue;
        union _gml__union_TransformationType_ union_TransformationType_;
      public:
        /// Return unique type id SOAP_TYPE_plu___gml__union_TransformationType_
        virtual long soap_type(void) const { return SOAP_TYPE_plu___gml__union_TransformationType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__union_TransformationType_, default initialized and not managed by a soap context
        virtual __gml__union_TransformationType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__gml__union_TransformationType_); }
      public:
        /// Constructor with default initializations
        __gml__union_TransformationType_() : __unionparameterValue() { }
        virtual ~__gml__union_TransformationType_() { }
        /// Friend allocator used by soap_new___gml__union_TransformationType_(struct soap*, int)
        friend SOAP_FMAC1 __gml__union_TransformationType_ * SOAP_FMAC2 soap_instantiate___gml__union_TransformationType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:1241 */
#ifndef SOAP_TYPE_plu_gml__TransformationType
#define SOAP_TYPE_plu_gml__TransformationType (-368)
/* complex XML schema type 'gml:TransformationType': */
class SOAP_CMAC gml__TransformationType : public gml__AbstractGeneralTransformationType {
      public:
        /// Union with union _gml__union_TransformationType variant selector __unionmethod set to one of: SOAP_UNION_plu__gml__union_TransformationType_method SOAP_UNION_plu__gml__union_TransformationType_usesMethod
        int __unionmethod;
        union _gml__union_TransformationType union_TransformationType;
        /// Sequence of elements '-union-TransformationType' of XML schema type '-gml:union-TransformationType' stored in dynamic array __union_TransformationType_ of length __sizeparameterValue
        int __sizeparameterValue;
        __gml__union_TransformationType_ *__union_TransformationType_;
      public:
        /// Return unique type id SOAP_TYPE_plu_gml__TransformationType
        virtual long soap_type(void) const { return SOAP_TYPE_plu_gml__TransformationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TransformationType, default initialized and not managed by a soap context
        virtual gml__TransformationType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gml__TransformationType); }
      public:
        /// Constructor with default initializations
        gml__TransformationType() : __unionmethod(), __sizeparameterValue(), __union_TransformationType_() { }
        virtual ~gml__TransformationType() { }
        /// Friend allocator used by soap_new_gml__TransformationType(struct soap*, int)
        friend SOAP_FMAC1 gml__TransformationType * SOAP_FMAC2 soap_instantiate_gml__TransformationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* PlannedLandUse_v3.0.h:42876 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_plu_SOAP_ENV__Header
#define SOAP_TYPE_plu_SOAP_ENV__Header (-775393280)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_plu_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_plu_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* PlannedLandUse_v3.0.h:42876 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_plu_SOAP_ENV__Code
#define SOAP_TYPE_plu_SOAP_ENV__Code (-775393281)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_plu_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_plu_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* PlannedLandUse_v3.0.h:42876 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_plu_SOAP_ENV__Detail
#define SOAP_TYPE_plu_SOAP_ENV__Detail (-775393283)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_plu_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_plu_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* PlannedLandUse_v3.0.h:42876 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_plu_SOAP_ENV__Reason
#define SOAP_TYPE_plu_SOAP_ENV__Reason (-775393286)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_plu_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_plu_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* PlannedLandUse_v3.0.h:42876 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_plu_SOAP_ENV__Fault
#define SOAP_TYPE_plu_SOAP_ENV__Fault (-775393287)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_plu_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_plu_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE_plu__XML
#define SOAP_TYPE_plu__XML (-5)

typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE_plu__QName
#define SOAP_TYPE_plu__QName (-6)

typedef char *_QName;
#endif

/* xsd.h:53 */
#ifndef SOAP_TYPE_plu__xml__lang
#define SOAP_TYPE_plu__xml__lang (-11)

typedef char *_xml__lang;
#endif

/* xsd.h:55 */
#ifndef SOAP_TYPE_plu__xsd__schema
#define SOAP_TYPE_plu__xsd__schema (-12)

typedef char *_xsd__schema;
#endif

/* xsd.h:62 */
#ifndef SOAP_TYPE_plu_xsd__anyURI
#define SOAP_TYPE_plu_xsd__anyURI (-15)

typedef char *xsd__anyURI;
#endif

/* xsd.h:77 */
#ifndef SOAP_TYPE_plu_xsd__byte
#define SOAP_TYPE_plu_xsd__byte (-21)

typedef char xsd__byte;
#endif

/* xsd.h:78 */
#ifndef SOAP_TYPE_plu_xsd__date
#define SOAP_TYPE_plu_xsd__date (-22)

typedef char *xsd__date;
#endif

/* xsd.h:79 */
#ifndef SOAP_TYPE_plu_xsd__decimal
#define SOAP_TYPE_plu_xsd__decimal (-24)

typedef double xsd__decimal;
#endif

/* xsd.h:80 */
#ifndef SOAP_TYPE_plu_xsd__double
#define SOAP_TYPE_plu_xsd__double (-25)

typedef double xsd__double;
#endif

/* xsd.h:81 */
#ifndef SOAP_TYPE_plu_xsd__duration
#define SOAP_TYPE_plu_xsd__duration (-26)

typedef char *xsd__duration;
#endif

/* xsd.h:82 */
#ifndef SOAP_TYPE_plu_xsd__float
#define SOAP_TYPE_plu_xsd__float (-28)

typedef float xsd__float;
#endif

/* xsd.h:83 */
#ifndef SOAP_TYPE_plu_xsd__ID
#define SOAP_TYPE_plu_xsd__ID (-29)

typedef char *xsd__ID;
#endif

/* xsd.h:84 */
#ifndef SOAP_TYPE_plu_xsd__integer
#define SOAP_TYPE_plu_xsd__integer (-31)

typedef LONG64 xsd__integer;
#endif

/* xsd.h:85 */
#ifndef SOAP_TYPE_plu_xsd__language
#define SOAP_TYPE_plu_xsd__language (-32)

typedef char *xsd__language;
#endif

/* xsd.h:86 */
#ifndef SOAP_TYPE_plu_xsd__long
#define SOAP_TYPE_plu_xsd__long (-33)

typedef LONG64 xsd__long;
#endif

/* xsd.h:87 */
#ifndef SOAP_TYPE_plu_xsd__Name
#define SOAP_TYPE_plu_xsd__Name (-34)

typedef char *xsd__Name;
#endif

/* xsd.h:88 */
#ifndef SOAP_TYPE_plu_xsd__NCName
#define SOAP_TYPE_plu_xsd__NCName (-35)

typedef char *xsd__NCName;
#endif

/* xsd.h:89 */
#ifndef SOAP_TYPE_plu_xsd__NMTOKEN
#define SOAP_TYPE_plu_xsd__NMTOKEN (-36)

typedef char *xsd__NMTOKEN;
#endif

/* xsd.h:90 */
#ifndef SOAP_TYPE_plu_xsd__negativeInteger
#define SOAP_TYPE_plu_xsd__negativeInteger (-37)

typedef LONG64 xsd__negativeInteger;
#endif

/* xsd.h:91 */
#ifndef SOAP_TYPE_plu_xsd__nonNegativeInteger
#define SOAP_TYPE_plu_xsd__nonNegativeInteger (-39)

typedef ULONG64 xsd__nonNegativeInteger;
#endif

/* xsd.h:92 */
#ifndef SOAP_TYPE_plu_xsd__nonPositiveInteger
#define SOAP_TYPE_plu_xsd__nonPositiveInteger (-40)

typedef LONG64 xsd__nonPositiveInteger;
#endif

/* xsd.h:93 */
#ifndef SOAP_TYPE_plu_xsd__normalizedString
#define SOAP_TYPE_plu_xsd__normalizedString (-41)

typedef char *xsd__normalizedString;
#endif

/* xsd.h:94 */
#ifndef SOAP_TYPE_plu_xsd__positiveInteger
#define SOAP_TYPE_plu_xsd__positiveInteger (-42)

typedef ULONG64 xsd__positiveInteger;
#endif

/* xsd.h:95 */
#ifndef SOAP_TYPE_plu_xsd__QName
#define SOAP_TYPE_plu_xsd__QName (-43)

typedef char *xsd__QName;
#endif

/* xsd.h:96 */
#ifndef SOAP_TYPE_plu_xsd__time
#define SOAP_TYPE_plu_xsd__time (-44)

typedef char *xsd__time;
#endif

/* xsd.h:97 */
#ifndef SOAP_TYPE_plu_xsd__token
#define SOAP_TYPE_plu_xsd__token (-45)

typedef char *xsd__token;
#endif

/* xsd.h:98 */
#ifndef SOAP_TYPE_plu_xsd__short
#define SOAP_TYPE_plu_xsd__short (-47)

typedef short xsd__short;
#endif

/* xsd.h:99 */
#ifndef SOAP_TYPE_plu_xsd__unsignedByte
#define SOAP_TYPE_plu_xsd__unsignedByte (-48)

typedef unsigned char xsd__unsignedByte;
#endif

/* xsd.h:100 */
#ifndef SOAP_TYPE_plu_xsd__unsignedInt
#define SOAP_TYPE_plu_xsd__unsignedInt (-49)

typedef unsigned int xsd__unsignedInt;
#endif

/* xsd.h:101 */
#ifndef SOAP_TYPE_plu_xsd__unsignedLong
#define SOAP_TYPE_plu_xsd__unsignedLong (-50)

typedef ULONG64 xsd__unsignedLong;
#endif

/* xsd.h:102 */
#ifndef SOAP_TYPE_plu_xsd__unsignedShort
#define SOAP_TYPE_plu_xsd__unsignedShort (-52)

typedef unsigned short xsd__unsignedShort;
#endif

/* xsd.h:104 */
#ifndef SOAP_TYPE_plu__SOAP_ENC__actor
#define SOAP_TYPE_plu__SOAP_ENC__actor (-53)

typedef char *_SOAP_ENC__actor;
#endif

/* xsd.h:105 */
#ifndef SOAP_TYPE_plu__SOAP_ENC__mustUnderstand
#define SOAP_TYPE_plu__SOAP_ENC__mustUnderstand (-54)

typedef int _SOAP_ENC__mustUnderstand;
#endif

/* PlannedLandUse_v3.0.h:2387 */
#ifndef SOAP_TYPE_plu_gml__NilReasonType
#define SOAP_TYPE_plu_gml__NilReasonType (-734)

typedef std::string gml__NilReasonType;
#endif

/* PlannedLandUse_v3.0.h:2391 */
#ifndef SOAP_TYPE_plu_gml__NilReasonEnumeration
#define SOAP_TYPE_plu_gml__NilReasonEnumeration (-735)

typedef std::string gml__NilReasonEnumeration;
#endif

/* PlannedLandUse_v3.0.h:2394 */
#ifndef SOAP_TYPE_plu_gml__booleanOrNilReason
#define SOAP_TYPE_plu_gml__booleanOrNilReason (-736)

typedef std::string gml__booleanOrNilReason;
#endif

/* PlannedLandUse_v3.0.h:2397 */
#ifndef SOAP_TYPE_plu_gml__doubleOrNilReason
#define SOAP_TYPE_plu_gml__doubleOrNilReason (-737)

typedef std::string gml__doubleOrNilReason;
#endif

/* PlannedLandUse_v3.0.h:2400 */
#ifndef SOAP_TYPE_plu_gml__integerOrNilReason
#define SOAP_TYPE_plu_gml__integerOrNilReason (-738)

typedef std::string gml__integerOrNilReason;
#endif

/* PlannedLandUse_v3.0.h:2403 */
#ifndef SOAP_TYPE_plu_gml__NameOrNilReason
#define SOAP_TYPE_plu_gml__NameOrNilReason (-739)

typedef std::string gml__NameOrNilReason;
#endif

/* PlannedLandUse_v3.0.h:2406 */
#ifndef SOAP_TYPE_plu_gml__stringOrNilReason
#define SOAP_TYPE_plu_gml__stringOrNilReason (-740)

typedef std::string gml__stringOrNilReason;
#endif

/* PlannedLandUse_v3.0.h:2409 */
#ifndef SOAP_TYPE_plu_gml__UomIdentifier
#define SOAP_TYPE_plu_gml__UomIdentifier (-741)

typedef std::string gml__UomIdentifier;
#endif

/* PlannedLandUse_v3.0.h:2416 */
#ifndef SOAP_TYPE_plu_gml__booleanList
#define SOAP_TYPE_plu_gml__booleanList (-742)

typedef std::string gml__booleanList;
#endif

/* PlannedLandUse_v3.0.h:2423 */
#ifndef SOAP_TYPE_plu_gml__doubleList
#define SOAP_TYPE_plu_gml__doubleList (-743)

typedef std::string gml__doubleList;
#endif

/* PlannedLandUse_v3.0.h:2430 */
#ifndef SOAP_TYPE_plu_gml__integerList
#define SOAP_TYPE_plu_gml__integerList (-744)

typedef std::string gml__integerList;
#endif

/* PlannedLandUse_v3.0.h:2437 */
#ifndef SOAP_TYPE_plu_gml__NameList
#define SOAP_TYPE_plu_gml__NameList (-745)

typedef std::string gml__NameList;
#endif

/* PlannedLandUse_v3.0.h:2444 */
#ifndef SOAP_TYPE_plu_gml__NCNameList
#define SOAP_TYPE_plu_gml__NCNameList (-746)

typedef std::string gml__NCNameList;
#endif

/* PlannedLandUse_v3.0.h:2451 */
#ifndef SOAP_TYPE_plu_gml__QNameList
#define SOAP_TYPE_plu_gml__QNameList (-747)

typedef xsd__QName gml__QNameList;
#endif

/* PlannedLandUse_v3.0.h:2458 */
#ifndef SOAP_TYPE_plu_gml__booleanOrNilReasonList
#define SOAP_TYPE_plu_gml__booleanOrNilReasonList (-748)

typedef std::string gml__booleanOrNilReasonList;
#endif

/* PlannedLandUse_v3.0.h:2465 */
#ifndef SOAP_TYPE_plu_gml__NameOrNilReasonList
#define SOAP_TYPE_plu_gml__NameOrNilReasonList (-749)

typedef std::string gml__NameOrNilReasonList;
#endif

/* PlannedLandUse_v3.0.h:2472 */
#ifndef SOAP_TYPE_plu_gml__doubleOrNilReasonList
#define SOAP_TYPE_plu_gml__doubleOrNilReasonList (-750)

typedef std::string gml__doubleOrNilReasonList;
#endif

/* PlannedLandUse_v3.0.h:2479 */
#ifndef SOAP_TYPE_plu_gml__integerOrNilReasonList
#define SOAP_TYPE_plu_gml__integerOrNilReasonList (-751)

typedef std::string gml__integerOrNilReasonList;
#endif

/* PlannedLandUse_v3.0.h:2486 */
#ifndef SOAP_TYPE_plu_gml__AxisDirectionList
#define SOAP_TYPE_plu_gml__AxisDirectionList (-752)

typedef std::string gml__AxisDirectionList;
#endif

/* PlannedLandUse_v3.0.h:2489 */
#ifndef SOAP_TYPE_plu_gml__TimePositionUnion
#define SOAP_TYPE_plu_gml__TimePositionUnion (-753)

typedef std::string gml__TimePositionUnion;
#endif

/* PlannedLandUse_v3.0.h:2492 */
#ifndef SOAP_TYPE_plu_gml__CalDate
#define SOAP_TYPE_plu_gml__CalDate (-754)

typedef std::string gml__CalDate;
#endif

/* PlannedLandUse_v3.0.h:2496 */
#ifndef SOAP_TYPE_plu_gml__TimeUnitType
#define SOAP_TYPE_plu_gml__TimeUnitType (-755)

typedef std::string gml__TimeUnitType;
#endif

/* PlannedLandUse_v3.0.h:2523 */
#ifndef SOAP_TYPE_plu_gco__Date_x005fType
#define SOAP_TYPE_plu_gco__Date_x005fType (-756)

typedef std::string gco__Date_x005fType;
#endif

/* PlannedLandUse_v3.0.h:2742 */
#ifndef SOAP_TYPE_plu_gml__UomSymbol
#define SOAP_TYPE_plu_gml__UomSymbol (-769)

typedef std::string gml__UomSymbol;
#endif

/* PlannedLandUse_v3.0.h:2759 */
#ifndef SOAP_TYPE_plu_gml__UomURI
#define SOAP_TYPE_plu_gml__UomURI (-771)

typedef char *gml__UomURI;
#endif

/* PlannedLandUse_v3.0.h:2794 */
#ifndef SOAP_TYPE_plu_gml__AxisDirection
#define SOAP_TYPE_plu_gml__AxisDirection (-775)

typedef std::string gml__AxisDirection;
#endif

/* PlannedLandUse_v3.0.h:2830 */
#ifndef SOAP_TYPE_plu_gml__CountExtentType
#define SOAP_TYPE_plu_gml__CountExtentType (-779)

typedef gml__integerOrNilReasonList gml__CountExtentType;
#endif

/* PlannedLandUse_v3.0.h:2886 */
#ifndef SOAP_TYPE_plu_gml__DegreeValueType
#define SOAP_TYPE_plu_gml__DegreeValueType (-784)

typedef xsd__nonNegativeInteger gml__DegreeValueType;
#endif

/* PlannedLandUse_v3.0.h:2898 */
#ifndef SOAP_TYPE_plu_gml__DecimalMinutesType
#define SOAP_TYPE_plu_gml__DecimalMinutesType (-786)

typedef xsd__decimal gml__DecimalMinutesType;
#endif

/* PlannedLandUse_v3.0.h:2910 */
#ifndef SOAP_TYPE_plu_gml__ArcMinutesType
#define SOAP_TYPE_plu_gml__ArcMinutesType (-788)

typedef xsd__nonNegativeInteger gml__ArcMinutesType;
#endif

/* PlannedLandUse_v3.0.h:2922 */
#ifndef SOAP_TYPE_plu_gml__ArcSecondsType
#define SOAP_TYPE_plu_gml__ArcSecondsType (-790)

typedef xsd__decimal gml__ArcSecondsType;
#endif

/* PlannedLandUse_v3.0.h:3059 */
#ifndef SOAP_TYPE_plu_xlink__hrefType
#define SOAP_TYPE_plu_xlink__hrefType (-802)

typedef xsd__anyURI xlink__hrefType;
#endif

/* PlannedLandUse_v3.0.h:3071 */
#ifndef SOAP_TYPE_plu_xlink__roleType
#define SOAP_TYPE_plu_xlink__roleType (-804)

typedef char *xlink__roleType;
#endif

/* PlannedLandUse_v3.0.h:3083 */
#ifndef SOAP_TYPE_plu_xlink__arcroleType
#define SOAP_TYPE_plu_xlink__arcroleType (-806)

typedef char *xlink__arcroleType;
#endif

/* PlannedLandUse_v3.0.h:3094 */
#ifndef SOAP_TYPE_plu_xlink__titleAttrType
#define SOAP_TYPE_plu_xlink__titleAttrType (-808)

typedef std::string xlink__titleAttrType;
#endif

/* PlannedLandUse_v3.0.h:3142 */
#ifndef SOAP_TYPE_plu_xlink__labelType
#define SOAP_TYPE_plu_xlink__labelType (-814)

typedef xsd__NCName xlink__labelType;
#endif

/* PlannedLandUse_v3.0.h:3153 */
#ifndef SOAP_TYPE_plu_xlink__fromType
#define SOAP_TYPE_plu_xlink__fromType (-816)

typedef xsd__NCName xlink__fromType;
#endif

/* PlannedLandUse_v3.0.h:3164 */
#ifndef SOAP_TYPE_plu_xlink__toType
#define SOAP_TYPE_plu_xlink__toType (-818)

typedef xsd__NCName xlink__toType;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* xsd__byte has binding name 'xsd__byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_plu_xsd__byte
#define SOAP_TYPE_plu_xsd__byte (-21)

#endif

/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_plu_byte
#define SOAP_TYPE_plu_byte (-3)

#endif

/* xsd__short has binding name 'xsd__short' for type 'xsd:short' */
#ifndef SOAP_TYPE_plu_xsd__short
#define SOAP_TYPE_plu_xsd__short (-47)

#endif

/* short has binding name 'short' for type 'xsd:short' */
#ifndef SOAP_TYPE_plu_short
#define SOAP_TYPE_plu_short (-46)

#endif

/* _SOAP_ENC__mustUnderstand has binding name '_SOAP_ENC__mustUnderstand' for type '' */
#ifndef SOAP_TYPE_plu__SOAP_ENC__mustUnderstand
#define SOAP_TYPE_plu__SOAP_ENC__mustUnderstand (-54)

#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_plu_int
#define SOAP_TYPE_plu_int (-1)

#endif

/* long has binding name 'long' for type 'xsd:long' */
#ifndef SOAP_TYPE_plu_long
#define SOAP_TYPE_plu_long (-892)

#endif

/* xsd__nonPositiveInteger has binding name 'xsd__nonPositiveInteger' for type 'xsd:nonPositiveInteger' */
#ifndef SOAP_TYPE_plu_xsd__nonPositiveInteger
#define SOAP_TYPE_plu_xsd__nonPositiveInteger (-40)

#endif

/* xsd__negativeInteger has binding name 'xsd__negativeInteger' for type 'xsd:negativeInteger' */
#ifndef SOAP_TYPE_plu_xsd__negativeInteger
#define SOAP_TYPE_plu_xsd__negativeInteger (-37)

#endif

/* xsd__long has binding name 'xsd__long' for type 'xsd:long' */
#ifndef SOAP_TYPE_plu_xsd__long
#define SOAP_TYPE_plu_xsd__long (-33)

#endif

/* xsd__integer has binding name 'xsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_plu_xsd__integer
#define SOAP_TYPE_plu_xsd__integer (-31)

#endif

/* LONG64 has binding name 'LONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_plu_LONG64
#define SOAP_TYPE_plu_LONG64 (-30)

#endif

/* xsd__float has binding name 'xsd__float' for type 'xsd:float' */
#ifndef SOAP_TYPE_plu_xsd__float
#define SOAP_TYPE_plu_xsd__float (-28)

#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_plu_float
#define SOAP_TYPE_plu_float (-27)

#endif

/* gml__ArcSecondsType has binding name 'gml__ArcSecondsType' for type 'gml:ArcSecondsType' */
#ifndef SOAP_TYPE_plu_gml__ArcSecondsType
#define SOAP_TYPE_plu_gml__ArcSecondsType (-790)

#endif

/* gml__DecimalMinutesType has binding name 'gml__DecimalMinutesType' for type 'gml:DecimalMinutesType' */
#ifndef SOAP_TYPE_plu_gml__DecimalMinutesType
#define SOAP_TYPE_plu_gml__DecimalMinutesType (-786)

#endif

/* xsd__double has binding name 'xsd__double' for type 'xsd:double' */
#ifndef SOAP_TYPE_plu_xsd__double
#define SOAP_TYPE_plu_xsd__double (-25)

#endif

/* xsd__decimal has binding name 'xsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_plu_xsd__decimal
#define SOAP_TYPE_plu_xsd__decimal (-24)

#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_plu_double
#define SOAP_TYPE_plu_double (-23)

#endif

/* xsd__unsignedByte has binding name 'xsd__unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_plu_xsd__unsignedByte
#define SOAP_TYPE_plu_xsd__unsignedByte (-48)

#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_plu_unsignedByte
#define SOAP_TYPE_plu_unsignedByte (-18)

#endif

/* xsd__unsignedShort has binding name 'xsd__unsignedShort' for type 'xsd:unsignedShort' */
#ifndef SOAP_TYPE_plu_xsd__unsignedShort
#define SOAP_TYPE_plu_xsd__unsignedShort (-52)

#endif

/* unsigned short has binding name 'unsignedShort' for type 'xsd:unsignedShort' */
#ifndef SOAP_TYPE_plu_unsignedShort
#define SOAP_TYPE_plu_unsignedShort (-51)

#endif

/* xsd__unsignedInt has binding name 'xsd__unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_plu_xsd__unsignedInt
#define SOAP_TYPE_plu_xsd__unsignedInt (-49)

#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_plu_unsignedInt
#define SOAP_TYPE_plu_unsignedInt (-17)

#endif

/* gml__ArcMinutesType has binding name 'gml__ArcMinutesType' for type 'gml:ArcMinutesType' */
#ifndef SOAP_TYPE_plu_gml__ArcMinutesType
#define SOAP_TYPE_plu_gml__ArcMinutesType (-788)

#endif

/* gml__DegreeValueType has binding name 'gml__DegreeValueType' for type 'gml:DegreeValueType' */
#ifndef SOAP_TYPE_plu_gml__DegreeValueType
#define SOAP_TYPE_plu_gml__DegreeValueType (-784)

#endif

/* xsd__unsignedLong has binding name 'xsd__unsignedLong' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_plu_xsd__unsignedLong
#define SOAP_TYPE_plu_xsd__unsignedLong (-50)

#endif

/* xsd__positiveInteger has binding name 'xsd__positiveInteger' for type 'xsd:positiveInteger' */
#ifndef SOAP_TYPE_plu_xsd__positiveInteger
#define SOAP_TYPE_plu_xsd__positiveInteger (-42)

#endif

/* xsd__nonNegativeInteger has binding name 'xsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_plu_xsd__nonNegativeInteger
#define SOAP_TYPE_plu_xsd__nonNegativeInteger (-39)

#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_plu_ULONG64
#define SOAP_TYPE_plu_ULONG64 (-38)

#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_plu_dateTime
#define SOAP_TYPE_plu_dateTime (-848)

#endif

/* enum _gml__DegreesType_direction has binding name '_gml__DegreesType_direction' for type 'gml:DegreesType-direction' */
#ifndef SOAP_TYPE_plu__gml__DegreesType_direction
#define SOAP_TYPE_plu__gml__DegreesType_direction (-2173)

#endif

/* enum _gml__RelatedTimeType_relativePosition has binding name '_gml__RelatedTimeType_relativePosition' for type 'gml:RelatedTimeType-relativePosition' */
#ifndef SOAP_TYPE_plu__gml__RelatedTimeType_relativePosition
#define SOAP_TYPE_plu__gml__RelatedTimeType_relativePosition (-1898)

#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_plu_bool
#define SOAP_TYPE_plu_bool (-832)

#endif

/* enum xlink__actuateType has binding name 'xlink__actuateType' for type 'xlink:actuateType' */
#ifndef SOAP_TYPE_plu_xlink__actuateType
#define SOAP_TYPE_plu_xlink__actuateType (-812)

#endif

/* enum xlink__showType has binding name 'xlink__showType' for type 'xlink:showType' */
#ifndef SOAP_TYPE_plu_xlink__showType
#define SOAP_TYPE_plu_xlink__showType (-810)

#endif

/* enum xlink__typeType has binding name 'xlink__typeType' for type 'xlink:typeType' */
#ifndef SOAP_TYPE_plu_xlink__typeType
#define SOAP_TYPE_plu_xlink__typeType (-800)

#endif

/* enum gmd__MD_x005fTopicCategoryCode_x005fType has binding name 'gmd__MD_x005fTopicCategoryCode_x005fType' for type 'gmd:MD_TopicCategoryCode_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fTopicCategoryCode_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fTopicCategoryCode_x005fType (-798)

#endif

/* enum gmd__MD_x005fObligationCode_x005fType has binding name 'gmd__MD_x005fObligationCode_x005fType' for type 'gmd:MD_ObligationCode_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fObligationCode_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fObligationCode_x005fType (-796)

#endif

/* enum gmd__MD_x005fPixelOrientationCode_x005fType has binding name 'gmd__MD_x005fPixelOrientationCode_x005fType' for type 'gmd:MD_PixelOrientationCode_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fPixelOrientationCode_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fPixelOrientationCode_x005fType (-794)

#endif

/* enum gml__IncrementOrder has binding name 'gml__IncrementOrder' for type 'gml:IncrementOrder' */
#ifndef SOAP_TYPE_plu_gml__IncrementOrder
#define SOAP_TYPE_plu_gml__IncrementOrder (-792)

#endif

/* enum gml__SuccessionType has binding name 'gml__SuccessionType' for type 'gml:SuccessionType' */
#ifndef SOAP_TYPE_plu_gml__SuccessionType
#define SOAP_TYPE_plu_gml__SuccessionType (-782)

#endif

/* enum gml__CompassPointEnumeration has binding name 'gml__CompassPointEnumeration' for type 'gml:CompassPointEnumeration' */
#ifndef SOAP_TYPE_plu_gml__CompassPointEnumeration
#define SOAP_TYPE_plu_gml__CompassPointEnumeration (-780)

#endif

/* enum gml__TimeIndeterminateValueType has binding name 'gml__TimeIndeterminateValueType' for type 'gml:TimeIndeterminateValueType' */
#ifndef SOAP_TYPE_plu_gml__TimeIndeterminateValueType
#define SOAP_TYPE_plu_gml__TimeIndeterminateValueType (-777)

#endif

/* enum gml__SequenceRuleEnumeration has binding name 'gml__SequenceRuleEnumeration' for type 'gml:SequenceRuleEnumeration' */
#ifndef SOAP_TYPE_plu_gml__SequenceRuleEnumeration
#define SOAP_TYPE_plu_gml__SequenceRuleEnumeration (-773)

#endif

/* enum gml__SignType has binding name 'gml__SignType' for type 'gml:SignType' */
#ifndef SOAP_TYPE_plu_gml__SignType
#define SOAP_TYPE_plu_gml__SignType (-767)

#endif

/* enum gml__AggregationType has binding name 'gml__AggregationType' for type 'gml:AggregationType' */
#ifndef SOAP_TYPE_plu_gml__AggregationType
#define SOAP_TYPE_plu_gml__AggregationType (-765)

#endif

/* enum gml__SurfaceInterpolationType has binding name 'gml__SurfaceInterpolationType' for type 'gml:SurfaceInterpolationType' */
#ifndef SOAP_TYPE_plu_gml__SurfaceInterpolationType
#define SOAP_TYPE_plu_gml__SurfaceInterpolationType (-763)

#endif

/* enum gml__KnotTypesType has binding name 'gml__KnotTypesType' for type 'gml:KnotTypesType' */
#ifndef SOAP_TYPE_plu_gml__KnotTypesType
#define SOAP_TYPE_plu_gml__KnotTypesType (-761)

#endif

/* enum gml__CurveInterpolationType has binding name 'gml__CurveInterpolationType' for type 'gml:CurveInterpolationType' */
#ifndef SOAP_TYPE_plu_gml__CurveInterpolationType
#define SOAP_TYPE_plu_gml__CurveInterpolationType (-759)

#endif

/* enum base__VerticalPositionValueType has binding name 'base__VerticalPositionValueType' for type 'base:VerticalPositionValueType' */
#ifndef SOAP_TYPE_plu_base__VerticalPositionValueType
#define SOAP_TYPE_plu_base__VerticalPositionValueType (-757)

#endif

/* _gml__TinType_controlPoint has binding name '_gml__TinType_controlPoint' for type '' */
#ifndef SOAP_TYPE_plu__gml__TinType_controlPoint
#define SOAP_TYPE_plu__gml__TinType_controlPoint (-2296)

#endif

/* _gml__AbstractGriddedSurfaceType_rows_Row has binding name '_gml__AbstractGriddedSurfaceType_rows_Row' for type '' */
#ifndef SOAP_TYPE_plu__gml__AbstractGriddedSurfaceType_rows_Row
#define SOAP_TYPE_plu__gml__AbstractGriddedSurfaceType_rows_Row (-2152)

#endif

/* _gml__AbstractGriddedSurfaceType_rows has binding name '_gml__AbstractGriddedSurfaceType_rows' for type '' */
#ifndef SOAP_TYPE_plu__gml__AbstractGriddedSurfaceType_rows
#define SOAP_TYPE_plu__gml__AbstractGriddedSurfaceType_rows (-2151)

#endif

/* _base__SpatialDataSetType_metadata has binding name '_base__SpatialDataSetType_metadata' for type '' */
#ifndef SOAP_TYPE_plu__base__SpatialDataSetType_metadata
#define SOAP_TYPE_plu__base__SpatialDataSetType_metadata (-2112)

#endif

/* _plu__SpatialPlanType_ordinance has binding name '_plu__SpatialPlanType_ordinance' for type '' */
#ifndef SOAP_TYPE_plu__plu__SpatialPlanType_ordinance
#define SOAP_TYPE_plu__plu__SpatialPlanType_ordinance (-2109)

#endif

/* _plu__SpatialPlanType_backgroundMap has binding name '_plu__SpatialPlanType_backgroundMap' for type '' */
#ifndef SOAP_TYPE_plu__plu__SpatialPlanType_backgroundMap
#define SOAP_TYPE_plu__plu__SpatialPlanType_backgroundMap (-2107)

#endif

/* _plu__SpatialPlanType_alternativeTitle has binding name '_plu__SpatialPlanType_alternativeTitle' for type '' */
#ifndef SOAP_TYPE_plu__plu__SpatialPlanType_alternativeTitle
#define SOAP_TYPE_plu__plu__SpatialPlanType_alternativeTitle (-2105)

#endif

/* _plu__SpatialPlanType_validTo has binding name '_plu__SpatialPlanType_validTo' for type '' */
#ifndef SOAP_TYPE_plu__plu__SpatialPlanType_validTo
#define SOAP_TYPE_plu__plu__SpatialPlanType_validTo (-2103)

#endif

/* _plu__SpatialPlanType_validFrom has binding name '_plu__SpatialPlanType_validFrom' for type '' */
#ifndef SOAP_TYPE_plu__plu__SpatialPlanType_validFrom
#define SOAP_TYPE_plu__plu__SpatialPlanType_validFrom (-2101)

#endif

/* _plu__SpatialPlanType_endLifespanVersion has binding name '_plu__SpatialPlanType_endLifespanVersion' for type '' */
#ifndef SOAP_TYPE_plu__plu__SpatialPlanType_endLifespanVersion
#define SOAP_TYPE_plu__plu__SpatialPlanType_endLifespanVersion (-2099)

#endif

/* _plu__SpatialPlanType_beginLifespanVersion has binding name '_plu__SpatialPlanType_beginLifespanVersion' for type '' */
#ifndef SOAP_TYPE_plu__plu__SpatialPlanType_beginLifespanVersion
#define SOAP_TYPE_plu__plu__SpatialPlanType_beginLifespanVersion (-2097)

#endif

/* _plu__SupplementaryRegulationType_name has binding name '_plu__SupplementaryRegulationType_name' for type '' */
#ifndef SOAP_TYPE_plu__plu__SupplementaryRegulationType_name
#define SOAP_TYPE_plu__plu__SupplementaryRegulationType_name (-2094)

#endif

/* _plu__SupplementaryRegulationType_specificRegulationNature has binding name '_plu__SupplementaryRegulationType_specificRegulationNature' for type '' */
#ifndef SOAP_TYPE_plu__plu__SupplementaryRegulationType_specificRegulationNature
#define SOAP_TYPE_plu__plu__SupplementaryRegulationType_specificRegulationNature (-2092)

#endif

/* _plu__SupplementaryRegulationType_inheritedFromOtherPlans has binding name '_plu__SupplementaryRegulationType_inheritedFromOtherPlans' for type '' */
#ifndef SOAP_TYPE_plu__plu__SupplementaryRegulationType_inheritedFromOtherPlans
#define SOAP_TYPE_plu__plu__SupplementaryRegulationType_inheritedFromOtherPlans (-2090)

#endif

/* _plu__SupplementaryRegulationType_endLifespanVersion has binding name '_plu__SupplementaryRegulationType_endLifespanVersion' for type '' */
#ifndef SOAP_TYPE_plu__plu__SupplementaryRegulationType_endLifespanVersion
#define SOAP_TYPE_plu__plu__SupplementaryRegulationType_endLifespanVersion (-2087)

#endif

/* _plu__SupplementaryRegulationType_dimensioningIndication has binding name '_plu__SupplementaryRegulationType_dimensioningIndication' for type '' */
#ifndef SOAP_TYPE_plu__plu__SupplementaryRegulationType_dimensioningIndication
#define SOAP_TYPE_plu__plu__SupplementaryRegulationType_dimensioningIndication (-2083)

#endif

/* _plu__SupplementaryRegulationType_beginLifespanVersion has binding name '_plu__SupplementaryRegulationType_beginLifespanVersion' for type '' */
#ifndef SOAP_TYPE_plu__plu__SupplementaryRegulationType_beginLifespanVersion
#define SOAP_TYPE_plu__plu__SupplementaryRegulationType_beginLifespanVersion (-2081)

#endif

/* _plu__SupplementaryRegulationType_backgroundMap has binding name '_plu__SupplementaryRegulationType_backgroundMap' for type '' */
#ifndef SOAP_TYPE_plu__plu__SupplementaryRegulationType_backgroundMap
#define SOAP_TYPE_plu__plu__SupplementaryRegulationType_backgroundMap (-2079)

#endif

/* _plu__SupplementaryRegulationType_validTo has binding name '_plu__SupplementaryRegulationType_validTo' for type '' */
#ifndef SOAP_TYPE_plu__plu__SupplementaryRegulationType_validTo
#define SOAP_TYPE_plu__plu__SupplementaryRegulationType_validTo (-2077)

#endif

/* _plu__SupplementaryRegulationType_validFrom has binding name '_plu__SupplementaryRegulationType_validFrom' for type '' */
#ifndef SOAP_TYPE_plu__plu__SupplementaryRegulationType_validFrom
#define SOAP_TYPE_plu__plu__SupplementaryRegulationType_validFrom (-2075)

#endif

/* _plu__OfficialDocumentationType_planDocument has binding name '_plu__OfficialDocumentationType_planDocument' for type '' */
#ifndef SOAP_TYPE_plu__plu__OfficialDocumentationType_planDocument
#define SOAP_TYPE_plu__plu__OfficialDocumentationType_planDocument (-2070)

#endif

/* _plu__OfficialDocumentationType_regulationText has binding name '_plu__OfficialDocumentationType_regulationText' for type '' */
#ifndef SOAP_TYPE_plu__plu__OfficialDocumentationType_regulationText
#define SOAP_TYPE_plu__plu__OfficialDocumentationType_regulationText (-2068)

#endif

/* _plu__OfficialDocumentationType_legislationCitation has binding name '_plu__OfficialDocumentationType_legislationCitation' for type '' */
#ifndef SOAP_TYPE_plu__plu__OfficialDocumentationType_legislationCitation
#define SOAP_TYPE_plu__plu__OfficialDocumentationType_legislationCitation (-2064)

#endif

/* _plu__ZoningElementType_dimensioningIndication has binding name '_plu__ZoningElementType_dimensioningIndication' for type '' */
#ifndef SOAP_TYPE_plu__plu__ZoningElementType_dimensioningIndication
#define SOAP_TYPE_plu__plu__ZoningElementType_dimensioningIndication (-2060)

#endif

/* _plu__ZoningElementType_backgroundMap has binding name '_plu__ZoningElementType_backgroundMap' for type '' */
#ifndef SOAP_TYPE_plu__plu__ZoningElementType_backgroundMap
#define SOAP_TYPE_plu__plu__ZoningElementType_backgroundMap (-2058)

#endif

/* _plu__ZoningElementType_endLifespanVersion has binding name '_plu__ZoningElementType_endLifespanVersion' for type '' */
#ifndef SOAP_TYPE_plu__plu__ZoningElementType_endLifespanVersion
#define SOAP_TYPE_plu__plu__ZoningElementType_endLifespanVersion (-2056)

#endif

/* _plu__ZoningElementType_specificPresence has binding name '_plu__ZoningElementType_specificPresence' for type '' */
#ifndef SOAP_TYPE_plu__plu__ZoningElementType_specificPresence
#define SOAP_TYPE_plu__plu__ZoningElementType_specificPresence (-2054)

#endif

/* _plu__ZoningElementType_hilucsPresence has binding name '_plu__ZoningElementType_hilucsPresence' for type '' */
#ifndef SOAP_TYPE_plu__plu__ZoningElementType_hilucsPresence
#define SOAP_TYPE_plu__plu__ZoningElementType_hilucsPresence (-2052)

#endif

/* _plu__ZoningElementType_beginLifespanVersion has binding name '_plu__ZoningElementType_beginLifespanVersion' for type '' */
#ifndef SOAP_TYPE_plu__plu__ZoningElementType_beginLifespanVersion
#define SOAP_TYPE_plu__plu__ZoningElementType_beginLifespanVersion (-2050)

#endif

/* _plu__ZoningElementType_validTo has binding name '_plu__ZoningElementType_validTo' for type '' */
#ifndef SOAP_TYPE_plu__plu__ZoningElementType_validTo
#define SOAP_TYPE_plu__plu__ZoningElementType_validTo (-2048)

#endif

/* _plu__ZoningElementType_validFrom has binding name '_plu__ZoningElementType_validFrom' for type '' */
#ifndef SOAP_TYPE_plu__plu__ZoningElementType_validFrom
#define SOAP_TYPE_plu__plu__ZoningElementType_validFrom (-2046)

#endif

/* _gml__ClothoidType_refLocation has binding name '_gml__ClothoidType_refLocation' for type '' */
#ifndef SOAP_TYPE_plu__gml__ClothoidType_refLocation
#define SOAP_TYPE_plu__gml__ClothoidType_refLocation (-1875)

#endif

/* _base2__DocumentCitationType_specificReference has binding name '_base2__DocumentCitationType_specificReference' for type '' */
#ifndef SOAP_TYPE_plu__base2__DocumentCitationType_specificReference
#define SOAP_TYPE_plu__base2__DocumentCitationType_specificReference (-1830)

#endif

/* _base2__DocumentCitationType_link has binding name '_base2__DocumentCitationType_link' for type '' */
#ifndef SOAP_TYPE_plu__base2__DocumentCitationType_link
#define SOAP_TYPE_plu__base2__DocumentCitationType_link (-1827)

#endif

/* _base2__DocumentCitationType_date has binding name '_base2__DocumentCitationType_date' for type '' */
#ifndef SOAP_TYPE_plu__base2__DocumentCitationType_date
#define SOAP_TYPE_plu__base2__DocumentCitationType_date (-1825)

#endif

/* _base2__DocumentCitationType_shortName has binding name '_base2__DocumentCitationType_shortName' for type '' */
#ifndef SOAP_TYPE_plu__base2__DocumentCitationType_shortName
#define SOAP_TYPE_plu__base2__DocumentCitationType_shortName (-1823)

#endif

/* _base2__RelatedPartyType_contact has binding name '_base2__RelatedPartyType_contact' for type '' */
#ifndef SOAP_TYPE_plu__base2__RelatedPartyType_contact
#define SOAP_TYPE_plu__base2__RelatedPartyType_contact (-876)

#endif

/* _base2__ContactType_website has binding name '_base2__ContactType_website' for type '' */
#ifndef SOAP_TYPE_plu__base2__ContactType_website
#define SOAP_TYPE_plu__base2__ContactType_website (-873)

#endif

/* _base2__ContactType_telephoneVoice has binding name '_base2__ContactType_telephoneVoice' for type '' */
#ifndef SOAP_TYPE_plu__base2__ContactType_telephoneVoice
#define SOAP_TYPE_plu__base2__ContactType_telephoneVoice (-870)

#endif

/* _base2__ContactType_telephoneFacsimile has binding name '_base2__ContactType_telephoneFacsimile' for type '' */
#ifndef SOAP_TYPE_plu__base2__ContactType_telephoneFacsimile
#define SOAP_TYPE_plu__base2__ContactType_telephoneFacsimile (-867)

#endif

/* _base2__ContactType_electronicMailAddress has binding name '_base2__ContactType_electronicMailAddress' for type '' */
#ifndef SOAP_TYPE_plu__base2__ContactType_electronicMailAddress
#define SOAP_TYPE_plu__base2__ContactType_electronicMailAddress (-865)

#endif

/* _base__IdentifierType_versionId has binding name '_base__IdentifierType_versionId' for type '' */
#ifndef SOAP_TYPE_plu__base__IdentifierType_versionId
#define SOAP_TYPE_plu__base__IdentifierType_versionId (-856)

#endif

/* _plu__BackgroundMapValueType_backgroudMapURI has binding name '_plu__BackgroundMapValueType_backgroudMapURI' for type '' */
#ifndef SOAP_TYPE_plu__plu__BackgroundMapValueType_backgroudMapURI
#define SOAP_TYPE_plu__plu__BackgroundMapValueType_backgroudMapURI (-850)

#endif

/* xlink__toType__ has binding name 'xlink__toType__' for type 'xlink:toType' */
#ifndef SOAP_TYPE_plu_xlink__toType__
#define SOAP_TYPE_plu_xlink__toType__ (-819)

#endif

/* xlink__fromType__ has binding name 'xlink__fromType__' for type 'xlink:fromType' */
#ifndef SOAP_TYPE_plu_xlink__fromType__
#define SOAP_TYPE_plu_xlink__fromType__ (-817)

#endif

/* xlink__labelType__ has binding name 'xlink__labelType__' for type 'xlink:labelType' */
#ifndef SOAP_TYPE_plu_xlink__labelType__
#define SOAP_TYPE_plu_xlink__labelType__ (-815)

#endif

/* xlink__actuateType_ has binding name 'xlink__actuateType_' for type 'xlink:actuateType' */
#ifndef SOAP_TYPE_plu_xlink__actuateType_
#define SOAP_TYPE_plu_xlink__actuateType_ (-813)

#endif

/* xlink__showType_ has binding name 'xlink__showType_' for type 'xlink:showType' */
#ifndef SOAP_TYPE_plu_xlink__showType_
#define SOAP_TYPE_plu_xlink__showType_ (-811)

#endif

/* xlink__titleAttrType__ has binding name 'xlink__titleAttrType__' for type 'xlink:titleAttrType' */
#ifndef SOAP_TYPE_plu_xlink__titleAttrType__
#define SOAP_TYPE_plu_xlink__titleAttrType__ (-809)

#endif

/* xlink__titleAttrType has binding name 'xlink__titleAttrType' for type 'xlink:titleAttrType' */
#ifndef SOAP_TYPE_plu_xlink__titleAttrType
#define SOAP_TYPE_plu_xlink__titleAttrType (-808)

#endif

/* xlink__arcroleType__ has binding name 'xlink__arcroleType__' for type 'xlink:arcroleType' */
#ifndef SOAP_TYPE_plu_xlink__arcroleType__
#define SOAP_TYPE_plu_xlink__arcroleType__ (-807)

#endif

/* xlink__roleType__ has binding name 'xlink__roleType__' for type 'xlink:roleType' */
#ifndef SOAP_TYPE_plu_xlink__roleType__
#define SOAP_TYPE_plu_xlink__roleType__ (-805)

#endif

/* xlink__hrefType__ has binding name 'xlink__hrefType__' for type 'xlink:hrefType' */
#ifndef SOAP_TYPE_plu_xlink__hrefType__
#define SOAP_TYPE_plu_xlink__hrefType__ (-803)

#endif

/* xlink__typeType_ has binding name 'xlink__typeType_' for type 'xlink:typeType' */
#ifndef SOAP_TYPE_plu_xlink__typeType_
#define SOAP_TYPE_plu_xlink__typeType_ (-801)

#endif

/* gmd__MD_x005fTopicCategoryCode_x005fType_ has binding name 'gmd__MD_x005fTopicCategoryCode_x005fType_' for type 'gmd:MD_TopicCategoryCode_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fTopicCategoryCode_x005fType_
#define SOAP_TYPE_plu_gmd__MD_x005fTopicCategoryCode_x005fType_ (-799)

#endif

/* gmd__MD_x005fObligationCode_x005fType_ has binding name 'gmd__MD_x005fObligationCode_x005fType_' for type 'gmd:MD_ObligationCode_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fObligationCode_x005fType_
#define SOAP_TYPE_plu_gmd__MD_x005fObligationCode_x005fType_ (-797)

#endif

/* gmd__MD_x005fPixelOrientationCode_x005fType_ has binding name 'gmd__MD_x005fPixelOrientationCode_x005fType_' for type 'gmd:MD_PixelOrientationCode_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fPixelOrientationCode_x005fType_
#define SOAP_TYPE_plu_gmd__MD_x005fPixelOrientationCode_x005fType_ (-795)

#endif

/* gml__IncrementOrder_ has binding name 'gml__IncrementOrder_' for type 'gml:IncrementOrder' */
#ifndef SOAP_TYPE_plu_gml__IncrementOrder_
#define SOAP_TYPE_plu_gml__IncrementOrder_ (-793)

#endif

/* gml__ArcSecondsType__ has binding name 'gml__ArcSecondsType__' for type 'gml:ArcSecondsType' */
#ifndef SOAP_TYPE_plu_gml__ArcSecondsType__
#define SOAP_TYPE_plu_gml__ArcSecondsType__ (-791)

#endif

/* gml__ArcMinutesType__ has binding name 'gml__ArcMinutesType__' for type 'gml:ArcMinutesType' */
#ifndef SOAP_TYPE_plu_gml__ArcMinutesType__
#define SOAP_TYPE_plu_gml__ArcMinutesType__ (-789)

#endif

/* gml__DecimalMinutesType__ has binding name 'gml__DecimalMinutesType__' for type 'gml:DecimalMinutesType' */
#ifndef SOAP_TYPE_plu_gml__DecimalMinutesType__
#define SOAP_TYPE_plu_gml__DecimalMinutesType__ (-787)

#endif

/* gml__DegreeValueType__ has binding name 'gml__DegreeValueType__' for type 'gml:DegreeValueType' */
#ifndef SOAP_TYPE_plu_gml__DegreeValueType__
#define SOAP_TYPE_plu_gml__DegreeValueType__ (-785)

#endif

/* gml__SuccessionType_ has binding name 'gml__SuccessionType_' for type 'gml:SuccessionType' */
#ifndef SOAP_TYPE_plu_gml__SuccessionType_
#define SOAP_TYPE_plu_gml__SuccessionType_ (-783)

#endif

/* gml__CompassPointEnumeration_ has binding name 'gml__CompassPointEnumeration_' for type 'gml:CompassPointEnumeration' */
#ifndef SOAP_TYPE_plu_gml__CompassPointEnumeration_
#define SOAP_TYPE_plu_gml__CompassPointEnumeration_ (-781)

#endif

/* gml__CountExtentType has binding name 'gml__CountExtentType' for type 'gml:CountExtentType' */
#ifndef SOAP_TYPE_plu_gml__CountExtentType
#define SOAP_TYPE_plu_gml__CountExtentType (-779)

#endif

/* gml__TimeIndeterminateValueType_ has binding name 'gml__TimeIndeterminateValueType_' for type 'gml:TimeIndeterminateValueType' */
#ifndef SOAP_TYPE_plu_gml__TimeIndeterminateValueType_
#define SOAP_TYPE_plu_gml__TimeIndeterminateValueType_ (-778)

#endif

/* gml__AxisDirection__ has binding name 'gml__AxisDirection__' for type 'gml:AxisDirection' */
#ifndef SOAP_TYPE_plu_gml__AxisDirection__
#define SOAP_TYPE_plu_gml__AxisDirection__ (-776)

#endif

/* gml__AxisDirection has binding name 'gml__AxisDirection' for type 'gml:AxisDirection' */
#ifndef SOAP_TYPE_plu_gml__AxisDirection
#define SOAP_TYPE_plu_gml__AxisDirection (-775)

#endif

/* gml__SequenceRuleEnumeration_ has binding name 'gml__SequenceRuleEnumeration_' for type 'gml:SequenceRuleEnumeration' */
#ifndef SOAP_TYPE_plu_gml__SequenceRuleEnumeration_
#define SOAP_TYPE_plu_gml__SequenceRuleEnumeration_ (-774)

#endif

/* gml__UomURI__ has binding name 'gml__UomURI__' for type 'gml:UomURI' */
#ifndef SOAP_TYPE_plu_gml__UomURI__
#define SOAP_TYPE_plu_gml__UomURI__ (-772)

#endif

/* gml__UomSymbol__ has binding name 'gml__UomSymbol__' for type 'gml:UomSymbol' */
#ifndef SOAP_TYPE_plu_gml__UomSymbol__
#define SOAP_TYPE_plu_gml__UomSymbol__ (-770)

#endif

/* gml__UomSymbol has binding name 'gml__UomSymbol' for type 'gml:UomSymbol' */
#ifndef SOAP_TYPE_plu_gml__UomSymbol
#define SOAP_TYPE_plu_gml__UomSymbol (-769)

#endif

/* gml__SignType_ has binding name 'gml__SignType_' for type 'gml:SignType' */
#ifndef SOAP_TYPE_plu_gml__SignType_
#define SOAP_TYPE_plu_gml__SignType_ (-768)

#endif

/* gml__AggregationType_ has binding name 'gml__AggregationType_' for type 'gml:AggregationType' */
#ifndef SOAP_TYPE_plu_gml__AggregationType_
#define SOAP_TYPE_plu_gml__AggregationType_ (-766)

#endif

/* gml__SurfaceInterpolationType_ has binding name 'gml__SurfaceInterpolationType_' for type 'gml:SurfaceInterpolationType' */
#ifndef SOAP_TYPE_plu_gml__SurfaceInterpolationType_
#define SOAP_TYPE_plu_gml__SurfaceInterpolationType_ (-764)

#endif

/* gml__KnotTypesType_ has binding name 'gml__KnotTypesType_' for type 'gml:KnotTypesType' */
#ifndef SOAP_TYPE_plu_gml__KnotTypesType_
#define SOAP_TYPE_plu_gml__KnotTypesType_ (-762)

#endif

/* gml__CurveInterpolationType_ has binding name 'gml__CurveInterpolationType_' for type 'gml:CurveInterpolationType' */
#ifndef SOAP_TYPE_plu_gml__CurveInterpolationType_
#define SOAP_TYPE_plu_gml__CurveInterpolationType_ (-760)

#endif

/* base__VerticalPositionValueType_ has binding name 'base__VerticalPositionValueType_' for type 'base:VerticalPositionValueType' */
#ifndef SOAP_TYPE_plu_base__VerticalPositionValueType_
#define SOAP_TYPE_plu_base__VerticalPositionValueType_ (-758)

#endif

/* gco__Date_x005fType has binding name 'gco__Date_x005fType' for type 'gco:Date_Type' */
#ifndef SOAP_TYPE_plu_gco__Date_x005fType
#define SOAP_TYPE_plu_gco__Date_x005fType (-756)

#endif

/* gml__TimeUnitType has binding name 'gml__TimeUnitType' for type 'gml:TimeUnitType' */
#ifndef SOAP_TYPE_plu_gml__TimeUnitType
#define SOAP_TYPE_plu_gml__TimeUnitType (-755)

#endif

/* gml__CalDate has binding name 'gml__CalDate' for type 'gml:CalDate' */
#ifndef SOAP_TYPE_plu_gml__CalDate
#define SOAP_TYPE_plu_gml__CalDate (-754)

#endif

/* gml__TimePositionUnion has binding name 'gml__TimePositionUnion' for type 'gml:TimePositionUnion' */
#ifndef SOAP_TYPE_plu_gml__TimePositionUnion
#define SOAP_TYPE_plu_gml__TimePositionUnion (-753)

#endif

/* gml__AxisDirectionList has binding name 'gml__AxisDirectionList' for type 'gml:AxisDirectionList' */
#ifndef SOAP_TYPE_plu_gml__AxisDirectionList
#define SOAP_TYPE_plu_gml__AxisDirectionList (-752)

#endif

/* gml__integerOrNilReasonList has binding name 'gml__integerOrNilReasonList' for type 'gml:integerOrNilReasonList' */
#ifndef SOAP_TYPE_plu_gml__integerOrNilReasonList
#define SOAP_TYPE_plu_gml__integerOrNilReasonList (-751)

#endif

/* gml__doubleOrNilReasonList has binding name 'gml__doubleOrNilReasonList' for type 'gml:doubleOrNilReasonList' */
#ifndef SOAP_TYPE_plu_gml__doubleOrNilReasonList
#define SOAP_TYPE_plu_gml__doubleOrNilReasonList (-750)

#endif

/* gml__NameOrNilReasonList has binding name 'gml__NameOrNilReasonList' for type 'gml:NameOrNilReasonList' */
#ifndef SOAP_TYPE_plu_gml__NameOrNilReasonList
#define SOAP_TYPE_plu_gml__NameOrNilReasonList (-749)

#endif

/* gml__booleanOrNilReasonList has binding name 'gml__booleanOrNilReasonList' for type 'gml:booleanOrNilReasonList' */
#ifndef SOAP_TYPE_plu_gml__booleanOrNilReasonList
#define SOAP_TYPE_plu_gml__booleanOrNilReasonList (-748)

#endif

/* gml__NCNameList has binding name 'gml__NCNameList' for type 'gml:NCNameList' */
#ifndef SOAP_TYPE_plu_gml__NCNameList
#define SOAP_TYPE_plu_gml__NCNameList (-746)

#endif

/* gml__NameList has binding name 'gml__NameList' for type 'gml:NameList' */
#ifndef SOAP_TYPE_plu_gml__NameList
#define SOAP_TYPE_plu_gml__NameList (-745)

#endif

/* gml__integerList has binding name 'gml__integerList' for type 'gml:integerList' */
#ifndef SOAP_TYPE_plu_gml__integerList
#define SOAP_TYPE_plu_gml__integerList (-744)

#endif

/* gml__doubleList has binding name 'gml__doubleList' for type 'gml:doubleList' */
#ifndef SOAP_TYPE_plu_gml__doubleList
#define SOAP_TYPE_plu_gml__doubleList (-743)

#endif

/* gml__booleanList has binding name 'gml__booleanList' for type 'gml:booleanList' */
#ifndef SOAP_TYPE_plu_gml__booleanList
#define SOAP_TYPE_plu_gml__booleanList (-742)

#endif

/* gml__UomIdentifier has binding name 'gml__UomIdentifier' for type 'gml:UomIdentifier' */
#ifndef SOAP_TYPE_plu_gml__UomIdentifier
#define SOAP_TYPE_plu_gml__UomIdentifier (-741)

#endif

/* gml__stringOrNilReason has binding name 'gml__stringOrNilReason' for type 'gml:stringOrNilReason' */
#ifndef SOAP_TYPE_plu_gml__stringOrNilReason
#define SOAP_TYPE_plu_gml__stringOrNilReason (-740)

#endif

/* gml__NameOrNilReason has binding name 'gml__NameOrNilReason' for type 'gml:NameOrNilReason' */
#ifndef SOAP_TYPE_plu_gml__NameOrNilReason
#define SOAP_TYPE_plu_gml__NameOrNilReason (-739)

#endif

/* gml__integerOrNilReason has binding name 'gml__integerOrNilReason' for type 'gml:integerOrNilReason' */
#ifndef SOAP_TYPE_plu_gml__integerOrNilReason
#define SOAP_TYPE_plu_gml__integerOrNilReason (-738)

#endif

/* gml__doubleOrNilReason has binding name 'gml__doubleOrNilReason' for type 'gml:doubleOrNilReason' */
#ifndef SOAP_TYPE_plu_gml__doubleOrNilReason
#define SOAP_TYPE_plu_gml__doubleOrNilReason (-737)

#endif

/* gml__booleanOrNilReason has binding name 'gml__booleanOrNilReason' for type 'gml:booleanOrNilReason' */
#ifndef SOAP_TYPE_plu_gml__booleanOrNilReason
#define SOAP_TYPE_plu_gml__booleanOrNilReason (-736)

#endif

/* gml__NilReasonEnumeration has binding name 'gml__NilReasonEnumeration' for type 'gml:NilReasonEnumeration' */
#ifndef SOAP_TYPE_plu_gml__NilReasonEnumeration
#define SOAP_TYPE_plu_gml__NilReasonEnumeration (-735)

#endif

/* gml__NilReasonType has binding name 'gml__NilReasonType' for type 'gml:NilReasonType' */
#ifndef SOAP_TYPE_plu_gml__NilReasonType
#define SOAP_TYPE_plu_gml__NilReasonType (-734)

#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_plu_std__string
#define SOAP_TYPE_plu_std__string (-733)

#endif

/* gsr__SC_x005fCRS_x005fPropertyType has binding name 'gsr__SC_x005fCRS_x005fPropertyType' for type 'gsr:SC_CRS_PropertyType' */
#ifndef SOAP_TYPE_plu_gsr__SC_x005fCRS_x005fPropertyType
#define SOAP_TYPE_plu_gsr__SC_x005fCRS_x005fPropertyType (-732)

#endif

/* gts__TM_x005fPeriodDuration_x005fPropertyType has binding name 'gts__TM_x005fPeriodDuration_x005fPropertyType' for type 'gts:TM_PeriodDuration_PropertyType' */
#ifndef SOAP_TYPE_plu_gts__TM_x005fPeriodDuration_x005fPropertyType
#define SOAP_TYPE_plu_gts__TM_x005fPeriodDuration_x005fPropertyType (-731)

#endif

/* gts__TM_x005fPrimitive_x005fPropertyType has binding name 'gts__TM_x005fPrimitive_x005fPropertyType' for type 'gts:TM_Primitive_PropertyType' */
#ifndef SOAP_TYPE_plu_gts__TM_x005fPrimitive_x005fPropertyType
#define SOAP_TYPE_plu_gts__TM_x005fPrimitive_x005fPropertyType (-730)

#endif

/* gss__GM_x005fObject_x005fPropertyType has binding name 'gss__GM_x005fObject_x005fPropertyType' for type 'gss:GM_Object_PropertyType' */
#ifndef SOAP_TYPE_plu_gss__GM_x005fObject_x005fPropertyType
#define SOAP_TYPE_plu_gss__GM_x005fObject_x005fPropertyType (-729)

#endif

/* gss__GM_x005fPoint_x005fPropertyType has binding name 'gss__GM_x005fPoint_x005fPropertyType' for type 'gss:GM_Point_PropertyType' */
#ifndef SOAP_TYPE_plu_gss__GM_x005fPoint_x005fPropertyType
#define SOAP_TYPE_plu_gss__GM_x005fPoint_x005fPropertyType (-728)

#endif

/* gco__CodeListValue_x005fType has binding name 'gco__CodeListValue_x005fType' for type 'gco:CodeListValue_Type' */
#ifndef SOAP_TYPE_plu_gco__CodeListValue_x005fType
#define SOAP_TYPE_plu_gco__CodeListValue_x005fType (-727)

#endif

/* gco__ObjectReference_x005fPropertyType has binding name 'gco__ObjectReference_x005fPropertyType' for type 'gco:ObjectReference_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__ObjectReference_x005fPropertyType
#define SOAP_TYPE_plu_gco__ObjectReference_x005fPropertyType (-726)

#endif

/* gco__AbstractObject_x005fType has binding name 'gco__AbstractObject_x005fType' for type 'gco:AbstractObject_Type' */
#ifndef SOAP_TYPE_plu_gco__AbstractObject_x005fType
#define SOAP_TYPE_plu_gco__AbstractObject_x005fType (-725)

#endif

/* gco__Binary_x005fPropertyType has binding name 'gco__Binary_x005fPropertyType' for type 'gco:Binary_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__Binary_x005fPropertyType
#define SOAP_TYPE_plu_gco__Binary_x005fPropertyType (-724)

#endif

/* gco__Binary_x005fType has binding name 'gco__Binary_x005fType' for type 'gco:Binary_Type' */
#ifndef SOAP_TYPE_plu_gco__Binary_x005fType
#define SOAP_TYPE_plu_gco__Binary_x005fType (-723)

#endif

/* gco__RecordType_x005fPropertyType has binding name 'gco__RecordType_x005fPropertyType' for type 'gco:RecordType_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__RecordType_x005fPropertyType
#define SOAP_TYPE_plu_gco__RecordType_x005fPropertyType (-722)

#endif

/* gco__RecordType_x005fType has binding name 'gco__RecordType_x005fType' for type 'gco:RecordType_Type' */
#ifndef SOAP_TYPE_plu_gco__RecordType_x005fType
#define SOAP_TYPE_plu_gco__RecordType_x005fType (-721)

#endif

/* gco__Record_x005fPropertyType has binding name 'gco__Record_x005fPropertyType' for type 'gco:Record_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__Record_x005fPropertyType
#define SOAP_TYPE_plu_gco__Record_x005fPropertyType (-720)

#endif

/* gco__UnlimitedInteger_x005fPropertyType has binding name 'gco__UnlimitedInteger_x005fPropertyType' for type 'gco:UnlimitedInteger_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__UnlimitedInteger_x005fPropertyType
#define SOAP_TYPE_plu_gco__UnlimitedInteger_x005fPropertyType (-719)

#endif

/* gco__UnlimitedInteger_x005fType has binding name 'gco__UnlimitedInteger_x005fType' for type 'gco:UnlimitedInteger_Type' */
#ifndef SOAP_TYPE_plu_gco__UnlimitedInteger_x005fType
#define SOAP_TYPE_plu_gco__UnlimitedInteger_x005fType (-718)

#endif

/* gco__Integer_x005fPropertyType has binding name 'gco__Integer_x005fPropertyType' for type 'gco:Integer_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__Integer_x005fPropertyType
#define SOAP_TYPE_plu_gco__Integer_x005fPropertyType (-717)

#endif

/* gco__Real_x005fPropertyType has binding name 'gco__Real_x005fPropertyType' for type 'gco:Real_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__Real_x005fPropertyType
#define SOAP_TYPE_plu_gco__Real_x005fPropertyType (-716)

#endif

/* gco__Decimal_x005fPropertyType has binding name 'gco__Decimal_x005fPropertyType' for type 'gco:Decimal_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__Decimal_x005fPropertyType
#define SOAP_TYPE_plu_gco__Decimal_x005fPropertyType (-715)

#endif

/* gco__Number_x005fPropertyType has binding name 'gco__Number_x005fPropertyType' for type 'gco:Number_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__Number_x005fPropertyType
#define SOAP_TYPE_plu_gco__Number_x005fPropertyType (-714)

#endif

/* gco__Date_x005fPropertyType has binding name 'gco__Date_x005fPropertyType' for type 'gco:Date_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__Date_x005fPropertyType
#define SOAP_TYPE_plu_gco__Date_x005fPropertyType (-713)

#endif

/* gco__DateTime_x005fPropertyType has binding name 'gco__DateTime_x005fPropertyType' for type 'gco:DateTime_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__DateTime_x005fPropertyType
#define SOAP_TYPE_plu_gco__DateTime_x005fPropertyType (-712)

#endif

/* gco__UomVolume_x005fPropertyType has binding name 'gco__UomVolume_x005fPropertyType' for type 'gco:UomVolume_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__UomVolume_x005fPropertyType
#define SOAP_TYPE_plu_gco__UomVolume_x005fPropertyType (-711)

#endif

/* gco__UomTime_x005fPropertyType has binding name 'gco__UomTime_x005fPropertyType' for type 'gco:UomTime_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__UomTime_x005fPropertyType
#define SOAP_TYPE_plu_gco__UomTime_x005fPropertyType (-710)

#endif

/* gco__UomVelocity_x005fPropertyType has binding name 'gco__UomVelocity_x005fPropertyType' for type 'gco:UomVelocity_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__UomVelocity_x005fPropertyType
#define SOAP_TYPE_plu_gco__UomVelocity_x005fPropertyType (-709)

#endif

/* gco__UomArea_x005fPropertyType has binding name 'gco__UomArea_x005fPropertyType' for type 'gco:UomArea_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__UomArea_x005fPropertyType
#define SOAP_TYPE_plu_gco__UomArea_x005fPropertyType (-708)

#endif

/* gco__UnitOfMeasure_x005fPropertyType has binding name 'gco__UnitOfMeasure_x005fPropertyType' for type 'gco:UnitOfMeasure_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__UnitOfMeasure_x005fPropertyType
#define SOAP_TYPE_plu_gco__UnitOfMeasure_x005fPropertyType (-707)

#endif

/* gco__UomScale_x005fPropertyType has binding name 'gco__UomScale_x005fPropertyType' for type 'gco:UomScale_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__UomScale_x005fPropertyType
#define SOAP_TYPE_plu_gco__UomScale_x005fPropertyType (-706)

#endif

/* gco__UomLength_x005fPropertyType has binding name 'gco__UomLength_x005fPropertyType' for type 'gco:UomLength_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__UomLength_x005fPropertyType
#define SOAP_TYPE_plu_gco__UomLength_x005fPropertyType (-705)

#endif

/* gco__UomAngle_x005fPropertyType has binding name 'gco__UomAngle_x005fPropertyType' for type 'gco:UomAngle_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__UomAngle_x005fPropertyType
#define SOAP_TYPE_plu_gco__UomAngle_x005fPropertyType (-704)

#endif

/* gco__ScopedName_x005fPropertyType has binding name 'gco__ScopedName_x005fPropertyType' for type 'gco:ScopedName_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__ScopedName_x005fPropertyType
#define SOAP_TYPE_plu_gco__ScopedName_x005fPropertyType (-703)

#endif

/* gco__LocalName_x005fPropertyType has binding name 'gco__LocalName_x005fPropertyType' for type 'gco:LocalName_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__LocalName_x005fPropertyType
#define SOAP_TYPE_plu_gco__LocalName_x005fPropertyType (-702)

#endif

/* gco__GenericName_x005fPropertyType has binding name 'gco__GenericName_x005fPropertyType' for type 'gco:GenericName_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__GenericName_x005fPropertyType
#define SOAP_TYPE_plu_gco__GenericName_x005fPropertyType (-701)

#endif

/* gco__Boolean_x005fPropertyType has binding name 'gco__Boolean_x005fPropertyType' for type 'gco:Boolean_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__Boolean_x005fPropertyType
#define SOAP_TYPE_plu_gco__Boolean_x005fPropertyType (-700)

#endif

/* gco__CharacterString_x005fPropertyType has binding name 'gco__CharacterString_x005fPropertyType' for type 'gco:CharacterString_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__CharacterString_x005fPropertyType
#define SOAP_TYPE_plu_gco__CharacterString_x005fPropertyType (-699)

#endif

/* gco__Distance_x005fPropertyType has binding name 'gco__Distance_x005fPropertyType' for type 'gco:Distance_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__Distance_x005fPropertyType
#define SOAP_TYPE_plu_gco__Distance_x005fPropertyType (-698)

#endif

/* gco__Scale_x005fPropertyType has binding name 'gco__Scale_x005fPropertyType' for type 'gco:Scale_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__Scale_x005fPropertyType
#define SOAP_TYPE_plu_gco__Scale_x005fPropertyType (-697)

#endif

/* gco__Angle_x005fPropertyType has binding name 'gco__Angle_x005fPropertyType' for type 'gco:Angle_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__Angle_x005fPropertyType
#define SOAP_TYPE_plu_gco__Angle_x005fPropertyType (-696)

#endif

/* gco__Length_x005fPropertyType has binding name 'gco__Length_x005fPropertyType' for type 'gco:Length_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__Length_x005fPropertyType
#define SOAP_TYPE_plu_gco__Length_x005fPropertyType (-695)

#endif

/* gco__Measure_x005fPropertyType has binding name 'gco__Measure_x005fPropertyType' for type 'gco:Measure_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__Measure_x005fPropertyType
#define SOAP_TYPE_plu_gco__Measure_x005fPropertyType (-694)

#endif

/* gco__MultiplicityRange_x005fPropertyType has binding name 'gco__MultiplicityRange_x005fPropertyType' for type 'gco:MultiplicityRange_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__MultiplicityRange_x005fPropertyType
#define SOAP_TYPE_plu_gco__MultiplicityRange_x005fPropertyType (-693)

#endif

/* gco__MultiplicityRange_x005fType has binding name 'gco__MultiplicityRange_x005fType' for type 'gco:MultiplicityRange_Type' */
#ifndef SOAP_TYPE_plu_gco__MultiplicityRange_x005fType
#define SOAP_TYPE_plu_gco__MultiplicityRange_x005fType (-692)

#endif

/* gco__Multiplicity_x005fPropertyType has binding name 'gco__Multiplicity_x005fPropertyType' for type 'gco:Multiplicity_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__Multiplicity_x005fPropertyType
#define SOAP_TYPE_plu_gco__Multiplicity_x005fPropertyType (-691)

#endif

/* gco__Multiplicity_x005fType has binding name 'gco__Multiplicity_x005fType' for type 'gco:Multiplicity_Type' */
#ifndef SOAP_TYPE_plu_gco__Multiplicity_x005fType
#define SOAP_TYPE_plu_gco__Multiplicity_x005fType (-690)

#endif

/* gco__MemberName_x005fPropertyType has binding name 'gco__MemberName_x005fPropertyType' for type 'gco:MemberName_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__MemberName_x005fPropertyType
#define SOAP_TYPE_plu_gco__MemberName_x005fPropertyType (-689)

#endif

/* gco__MemberName_x005fType has binding name 'gco__MemberName_x005fType' for type 'gco:MemberName_Type' */
#ifndef SOAP_TYPE_plu_gco__MemberName_x005fType
#define SOAP_TYPE_plu_gco__MemberName_x005fType (-688)

#endif

/* gco__TypeName_x005fPropertyType has binding name 'gco__TypeName_x005fPropertyType' for type 'gco:TypeName_PropertyType' */
#ifndef SOAP_TYPE_plu_gco__TypeName_x005fPropertyType
#define SOAP_TYPE_plu_gco__TypeName_x005fPropertyType (-687)

#endif

/* gco__TypeName_x005fType has binding name 'gco__TypeName_x005fType' for type 'gco:TypeName_Type' */
#ifndef SOAP_TYPE_plu_gco__TypeName_x005fType
#define SOAP_TYPE_plu_gco__TypeName_x005fType (-686)

#endif

/* xlink__arcType has binding name 'xlink__arcType' for type 'xlink:arcType' */
#ifndef SOAP_TYPE_plu_xlink__arcType
#define SOAP_TYPE_plu_xlink__arcType (-685)

#endif

/* xlink__locatorType has binding name 'xlink__locatorType' for type 'xlink:locatorType' */
#ifndef SOAP_TYPE_plu_xlink__locatorType
#define SOAP_TYPE_plu_xlink__locatorType (-684)

#endif

/* xlink__resourceType has binding name 'xlink__resourceType' for type 'xlink:resourceType' */
#ifndef SOAP_TYPE_plu_xlink__resourceType
#define SOAP_TYPE_plu_xlink__resourceType (-683)

#endif

/* xlink__titleEltType has binding name 'xlink__titleEltType' for type 'xlink:titleEltType' */
#ifndef SOAP_TYPE_plu_xlink__titleEltType
#define SOAP_TYPE_plu_xlink__titleEltType (-682)

#endif

/* xlink__extended has binding name 'xlink__extended' for type 'xlink:extended' */
#ifndef SOAP_TYPE_plu_xlink__extended
#define SOAP_TYPE_plu_xlink__extended (-681)

#endif

/* xlink__simple has binding name 'xlink__simple' for type 'xlink:simple' */
#ifndef SOAP_TYPE_plu_xlink__simple
#define SOAP_TYPE_plu_xlink__simple (-680)

#endif

/* gmd__Country_x005fPropertyType has binding name 'gmd__Country_x005fPropertyType' for type 'gmd:Country_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__Country_x005fPropertyType
#define SOAP_TYPE_plu_gmd__Country_x005fPropertyType (-679)

#endif

/* gmd__LanguageCode_x005fPropertyType has binding name 'gmd__LanguageCode_x005fPropertyType' for type 'gmd:LanguageCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__LanguageCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__LanguageCode_x005fPropertyType (-678)

#endif

/* gmd__PT_x005fLocaleContainer_x005fPropertyType has binding name 'gmd__PT_x005fLocaleContainer_x005fPropertyType' for type 'gmd:PT_LocaleContainer_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__PT_x005fLocaleContainer_x005fPropertyType
#define SOAP_TYPE_plu_gmd__PT_x005fLocaleContainer_x005fPropertyType (-677)

#endif

/* gmd__PT_x005fLocaleContainer_x005fType has binding name 'gmd__PT_x005fLocaleContainer_x005fType' for type 'gmd:PT_LocaleContainer_Type' */
#ifndef SOAP_TYPE_plu_gmd__PT_x005fLocaleContainer_x005fType
#define SOAP_TYPE_plu_gmd__PT_x005fLocaleContainer_x005fType (-676)

#endif

/* gmd__LocalisedCharacterString_x005fPropertyType has binding name 'gmd__LocalisedCharacterString_x005fPropertyType' for type 'gmd:LocalisedCharacterString_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__LocalisedCharacterString_x005fPropertyType
#define SOAP_TYPE_plu_gmd__LocalisedCharacterString_x005fPropertyType (-675)

#endif

/* gmd__LocalisedCharacterString_x005fType has binding name 'gmd__LocalisedCharacterString_x005fType' for type 'gmd:LocalisedCharacterString_Type' */
#ifndef SOAP_TYPE_plu_gmd__LocalisedCharacterString_x005fType
#define SOAP_TYPE_plu_gmd__LocalisedCharacterString_x005fType (-674)

#endif

/* gmd__PT_x005fLocale_x005fPropertyType has binding name 'gmd__PT_x005fLocale_x005fPropertyType' for type 'gmd:PT_Locale_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__PT_x005fLocale_x005fPropertyType
#define SOAP_TYPE_plu_gmd__PT_x005fLocale_x005fPropertyType (-673)

#endif

/* gmd__PT_x005fLocale_x005fType has binding name 'gmd__PT_x005fLocale_x005fType' for type 'gmd:PT_Locale_Type' */
#ifndef SOAP_TYPE_plu_gmd__PT_x005fLocale_x005fType
#define SOAP_TYPE_plu_gmd__PT_x005fLocale_x005fType (-672)

#endif

/* gmd__PT_x005fFreeText_x005fPropertyType has binding name 'gmd__PT_x005fFreeText_x005fPropertyType' for type 'gmd:PT_FreeText_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__PT_x005fFreeText_x005fPropertyType
#define SOAP_TYPE_plu_gmd__PT_x005fFreeText_x005fPropertyType (-671)

#endif

/* gmd__PT_x005fFreeText_x005fType has binding name 'gmd__PT_x005fFreeText_x005fType' for type 'gmd:PT_FreeText_Type' */
#ifndef SOAP_TYPE_plu_gmd__PT_x005fFreeText_x005fType
#define SOAP_TYPE_plu_gmd__PT_x005fFreeText_x005fType (-670)

#endif

/* gmd__MD_x005fScopeCode_x005fPropertyType has binding name 'gmd__MD_x005fScopeCode_x005fPropertyType' for type 'gmd:MD_ScopeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fScopeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fScopeCode_x005fPropertyType (-669)

#endif

/* gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType has binding name 'gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType' for type 'gmd:MD_MaintenanceFrequencyCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType (-668)

#endif

/* gmd__MD_x005fScopeDescription_x005fPropertyType has binding name 'gmd__MD_x005fScopeDescription_x005fPropertyType' for type 'gmd:MD_ScopeDescription_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fScopeDescription_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fScopeDescription_x005fPropertyType (-667)

#endif

/* gmd__MD_x005fScopeDescription_x005fType has binding name 'gmd__MD_x005fScopeDescription_x005fType' for type 'gmd:MD_ScopeDescription_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fScopeDescription_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fScopeDescription_x005fType (-666)

#endif

/* gmd__MD_x005fMaintenanceInformation_x005fPropertyType has binding name 'gmd__MD_x005fMaintenanceInformation_x005fPropertyType' for type 'gmd:MD_MaintenanceInformation_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMaintenanceInformation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fMaintenanceInformation_x005fPropertyType (-665)

#endif

/* gmd__MD_x005fMaintenanceInformation_x005fType has binding name 'gmd__MD_x005fMaintenanceInformation_x005fType' for type 'gmd:MD_MaintenanceInformation_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMaintenanceInformation_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fMaintenanceInformation_x005fType (-664)

#endif

/* gmd__MD_x005fMediumNameCode_x005fPropertyType has binding name 'gmd__MD_x005fMediumNameCode_x005fPropertyType' for type 'gmd:MD_MediumNameCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMediumNameCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fMediumNameCode_x005fPropertyType (-663)

#endif

/* gmd__MD_x005fMediumFormatCode_x005fPropertyType has binding name 'gmd__MD_x005fMediumFormatCode_x005fPropertyType' for type 'gmd:MD_MediumFormatCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMediumFormatCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fMediumFormatCode_x005fPropertyType (-662)

#endif

/* gmd__MD_x005fDistributionUnits_x005fPropertyType has binding name 'gmd__MD_x005fDistributionUnits_x005fPropertyType' for type 'gmd:MD_DistributionUnits_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDistributionUnits_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fDistributionUnits_x005fPropertyType (-661)

#endif

/* gmd__MD_x005fFormat_x005fPropertyType has binding name 'gmd__MD_x005fFormat_x005fPropertyType' for type 'gmd:MD_Format_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fFormat_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fFormat_x005fPropertyType (-660)

#endif

/* gmd__MD_x005fFormat_x005fType has binding name 'gmd__MD_x005fFormat_x005fType' for type 'gmd:MD_Format_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fFormat_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fFormat_x005fType (-659)

#endif

/* gmd__MD_x005fDistribution_x005fPropertyType has binding name 'gmd__MD_x005fDistribution_x005fPropertyType' for type 'gmd:MD_Distribution_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDistribution_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fDistribution_x005fPropertyType (-658)

#endif

/* gmd__MD_x005fDistribution_x005fType has binding name 'gmd__MD_x005fDistribution_x005fType' for type 'gmd:MD_Distribution_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDistribution_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fDistribution_x005fType (-657)

#endif

/* gmd__MD_x005fDistributor_x005fPropertyType has binding name 'gmd__MD_x005fDistributor_x005fPropertyType' for type 'gmd:MD_Distributor_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDistributor_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fDistributor_x005fPropertyType (-656)

#endif

/* gmd__MD_x005fDistributor_x005fType has binding name 'gmd__MD_x005fDistributor_x005fType' for type 'gmd:MD_Distributor_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDistributor_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fDistributor_x005fType (-655)

#endif

/* gmd__MD_x005fStandardOrderProcess_x005fPropertyType has binding name 'gmd__MD_x005fStandardOrderProcess_x005fPropertyType' for type 'gmd:MD_StandardOrderProcess_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fStandardOrderProcess_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fStandardOrderProcess_x005fPropertyType (-654)

#endif

/* gmd__MD_x005fStandardOrderProcess_x005fType has binding name 'gmd__MD_x005fStandardOrderProcess_x005fType' for type 'gmd:MD_StandardOrderProcess_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fStandardOrderProcess_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fStandardOrderProcess_x005fType (-653)

#endif

/* gmd__MD_x005fDigitalTransferOptions_x005fPropertyType has binding name 'gmd__MD_x005fDigitalTransferOptions_x005fPropertyType' for type 'gmd:MD_DigitalTransferOptions_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDigitalTransferOptions_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fDigitalTransferOptions_x005fPropertyType (-652)

#endif

/* gmd__MD_x005fDigitalTransferOptions_x005fType has binding name 'gmd__MD_x005fDigitalTransferOptions_x005fType' for type 'gmd:MD_DigitalTransferOptions_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDigitalTransferOptions_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fDigitalTransferOptions_x005fType (-651)

#endif

/* gmd__MD_x005fMedium_x005fPropertyType has binding name 'gmd__MD_x005fMedium_x005fPropertyType' for type 'gmd:MD_Medium_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMedium_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fMedium_x005fPropertyType (-650)

#endif

/* gmd__MD_x005fMedium_x005fType has binding name 'gmd__MD_x005fMedium_x005fType' for type 'gmd:MD_Medium_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMedium_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fMedium_x005fType (-649)

#endif

/* gmd__MD_x005fRestrictionCode_x005fPropertyType has binding name 'gmd__MD_x005fRestrictionCode_x005fPropertyType' for type 'gmd:MD_RestrictionCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fRestrictionCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fRestrictionCode_x005fPropertyType (-648)

#endif

/* gmd__MD_x005fClassificationCode_x005fPropertyType has binding name 'gmd__MD_x005fClassificationCode_x005fPropertyType' for type 'gmd:MD_ClassificationCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fClassificationCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fClassificationCode_x005fPropertyType (-647)

#endif

/* gmd__MD_x005fSecurityConstraints_x005fPropertyType has binding name 'gmd__MD_x005fSecurityConstraints_x005fPropertyType' for type 'gmd:MD_SecurityConstraints_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fSecurityConstraints_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fSecurityConstraints_x005fPropertyType (-646)

#endif

/* gmd__MD_x005fSecurityConstraints_x005fType has binding name 'gmd__MD_x005fSecurityConstraints_x005fType' for type 'gmd:MD_SecurityConstraints_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fSecurityConstraints_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fSecurityConstraints_x005fType (-645)

#endif

/* gmd__MD_x005fLegalConstraints_x005fPropertyType has binding name 'gmd__MD_x005fLegalConstraints_x005fPropertyType' for type 'gmd:MD_LegalConstraints_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fLegalConstraints_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fLegalConstraints_x005fPropertyType (-644)

#endif

/* gmd__MD_x005fLegalConstraints_x005fType has binding name 'gmd__MD_x005fLegalConstraints_x005fType' for type 'gmd:MD_LegalConstraints_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fLegalConstraints_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fLegalConstraints_x005fType (-643)

#endif

/* gmd__MD_x005fConstraints_x005fPropertyType has binding name 'gmd__MD_x005fConstraints_x005fPropertyType' for type 'gmd:MD_Constraints_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fConstraints_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fConstraints_x005fPropertyType (-642)

#endif

/* gmd__MD_x005fConstraints_x005fType has binding name 'gmd__MD_x005fConstraints_x005fType' for type 'gmd:MD_Constraints_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fConstraints_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fConstraints_x005fType (-641)

#endif

/* gmd__DS_x005fInitiativeTypeCode_x005fPropertyType has binding name 'gmd__DS_x005fInitiativeTypeCode_x005fPropertyType' for type 'gmd:DS_InitiativeTypeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fInitiativeTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fInitiativeTypeCode_x005fPropertyType (-640)

#endif

/* gmd__DS_x005fAssociationTypeCode_x005fPropertyType has binding name 'gmd__DS_x005fAssociationTypeCode_x005fPropertyType' for type 'gmd:DS_AssociationTypeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fAssociationTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fAssociationTypeCode_x005fPropertyType (-639)

#endif

/* gmd__MD_x005fKeywordTypeCode_x005fPropertyType has binding name 'gmd__MD_x005fKeywordTypeCode_x005fPropertyType' for type 'gmd:MD_KeywordTypeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fKeywordTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fKeywordTypeCode_x005fPropertyType (-638)

#endif

/* gmd__MD_x005fProgressCode_x005fPropertyType has binding name 'gmd__MD_x005fProgressCode_x005fPropertyType' for type 'gmd:MD_ProgressCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fProgressCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fProgressCode_x005fPropertyType (-637)

#endif

/* gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType has binding name 'gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType' for type 'gmd:MD_SpatialRepresentationTypeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType (-636)

#endif

/* gmd__MD_x005fCharacterSetCode_x005fPropertyType has binding name 'gmd__MD_x005fCharacterSetCode_x005fPropertyType' for type 'gmd:MD_CharacterSetCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fCharacterSetCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fCharacterSetCode_x005fPropertyType (-635)

#endif

/* gmd__MD_x005fTopicCategoryCode_x005fPropertyType has binding name 'gmd__MD_x005fTopicCategoryCode_x005fPropertyType' for type 'gmd:MD_TopicCategoryCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fTopicCategoryCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fTopicCategoryCode_x005fPropertyType (-634)

#endif

/* gmd__MD_x005fResolution_x005fPropertyType has binding name 'gmd__MD_x005fResolution_x005fPropertyType' for type 'gmd:MD_Resolution_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fResolution_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fResolution_x005fPropertyType (-633)

#endif

/* gmd__MD_x005fResolution_x005fType has binding name 'gmd__MD_x005fResolution_x005fType' for type 'gmd:MD_Resolution_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fResolution_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fResolution_x005fType (-632)

#endif

/* gmd__MD_x005fAggregateInformation_x005fPropertyType has binding name 'gmd__MD_x005fAggregateInformation_x005fPropertyType' for type 'gmd:MD_AggregateInformation_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fAggregateInformation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fAggregateInformation_x005fPropertyType (-631)

#endif

/* gmd__MD_x005fAggregateInformation_x005fType has binding name 'gmd__MD_x005fAggregateInformation_x005fType' for type 'gmd:MD_AggregateInformation_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fAggregateInformation_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fAggregateInformation_x005fType (-630)

#endif

/* gmd__DS_x005fAssociation_x005fPropertyType has binding name 'gmd__DS_x005fAssociation_x005fPropertyType' for type 'gmd:DS_Association_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fAssociation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fAssociation_x005fPropertyType (-629)

#endif

/* gmd__DS_x005fAssociation_x005fType has binding name 'gmd__DS_x005fAssociation_x005fType' for type 'gmd:DS_Association_Type' */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fAssociation_x005fType
#define SOAP_TYPE_plu_gmd__DS_x005fAssociation_x005fType (-628)

#endif

/* gmd__MD_x005fKeywords_x005fPropertyType has binding name 'gmd__MD_x005fKeywords_x005fPropertyType' for type 'gmd:MD_Keywords_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fKeywords_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fKeywords_x005fPropertyType (-627)

#endif

/* gmd__MD_x005fKeywords_x005fType has binding name 'gmd__MD_x005fKeywords_x005fType' for type 'gmd:MD_Keywords_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fKeywords_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fKeywords_x005fType (-626)

#endif

/* gmd__MD_x005fUsage_x005fPropertyType has binding name 'gmd__MD_x005fUsage_x005fPropertyType' for type 'gmd:MD_Usage_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fUsage_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fUsage_x005fPropertyType (-625)

#endif

/* gmd__MD_x005fUsage_x005fType has binding name 'gmd__MD_x005fUsage_x005fType' for type 'gmd:MD_Usage_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fUsage_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fUsage_x005fType (-624)

#endif

/* gmd__MD_x005fRepresentativeFraction_x005fPropertyType has binding name 'gmd__MD_x005fRepresentativeFraction_x005fPropertyType' for type 'gmd:MD_RepresentativeFraction_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fRepresentativeFraction_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fRepresentativeFraction_x005fPropertyType (-623)

#endif

/* gmd__MD_x005fRepresentativeFraction_x005fType has binding name 'gmd__MD_x005fRepresentativeFraction_x005fType' for type 'gmd:MD_RepresentativeFraction_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fRepresentativeFraction_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fRepresentativeFraction_x005fType (-622)

#endif

/* gmd__MD_x005fServiceIdentification_x005fPropertyType has binding name 'gmd__MD_x005fServiceIdentification_x005fPropertyType' for type 'gmd:MD_ServiceIdentification_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fServiceIdentification_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fServiceIdentification_x005fPropertyType (-621)

#endif

/* gmd__MD_x005fServiceIdentification_x005fType has binding name 'gmd__MD_x005fServiceIdentification_x005fType' for type 'gmd:MD_ServiceIdentification_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fServiceIdentification_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fServiceIdentification_x005fType (-620)

#endif

/* gmd__MD_x005fDataIdentification_x005fPropertyType has binding name 'gmd__MD_x005fDataIdentification_x005fPropertyType' for type 'gmd:MD_DataIdentification_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDataIdentification_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fDataIdentification_x005fPropertyType (-619)

#endif

/* gmd__MD_x005fDataIdentification_x005fType has binding name 'gmd__MD_x005fDataIdentification_x005fType' for type 'gmd:MD_DataIdentification_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDataIdentification_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fDataIdentification_x005fType (-618)

#endif

/* gmd__MD_x005fBrowseGraphic_x005fPropertyType has binding name 'gmd__MD_x005fBrowseGraphic_x005fPropertyType' for type 'gmd:MD_BrowseGraphic_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fBrowseGraphic_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fBrowseGraphic_x005fPropertyType (-617)

#endif

/* gmd__MD_x005fBrowseGraphic_x005fType has binding name 'gmd__MD_x005fBrowseGraphic_x005fType' for type 'gmd:MD_BrowseGraphic_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fBrowseGraphic_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fBrowseGraphic_x005fType (-616)

#endif

/* gmd__MD_x005fIdentification_x005fPropertyType has binding name 'gmd__MD_x005fIdentification_x005fPropertyType' for type 'gmd:MD_Identification_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fIdentification_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fIdentification_x005fPropertyType (-615)

#endif

/* gmd__AbstractMD_x005fIdentification_x005fType has binding name 'gmd__AbstractMD_x005fIdentification_x005fType' for type 'gmd:AbstractMD_Identification_Type' */
#ifndef SOAP_TYPE_plu_gmd__AbstractMD_x005fIdentification_x005fType
#define SOAP_TYPE_plu_gmd__AbstractMD_x005fIdentification_x005fType (-614)

#endif

/* gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType has binding name 'gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType' for type 'gmd:DQ_EvaluationMethodTypeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType (-613)

#endif

/* gmd__DQ_x005fScope_x005fPropertyType has binding name 'gmd__DQ_x005fScope_x005fPropertyType' for type 'gmd:DQ_Scope_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fScope_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fScope_x005fPropertyType (-612)

#endif

/* gmd__DQ_x005fScope_x005fType has binding name 'gmd__DQ_x005fScope_x005fType' for type 'gmd:DQ_Scope_Type' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fScope_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fScope_x005fType (-611)

#endif

/* gmd__DQ_x005fDataQuality_x005fPropertyType has binding name 'gmd__DQ_x005fDataQuality_x005fPropertyType' for type 'gmd:DQ_DataQuality_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fDataQuality_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fDataQuality_x005fPropertyType (-610)

#endif

/* gmd__DQ_x005fDataQuality_x005fType has binding name 'gmd__DQ_x005fDataQuality_x005fType' for type 'gmd:DQ_DataQuality_Type' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fDataQuality_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fDataQuality_x005fType (-609)

#endif

/* gmd__DQ_x005fElement_x005fPropertyType has binding name 'gmd__DQ_x005fElement_x005fPropertyType' for type 'gmd:DQ_Element_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fElement_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fElement_x005fPropertyType (-608)

#endif

/* gmd__AbstractDQ_x005fElement_x005fType has binding name 'gmd__AbstractDQ_x005fElement_x005fType' for type 'gmd:AbstractDQ_Element_Type' */
#ifndef SOAP_TYPE_plu_gmd__AbstractDQ_x005fElement_x005fType
#define SOAP_TYPE_plu_gmd__AbstractDQ_x005fElement_x005fType (-607)

#endif

/* gmd__DQ_x005fCompleteness_x005fPropertyType has binding name 'gmd__DQ_x005fCompleteness_x005fPropertyType' for type 'gmd:DQ_Completeness_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fCompleteness_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fCompleteness_x005fPropertyType (-606)

#endif

/* gmd__AbstractDQ_x005fCompleteness_x005fType has binding name 'gmd__AbstractDQ_x005fCompleteness_x005fType' for type 'gmd:AbstractDQ_Completeness_Type' */
#ifndef SOAP_TYPE_plu_gmd__AbstractDQ_x005fCompleteness_x005fType
#define SOAP_TYPE_plu_gmd__AbstractDQ_x005fCompleteness_x005fType (-605)

#endif

/* gmd__DQ_x005fLogicalConsistency_x005fPropertyType has binding name 'gmd__DQ_x005fLogicalConsistency_x005fPropertyType' for type 'gmd:DQ_LogicalConsistency_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fLogicalConsistency_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fLogicalConsistency_x005fPropertyType (-604)

#endif

/* gmd__AbstractDQ_x005fLogicalConsistency_x005fType has binding name 'gmd__AbstractDQ_x005fLogicalConsistency_x005fType' for type 'gmd:AbstractDQ_LogicalConsistency_Type' */
#ifndef SOAP_TYPE_plu_gmd__AbstractDQ_x005fLogicalConsistency_x005fType
#define SOAP_TYPE_plu_gmd__AbstractDQ_x005fLogicalConsistency_x005fType (-603)

#endif

/* gmd__DQ_x005fPositionalAccuracy_x005fPropertyType has binding name 'gmd__DQ_x005fPositionalAccuracy_x005fPropertyType' for type 'gmd:DQ_PositionalAccuracy_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fPositionalAccuracy_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fPositionalAccuracy_x005fPropertyType (-602)

#endif

/* gmd__AbstractDQ_x005fPositionalAccuracy_x005fType has binding name 'gmd__AbstractDQ_x005fPositionalAccuracy_x005fType' for type 'gmd:AbstractDQ_PositionalAccuracy_Type' */
#ifndef SOAP_TYPE_plu_gmd__AbstractDQ_x005fPositionalAccuracy_x005fType
#define SOAP_TYPE_plu_gmd__AbstractDQ_x005fPositionalAccuracy_x005fType (-601)

#endif

/* gmd__DQ_x005fThematicAccuracy_x005fPropertyType has binding name 'gmd__DQ_x005fThematicAccuracy_x005fPropertyType' for type 'gmd:DQ_ThematicAccuracy_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fThematicAccuracy_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fThematicAccuracy_x005fPropertyType (-600)

#endif

/* gmd__AbstractDQ_x005fThematicAccuracy_x005fType has binding name 'gmd__AbstractDQ_x005fThematicAccuracy_x005fType' for type 'gmd:AbstractDQ_ThematicAccuracy_Type' */
#ifndef SOAP_TYPE_plu_gmd__AbstractDQ_x005fThematicAccuracy_x005fType
#define SOAP_TYPE_plu_gmd__AbstractDQ_x005fThematicAccuracy_x005fType (-599)

#endif

/* gmd__DQ_x005fTemporalAccuracy_x005fPropertyType has binding name 'gmd__DQ_x005fTemporalAccuracy_x005fPropertyType' for type 'gmd:DQ_TemporalAccuracy_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fTemporalAccuracy_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fTemporalAccuracy_x005fPropertyType (-598)

#endif

/* gmd__AbstractDQ_x005fTemporalAccuracy_x005fType has binding name 'gmd__AbstractDQ_x005fTemporalAccuracy_x005fType' for type 'gmd:AbstractDQ_TemporalAccuracy_Type' */
#ifndef SOAP_TYPE_plu_gmd__AbstractDQ_x005fTemporalAccuracy_x005fType
#define SOAP_TYPE_plu_gmd__AbstractDQ_x005fTemporalAccuracy_x005fType (-597)

#endif

/* gmd__DQ_x005fCompletenessCommission_x005fPropertyType has binding name 'gmd__DQ_x005fCompletenessCommission_x005fPropertyType' for type 'gmd:DQ_CompletenessCommission_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fCompletenessCommission_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fCompletenessCommission_x005fPropertyType (-596)

#endif

/* gmd__DQ_x005fCompletenessCommission_x005fType has binding name 'gmd__DQ_x005fCompletenessCommission_x005fType' for type 'gmd:DQ_CompletenessCommission_Type' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fCompletenessCommission_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fCompletenessCommission_x005fType (-595)

#endif

/* gmd__DQ_x005fCompletenessOmission_x005fPropertyType has binding name 'gmd__DQ_x005fCompletenessOmission_x005fPropertyType' for type 'gmd:DQ_CompletenessOmission_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fCompletenessOmission_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fCompletenessOmission_x005fPropertyType (-594)

#endif

/* gmd__DQ_x005fCompletenessOmission_x005fType has binding name 'gmd__DQ_x005fCompletenessOmission_x005fType' for type 'gmd:DQ_CompletenessOmission_Type' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fCompletenessOmission_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fCompletenessOmission_x005fType (-593)

#endif

/* gmd__DQ_x005fConceptualConsistency_x005fPropertyType has binding name 'gmd__DQ_x005fConceptualConsistency_x005fPropertyType' for type 'gmd:DQ_ConceptualConsistency_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fConceptualConsistency_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fConceptualConsistency_x005fPropertyType (-592)

#endif

/* gmd__DQ_x005fConceptualConsistency_x005fType has binding name 'gmd__DQ_x005fConceptualConsistency_x005fType' for type 'gmd:DQ_ConceptualConsistency_Type' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fConceptualConsistency_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fConceptualConsistency_x005fType (-591)

#endif

/* gmd__DQ_x005fDomainConsistency_x005fPropertyType has binding name 'gmd__DQ_x005fDomainConsistency_x005fPropertyType' for type 'gmd:DQ_DomainConsistency_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fDomainConsistency_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fDomainConsistency_x005fPropertyType (-590)

#endif

/* gmd__DQ_x005fDomainConsistency_x005fType has binding name 'gmd__DQ_x005fDomainConsistency_x005fType' for type 'gmd:DQ_DomainConsistency_Type' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fDomainConsistency_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fDomainConsistency_x005fType (-589)

#endif

/* gmd__DQ_x005fFormatConsistency_x005fPropertyType has binding name 'gmd__DQ_x005fFormatConsistency_x005fPropertyType' for type 'gmd:DQ_FormatConsistency_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fFormatConsistency_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fFormatConsistency_x005fPropertyType (-588)

#endif

/* gmd__DQ_x005fFormatConsistency_x005fType has binding name 'gmd__DQ_x005fFormatConsistency_x005fType' for type 'gmd:DQ_FormatConsistency_Type' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fFormatConsistency_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fFormatConsistency_x005fType (-587)

#endif

/* gmd__DQ_x005fTopologicalConsistency_x005fPropertyType has binding name 'gmd__DQ_x005fTopologicalConsistency_x005fPropertyType' for type 'gmd:DQ_TopologicalConsistency_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fTopologicalConsistency_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fTopologicalConsistency_x005fPropertyType (-586)

#endif

/* gmd__DQ_x005fTopologicalConsistency_x005fType has binding name 'gmd__DQ_x005fTopologicalConsistency_x005fType' for type 'gmd:DQ_TopologicalConsistency_Type' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fTopologicalConsistency_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fTopologicalConsistency_x005fType (-585)

#endif

/* gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType has binding name 'gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType' for type 'gmd:DQ_AbsoluteExternalPositionalAccuracy_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType (-584)

#endif

/* gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType has binding name 'gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType' for type 'gmd:DQ_AbsoluteExternalPositionalAccuracy_Type' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType (-583)

#endif

/* gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType has binding name 'gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType' for type 'gmd:DQ_GriddedDataPositionalAccuracy_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType (-582)

#endif

/* gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType has binding name 'gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType' for type 'gmd:DQ_GriddedDataPositionalAccuracy_Type' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType (-581)

#endif

/* gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType has binding name 'gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType' for type 'gmd:DQ_RelativeInternalPositionalAccuracy_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType (-580)

#endif

/* gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType has binding name 'gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType' for type 'gmd:DQ_RelativeInternalPositionalAccuracy_Type' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType (-579)

#endif

/* gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType has binding name 'gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType' for type 'gmd:DQ_ThematicClassificationCorrectness_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType (-578)

#endif

/* gmd__DQ_x005fThematicClassificationCorrectness_x005fType has binding name 'gmd__DQ_x005fThematicClassificationCorrectness_x005fType' for type 'gmd:DQ_ThematicClassificationCorrectness_Type' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fThematicClassificationCorrectness_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fThematicClassificationCorrectness_x005fType (-577)

#endif

/* gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType has binding name 'gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType' for type 'gmd:DQ_NonQuantitativeAttributeAccuracy_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType (-576)

#endif

/* gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType has binding name 'gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType' for type 'gmd:DQ_NonQuantitativeAttributeAccuracy_Type' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType (-575)

#endif

/* gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType has binding name 'gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType' for type 'gmd:DQ_QuantitativeAttributeAccuracy_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType (-574)

#endif

/* gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType has binding name 'gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType' for type 'gmd:DQ_QuantitativeAttributeAccuracy_Type' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType (-573)

#endif

/* gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType has binding name 'gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType' for type 'gmd:DQ_AccuracyOfATimeMeasurement_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType (-572)

#endif

/* gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType has binding name 'gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType' for type 'gmd:DQ_AccuracyOfATimeMeasurement_Type' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType (-571)

#endif

/* gmd__DQ_x005fTemporalConsistency_x005fPropertyType has binding name 'gmd__DQ_x005fTemporalConsistency_x005fPropertyType' for type 'gmd:DQ_TemporalConsistency_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fTemporalConsistency_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fTemporalConsistency_x005fPropertyType (-570)

#endif

/* gmd__DQ_x005fTemporalConsistency_x005fType has binding name 'gmd__DQ_x005fTemporalConsistency_x005fType' for type 'gmd:DQ_TemporalConsistency_Type' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fTemporalConsistency_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fTemporalConsistency_x005fType (-569)

#endif

/* gmd__DQ_x005fTemporalValidity_x005fPropertyType has binding name 'gmd__DQ_x005fTemporalValidity_x005fPropertyType' for type 'gmd:DQ_TemporalValidity_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fTemporalValidity_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fTemporalValidity_x005fPropertyType (-568)

#endif

/* gmd__DQ_x005fTemporalValidity_x005fType has binding name 'gmd__DQ_x005fTemporalValidity_x005fType' for type 'gmd:DQ_TemporalValidity_Type' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fTemporalValidity_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fTemporalValidity_x005fType (-567)

#endif

/* gmd__DQ_x005fResult_x005fPropertyType has binding name 'gmd__DQ_x005fResult_x005fPropertyType' for type 'gmd:DQ_Result_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fResult_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fResult_x005fPropertyType (-566)

#endif

/* gmd__AbstractDQ_x005fResult_x005fType has binding name 'gmd__AbstractDQ_x005fResult_x005fType' for type 'gmd:AbstractDQ_Result_Type' */
#ifndef SOAP_TYPE_plu_gmd__AbstractDQ_x005fResult_x005fType
#define SOAP_TYPE_plu_gmd__AbstractDQ_x005fResult_x005fType (-565)

#endif

/* gmd__DQ_x005fQuantitativeResult_x005fPropertyType has binding name 'gmd__DQ_x005fQuantitativeResult_x005fPropertyType' for type 'gmd:DQ_QuantitativeResult_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeResult_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeResult_x005fPropertyType (-564)

#endif

/* gmd__DQ_x005fQuantitativeResult_x005fType has binding name 'gmd__DQ_x005fQuantitativeResult_x005fType' for type 'gmd:DQ_QuantitativeResult_Type' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeResult_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fQuantitativeResult_x005fType (-563)

#endif

/* gmd__DQ_x005fConformanceResult_x005fPropertyType has binding name 'gmd__DQ_x005fConformanceResult_x005fPropertyType' for type 'gmd:DQ_ConformanceResult_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fConformanceResult_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DQ_x005fConformanceResult_x005fPropertyType (-562)

#endif

/* gmd__DQ_x005fConformanceResult_x005fType has binding name 'gmd__DQ_x005fConformanceResult_x005fType' for type 'gmd:DQ_ConformanceResult_Type' */
#ifndef SOAP_TYPE_plu_gmd__DQ_x005fConformanceResult_x005fType
#define SOAP_TYPE_plu_gmd__DQ_x005fConformanceResult_x005fType (-561)

#endif

/* gmd__LI_x005fLineage_x005fPropertyType has binding name 'gmd__LI_x005fLineage_x005fPropertyType' for type 'gmd:LI_Lineage_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__LI_x005fLineage_x005fPropertyType
#define SOAP_TYPE_plu_gmd__LI_x005fLineage_x005fPropertyType (-560)

#endif

/* gmd__LI_x005fLineage_x005fType has binding name 'gmd__LI_x005fLineage_x005fType' for type 'gmd:LI_Lineage_Type' */
#ifndef SOAP_TYPE_plu_gmd__LI_x005fLineage_x005fType
#define SOAP_TYPE_plu_gmd__LI_x005fLineage_x005fType (-559)

#endif

/* gmd__LI_x005fSource_x005fPropertyType has binding name 'gmd__LI_x005fSource_x005fPropertyType' for type 'gmd:LI_Source_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__LI_x005fSource_x005fPropertyType
#define SOAP_TYPE_plu_gmd__LI_x005fSource_x005fPropertyType (-558)

#endif

/* gmd__LI_x005fSource_x005fType has binding name 'gmd__LI_x005fSource_x005fType' for type 'gmd:LI_Source_Type' */
#ifndef SOAP_TYPE_plu_gmd__LI_x005fSource_x005fType
#define SOAP_TYPE_plu_gmd__LI_x005fSource_x005fType (-557)

#endif

/* gmd__LI_x005fProcessStep_x005fPropertyType has binding name 'gmd__LI_x005fProcessStep_x005fPropertyType' for type 'gmd:LI_ProcessStep_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__LI_x005fProcessStep_x005fPropertyType
#define SOAP_TYPE_plu_gmd__LI_x005fProcessStep_x005fPropertyType (-556)

#endif

/* gmd__LI_x005fProcessStep_x005fType has binding name 'gmd__LI_x005fProcessStep_x005fType' for type 'gmd:LI_ProcessStep_Type' */
#ifndef SOAP_TYPE_plu_gmd__LI_x005fProcessStep_x005fType
#define SOAP_TYPE_plu_gmd__LI_x005fProcessStep_x005fType (-555)

#endif

/* gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType has binding name 'gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType' for type 'gmd:MD_PortrayalCatalogueReference_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType (-554)

#endif

/* gmd__MD_x005fPortrayalCatalogueReference_x005fType has binding name 'gmd__MD_x005fPortrayalCatalogueReference_x005fType' for type 'gmd:MD_PortrayalCatalogueReference_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fPortrayalCatalogueReference_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fPortrayalCatalogueReference_x005fType (-553)

#endif

/* gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType has binding name 'gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType' for type 'gmd:MD_ApplicationSchemaInformation_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType (-552)

#endif

/* gmd__MD_x005fApplicationSchemaInformation_x005fType has binding name 'gmd__MD_x005fApplicationSchemaInformation_x005fType' for type 'gmd:MD_ApplicationSchemaInformation_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fApplicationSchemaInformation_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fApplicationSchemaInformation_x005fType (-551)

#endif

/* gmd__MD_x005fImagingConditionCode_x005fPropertyType has binding name 'gmd__MD_x005fImagingConditionCode_x005fPropertyType' for type 'gmd:MD_ImagingConditionCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fImagingConditionCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fImagingConditionCode_x005fPropertyType (-550)

#endif

/* gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType has binding name 'gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType' for type 'gmd:MD_CoverageContentTypeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType (-549)

#endif

/* gmd__MD_x005fBand_x005fPropertyType has binding name 'gmd__MD_x005fBand_x005fPropertyType' for type 'gmd:MD_Band_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fBand_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fBand_x005fPropertyType (-548)

#endif

/* gmd__MD_x005fBand_x005fType has binding name 'gmd__MD_x005fBand_x005fType' for type 'gmd:MD_Band_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fBand_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fBand_x005fType (-547)

#endif

/* gmd__MD_x005fRangeDimension_x005fPropertyType has binding name 'gmd__MD_x005fRangeDimension_x005fPropertyType' for type 'gmd:MD_RangeDimension_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fRangeDimension_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fRangeDimension_x005fPropertyType (-546)

#endif

/* gmd__MD_x005fRangeDimension_x005fType has binding name 'gmd__MD_x005fRangeDimension_x005fType' for type 'gmd:MD_RangeDimension_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fRangeDimension_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fRangeDimension_x005fType (-545)

#endif

/* gmd__MD_x005fContentInformation_x005fPropertyType has binding name 'gmd__MD_x005fContentInformation_x005fPropertyType' for type 'gmd:MD_ContentInformation_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fContentInformation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fContentInformation_x005fPropertyType (-544)

#endif

/* gmd__AbstractMD_x005fContentInformation_x005fType has binding name 'gmd__AbstractMD_x005fContentInformation_x005fType' for type 'gmd:AbstractMD_ContentInformation_Type' */
#ifndef SOAP_TYPE_plu_gmd__AbstractMD_x005fContentInformation_x005fType
#define SOAP_TYPE_plu_gmd__AbstractMD_x005fContentInformation_x005fType (-543)

#endif

/* gmd__MD_x005fImageDescription_x005fPropertyType has binding name 'gmd__MD_x005fImageDescription_x005fPropertyType' for type 'gmd:MD_ImageDescription_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fImageDescription_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fImageDescription_x005fPropertyType (-542)

#endif

/* gmd__MD_x005fImageDescription_x005fType has binding name 'gmd__MD_x005fImageDescription_x005fType' for type 'gmd:MD_ImageDescription_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fImageDescription_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fImageDescription_x005fType (-541)

#endif

/* gmd__MD_x005fCoverageDescription_x005fPropertyType has binding name 'gmd__MD_x005fCoverageDescription_x005fPropertyType' for type 'gmd:MD_CoverageDescription_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fCoverageDescription_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fCoverageDescription_x005fPropertyType (-540)

#endif

/* gmd__MD_x005fCoverageDescription_x005fType has binding name 'gmd__MD_x005fCoverageDescription_x005fType' for type 'gmd:MD_CoverageDescription_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fCoverageDescription_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fCoverageDescription_x005fType (-539)

#endif

/* gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType has binding name 'gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType' for type 'gmd:MD_FeatureCatalogueDescription_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType (-538)

#endif

/* gmd__MD_x005fFeatureCatalogueDescription_x005fType has binding name 'gmd__MD_x005fFeatureCatalogueDescription_x005fType' for type 'gmd:MD_FeatureCatalogueDescription_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fFeatureCatalogueDescription_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fFeatureCatalogueDescription_x005fType (-537)

#endif

/* gmd__MD_x005fDatatypeCode_x005fPropertyType has binding name 'gmd__MD_x005fDatatypeCode_x005fPropertyType' for type 'gmd:MD_DatatypeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDatatypeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fDatatypeCode_x005fPropertyType (-536)

#endif

/* gmd__MD_x005fObligationCode_x005fPropertyType has binding name 'gmd__MD_x005fObligationCode_x005fPropertyType' for type 'gmd:MD_ObligationCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fObligationCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fObligationCode_x005fPropertyType (-535)

#endif

/* gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType has binding name 'gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType' for type 'gmd:MD_MetadataExtensionInformation_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType (-534)

#endif

/* gmd__MD_x005fMetadataExtensionInformation_x005fType has binding name 'gmd__MD_x005fMetadataExtensionInformation_x005fType' for type 'gmd:MD_MetadataExtensionInformation_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMetadataExtensionInformation_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fMetadataExtensionInformation_x005fType (-533)

#endif

/* gmd__MD_x005fExtendedElementInformation_x005fPropertyType has binding name 'gmd__MD_x005fExtendedElementInformation_x005fPropertyType' for type 'gmd:MD_ExtendedElementInformation_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fExtendedElementInformation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fExtendedElementInformation_x005fPropertyType (-532)

#endif

/* gmd__MD_x005fExtendedElementInformation_x005fType has binding name 'gmd__MD_x005fExtendedElementInformation_x005fType' for type 'gmd:MD_ExtendedElementInformation_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fExtendedElementInformation_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fExtendedElementInformation_x005fType (-531)

#endif

/* gmd__EX_x005fGeographicDescription_x005fPropertyType has binding name 'gmd__EX_x005fGeographicDescription_x005fPropertyType' for type 'gmd:EX_GeographicDescription_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fGeographicDescription_x005fPropertyType
#define SOAP_TYPE_plu_gmd__EX_x005fGeographicDescription_x005fPropertyType (-530)

#endif

/* gmd__EX_x005fGeographicDescription_x005fType has binding name 'gmd__EX_x005fGeographicDescription_x005fType' for type 'gmd:EX_GeographicDescription_Type' */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fGeographicDescription_x005fType
#define SOAP_TYPE_plu_gmd__EX_x005fGeographicDescription_x005fType (-529)

#endif

/* gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType has binding name 'gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType' for type 'gmd:EX_SpatialTemporalExtent_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType
#define SOAP_TYPE_plu_gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType (-528)

#endif

/* gmd__EX_x005fSpatialTemporalExtent_x005fType has binding name 'gmd__EX_x005fSpatialTemporalExtent_x005fType' for type 'gmd:EX_SpatialTemporalExtent_Type' */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fSpatialTemporalExtent_x005fType
#define SOAP_TYPE_plu_gmd__EX_x005fSpatialTemporalExtent_x005fType (-527)

#endif

/* gmd__EX_x005fGeographicBoundingBox_x005fPropertyType has binding name 'gmd__EX_x005fGeographicBoundingBox_x005fPropertyType' for type 'gmd:EX_GeographicBoundingBox_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fGeographicBoundingBox_x005fPropertyType
#define SOAP_TYPE_plu_gmd__EX_x005fGeographicBoundingBox_x005fPropertyType (-526)

#endif

/* gmd__EX_x005fGeographicBoundingBox_x005fType has binding name 'gmd__EX_x005fGeographicBoundingBox_x005fType' for type 'gmd:EX_GeographicBoundingBox_Type' */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fGeographicBoundingBox_x005fType
#define SOAP_TYPE_plu_gmd__EX_x005fGeographicBoundingBox_x005fType (-525)

#endif

/* gmd__EX_x005fGeographicExtent_x005fPropertyType has binding name 'gmd__EX_x005fGeographicExtent_x005fPropertyType' for type 'gmd:EX_GeographicExtent_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fGeographicExtent_x005fPropertyType
#define SOAP_TYPE_plu_gmd__EX_x005fGeographicExtent_x005fPropertyType (-524)

#endif

/* gmd__AbstractEX_x005fGeographicExtent_x005fType has binding name 'gmd__AbstractEX_x005fGeographicExtent_x005fType' for type 'gmd:AbstractEX_GeographicExtent_Type' */
#ifndef SOAP_TYPE_plu_gmd__AbstractEX_x005fGeographicExtent_x005fType
#define SOAP_TYPE_plu_gmd__AbstractEX_x005fGeographicExtent_x005fType (-523)

#endif

/* gmd__EX_x005fExtent_x005fPropertyType has binding name 'gmd__EX_x005fExtent_x005fPropertyType' for type 'gmd:EX_Extent_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fExtent_x005fPropertyType
#define SOAP_TYPE_plu_gmd__EX_x005fExtent_x005fPropertyType (-522)

#endif

/* gmd__EX_x005fExtent_x005fType has binding name 'gmd__EX_x005fExtent_x005fType' for type 'gmd:EX_Extent_Type' */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fExtent_x005fType
#define SOAP_TYPE_plu_gmd__EX_x005fExtent_x005fType (-521)

#endif

/* gmd__EX_x005fBoundingPolygon_x005fPropertyType has binding name 'gmd__EX_x005fBoundingPolygon_x005fPropertyType' for type 'gmd:EX_BoundingPolygon_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fBoundingPolygon_x005fPropertyType
#define SOAP_TYPE_plu_gmd__EX_x005fBoundingPolygon_x005fPropertyType (-520)

#endif

/* gmd__EX_x005fBoundingPolygon_x005fType has binding name 'gmd__EX_x005fBoundingPolygon_x005fType' for type 'gmd:EX_BoundingPolygon_Type' */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fBoundingPolygon_x005fType
#define SOAP_TYPE_plu_gmd__EX_x005fBoundingPolygon_x005fType (-519)

#endif

/* gmd__EX_x005fVerticalExtent_x005fPropertyType has binding name 'gmd__EX_x005fVerticalExtent_x005fPropertyType' for type 'gmd:EX_VerticalExtent_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fVerticalExtent_x005fPropertyType
#define SOAP_TYPE_plu_gmd__EX_x005fVerticalExtent_x005fPropertyType (-518)

#endif

/* gmd__EX_x005fVerticalExtent_x005fType has binding name 'gmd__EX_x005fVerticalExtent_x005fType' for type 'gmd:EX_VerticalExtent_Type' */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fVerticalExtent_x005fType
#define SOAP_TYPE_plu_gmd__EX_x005fVerticalExtent_x005fType (-517)

#endif

/* gmd__EX_x005fTemporalExtent_x005fPropertyType has binding name 'gmd__EX_x005fTemporalExtent_x005fPropertyType' for type 'gmd:EX_TemporalExtent_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fTemporalExtent_x005fPropertyType
#define SOAP_TYPE_plu_gmd__EX_x005fTemporalExtent_x005fPropertyType (-516)

#endif

/* gmd__EX_x005fTemporalExtent_x005fType has binding name 'gmd__EX_x005fTemporalExtent_x005fType' for type 'gmd:EX_TemporalExtent_Type' */
#ifndef SOAP_TYPE_plu_gmd__EX_x005fTemporalExtent_x005fType
#define SOAP_TYPE_plu_gmd__EX_x005fTemporalExtent_x005fType (-515)

#endif

/* gmd__RS_x005fReferenceSystem_x005fPropertyType has binding name 'gmd__RS_x005fReferenceSystem_x005fPropertyType' for type 'gmd:RS_ReferenceSystem_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__RS_x005fReferenceSystem_x005fPropertyType
#define SOAP_TYPE_plu_gmd__RS_x005fReferenceSystem_x005fPropertyType (-514)

#endif

/* gmd__AbstractRS_x005fReferenceSystem_x005fType has binding name 'gmd__AbstractRS_x005fReferenceSystem_x005fType' for type 'gmd:AbstractRS_ReferenceSystem_Type' */
#ifndef SOAP_TYPE_plu_gmd__AbstractRS_x005fReferenceSystem_x005fType
#define SOAP_TYPE_plu_gmd__AbstractRS_x005fReferenceSystem_x005fType (-513)

#endif

/* gmd__MD_x005fIdentifier_x005fPropertyType has binding name 'gmd__MD_x005fIdentifier_x005fPropertyType' for type 'gmd:MD_Identifier_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fIdentifier_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fIdentifier_x005fPropertyType (-512)

#endif

/* gmd__MD_x005fIdentifier_x005fType has binding name 'gmd__MD_x005fIdentifier_x005fType' for type 'gmd:MD_Identifier_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fIdentifier_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fIdentifier_x005fType (-511)

#endif

/* gmd__MD_x005fReferenceSystem_x005fPropertyType has binding name 'gmd__MD_x005fReferenceSystem_x005fPropertyType' for type 'gmd:MD_ReferenceSystem_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fReferenceSystem_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fReferenceSystem_x005fPropertyType (-510)

#endif

/* gmd__MD_x005fReferenceSystem_x005fType has binding name 'gmd__MD_x005fReferenceSystem_x005fType' for type 'gmd:MD_ReferenceSystem_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fReferenceSystem_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fReferenceSystem_x005fType (-509)

#endif

/* gmd__RS_x005fIdentifier_x005fPropertyType has binding name 'gmd__RS_x005fIdentifier_x005fPropertyType' for type 'gmd:RS_Identifier_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__RS_x005fIdentifier_x005fPropertyType
#define SOAP_TYPE_plu_gmd__RS_x005fIdentifier_x005fPropertyType (-508)

#endif

/* gmd__RS_x005fIdentifier_x005fType has binding name 'gmd__RS_x005fIdentifier_x005fType' for type 'gmd:RS_Identifier_Type' */
#ifndef SOAP_TYPE_plu_gmd__RS_x005fIdentifier_x005fType
#define SOAP_TYPE_plu_gmd__RS_x005fIdentifier_x005fType (-507)

#endif

/* gmd__CI_x005fDateTypeCode_x005fPropertyType has binding name 'gmd__CI_x005fDateTypeCode_x005fPropertyType' for type 'gmd:CI_DateTypeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fDateTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fDateTypeCode_x005fPropertyType (-506)

#endif

/* gmd__CI_x005fOnLineFunctionCode_x005fPropertyType has binding name 'gmd__CI_x005fOnLineFunctionCode_x005fPropertyType' for type 'gmd:CI_OnLineFunctionCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fOnLineFunctionCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fOnLineFunctionCode_x005fPropertyType (-505)

#endif

/* gmd__CI_x005fPresentationFormCode_x005fPropertyType has binding name 'gmd__CI_x005fPresentationFormCode_x005fPropertyType' for type 'gmd:CI_PresentationFormCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fPresentationFormCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fPresentationFormCode_x005fPropertyType (-504)

#endif

/* gmd__CI_x005fRoleCode_x005fPropertyType has binding name 'gmd__CI_x005fRoleCode_x005fPropertyType' for type 'gmd:CI_RoleCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fRoleCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fRoleCode_x005fPropertyType (-503)

#endif

/* gmd__URL_x005fPropertyType has binding name 'gmd__URL_x005fPropertyType' for type 'gmd:URL_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__URL_x005fPropertyType
#define SOAP_TYPE_plu_gmd__URL_x005fPropertyType (-502)

#endif

/* gmd__CI_x005fSeries_x005fPropertyType has binding name 'gmd__CI_x005fSeries_x005fPropertyType' for type 'gmd:CI_Series_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fSeries_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fSeries_x005fPropertyType (-501)

#endif

/* gmd__CI_x005fSeries_x005fType has binding name 'gmd__CI_x005fSeries_x005fType' for type 'gmd:CI_Series_Type' */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fSeries_x005fType
#define SOAP_TYPE_plu_gmd__CI_x005fSeries_x005fType (-500)

#endif

/* gmd__CI_x005fDate_x005fPropertyType has binding name 'gmd__CI_x005fDate_x005fPropertyType' for type 'gmd:CI_Date_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fDate_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fDate_x005fPropertyType (-499)

#endif

/* gmd__CI_x005fDate_x005fType has binding name 'gmd__CI_x005fDate_x005fType' for type 'gmd:CI_Date_Type' */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fDate_x005fType
#define SOAP_TYPE_plu_gmd__CI_x005fDate_x005fType (-498)

#endif

/* gmd__CI_x005fTelephone_x005fPropertyType has binding name 'gmd__CI_x005fTelephone_x005fPropertyType' for type 'gmd:CI_Telephone_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fTelephone_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fTelephone_x005fPropertyType (-497)

#endif

/* gmd__CI_x005fTelephone_x005fType has binding name 'gmd__CI_x005fTelephone_x005fType' for type 'gmd:CI_Telephone_Type' */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fTelephone_x005fType
#define SOAP_TYPE_plu_gmd__CI_x005fTelephone_x005fType (-496)

#endif

/* gmd__CI_x005fContact_x005fPropertyType has binding name 'gmd__CI_x005fContact_x005fPropertyType' for type 'gmd:CI_Contact_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fContact_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fContact_x005fPropertyType (-495)

#endif

/* gmd__CI_x005fContact_x005fType has binding name 'gmd__CI_x005fContact_x005fType' for type 'gmd:CI_Contact_Type' */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fContact_x005fType
#define SOAP_TYPE_plu_gmd__CI_x005fContact_x005fType (-494)

#endif

/* gmd__CI_x005fOnlineResource_x005fPropertyType has binding name 'gmd__CI_x005fOnlineResource_x005fPropertyType' for type 'gmd:CI_OnlineResource_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fOnlineResource_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fOnlineResource_x005fPropertyType (-493)

#endif

/* gmd__CI_x005fOnlineResource_x005fType has binding name 'gmd__CI_x005fOnlineResource_x005fType' for type 'gmd:CI_OnlineResource_Type' */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fOnlineResource_x005fType
#define SOAP_TYPE_plu_gmd__CI_x005fOnlineResource_x005fType (-492)

#endif

/* gmd__CI_x005fAddress_x005fPropertyType has binding name 'gmd__CI_x005fAddress_x005fPropertyType' for type 'gmd:CI_Address_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fAddress_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fAddress_x005fPropertyType (-491)

#endif

/* gmd__CI_x005fAddress_x005fType has binding name 'gmd__CI_x005fAddress_x005fType' for type 'gmd:CI_Address_Type' */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fAddress_x005fType
#define SOAP_TYPE_plu_gmd__CI_x005fAddress_x005fType (-490)

#endif

/* gmd__CI_x005fCitation_x005fPropertyType has binding name 'gmd__CI_x005fCitation_x005fPropertyType' for type 'gmd:CI_Citation_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fCitation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fCitation_x005fPropertyType (-489)

#endif

/* gmd__CI_x005fCitation_x005fType has binding name 'gmd__CI_x005fCitation_x005fType' for type 'gmd:CI_Citation_Type' */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fCitation_x005fType
#define SOAP_TYPE_plu_gmd__CI_x005fCitation_x005fType (-488)

#endif

/* gmd__CI_x005fResponsibleParty_x005fPropertyType has binding name 'gmd__CI_x005fResponsibleParty_x005fPropertyType' for type 'gmd:CI_ResponsibleParty_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fResponsibleParty_x005fPropertyType
#define SOAP_TYPE_plu_gmd__CI_x005fResponsibleParty_x005fPropertyType (-487)

#endif

/* gmd__CI_x005fResponsibleParty_x005fType has binding name 'gmd__CI_x005fResponsibleParty_x005fType' for type 'gmd:CI_ResponsibleParty_Type' */
#ifndef SOAP_TYPE_plu_gmd__CI_x005fResponsibleParty_x005fType
#define SOAP_TYPE_plu_gmd__CI_x005fResponsibleParty_x005fType (-486)

#endif

/* gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType has binding name 'gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType' for type 'gmd:MD_DimensionNameTypeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType (-485)

#endif

/* gmd__MD_x005fCellGeometryCode_x005fPropertyType has binding name 'gmd__MD_x005fCellGeometryCode_x005fPropertyType' for type 'gmd:MD_CellGeometryCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fCellGeometryCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fCellGeometryCode_x005fPropertyType (-484)

#endif

/* gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType has binding name 'gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType' for type 'gmd:MD_GeometricObjectTypeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType (-483)

#endif

/* gmd__MD_x005fTopologyLevelCode_x005fPropertyType has binding name 'gmd__MD_x005fTopologyLevelCode_x005fPropertyType' for type 'gmd:MD_TopologyLevelCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fTopologyLevelCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fTopologyLevelCode_x005fPropertyType (-482)

#endif

/* gmd__MD_x005fPixelOrientationCode_x005fPropertyType has binding name 'gmd__MD_x005fPixelOrientationCode_x005fPropertyType' for type 'gmd:MD_PixelOrientationCode_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fPixelOrientationCode_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fPixelOrientationCode_x005fPropertyType (-481)

#endif

/* gmd__MD_x005fGeometricObjects_x005fPropertyType has binding name 'gmd__MD_x005fGeometricObjects_x005fPropertyType' for type 'gmd:MD_GeometricObjects_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fGeometricObjects_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fGeometricObjects_x005fPropertyType (-480)

#endif

/* gmd__MD_x005fGeometricObjects_x005fType has binding name 'gmd__MD_x005fGeometricObjects_x005fType' for type 'gmd:MD_GeometricObjects_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fGeometricObjects_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fGeometricObjects_x005fType (-479)

#endif

/* gmd__MD_x005fGeorectified_x005fPropertyType has binding name 'gmd__MD_x005fGeorectified_x005fPropertyType' for type 'gmd:MD_Georectified_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fGeorectified_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fGeorectified_x005fPropertyType (-478)

#endif

/* gmd__MD_x005fGeorectified_x005fType has binding name 'gmd__MD_x005fGeorectified_x005fType' for type 'gmd:MD_Georectified_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fGeorectified_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fGeorectified_x005fType (-477)

#endif

/* gmd__MD_x005fDimension_x005fPropertyType has binding name 'gmd__MD_x005fDimension_x005fPropertyType' for type 'gmd:MD_Dimension_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDimension_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fDimension_x005fPropertyType (-476)

#endif

/* gmd__MD_x005fDimension_x005fType has binding name 'gmd__MD_x005fDimension_x005fType' for type 'gmd:MD_Dimension_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fDimension_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fDimension_x005fType (-475)

#endif

/* gmd__MD_x005fGeoreferenceable_x005fPropertyType has binding name 'gmd__MD_x005fGeoreferenceable_x005fPropertyType' for type 'gmd:MD_Georeferenceable_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fGeoreferenceable_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fGeoreferenceable_x005fPropertyType (-474)

#endif

/* gmd__MD_x005fGeoreferenceable_x005fType has binding name 'gmd__MD_x005fGeoreferenceable_x005fType' for type 'gmd:MD_Georeferenceable_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fGeoreferenceable_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fGeoreferenceable_x005fType (-473)

#endif

/* gmd__MD_x005fSpatialRepresentation_x005fPropertyType has binding name 'gmd__MD_x005fSpatialRepresentation_x005fPropertyType' for type 'gmd:MD_SpatialRepresentation_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fSpatialRepresentation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fSpatialRepresentation_x005fPropertyType (-472)

#endif

/* gmd__AbstractMD_x005fSpatialRepresentation_x005fType has binding name 'gmd__AbstractMD_x005fSpatialRepresentation_x005fType' for type 'gmd:AbstractMD_SpatialRepresentation_Type' */
#ifndef SOAP_TYPE_plu_gmd__AbstractMD_x005fSpatialRepresentation_x005fType
#define SOAP_TYPE_plu_gmd__AbstractMD_x005fSpatialRepresentation_x005fType (-471)

#endif

/* gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType has binding name 'gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType' for type 'gmd:MD_VectorSpatialRepresentation_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType (-470)

#endif

/* gmd__MD_x005fVectorSpatialRepresentation_x005fType has binding name 'gmd__MD_x005fVectorSpatialRepresentation_x005fType' for type 'gmd:MD_VectorSpatialRepresentation_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fVectorSpatialRepresentation_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fVectorSpatialRepresentation_x005fType (-469)

#endif

/* gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType has binding name 'gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType' for type 'gmd:MD_GridSpatialRepresentation_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType (-468)

#endif

/* gmd__MD_x005fGridSpatialRepresentation_x005fType has binding name 'gmd__MD_x005fGridSpatialRepresentation_x005fType' for type 'gmd:MD_GridSpatialRepresentation_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fGridSpatialRepresentation_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fGridSpatialRepresentation_x005fType (-467)

#endif

/* gmd__MD_x005fMetadata_x005fPropertyType has binding name 'gmd__MD_x005fMetadata_x005fPropertyType' for type 'gmd:MD_Metadata_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMetadata_x005fPropertyType
#define SOAP_TYPE_plu_gmd__MD_x005fMetadata_x005fPropertyType (-466)

#endif

/* gmd__MD_x005fMetadata_x005fType has binding name 'gmd__MD_x005fMetadata_x005fType' for type 'gmd:MD_Metadata_Type' */
#ifndef SOAP_TYPE_plu_gmd__MD_x005fMetadata_x005fType
#define SOAP_TYPE_plu_gmd__MD_x005fMetadata_x005fType (-465)

#endif

/* gmd__DS_x005fStereoMate_x005fPropertyType has binding name 'gmd__DS_x005fStereoMate_x005fPropertyType' for type 'gmd:DS_StereoMate_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fStereoMate_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fStereoMate_x005fPropertyType (-464)

#endif

/* gmd__DS_x005fStereoMate_x005fType has binding name 'gmd__DS_x005fStereoMate_x005fType' for type 'gmd:DS_StereoMate_Type' */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fStereoMate_x005fType
#define SOAP_TYPE_plu_gmd__DS_x005fStereoMate_x005fType (-463)

#endif

/* gmd__DS_x005fProductionSeries_x005fPropertyType has binding name 'gmd__DS_x005fProductionSeries_x005fPropertyType' for type 'gmd:DS_ProductionSeries_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fProductionSeries_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fProductionSeries_x005fPropertyType (-462)

#endif

/* gmd__DS_x005fProductionSeries_x005fType has binding name 'gmd__DS_x005fProductionSeries_x005fType' for type 'gmd:DS_ProductionSeries_Type' */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fProductionSeries_x005fType
#define SOAP_TYPE_plu_gmd__DS_x005fProductionSeries_x005fType (-461)

#endif

/* gmd__DS_x005fSensor_x005fPropertyType has binding name 'gmd__DS_x005fSensor_x005fPropertyType' for type 'gmd:DS_Sensor_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fSensor_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fSensor_x005fPropertyType (-460)

#endif

/* gmd__DS_x005fSensor_x005fType has binding name 'gmd__DS_x005fSensor_x005fType' for type 'gmd:DS_Sensor_Type' */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fSensor_x005fType
#define SOAP_TYPE_plu_gmd__DS_x005fSensor_x005fType (-459)

#endif

/* gmd__DS_x005fPlatform_x005fPropertyType has binding name 'gmd__DS_x005fPlatform_x005fPropertyType' for type 'gmd:DS_Platform_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fPlatform_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fPlatform_x005fPropertyType (-458)

#endif

/* gmd__DS_x005fPlatform_x005fType has binding name 'gmd__DS_x005fPlatform_x005fType' for type 'gmd:DS_Platform_Type' */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fPlatform_x005fType
#define SOAP_TYPE_plu_gmd__DS_x005fPlatform_x005fType (-457)

#endif

/* gmd__DS_x005fInitiative_x005fPropertyType has binding name 'gmd__DS_x005fInitiative_x005fPropertyType' for type 'gmd:DS_Initiative_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fInitiative_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fInitiative_x005fPropertyType (-456)

#endif

/* gmd__DS_x005fInitiative_x005fType has binding name 'gmd__DS_x005fInitiative_x005fType' for type 'gmd:DS_Initiative_Type' */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fInitiative_x005fType
#define SOAP_TYPE_plu_gmd__DS_x005fInitiative_x005fType (-455)

#endif

/* gmd__DS_x005fSeries_x005fPropertyType has binding name 'gmd__DS_x005fSeries_x005fPropertyType' for type 'gmd:DS_Series_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fSeries_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fSeries_x005fPropertyType (-454)

#endif

/* gmd__DS_x005fSeries_x005fType has binding name 'gmd__DS_x005fSeries_x005fType' for type 'gmd:DS_Series_Type' */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fSeries_x005fType
#define SOAP_TYPE_plu_gmd__DS_x005fSeries_x005fType (-453)

#endif

/* gmd__DS_x005fOtherAggregate_x005fPropertyType has binding name 'gmd__DS_x005fOtherAggregate_x005fPropertyType' for type 'gmd:DS_OtherAggregate_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fOtherAggregate_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fOtherAggregate_x005fPropertyType (-452)

#endif

/* gmd__DS_x005fOtherAggregate_x005fType has binding name 'gmd__DS_x005fOtherAggregate_x005fType' for type 'gmd:DS_OtherAggregate_Type' */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fOtherAggregate_x005fType
#define SOAP_TYPE_plu_gmd__DS_x005fOtherAggregate_x005fType (-451)

#endif

/* gmd__DS_x005fDataSet_x005fPropertyType has binding name 'gmd__DS_x005fDataSet_x005fPropertyType' for type 'gmd:DS_DataSet_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fDataSet_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fDataSet_x005fPropertyType (-450)

#endif

/* gmd__DS_x005fDataSet_x005fType has binding name 'gmd__DS_x005fDataSet_x005fType' for type 'gmd:DS_DataSet_Type' */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fDataSet_x005fType
#define SOAP_TYPE_plu_gmd__DS_x005fDataSet_x005fType (-449)

#endif

/* gmd__DS_x005fAggregate_x005fPropertyType has binding name 'gmd__DS_x005fAggregate_x005fPropertyType' for type 'gmd:DS_Aggregate_PropertyType' */
#ifndef SOAP_TYPE_plu_gmd__DS_x005fAggregate_x005fPropertyType
#define SOAP_TYPE_plu_gmd__DS_x005fAggregate_x005fPropertyType (-448)

#endif

/* gmd__AbstractDS_x005fAggregate_x005fType has binding name 'gmd__AbstractDS_x005fAggregate_x005fType' for type 'gmd:AbstractDS_Aggregate_Type' */
#ifndef SOAP_TYPE_plu_gmd__AbstractDS_x005fAggregate_x005fType
#define SOAP_TYPE_plu_gmd__AbstractDS_x005fAggregate_x005fType (-447)

#endif

/* _gml__formulaCitation has binding name '_gml__formulaCitation' for type '' */
#ifndef SOAP_TYPE_plu__gml__formulaCitation
#define SOAP_TYPE_plu__gml__formulaCitation (-446)

#endif

/* _gml__coordinateOperationAccuracy has binding name '_gml__coordinateOperationAccuracy' for type '' */
#ifndef SOAP_TYPE_plu__gml__coordinateOperationAccuracy
#define SOAP_TYPE_plu__gml__coordinateOperationAccuracy (-445)

#endif

/* _gml__SecondDefiningParameter has binding name '_gml__SecondDefiningParameter' for type '' */
#ifndef SOAP_TYPE_plu__gml__SecondDefiningParameter
#define SOAP_TYPE_plu__gml__SecondDefiningParameter (-444)

#endif

/* _gml__secondDefiningParameter has binding name '_gml__secondDefiningParameter' for type '' */
#ifndef SOAP_TYPE_plu__gml__secondDefiningParameter
#define SOAP_TYPE_plu__gml__secondDefiningParameter (-443)

#endif

/* _gml__domainOfValidity has binding name '_gml__domainOfValidity' for type '' */
#ifndef SOAP_TYPE_plu__gml__domainOfValidity
#define SOAP_TYPE_plu__gml__domainOfValidity (-442)

#endif

/* _gml__Quantity has binding name '_gml__Quantity' for type '' */
#ifndef SOAP_TYPE_plu__gml__Quantity
#define SOAP_TYPE_plu__gml__Quantity (-441)

#endif

/* _gml__Count has binding name '_gml__Count' for type '' */
#ifndef SOAP_TYPE_plu__gml__Count
#define SOAP_TYPE_plu__gml__Count (-440)

#endif

/* _gml__Category has binding name '_gml__Category' for type '' */
#ifndef SOAP_TYPE_plu__gml__Category
#define SOAP_TYPE_plu__gml__Category (-439)

#endif

/* _gml__Boolean has binding name '_gml__Boolean' for type '' */
#ifndef SOAP_TYPE_plu__gml__Boolean
#define SOAP_TYPE_plu__gml__Boolean (-438)

#endif

/* gml__MovingObjectStatusType has binding name 'gml__MovingObjectStatusType' for type 'gml:MovingObjectStatusType' */
#ifndef SOAP_TYPE_plu_gml__MovingObjectStatusType
#define SOAP_TYPE_plu_gml__MovingObjectStatusType (-437)

#endif

/* gml__DefinitionProxyType has binding name 'gml__DefinitionProxyType' for type 'gml:DefinitionProxyType' */
#ifndef SOAP_TYPE_plu_gml__DefinitionProxyType
#define SOAP_TYPE_plu_gml__DefinitionProxyType (-436)

#endif

/* gml__IndirectEntryType has binding name 'gml__IndirectEntryType' for type 'gml:IndirectEntryType' */
#ifndef SOAP_TYPE_plu_gml__IndirectEntryType
#define SOAP_TYPE_plu_gml__IndirectEntryType (-435)

#endif

/* gml__FeatureCollectionType has binding name 'gml__FeatureCollectionType' for type 'gml:FeatureCollectionType' */
#ifndef SOAP_TYPE_plu_gml__FeatureCollectionType
#define SOAP_TYPE_plu_gml__FeatureCollectionType (-434)

#endif

/* gml__AbstractFeatureCollectionType has binding name 'gml__AbstractFeatureCollectionType' for type 'gml:AbstractFeatureCollectionType' */
#ifndef SOAP_TYPE_plu_gml__AbstractFeatureCollectionType
#define SOAP_TYPE_plu_gml__AbstractFeatureCollectionType (-433)

#endif

/* gml__BoundedFeatureType has binding name 'gml__BoundedFeatureType' for type 'gml:BoundedFeatureType' */
#ifndef SOAP_TYPE_plu_gml__BoundedFeatureType
#define SOAP_TYPE_plu_gml__BoundedFeatureType (-432)

#endif

/* gml__FeatureArrayPropertyType has binding name 'gml__FeatureArrayPropertyType' for type 'gml:FeatureArrayPropertyType' */
#ifndef SOAP_TYPE_plu_gml__FeatureArrayPropertyType
#define SOAP_TYPE_plu_gml__FeatureArrayPropertyType (-431)

#endif

/* gml__PriorityLocationPropertyType has binding name 'gml__PriorityLocationPropertyType' for type 'gml:PriorityLocationPropertyType' */
#ifndef SOAP_TYPE_plu_gml__PriorityLocationPropertyType
#define SOAP_TYPE_plu_gml__PriorityLocationPropertyType (-430)

#endif

/* gml__LocationPropertyType has binding name 'gml__LocationPropertyType' for type 'gml:LocationPropertyType' */
#ifndef SOAP_TYPE_plu_gml__LocationPropertyType
#define SOAP_TYPE_plu_gml__LocationPropertyType (-429)

#endif

/* gml__GenericMetaDataType has binding name 'gml__GenericMetaDataType' for type 'gml:GenericMetaDataType' */
#ifndef SOAP_TYPE_plu_gml__GenericMetaDataType
#define SOAP_TYPE_plu_gml__GenericMetaDataType (-428)

#endif

/* gml__AbstractMetaDataType has binding name 'gml__AbstractMetaDataType' for type 'gml:AbstractMetaDataType' */
#ifndef SOAP_TYPE_plu_gml__AbstractMetaDataType
#define SOAP_TYPE_plu_gml__AbstractMetaDataType (-427)

#endif

/* gml__MetaDataPropertyType has binding name 'gml__MetaDataPropertyType' for type 'gml:MetaDataPropertyType' */
#ifndef SOAP_TYPE_plu_gml__MetaDataPropertyType
#define SOAP_TYPE_plu_gml__MetaDataPropertyType (-426)

#endif

/* gml__ArrayType has binding name 'gml__ArrayType' for type 'gml:ArrayType' */
#ifndef SOAP_TYPE_plu_gml__ArrayType
#define SOAP_TYPE_plu_gml__ArrayType (-425)

#endif

/* gml__BagType has binding name 'gml__BagType' for type 'gml:BagType' */
#ifndef SOAP_TYPE_plu_gml__BagType
#define SOAP_TYPE_plu_gml__BagType (-424)

#endif

/* gml__StringOrRefType has binding name 'gml__StringOrRefType' for type 'gml:StringOrRefType' */
#ifndef SOAP_TYPE_plu_gml__StringOrRefType
#define SOAP_TYPE_plu_gml__StringOrRefType (-423)

#endif

/* gml__ArrayAssociationType has binding name 'gml__ArrayAssociationType' for type 'gml:ArrayAssociationType' */
#ifndef SOAP_TYPE_plu_gml__ArrayAssociationType
#define SOAP_TYPE_plu_gml__ArrayAssociationType (-422)

#endif

/* gml__AngleChoiceType has binding name 'gml__AngleChoiceType' for type 'gml:AngleChoiceType' */
#ifndef SOAP_TYPE_plu_gml__AngleChoiceType
#define SOAP_TYPE_plu_gml__AngleChoiceType (-421)

#endif

/* gml__DegreesType has binding name 'gml__DegreesType' for type 'gml:DegreesType' */
#ifndef SOAP_TYPE_plu_gml__DegreesType
#define SOAP_TYPE_plu_gml__DegreesType (-420)

#endif

/* gml__DMSAngleType has binding name 'gml__DMSAngleType' for type 'gml:DMSAngleType' */
#ifndef SOAP_TYPE_plu_gml__DMSAngleType
#define SOAP_TYPE_plu_gml__DMSAngleType (-419)

#endif

/* gml__GeocentricCRSPropertyType has binding name 'gml__GeocentricCRSPropertyType' for type 'gml:GeocentricCRSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__GeocentricCRSPropertyType
#define SOAP_TYPE_plu_gml__GeocentricCRSPropertyType (-418)

#endif

/* gml__GeocentricCRSType has binding name 'gml__GeocentricCRSType' for type 'gml:GeocentricCRSType' */
#ifndef SOAP_TYPE_plu_gml__GeocentricCRSType
#define SOAP_TYPE_plu_gml__GeocentricCRSType (-417)

#endif

/* gml__GeographicCRSPropertyType has binding name 'gml__GeographicCRSPropertyType' for type 'gml:GeographicCRSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__GeographicCRSPropertyType
#define SOAP_TYPE_plu_gml__GeographicCRSPropertyType (-416)

#endif

/* gml__GeographicCRSType has binding name 'gml__GeographicCRSType' for type 'gml:GeographicCRSType' */
#ifndef SOAP_TYPE_plu_gml__GeographicCRSType
#define SOAP_TYPE_plu_gml__GeographicCRSType (-415)

#endif

/* gml__ObliqueCartesianCSPropertyType has binding name 'gml__ObliqueCartesianCSPropertyType' for type 'gml:ObliqueCartesianCSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__ObliqueCartesianCSPropertyType
#define SOAP_TYPE_plu_gml__ObliqueCartesianCSPropertyType (-414)

#endif

/* gml__ObliqueCartesianCSType has binding name 'gml__ObliqueCartesianCSType' for type 'gml:ObliqueCartesianCSType' */
#ifndef SOAP_TYPE_plu_gml__ObliqueCartesianCSType
#define SOAP_TYPE_plu_gml__ObliqueCartesianCSType (-413)

#endif

/* gml__TemporalCSPropertyType has binding name 'gml__TemporalCSPropertyType' for type 'gml:TemporalCSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__TemporalCSPropertyType
#define SOAP_TYPE_plu_gml__TemporalCSPropertyType (-412)

#endif

/* gml__TemporalCSType has binding name 'gml__TemporalCSType' for type 'gml:TemporalCSType' */
#ifndef SOAP_TYPE_plu_gml__TemporalCSType
#define SOAP_TYPE_plu_gml__TemporalCSType (-411)

#endif

/* gml__OperationPropertyType has binding name 'gml__OperationPropertyType' for type 'gml:OperationPropertyType' */
#ifndef SOAP_TYPE_plu_gml__OperationPropertyType
#define SOAP_TYPE_plu_gml__OperationPropertyType (-410)

#endif

/* gml__TimeEdgePropertyType has binding name 'gml__TimeEdgePropertyType' for type 'gml:TimeEdgePropertyType' */
#ifndef SOAP_TYPE_plu_gml__TimeEdgePropertyType
#define SOAP_TYPE_plu_gml__TimeEdgePropertyType (-409)

#endif

/* gml__TimeEdgeType has binding name 'gml__TimeEdgeType' for type 'gml:TimeEdgeType' */
#ifndef SOAP_TYPE_plu_gml__TimeEdgeType
#define SOAP_TYPE_plu_gml__TimeEdgeType (-408)

#endif

/* gml__TimeNodePropertyType has binding name 'gml__TimeNodePropertyType' for type 'gml:TimeNodePropertyType' */
#ifndef SOAP_TYPE_plu_gml__TimeNodePropertyType
#define SOAP_TYPE_plu_gml__TimeNodePropertyType (-407)

#endif

/* gml__TimeNodeType has binding name 'gml__TimeNodeType' for type 'gml:TimeNodeType' */
#ifndef SOAP_TYPE_plu_gml__TimeNodeType
#define SOAP_TYPE_plu_gml__TimeNodeType (-406)

#endif

/* gml__TimeTopologyComplexPropertyType has binding name 'gml__TimeTopologyComplexPropertyType' for type 'gml:TimeTopologyComplexPropertyType' */
#ifndef SOAP_TYPE_plu_gml__TimeTopologyComplexPropertyType
#define SOAP_TYPE_plu_gml__TimeTopologyComplexPropertyType (-405)

#endif

/* gml__TimeTopologyComplexType has binding name 'gml__TimeTopologyComplexType' for type 'gml:TimeTopologyComplexType' */
#ifndef SOAP_TYPE_plu_gml__TimeTopologyComplexType
#define SOAP_TYPE_plu_gml__TimeTopologyComplexType (-404)

#endif

/* gml__TimeTopologyPrimitivePropertyType has binding name 'gml__TimeTopologyPrimitivePropertyType' for type 'gml:TimeTopologyPrimitivePropertyType' */
#ifndef SOAP_TYPE_plu_gml__TimeTopologyPrimitivePropertyType
#define SOAP_TYPE_plu_gml__TimeTopologyPrimitivePropertyType (-403)

#endif

/* gml__AbstractTimeTopologyPrimitiveType has binding name 'gml__AbstractTimeTopologyPrimitiveType' for type 'gml:AbstractTimeTopologyPrimitiveType' */
#ifndef SOAP_TYPE_plu_gml__AbstractTimeTopologyPrimitiveType
#define SOAP_TYPE_plu_gml__AbstractTimeTopologyPrimitiveType (-402)

#endif

/* gml__TimeOrdinalEraPropertyType has binding name 'gml__TimeOrdinalEraPropertyType' for type 'gml:TimeOrdinalEraPropertyType' */
#ifndef SOAP_TYPE_plu_gml__TimeOrdinalEraPropertyType
#define SOAP_TYPE_plu_gml__TimeOrdinalEraPropertyType (-401)

#endif

/* gml__TimeOrdinalEraType has binding name 'gml__TimeOrdinalEraType' for type 'gml:TimeOrdinalEraType' */
#ifndef SOAP_TYPE_plu_gml__TimeOrdinalEraType
#define SOAP_TYPE_plu_gml__TimeOrdinalEraType (-400)

#endif

/* gml__TimeOrdinalReferenceSystemType has binding name 'gml__TimeOrdinalReferenceSystemType' for type 'gml:TimeOrdinalReferenceSystemType' */
#ifndef SOAP_TYPE_plu_gml__TimeOrdinalReferenceSystemType
#define SOAP_TYPE_plu_gml__TimeOrdinalReferenceSystemType (-399)

#endif

/* gml__TimeClockPropertyType has binding name 'gml__TimeClockPropertyType' for type 'gml:TimeClockPropertyType' */
#ifndef SOAP_TYPE_plu_gml__TimeClockPropertyType
#define SOAP_TYPE_plu_gml__TimeClockPropertyType (-398)

#endif

/* gml__TimeClockType has binding name 'gml__TimeClockType' for type 'gml:TimeClockType' */
#ifndef SOAP_TYPE_plu_gml__TimeClockType
#define SOAP_TYPE_plu_gml__TimeClockType (-397)

#endif

/* gml__TimeCalendarEraPropertyType has binding name 'gml__TimeCalendarEraPropertyType' for type 'gml:TimeCalendarEraPropertyType' */
#ifndef SOAP_TYPE_plu_gml__TimeCalendarEraPropertyType
#define SOAP_TYPE_plu_gml__TimeCalendarEraPropertyType (-396)

#endif

/* gml__TimeCalendarPropertyType has binding name 'gml__TimeCalendarPropertyType' for type 'gml:TimeCalendarPropertyType' */
#ifndef SOAP_TYPE_plu_gml__TimeCalendarPropertyType
#define SOAP_TYPE_plu_gml__TimeCalendarPropertyType (-395)

#endif

/* gml__TimeCalendarEraType has binding name 'gml__TimeCalendarEraType' for type 'gml:TimeCalendarEraType' */
#ifndef SOAP_TYPE_plu_gml__TimeCalendarEraType
#define SOAP_TYPE_plu_gml__TimeCalendarEraType (-394)

#endif

/* gml__TimeCalendarType has binding name 'gml__TimeCalendarType' for type 'gml:TimeCalendarType' */
#ifndef SOAP_TYPE_plu_gml__TimeCalendarType
#define SOAP_TYPE_plu_gml__TimeCalendarType (-393)

#endif

/* gml__TimeCoordinateSystemType has binding name 'gml__TimeCoordinateSystemType' for type 'gml:TimeCoordinateSystemType' */
#ifndef SOAP_TYPE_plu_gml__TimeCoordinateSystemType
#define SOAP_TYPE_plu_gml__TimeCoordinateSystemType (-392)

#endif

/* gml__TimeReferenceSystemType has binding name 'gml__TimeReferenceSystemType' for type 'gml:TimeReferenceSystemType' */
#ifndef SOAP_TYPE_plu_gml__TimeReferenceSystemType
#define SOAP_TYPE_plu_gml__TimeReferenceSystemType (-391)

#endif

/* gml__DirectionDescriptionType has binding name 'gml__DirectionDescriptionType' for type 'gml:DirectionDescriptionType' */
#ifndef SOAP_TYPE_plu_gml__DirectionDescriptionType
#define SOAP_TYPE_plu_gml__DirectionDescriptionType (-390)

#endif

/* gml__DirectionVectorType has binding name 'gml__DirectionVectorType' for type 'gml:DirectionVectorType' */
#ifndef SOAP_TYPE_plu_gml__DirectionVectorType
#define SOAP_TYPE_plu_gml__DirectionVectorType (-389)

#endif

/* gml__DirectionPropertyType has binding name 'gml__DirectionPropertyType' for type 'gml:DirectionPropertyType' */
#ifndef SOAP_TYPE_plu_gml__DirectionPropertyType
#define SOAP_TYPE_plu_gml__DirectionPropertyType (-388)

#endif

/* gml__DirectedObservationAtDistanceType has binding name 'gml__DirectedObservationAtDistanceType' for type 'gml:DirectedObservationAtDistanceType' */
#ifndef SOAP_TYPE_plu_gml__DirectedObservationAtDistanceType
#define SOAP_TYPE_plu_gml__DirectedObservationAtDistanceType (-387)

#endif

/* gml__DirectedObservationType has binding name 'gml__DirectedObservationType' for type 'gml:DirectedObservationType' */
#ifndef SOAP_TYPE_plu_gml__DirectedObservationType
#define SOAP_TYPE_plu_gml__DirectedObservationType (-386)

#endif

/* gml__ResultType has binding name 'gml__ResultType' for type 'gml:ResultType' */
#ifndef SOAP_TYPE_plu_gml__ResultType
#define SOAP_TYPE_plu_gml__ResultType (-385)

#endif

/* gml__TargetPropertyType has binding name 'gml__TargetPropertyType' for type 'gml:TargetPropertyType' */
#ifndef SOAP_TYPE_plu_gml__TargetPropertyType
#define SOAP_TYPE_plu_gml__TargetPropertyType (-384)

#endif

/* gml__ProcedurePropertyType has binding name 'gml__ProcedurePropertyType' for type 'gml:ProcedurePropertyType' */
#ifndef SOAP_TYPE_plu_gml__ProcedurePropertyType
#define SOAP_TYPE_plu_gml__ProcedurePropertyType (-383)

#endif

/* gml__ObservationType has binding name 'gml__ObservationType' for type 'gml:ObservationType' */
#ifndef SOAP_TYPE_plu_gml__ObservationType
#define SOAP_TYPE_plu_gml__ObservationType (-382)

#endif

/* gml__OperationParameterGroupPropertyType has binding name 'gml__OperationParameterGroupPropertyType' for type 'gml:OperationParameterGroupPropertyType' */
#ifndef SOAP_TYPE_plu_gml__OperationParameterGroupPropertyType
#define SOAP_TYPE_plu_gml__OperationParameterGroupPropertyType (-381)

#endif

/* gml__OperationParameterGroupType has binding name 'gml__OperationParameterGroupType' for type 'gml:OperationParameterGroupType' */
#ifndef SOAP_TYPE_plu_gml__OperationParameterGroupType
#define SOAP_TYPE_plu_gml__OperationParameterGroupType (-380)

#endif

/* gml__OperationParameterPropertyType has binding name 'gml__OperationParameterPropertyType' for type 'gml:OperationParameterPropertyType' */
#ifndef SOAP_TYPE_plu_gml__OperationParameterPropertyType
#define SOAP_TYPE_plu_gml__OperationParameterPropertyType (-379)

#endif

/* gml__OperationParameterType has binding name 'gml__OperationParameterType' for type 'gml:OperationParameterType' */
#ifndef SOAP_TYPE_plu_gml__OperationParameterType
#define SOAP_TYPE_plu_gml__OperationParameterType (-378)

#endif

/* gml__AbstractGeneralOperationParameterPropertyType has binding name 'gml__AbstractGeneralOperationParameterPropertyType' for type 'gml:AbstractGeneralOperationParameterPropertyType' */
#ifndef SOAP_TYPE_plu_gml__AbstractGeneralOperationParameterPropertyType
#define SOAP_TYPE_plu_gml__AbstractGeneralOperationParameterPropertyType (-377)

#endif

/* gml__AbstractGeneralOperationParameterType has binding name 'gml__AbstractGeneralOperationParameterType' for type 'gml:AbstractGeneralOperationParameterType' */
#ifndef SOAP_TYPE_plu_gml__AbstractGeneralOperationParameterType
#define SOAP_TYPE_plu_gml__AbstractGeneralOperationParameterType (-376)

#endif

/* gml__OperationMethodPropertyType has binding name 'gml__OperationMethodPropertyType' for type 'gml:OperationMethodPropertyType' */
#ifndef SOAP_TYPE_plu_gml__OperationMethodPropertyType
#define SOAP_TYPE_plu_gml__OperationMethodPropertyType (-375)

#endif

/* gml__OperationMethodType has binding name 'gml__OperationMethodType' for type 'gml:OperationMethodType' */
#ifndef SOAP_TYPE_plu_gml__OperationMethodType
#define SOAP_TYPE_plu_gml__OperationMethodType (-374)

#endif

/* gml__ParameterValueGroupType has binding name 'gml__ParameterValueGroupType' for type 'gml:ParameterValueGroupType' */
#ifndef SOAP_TYPE_plu_gml__ParameterValueGroupType
#define SOAP_TYPE_plu_gml__ParameterValueGroupType (-373)

#endif

/* gml__ParameterValueType has binding name 'gml__ParameterValueType' for type 'gml:ParameterValueType' */
#ifndef SOAP_TYPE_plu_gml__ParameterValueType
#define SOAP_TYPE_plu_gml__ParameterValueType (-372)

#endif

/* gml__AbstractGeneralParameterValuePropertyType has binding name 'gml__AbstractGeneralParameterValuePropertyType' for type 'gml:AbstractGeneralParameterValuePropertyType' */
#ifndef SOAP_TYPE_plu_gml__AbstractGeneralParameterValuePropertyType
#define SOAP_TYPE_plu_gml__AbstractGeneralParameterValuePropertyType (-371)

#endif

/* gml__AbstractGeneralParameterValueType has binding name 'gml__AbstractGeneralParameterValueType' for type 'gml:AbstractGeneralParameterValueType' */
#ifndef SOAP_TYPE_plu_gml__AbstractGeneralParameterValueType
#define SOAP_TYPE_plu_gml__AbstractGeneralParameterValueType (-370)

#endif

/* gml__TransformationPropertyType has binding name 'gml__TransformationPropertyType' for type 'gml:TransformationPropertyType' */
#ifndef SOAP_TYPE_plu_gml__TransformationPropertyType
#define SOAP_TYPE_plu_gml__TransformationPropertyType (-369)

#endif

/* gml__TransformationType has binding name 'gml__TransformationType' for type 'gml:TransformationType' */
#ifndef SOAP_TYPE_plu_gml__TransformationType
#define SOAP_TYPE_plu_gml__TransformationType (-368)

#endif

/* gml__ConversionPropertyType has binding name 'gml__ConversionPropertyType' for type 'gml:ConversionPropertyType' */
#ifndef SOAP_TYPE_plu_gml__ConversionPropertyType
#define SOAP_TYPE_plu_gml__ConversionPropertyType (-367)

#endif

/* gml__ConversionType has binding name 'gml__ConversionType' for type 'gml:ConversionType' */
#ifndef SOAP_TYPE_plu_gml__ConversionType
#define SOAP_TYPE_plu_gml__ConversionType (-366)

#endif

/* gml__PassThroughOperationPropertyType has binding name 'gml__PassThroughOperationPropertyType' for type 'gml:PassThroughOperationPropertyType' */
#ifndef SOAP_TYPE_plu_gml__PassThroughOperationPropertyType
#define SOAP_TYPE_plu_gml__PassThroughOperationPropertyType (-365)

#endif

/* gml__PassThroughOperationType has binding name 'gml__PassThroughOperationType' for type 'gml:PassThroughOperationType' */
#ifndef SOAP_TYPE_plu_gml__PassThroughOperationType
#define SOAP_TYPE_plu_gml__PassThroughOperationType (-364)

#endif

/* gml__ConcatenatedOperationPropertyType has binding name 'gml__ConcatenatedOperationPropertyType' for type 'gml:ConcatenatedOperationPropertyType' */
#ifndef SOAP_TYPE_plu_gml__ConcatenatedOperationPropertyType
#define SOAP_TYPE_plu_gml__ConcatenatedOperationPropertyType (-363)

#endif

/* gml__ConcatenatedOperationType has binding name 'gml__ConcatenatedOperationType' for type 'gml:ConcatenatedOperationType' */
#ifndef SOAP_TYPE_plu_gml__ConcatenatedOperationType
#define SOAP_TYPE_plu_gml__ConcatenatedOperationType (-362)

#endif

/* gml__GeneralTransformationPropertyType has binding name 'gml__GeneralTransformationPropertyType' for type 'gml:GeneralTransformationPropertyType' */
#ifndef SOAP_TYPE_plu_gml__GeneralTransformationPropertyType
#define SOAP_TYPE_plu_gml__GeneralTransformationPropertyType (-361)

#endif

/* gml__AbstractGeneralTransformationType has binding name 'gml__AbstractGeneralTransformationType' for type 'gml:AbstractGeneralTransformationType' */
#ifndef SOAP_TYPE_plu_gml__AbstractGeneralTransformationType
#define SOAP_TYPE_plu_gml__AbstractGeneralTransformationType (-360)

#endif

/* gml__GeneralConversionPropertyType has binding name 'gml__GeneralConversionPropertyType' for type 'gml:GeneralConversionPropertyType' */
#ifndef SOAP_TYPE_plu_gml__GeneralConversionPropertyType
#define SOAP_TYPE_plu_gml__GeneralConversionPropertyType (-359)

#endif

/* gml__AbstractGeneralConversionType has binding name 'gml__AbstractGeneralConversionType' for type 'gml:AbstractGeneralConversionType' */
#ifndef SOAP_TYPE_plu_gml__AbstractGeneralConversionType
#define SOAP_TYPE_plu_gml__AbstractGeneralConversionType (-358)

#endif

/* gml__SingleOperationPropertyType has binding name 'gml__SingleOperationPropertyType' for type 'gml:SingleOperationPropertyType' */
#ifndef SOAP_TYPE_plu_gml__SingleOperationPropertyType
#define SOAP_TYPE_plu_gml__SingleOperationPropertyType (-357)

#endif

/* gml__CoordinateOperationPropertyType has binding name 'gml__CoordinateOperationPropertyType' for type 'gml:CoordinateOperationPropertyType' */
#ifndef SOAP_TYPE_plu_gml__CoordinateOperationPropertyType
#define SOAP_TYPE_plu_gml__CoordinateOperationPropertyType (-356)

#endif

/* gml__AbstractCoordinateOperationType has binding name 'gml__AbstractCoordinateOperationType' for type 'gml:AbstractCoordinateOperationType' */
#ifndef SOAP_TYPE_plu_gml__AbstractCoordinateOperationType
#define SOAP_TYPE_plu_gml__AbstractCoordinateOperationType (-355)

#endif

/* gml__TemporalDatumPropertyType has binding name 'gml__TemporalDatumPropertyType' for type 'gml:TemporalDatumPropertyType' */
#ifndef SOAP_TYPE_plu_gml__TemporalDatumPropertyType
#define SOAP_TYPE_plu_gml__TemporalDatumPropertyType (-354)

#endif

/* gml__TemporalDatumBaseType has binding name 'gml__TemporalDatumBaseType' for type 'gml:TemporalDatumBaseType' */
#ifndef SOAP_TYPE_plu_gml__TemporalDatumBaseType
#define SOAP_TYPE_plu_gml__TemporalDatumBaseType (-353)

#endif

/* gml__TemporalDatumType has binding name 'gml__TemporalDatumType' for type 'gml:TemporalDatumType' */
#ifndef SOAP_TYPE_plu_gml__TemporalDatumType
#define SOAP_TYPE_plu_gml__TemporalDatumType (-352)

#endif

/* gml__VerticalDatumPropertyType has binding name 'gml__VerticalDatumPropertyType' for type 'gml:VerticalDatumPropertyType' */
#ifndef SOAP_TYPE_plu_gml__VerticalDatumPropertyType
#define SOAP_TYPE_plu_gml__VerticalDatumPropertyType (-351)

#endif

/* gml__VerticalDatumType has binding name 'gml__VerticalDatumType' for type 'gml:VerticalDatumType' */
#ifndef SOAP_TYPE_plu_gml__VerticalDatumType
#define SOAP_TYPE_plu_gml__VerticalDatumType (-350)

#endif

/* gml__ImageDatumPropertyType has binding name 'gml__ImageDatumPropertyType' for type 'gml:ImageDatumPropertyType' */
#ifndef SOAP_TYPE_plu_gml__ImageDatumPropertyType
#define SOAP_TYPE_plu_gml__ImageDatumPropertyType (-349)

#endif

/* gml__ImageDatumType has binding name 'gml__ImageDatumType' for type 'gml:ImageDatumType' */
#ifndef SOAP_TYPE_plu_gml__ImageDatumType
#define SOAP_TYPE_plu_gml__ImageDatumType (-348)

#endif

/* gml__EngineeringDatumPropertyType has binding name 'gml__EngineeringDatumPropertyType' for type 'gml:EngineeringDatumPropertyType' */
#ifndef SOAP_TYPE_plu_gml__EngineeringDatumPropertyType
#define SOAP_TYPE_plu_gml__EngineeringDatumPropertyType (-347)

#endif

/* gml__EngineeringDatumType has binding name 'gml__EngineeringDatumType' for type 'gml:EngineeringDatumType' */
#ifndef SOAP_TYPE_plu_gml__EngineeringDatumType
#define SOAP_TYPE_plu_gml__EngineeringDatumType (-346)

#endif

/* gml__PrimeMeridianPropertyType has binding name 'gml__PrimeMeridianPropertyType' for type 'gml:PrimeMeridianPropertyType' */
#ifndef SOAP_TYPE_plu_gml__PrimeMeridianPropertyType
#define SOAP_TYPE_plu_gml__PrimeMeridianPropertyType (-345)

#endif

/* gml__PrimeMeridianType has binding name 'gml__PrimeMeridianType' for type 'gml:PrimeMeridianType' */
#ifndef SOAP_TYPE_plu_gml__PrimeMeridianType
#define SOAP_TYPE_plu_gml__PrimeMeridianType (-344)

#endif

/* gml__EllipsoidPropertyType has binding name 'gml__EllipsoidPropertyType' for type 'gml:EllipsoidPropertyType' */
#ifndef SOAP_TYPE_plu_gml__EllipsoidPropertyType
#define SOAP_TYPE_plu_gml__EllipsoidPropertyType (-343)

#endif

/* gml__EllipsoidType has binding name 'gml__EllipsoidType' for type 'gml:EllipsoidType' */
#ifndef SOAP_TYPE_plu_gml__EllipsoidType
#define SOAP_TYPE_plu_gml__EllipsoidType (-342)

#endif

/* gml__GeodeticDatumPropertyType has binding name 'gml__GeodeticDatumPropertyType' for type 'gml:GeodeticDatumPropertyType' */
#ifndef SOAP_TYPE_plu_gml__GeodeticDatumPropertyType
#define SOAP_TYPE_plu_gml__GeodeticDatumPropertyType (-341)

#endif

/* gml__GeodeticDatumType has binding name 'gml__GeodeticDatumType' for type 'gml:GeodeticDatumType' */
#ifndef SOAP_TYPE_plu_gml__GeodeticDatumType
#define SOAP_TYPE_plu_gml__GeodeticDatumType (-340)

#endif

/* gml__DatumPropertyType has binding name 'gml__DatumPropertyType' for type 'gml:DatumPropertyType' */
#ifndef SOAP_TYPE_plu_gml__DatumPropertyType
#define SOAP_TYPE_plu_gml__DatumPropertyType (-339)

#endif

/* gml__AbstractDatumType has binding name 'gml__AbstractDatumType' for type 'gml:AbstractDatumType' */
#ifndef SOAP_TYPE_plu_gml__AbstractDatumType
#define SOAP_TYPE_plu_gml__AbstractDatumType (-338)

#endif

/* gml__CRSPropertyType has binding name 'gml__CRSPropertyType' for type 'gml:CRSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__CRSPropertyType
#define SOAP_TYPE_plu_gml__CRSPropertyType (-337)

#endif

/* gml__AbstractCRSType has binding name 'gml__AbstractCRSType' for type 'gml:AbstractCRSType' */
#ifndef SOAP_TYPE_plu_gml__AbstractCRSType
#define SOAP_TYPE_plu_gml__AbstractCRSType (-336)

#endif

/* gml__IdentifiedObjectType has binding name 'gml__IdentifiedObjectType' for type 'gml:IdentifiedObjectType' */
#ifndef SOAP_TYPE_plu_gml__IdentifiedObjectType
#define SOAP_TYPE_plu_gml__IdentifiedObjectType (-335)

#endif

/* gml__AffineCSPropertyType has binding name 'gml__AffineCSPropertyType' for type 'gml:AffineCSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__AffineCSPropertyType
#define SOAP_TYPE_plu_gml__AffineCSPropertyType (-334)

#endif

/* gml__AffineCSType has binding name 'gml__AffineCSType' for type 'gml:AffineCSType' */
#ifndef SOAP_TYPE_plu_gml__AffineCSType
#define SOAP_TYPE_plu_gml__AffineCSType (-333)

#endif

/* gml__CylindricalCSPropertyType has binding name 'gml__CylindricalCSPropertyType' for type 'gml:CylindricalCSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__CylindricalCSPropertyType
#define SOAP_TYPE_plu_gml__CylindricalCSPropertyType (-332)

#endif

/* gml__CylindricalCSType has binding name 'gml__CylindricalCSType' for type 'gml:CylindricalCSType' */
#ifndef SOAP_TYPE_plu_gml__CylindricalCSType
#define SOAP_TYPE_plu_gml__CylindricalCSType (-331)

#endif

/* gml__PolarCSPropertyType has binding name 'gml__PolarCSPropertyType' for type 'gml:PolarCSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__PolarCSPropertyType
#define SOAP_TYPE_plu_gml__PolarCSPropertyType (-330)

#endif

/* gml__PolarCSType has binding name 'gml__PolarCSType' for type 'gml:PolarCSType' */
#ifndef SOAP_TYPE_plu_gml__PolarCSType
#define SOAP_TYPE_plu_gml__PolarCSType (-329)

#endif

/* gml__SphericalCSPropertyType has binding name 'gml__SphericalCSPropertyType' for type 'gml:SphericalCSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__SphericalCSPropertyType
#define SOAP_TYPE_plu_gml__SphericalCSPropertyType (-328)

#endif

/* gml__SphericalCSType has binding name 'gml__SphericalCSType' for type 'gml:SphericalCSType' */
#ifndef SOAP_TYPE_plu_gml__SphericalCSType
#define SOAP_TYPE_plu_gml__SphericalCSType (-327)

#endif

/* gml__UserDefinedCSPropertyType has binding name 'gml__UserDefinedCSPropertyType' for type 'gml:UserDefinedCSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__UserDefinedCSPropertyType
#define SOAP_TYPE_plu_gml__UserDefinedCSPropertyType (-326)

#endif

/* gml__UserDefinedCSType has binding name 'gml__UserDefinedCSType' for type 'gml:UserDefinedCSType' */
#ifndef SOAP_TYPE_plu_gml__UserDefinedCSType
#define SOAP_TYPE_plu_gml__UserDefinedCSType (-325)

#endif

/* gml__LinearCSPropertyType has binding name 'gml__LinearCSPropertyType' for type 'gml:LinearCSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__LinearCSPropertyType
#define SOAP_TYPE_plu_gml__LinearCSPropertyType (-324)

#endif

/* gml__LinearCSType has binding name 'gml__LinearCSType' for type 'gml:LinearCSType' */
#ifndef SOAP_TYPE_plu_gml__LinearCSType
#define SOAP_TYPE_plu_gml__LinearCSType (-323)

#endif

/* gml__TimeCSPropertyType has binding name 'gml__TimeCSPropertyType' for type 'gml:TimeCSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__TimeCSPropertyType
#define SOAP_TYPE_plu_gml__TimeCSPropertyType (-322)

#endif

/* gml__TimeCSType has binding name 'gml__TimeCSType' for type 'gml:TimeCSType' */
#ifndef SOAP_TYPE_plu_gml__TimeCSType
#define SOAP_TYPE_plu_gml__TimeCSType (-321)

#endif

/* gml__VerticalCSPropertyType has binding name 'gml__VerticalCSPropertyType' for type 'gml:VerticalCSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__VerticalCSPropertyType
#define SOAP_TYPE_plu_gml__VerticalCSPropertyType (-320)

#endif

/* gml__VerticalCSType has binding name 'gml__VerticalCSType' for type 'gml:VerticalCSType' */
#ifndef SOAP_TYPE_plu_gml__VerticalCSType
#define SOAP_TYPE_plu_gml__VerticalCSType (-319)

#endif

/* gml__CartesianCSPropertyType has binding name 'gml__CartesianCSPropertyType' for type 'gml:CartesianCSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__CartesianCSPropertyType
#define SOAP_TYPE_plu_gml__CartesianCSPropertyType (-318)

#endif

/* gml__CartesianCSType has binding name 'gml__CartesianCSType' for type 'gml:CartesianCSType' */
#ifndef SOAP_TYPE_plu_gml__CartesianCSType
#define SOAP_TYPE_plu_gml__CartesianCSType (-317)

#endif

/* gml__EllipsoidalCSPropertyType has binding name 'gml__EllipsoidalCSPropertyType' for type 'gml:EllipsoidalCSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__EllipsoidalCSPropertyType
#define SOAP_TYPE_plu_gml__EllipsoidalCSPropertyType (-316)

#endif

/* gml__EllipsoidalCSType has binding name 'gml__EllipsoidalCSType' for type 'gml:EllipsoidalCSType' */
#ifndef SOAP_TYPE_plu_gml__EllipsoidalCSType
#define SOAP_TYPE_plu_gml__EllipsoidalCSType (-315)

#endif

/* gml__CoordinateSystemPropertyType has binding name 'gml__CoordinateSystemPropertyType' for type 'gml:CoordinateSystemPropertyType' */
#ifndef SOAP_TYPE_plu_gml__CoordinateSystemPropertyType
#define SOAP_TYPE_plu_gml__CoordinateSystemPropertyType (-314)

#endif

/* gml__AbstractCoordinateSystemType has binding name 'gml__AbstractCoordinateSystemType' for type 'gml:AbstractCoordinateSystemType' */
#ifndef SOAP_TYPE_plu_gml__AbstractCoordinateSystemType
#define SOAP_TYPE_plu_gml__AbstractCoordinateSystemType (-313)

#endif

/* gml__CoordinateSystemAxisPropertyType has binding name 'gml__CoordinateSystemAxisPropertyType' for type 'gml:CoordinateSystemAxisPropertyType' */
#ifndef SOAP_TYPE_plu_gml__CoordinateSystemAxisPropertyType
#define SOAP_TYPE_plu_gml__CoordinateSystemAxisPropertyType (-312)

#endif

/* gml__CoordinateSystemAxisType has binding name 'gml__CoordinateSystemAxisType' for type 'gml:CoordinateSystemAxisType' */
#ifndef SOAP_TYPE_plu_gml__CoordinateSystemAxisType
#define SOAP_TYPE_plu_gml__CoordinateSystemAxisType (-311)

#endif

/* gml__TemporalCRSPropertyType has binding name 'gml__TemporalCRSPropertyType' for type 'gml:TemporalCRSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__TemporalCRSPropertyType
#define SOAP_TYPE_plu_gml__TemporalCRSPropertyType (-310)

#endif

/* gml__TemporalCRSType has binding name 'gml__TemporalCRSType' for type 'gml:TemporalCRSType' */
#ifndef SOAP_TYPE_plu_gml__TemporalCRSType
#define SOAP_TYPE_plu_gml__TemporalCRSType (-309)

#endif

/* gml__ImageCRSPropertyType has binding name 'gml__ImageCRSPropertyType' for type 'gml:ImageCRSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__ImageCRSPropertyType
#define SOAP_TYPE_plu_gml__ImageCRSPropertyType (-308)

#endif

/* gml__ImageCRSType has binding name 'gml__ImageCRSType' for type 'gml:ImageCRSType' */
#ifndef SOAP_TYPE_plu_gml__ImageCRSType
#define SOAP_TYPE_plu_gml__ImageCRSType (-307)

#endif

/* gml__EngineeringCRSPropertyType has binding name 'gml__EngineeringCRSPropertyType' for type 'gml:EngineeringCRSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__EngineeringCRSPropertyType
#define SOAP_TYPE_plu_gml__EngineeringCRSPropertyType (-306)

#endif

/* gml__EngineeringCRSType has binding name 'gml__EngineeringCRSType' for type 'gml:EngineeringCRSType' */
#ifndef SOAP_TYPE_plu_gml__EngineeringCRSType
#define SOAP_TYPE_plu_gml__EngineeringCRSType (-305)

#endif

/* gml__DerivedCRSPropertyType has binding name 'gml__DerivedCRSPropertyType' for type 'gml:DerivedCRSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__DerivedCRSPropertyType
#define SOAP_TYPE_plu_gml__DerivedCRSPropertyType (-304)

#endif

/* gml__DerivedCRSType has binding name 'gml__DerivedCRSType' for type 'gml:DerivedCRSType' */
#ifndef SOAP_TYPE_plu_gml__DerivedCRSType
#define SOAP_TYPE_plu_gml__DerivedCRSType (-303)

#endif

/* gml__ProjectedCRSPropertyType has binding name 'gml__ProjectedCRSPropertyType' for type 'gml:ProjectedCRSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__ProjectedCRSPropertyType
#define SOAP_TYPE_plu_gml__ProjectedCRSPropertyType (-302)

#endif

/* gml__ProjectedCRSType has binding name 'gml__ProjectedCRSType' for type 'gml:ProjectedCRSType' */
#ifndef SOAP_TYPE_plu_gml__ProjectedCRSType
#define SOAP_TYPE_plu_gml__ProjectedCRSType (-301)

#endif

/* gml__VerticalCRSPropertyType has binding name 'gml__VerticalCRSPropertyType' for type 'gml:VerticalCRSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__VerticalCRSPropertyType
#define SOAP_TYPE_plu_gml__VerticalCRSPropertyType (-300)

#endif

/* gml__VerticalCRSType has binding name 'gml__VerticalCRSType' for type 'gml:VerticalCRSType' */
#ifndef SOAP_TYPE_plu_gml__VerticalCRSType
#define SOAP_TYPE_plu_gml__VerticalCRSType (-299)

#endif

/* gml__GeodeticCRSPropertyType has binding name 'gml__GeodeticCRSPropertyType' for type 'gml:GeodeticCRSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__GeodeticCRSPropertyType
#define SOAP_TYPE_plu_gml__GeodeticCRSPropertyType (-298)

#endif

/* gml__GeodeticCRSType has binding name 'gml__GeodeticCRSType' for type 'gml:GeodeticCRSType' */
#ifndef SOAP_TYPE_plu_gml__GeodeticCRSType
#define SOAP_TYPE_plu_gml__GeodeticCRSType (-297)

#endif

/* gml__CompoundCRSPropertyType has binding name 'gml__CompoundCRSPropertyType' for type 'gml:CompoundCRSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__CompoundCRSPropertyType
#define SOAP_TYPE_plu_gml__CompoundCRSPropertyType (-296)

#endif

/* gml__CompoundCRSType has binding name 'gml__CompoundCRSType' for type 'gml:CompoundCRSType' */
#ifndef SOAP_TYPE_plu_gml__CompoundCRSType
#define SOAP_TYPE_plu_gml__CompoundCRSType (-295)

#endif

/* gml__AbstractGeneralDerivedCRSType has binding name 'gml__AbstractGeneralDerivedCRSType' for type 'gml:AbstractGeneralDerivedCRSType' */
#ifndef SOAP_TYPE_plu_gml__AbstractGeneralDerivedCRSType
#define SOAP_TYPE_plu_gml__AbstractGeneralDerivedCRSType (-294)

#endif

/* gml__SingleCRSPropertyType has binding name 'gml__SingleCRSPropertyType' for type 'gml:SingleCRSPropertyType' */
#ifndef SOAP_TYPE_plu_gml__SingleCRSPropertyType
#define SOAP_TYPE_plu_gml__SingleCRSPropertyType (-293)

#endif

/* gml__RectifiedGridType has binding name 'gml__RectifiedGridType' for type 'gml:RectifiedGridType' */
#ifndef SOAP_TYPE_plu_gml__RectifiedGridType
#define SOAP_TYPE_plu_gml__RectifiedGridType (-292)

#endif

/* gml__GridEnvelopeType has binding name 'gml__GridEnvelopeType' for type 'gml:GridEnvelopeType' */
#ifndef SOAP_TYPE_plu_gml__GridEnvelopeType
#define SOAP_TYPE_plu_gml__GridEnvelopeType (-291)

#endif

/* gml__GridLimitsType has binding name 'gml__GridLimitsType' for type 'gml:GridLimitsType' */
#ifndef SOAP_TYPE_plu_gml__GridLimitsType
#define SOAP_TYPE_plu_gml__GridLimitsType (-290)

#endif

/* gml__GridType has binding name 'gml__GridType' for type 'gml:GridType' */
#ifndef SOAP_TYPE_plu_gml__GridType
#define SOAP_TYPE_plu_gml__GridType (-289)

#endif

/* gml__CountPropertyType has binding name 'gml__CountPropertyType' for type 'gml:CountPropertyType' */
#ifndef SOAP_TYPE_plu_gml__CountPropertyType
#define SOAP_TYPE_plu_gml__CountPropertyType (-288)

#endif

/* gml__QuantityPropertyType has binding name 'gml__QuantityPropertyType' for type 'gml:QuantityPropertyType' */
#ifndef SOAP_TYPE_plu_gml__QuantityPropertyType
#define SOAP_TYPE_plu_gml__QuantityPropertyType (-287)

#endif

/* gml__CategoryPropertyType has binding name 'gml__CategoryPropertyType' for type 'gml:CategoryPropertyType' */
#ifndef SOAP_TYPE_plu_gml__CategoryPropertyType
#define SOAP_TYPE_plu_gml__CategoryPropertyType (-286)

#endif

/* gml__BooleanPropertyType has binding name 'gml__BooleanPropertyType' for type 'gml:BooleanPropertyType' */
#ifndef SOAP_TYPE_plu_gml__BooleanPropertyType
#define SOAP_TYPE_plu_gml__BooleanPropertyType (-285)

#endif

/* gml__QuantityExtentType has binding name 'gml__QuantityExtentType' for type 'gml:QuantityExtentType' */
#ifndef SOAP_TYPE_plu_gml__QuantityExtentType
#define SOAP_TYPE_plu_gml__QuantityExtentType (-284)

#endif

/* gml__CategoryExtentType has binding name 'gml__CategoryExtentType' for type 'gml:CategoryExtentType' */
#ifndef SOAP_TYPE_plu_gml__CategoryExtentType
#define SOAP_TYPE_plu_gml__CategoryExtentType (-283)

#endif

/* gml__ValueArrayType has binding name 'gml__ValueArrayType' for type 'gml:ValueArrayType' */
#ifndef SOAP_TYPE_plu_gml__ValueArrayType
#define SOAP_TYPE_plu_gml__ValueArrayType (-282)

#endif

/* gml__CompositeValueType has binding name 'gml__CompositeValueType' for type 'gml:CompositeValueType' */
#ifndef SOAP_TYPE_plu_gml__CompositeValueType
#define SOAP_TYPE_plu_gml__CompositeValueType (-281)

#endif

/* gml__ValueArrayPropertyType has binding name 'gml__ValueArrayPropertyType' for type 'gml:ValueArrayPropertyType' */
#ifndef SOAP_TYPE_plu_gml__ValueArrayPropertyType
#define SOAP_TYPE_plu_gml__ValueArrayPropertyType (-280)

#endif

/* gml__ValuePropertyType has binding name 'gml__ValuePropertyType' for type 'gml:ValuePropertyType' */
#ifndef SOAP_TYPE_plu_gml__ValuePropertyType
#define SOAP_TYPE_plu_gml__ValuePropertyType (-279)

#endif

/* gml__TimeIntervalLengthType has binding name 'gml__TimeIntervalLengthType' for type 'gml:TimeIntervalLengthType' */
#ifndef SOAP_TYPE_plu_gml__TimeIntervalLengthType
#define SOAP_TYPE_plu_gml__TimeIntervalLengthType (-278)

#endif

/* gml__TimePositionType has binding name 'gml__TimePositionType' for type 'gml:TimePositionType' */
#ifndef SOAP_TYPE_plu_gml__TimePositionType
#define SOAP_TYPE_plu_gml__TimePositionType (-277)

#endif

/* gml__TimePeriodPropertyType has binding name 'gml__TimePeriodPropertyType' for type 'gml:TimePeriodPropertyType' */
#ifndef SOAP_TYPE_plu_gml__TimePeriodPropertyType
#define SOAP_TYPE_plu_gml__TimePeriodPropertyType (-276)

#endif

/* gml__TimePeriodType has binding name 'gml__TimePeriodType' for type 'gml:TimePeriodType' */
#ifndef SOAP_TYPE_plu_gml__TimePeriodType
#define SOAP_TYPE_plu_gml__TimePeriodType (-275)

#endif

/* gml__TimeInstantPropertyType has binding name 'gml__TimeInstantPropertyType' for type 'gml:TimeInstantPropertyType' */
#ifndef SOAP_TYPE_plu_gml__TimeInstantPropertyType
#define SOAP_TYPE_plu_gml__TimeInstantPropertyType (-274)

#endif

/* gml__TimeInstantType has binding name 'gml__TimeInstantType' for type 'gml:TimeInstantType' */
#ifndef SOAP_TYPE_plu_gml__TimeInstantType
#define SOAP_TYPE_plu_gml__TimeInstantType (-273)

#endif

/* gml__AbstractTimeGeometricPrimitiveType has binding name 'gml__AbstractTimeGeometricPrimitiveType' for type 'gml:AbstractTimeGeometricPrimitiveType' */
#ifndef SOAP_TYPE_plu_gml__AbstractTimeGeometricPrimitiveType
#define SOAP_TYPE_plu_gml__AbstractTimeGeometricPrimitiveType (-272)

#endif

/* gml__AbstractTimeComplexType has binding name 'gml__AbstractTimeComplexType' for type 'gml:AbstractTimeComplexType' */
#ifndef SOAP_TYPE_plu_gml__AbstractTimeComplexType
#define SOAP_TYPE_plu_gml__AbstractTimeComplexType (-271)

#endif

/* gml__RelatedTimeType has binding name 'gml__RelatedTimeType' for type 'gml:RelatedTimeType' */
#ifndef SOAP_TYPE_plu_gml__RelatedTimeType
#define SOAP_TYPE_plu_gml__RelatedTimeType (-270)

#endif

/* gml__TimePrimitivePropertyType has binding name 'gml__TimePrimitivePropertyType' for type 'gml:TimePrimitivePropertyType' */
#ifndef SOAP_TYPE_plu_gml__TimePrimitivePropertyType
#define SOAP_TYPE_plu_gml__TimePrimitivePropertyType (-269)

#endif

/* gml__AbstractTimePrimitiveType has binding name 'gml__AbstractTimePrimitiveType' for type 'gml:AbstractTimePrimitiveType' */
#ifndef SOAP_TYPE_plu_gml__AbstractTimePrimitiveType
#define SOAP_TYPE_plu_gml__AbstractTimePrimitiveType (-268)

#endif

/* gml__AbstractTimeObjectType has binding name 'gml__AbstractTimeObjectType' for type 'gml:AbstractTimeObjectType' */
#ifndef SOAP_TYPE_plu_gml__AbstractTimeObjectType
#define SOAP_TYPE_plu_gml__AbstractTimeObjectType (-267)

#endif

/* gml__AbstractFeatureMemberType has binding name 'gml__AbstractFeatureMemberType' for type 'gml:AbstractFeatureMemberType' */
#ifndef SOAP_TYPE_plu_gml__AbstractFeatureMemberType
#define SOAP_TYPE_plu_gml__AbstractFeatureMemberType (-266)

#endif

/* gml__EnvelopeWithTimePeriodType has binding name 'gml__EnvelopeWithTimePeriodType' for type 'gml:EnvelopeWithTimePeriodType' */
#ifndef SOAP_TYPE_plu_gml__EnvelopeWithTimePeriodType
#define SOAP_TYPE_plu_gml__EnvelopeWithTimePeriodType (-265)

#endif

/* gml__BoundingShapeType has binding name 'gml__BoundingShapeType' for type 'gml:BoundingShapeType' */
#ifndef SOAP_TYPE_plu_gml__BoundingShapeType
#define SOAP_TYPE_plu_gml__BoundingShapeType (-264)

#endif

/* gml__FeaturePropertyType has binding name 'gml__FeaturePropertyType' for type 'gml:FeaturePropertyType' */
#ifndef SOAP_TYPE_plu_gml__FeaturePropertyType
#define SOAP_TYPE_plu_gml__FeaturePropertyType (-263)

#endif

/* gml__AbstractFeatureType has binding name 'gml__AbstractFeatureType' for type 'gml:AbstractFeatureType' */
#ifndef SOAP_TYPE_plu_gml__AbstractFeatureType
#define SOAP_TYPE_plu_gml__AbstractFeatureType (-262)

#endif

/* gml__SequenceRuleType has binding name 'gml__SequenceRuleType' for type 'gml:SequenceRuleType' */
#ifndef SOAP_TYPE_plu_gml__SequenceRuleType
#define SOAP_TYPE_plu_gml__SequenceRuleType (-261)

#endif

/* gml__GridFunctionType has binding name 'gml__GridFunctionType' for type 'gml:GridFunctionType' */
#ifndef SOAP_TYPE_plu_gml__GridFunctionType
#define SOAP_TYPE_plu_gml__GridFunctionType (-260)

#endif

/* gml__MappingRuleType has binding name 'gml__MappingRuleType' for type 'gml:MappingRuleType' */
#ifndef SOAP_TYPE_plu_gml__MappingRuleType
#define SOAP_TYPE_plu_gml__MappingRuleType (-259)

#endif

/* gml__CoverageFunctionType has binding name 'gml__CoverageFunctionType' for type 'gml:CoverageFunctionType' */
#ifndef SOAP_TYPE_plu_gml__CoverageFunctionType
#define SOAP_TYPE_plu_gml__CoverageFunctionType (-258)

#endif

/* gml__FileType has binding name 'gml__FileType' for type 'gml:FileType' */
#ifndef SOAP_TYPE_plu_gml__FileType
#define SOAP_TYPE_plu_gml__FileType (-257)

#endif

/* gml__DataBlockType has binding name 'gml__DataBlockType' for type 'gml:DataBlockType' */
#ifndef SOAP_TYPE_plu_gml__DataBlockType
#define SOAP_TYPE_plu_gml__DataBlockType (-256)

#endif

/* gml__RangeSetType has binding name 'gml__RangeSetType' for type 'gml:RangeSetType' */
#ifndef SOAP_TYPE_plu_gml__RangeSetType
#define SOAP_TYPE_plu_gml__RangeSetType (-255)

#endif

/* gml__DomainSetType has binding name 'gml__DomainSetType' for type 'gml:DomainSetType' */
#ifndef SOAP_TYPE_plu_gml__DomainSetType
#define SOAP_TYPE_plu_gml__DomainSetType (-254)

#endif

/* gml__AbstractContinuousCoverageType has binding name 'gml__AbstractContinuousCoverageType' for type 'gml:AbstractContinuousCoverageType' */
#ifndef SOAP_TYPE_plu_gml__AbstractContinuousCoverageType
#define SOAP_TYPE_plu_gml__AbstractContinuousCoverageType (-253)

#endif

/* gml__DiscreteCoverageType has binding name 'gml__DiscreteCoverageType' for type 'gml:DiscreteCoverageType' */
#ifndef SOAP_TYPE_plu_gml__DiscreteCoverageType
#define SOAP_TYPE_plu_gml__DiscreteCoverageType (-252)

#endif

/* gml__AbstractCoverageType has binding name 'gml__AbstractCoverageType' for type 'gml:AbstractCoverageType' */
#ifndef SOAP_TYPE_plu_gml__AbstractCoverageType
#define SOAP_TYPE_plu_gml__AbstractCoverageType (-251)

#endif

/* gml__MeasureOrNilReasonListType has binding name 'gml__MeasureOrNilReasonListType' for type 'gml:MeasureOrNilReasonListType' */
#ifndef SOAP_TYPE_plu_gml__MeasureOrNilReasonListType
#define SOAP_TYPE_plu_gml__MeasureOrNilReasonListType (-250)

#endif

/* gml__MeasureListType has binding name 'gml__MeasureListType' for type 'gml:MeasureListType' */
#ifndef SOAP_TYPE_plu_gml__MeasureListType
#define SOAP_TYPE_plu_gml__MeasureListType (-249)

#endif

/* gml__CodeOrNilReasonListType has binding name 'gml__CodeOrNilReasonListType' for type 'gml:CodeOrNilReasonListType' */
#ifndef SOAP_TYPE_plu_gml__CodeOrNilReasonListType
#define SOAP_TYPE_plu_gml__CodeOrNilReasonListType (-248)

#endif

/* gml__CodeListType has binding name 'gml__CodeListType' for type 'gml:CodeListType' */
#ifndef SOAP_TYPE_plu_gml__CodeListType
#define SOAP_TYPE_plu_gml__CodeListType (-247)

#endif

/* gml__CoordinatesType has binding name 'gml__CoordinatesType' for type 'gml:CoordinatesType' */
#ifndef SOAP_TYPE_plu_gml__CoordinatesType
#define SOAP_TYPE_plu_gml__CoordinatesType (-246)

#endif

/* gml__MeasureType has binding name 'gml__MeasureType' for type 'gml:MeasureType' */
#ifndef SOAP_TYPE_plu_gml__MeasureType
#define SOAP_TYPE_plu_gml__MeasureType (-245)

#endif

/* gml__CodeWithAuthorityType has binding name 'gml__CodeWithAuthorityType' for type 'gml:CodeWithAuthorityType' */
#ifndef SOAP_TYPE_plu_gml__CodeWithAuthorityType
#define SOAP_TYPE_plu_gml__CodeWithAuthorityType (-244)

#endif

/* gml__CodeType has binding name 'gml__CodeType' for type 'gml:CodeType' */
#ifndef SOAP_TYPE_plu_gml__CodeType
#define SOAP_TYPE_plu_gml__CodeType (-243)

#endif

/* gml__AbstractMetadataPropertyType has binding name 'gml__AbstractMetadataPropertyType' for type 'gml:AbstractMetadataPropertyType' */
#ifndef SOAP_TYPE_plu_gml__AbstractMetadataPropertyType
#define SOAP_TYPE_plu_gml__AbstractMetadataPropertyType (-242)

#endif

/* gml__AbstractMemberType has binding name 'gml__AbstractMemberType' for type 'gml:AbstractMemberType' */
#ifndef SOAP_TYPE_plu_gml__AbstractMemberType
#define SOAP_TYPE_plu_gml__AbstractMemberType (-241)

#endif

/* gml__InlinePropertyType has binding name 'gml__InlinePropertyType' for type 'gml:InlinePropertyType' */
#ifndef SOAP_TYPE_plu_gml__InlinePropertyType
#define SOAP_TYPE_plu_gml__InlinePropertyType (-240)

#endif

/* gml__ReferenceType has binding name 'gml__ReferenceType' for type 'gml:ReferenceType' */
#ifndef SOAP_TYPE_plu_gml__ReferenceType
#define SOAP_TYPE_plu_gml__ReferenceType (-239)

#endif

/* gml__AssociationRoleType has binding name 'gml__AssociationRoleType' for type 'gml:AssociationRoleType' */
#ifndef SOAP_TYPE_plu_gml__AssociationRoleType
#define SOAP_TYPE_plu_gml__AssociationRoleType (-238)

#endif

/* gml__AbstractGMLType has binding name 'gml__AbstractGMLType' for type 'gml:AbstractGMLType' */
#ifndef SOAP_TYPE_plu_gml__AbstractGMLType
#define SOAP_TYPE_plu_gml__AbstractGMLType (-237)

#endif

/* gml__DictionaryEntryType has binding name 'gml__DictionaryEntryType' for type 'gml:DictionaryEntryType' */
#ifndef SOAP_TYPE_plu_gml__DictionaryEntryType
#define SOAP_TYPE_plu_gml__DictionaryEntryType (-236)

#endif

/* gml__DictionaryType has binding name 'gml__DictionaryType' for type 'gml:DictionaryType' */
#ifndef SOAP_TYPE_plu_gml__DictionaryType
#define SOAP_TYPE_plu_gml__DictionaryType (-235)

#endif

/* gml__DefinitionType has binding name 'gml__DefinitionType' for type 'gml:DefinitionType' */
#ifndef SOAP_TYPE_plu_gml__DefinitionType
#define SOAP_TYPE_plu_gml__DefinitionType (-234)

#endif

/* gml__DefinitionBaseType has binding name 'gml__DefinitionBaseType' for type 'gml:DefinitionBaseType' */
#ifndef SOAP_TYPE_plu_gml__DefinitionBaseType
#define SOAP_TYPE_plu_gml__DefinitionBaseType (-233)

#endif

/* gml__FormulaType has binding name 'gml__FormulaType' for type 'gml:FormulaType' */
#ifndef SOAP_TYPE_plu_gml__FormulaType
#define SOAP_TYPE_plu_gml__FormulaType (-232)

#endif

/* gml__ConversionToPreferredUnitType has binding name 'gml__ConversionToPreferredUnitType' for type 'gml:ConversionToPreferredUnitType' */
#ifndef SOAP_TYPE_plu_gml__ConversionToPreferredUnitType
#define SOAP_TYPE_plu_gml__ConversionToPreferredUnitType (-231)

#endif

/* gml__ConventionalUnitType has binding name 'gml__ConventionalUnitType' for type 'gml:ConventionalUnitType' */
#ifndef SOAP_TYPE_plu_gml__ConventionalUnitType
#define SOAP_TYPE_plu_gml__ConventionalUnitType (-230)

#endif

/* gml__DerivationUnitTermType has binding name 'gml__DerivationUnitTermType' for type 'gml:DerivationUnitTermType' */
#ifndef SOAP_TYPE_plu_gml__DerivationUnitTermType
#define SOAP_TYPE_plu_gml__DerivationUnitTermType (-229)

#endif

/* gml__DerivedUnitType has binding name 'gml__DerivedUnitType' for type 'gml:DerivedUnitType' */
#ifndef SOAP_TYPE_plu_gml__DerivedUnitType
#define SOAP_TYPE_plu_gml__DerivedUnitType (-228)

#endif

/* gml__BaseUnitType has binding name 'gml__BaseUnitType' for type 'gml:BaseUnitType' */
#ifndef SOAP_TYPE_plu_gml__BaseUnitType
#define SOAP_TYPE_plu_gml__BaseUnitType (-227)

#endif

/* gml__UnitDefinitionType has binding name 'gml__UnitDefinitionType' for type 'gml:UnitDefinitionType' */
#ifndef SOAP_TYPE_plu_gml__UnitDefinitionType
#define SOAP_TYPE_plu_gml__UnitDefinitionType (-226)

#endif

/* gml__UnitOfMeasureType has binding name 'gml__UnitOfMeasureType' for type 'gml:UnitOfMeasureType' */
#ifndef SOAP_TYPE_plu_gml__UnitOfMeasureType
#define SOAP_TYPE_plu_gml__UnitOfMeasureType (-225)

#endif

/* gml__AngleType has binding name 'gml__AngleType' for type 'gml:AngleType' */
#ifndef SOAP_TYPE_plu_gml__AngleType
#define SOAP_TYPE_plu_gml__AngleType (-224)

#endif

/* gml__SpeedType has binding name 'gml__SpeedType' for type 'gml:SpeedType' */
#ifndef SOAP_TYPE_plu_gml__SpeedType
#define SOAP_TYPE_plu_gml__SpeedType (-223)

#endif

/* gml__VolumeType has binding name 'gml__VolumeType' for type 'gml:VolumeType' */
#ifndef SOAP_TYPE_plu_gml__VolumeType
#define SOAP_TYPE_plu_gml__VolumeType (-222)

#endif

/* gml__AreaType has binding name 'gml__AreaType' for type 'gml:AreaType' */
#ifndef SOAP_TYPE_plu_gml__AreaType
#define SOAP_TYPE_plu_gml__AreaType (-221)

#endif

/* gml__GridLengthType has binding name 'gml__GridLengthType' for type 'gml:GridLengthType' */
#ifndef SOAP_TYPE_plu_gml__GridLengthType
#define SOAP_TYPE_plu_gml__GridLengthType (-220)

#endif

/* gml__TimeType has binding name 'gml__TimeType' for type 'gml:TimeType' */
#ifndef SOAP_TYPE_plu_gml__TimeType
#define SOAP_TYPE_plu_gml__TimeType (-219)

#endif

/* gml__ScaleType has binding name 'gml__ScaleType' for type 'gml:ScaleType' */
#ifndef SOAP_TYPE_plu_gml__ScaleType
#define SOAP_TYPE_plu_gml__ScaleType (-218)

#endif

/* gml__LengthType has binding name 'gml__LengthType' for type 'gml:LengthType' */
#ifndef SOAP_TYPE_plu_gml__LengthType
#define SOAP_TYPE_plu_gml__LengthType (-217)

#endif

/* gml__LineStringType has binding name 'gml__LineStringType' for type 'gml:LineStringType' */
#ifndef SOAP_TYPE_plu_gml__LineStringType
#define SOAP_TYPE_plu_gml__LineStringType (-216)

#endif

/* gml__CurveArrayPropertyType has binding name 'gml__CurveArrayPropertyType' for type 'gml:CurveArrayPropertyType' */
#ifndef SOAP_TYPE_plu_gml__CurveArrayPropertyType
#define SOAP_TYPE_plu_gml__CurveArrayPropertyType (-215)

#endif

/* gml__CurvePropertyType has binding name 'gml__CurvePropertyType' for type 'gml:CurvePropertyType' */
#ifndef SOAP_TYPE_plu_gml__CurvePropertyType
#define SOAP_TYPE_plu_gml__CurvePropertyType (-214)

#endif

/* gml__AbstractCurveType has binding name 'gml__AbstractCurveType' for type 'gml:AbstractCurveType' */
#ifndef SOAP_TYPE_plu_gml__AbstractCurveType
#define SOAP_TYPE_plu_gml__AbstractCurveType (-213)

#endif

/* gml__PointArrayPropertyType has binding name 'gml__PointArrayPropertyType' for type 'gml:PointArrayPropertyType' */
#ifndef SOAP_TYPE_plu_gml__PointArrayPropertyType
#define SOAP_TYPE_plu_gml__PointArrayPropertyType (-212)

#endif

/* gml__PointPropertyType has binding name 'gml__PointPropertyType' for type 'gml:PointPropertyType' */
#ifndef SOAP_TYPE_plu_gml__PointPropertyType
#define SOAP_TYPE_plu_gml__PointPropertyType (-211)

#endif

/* gml__PointType has binding name 'gml__PointType' for type 'gml:PointType' */
#ifndef SOAP_TYPE_plu_gml__PointType
#define SOAP_TYPE_plu_gml__PointType (-210)

#endif

/* gml__GeometricPrimitivePropertyType has binding name 'gml__GeometricPrimitivePropertyType' for type 'gml:GeometricPrimitivePropertyType' */
#ifndef SOAP_TYPE_plu_gml__GeometricPrimitivePropertyType
#define SOAP_TYPE_plu_gml__GeometricPrimitivePropertyType (-209)

#endif

/* gml__AbstractGeometricPrimitiveType has binding name 'gml__AbstractGeometricPrimitiveType' for type 'gml:AbstractGeometricPrimitiveType' */
#ifndef SOAP_TYPE_plu_gml__AbstractGeometricPrimitiveType
#define SOAP_TYPE_plu_gml__AbstractGeometricPrimitiveType (-208)

#endif

/* gml__EnvelopeType has binding name 'gml__EnvelopeType' for type 'gml:EnvelopeType' */
#ifndef SOAP_TYPE_plu_gml__EnvelopeType
#define SOAP_TYPE_plu_gml__EnvelopeType (-207)

#endif

/* gml__VectorType has binding name 'gml__VectorType' for type 'gml:VectorType' */
#ifndef SOAP_TYPE_plu_gml__VectorType
#define SOAP_TYPE_plu_gml__VectorType (-206)

#endif

/* gml__DirectPositionListType has binding name 'gml__DirectPositionListType' for type 'gml:DirectPositionListType' */
#ifndef SOAP_TYPE_plu_gml__DirectPositionListType
#define SOAP_TYPE_plu_gml__DirectPositionListType (-205)

#endif

/* gml__DirectPositionType has binding name 'gml__DirectPositionType' for type 'gml:DirectPositionType' */
#ifndef SOAP_TYPE_plu_gml__DirectPositionType
#define SOAP_TYPE_plu_gml__DirectPositionType (-204)

#endif

/* gml__GeometryArrayPropertyType has binding name 'gml__GeometryArrayPropertyType' for type 'gml:GeometryArrayPropertyType' */
#ifndef SOAP_TYPE_plu_gml__GeometryArrayPropertyType
#define SOAP_TYPE_plu_gml__GeometryArrayPropertyType (-203)

#endif

/* gml__GeometryPropertyType has binding name 'gml__GeometryPropertyType' for type 'gml:GeometryPropertyType' */
#ifndef SOAP_TYPE_plu_gml__GeometryPropertyType
#define SOAP_TYPE_plu_gml__GeometryPropertyType (-202)

#endif

/* gml__AbstractGeometryType has binding name 'gml__AbstractGeometryType' for type 'gml:AbstractGeometryType' */
#ifndef SOAP_TYPE_plu_gml__AbstractGeometryType
#define SOAP_TYPE_plu_gml__AbstractGeometryType (-201)

#endif

/* gml__LinearRingPropertyType has binding name 'gml__LinearRingPropertyType' for type 'gml:LinearRingPropertyType' */
#ifndef SOAP_TYPE_plu_gml__LinearRingPropertyType
#define SOAP_TYPE_plu_gml__LinearRingPropertyType (-200)

#endif

/* gml__LinearRingType has binding name 'gml__LinearRingType' for type 'gml:LinearRingType' */
#ifndef SOAP_TYPE_plu_gml__LinearRingType
#define SOAP_TYPE_plu_gml__LinearRingType (-199)

#endif

/* gml__AbstractRingPropertyType has binding name 'gml__AbstractRingPropertyType' for type 'gml:AbstractRingPropertyType' */
#ifndef SOAP_TYPE_plu_gml__AbstractRingPropertyType
#define SOAP_TYPE_plu_gml__AbstractRingPropertyType (-198)

#endif

/* gml__AbstractRingType has binding name 'gml__AbstractRingType' for type 'gml:AbstractRingType' */
#ifndef SOAP_TYPE_plu_gml__AbstractRingType
#define SOAP_TYPE_plu_gml__AbstractRingType (-197)

#endif

/* gml__PolygonType has binding name 'gml__PolygonType' for type 'gml:PolygonType' */
#ifndef SOAP_TYPE_plu_gml__PolygonType
#define SOAP_TYPE_plu_gml__PolygonType (-196)

#endif

/* gml__SurfaceArrayPropertyType has binding name 'gml__SurfaceArrayPropertyType' for type 'gml:SurfaceArrayPropertyType' */
#ifndef SOAP_TYPE_plu_gml__SurfaceArrayPropertyType
#define SOAP_TYPE_plu_gml__SurfaceArrayPropertyType (-195)

#endif

/* gml__SurfacePropertyType has binding name 'gml__SurfacePropertyType' for type 'gml:SurfacePropertyType' */
#ifndef SOAP_TYPE_plu_gml__SurfacePropertyType
#define SOAP_TYPE_plu_gml__SurfacePropertyType (-194)

#endif

/* gml__AbstractSurfaceType has binding name 'gml__AbstractSurfaceType' for type 'gml:AbstractSurfaceType' */
#ifndef SOAP_TYPE_plu_gml__AbstractSurfaceType
#define SOAP_TYPE_plu_gml__AbstractSurfaceType (-193)

#endif

/* gml__ShellPropertyType has binding name 'gml__ShellPropertyType' for type 'gml:ShellPropertyType' */
#ifndef SOAP_TYPE_plu_gml__ShellPropertyType
#define SOAP_TYPE_plu_gml__ShellPropertyType (-192)

#endif

/* gml__ShellType has binding name 'gml__ShellType' for type 'gml:ShellType' */
#ifndef SOAP_TYPE_plu_gml__ShellType
#define SOAP_TYPE_plu_gml__ShellType (-191)

#endif

/* gml__SolidType has binding name 'gml__SolidType' for type 'gml:SolidType' */
#ifndef SOAP_TYPE_plu_gml__SolidType
#define SOAP_TYPE_plu_gml__SolidType (-190)

#endif

/* gml__SolidArrayPropertyType has binding name 'gml__SolidArrayPropertyType' for type 'gml:SolidArrayPropertyType' */
#ifndef SOAP_TYPE_plu_gml__SolidArrayPropertyType
#define SOAP_TYPE_plu_gml__SolidArrayPropertyType (-189)

#endif

/* gml__SolidPropertyType has binding name 'gml__SolidPropertyType' for type 'gml:SolidPropertyType' */
#ifndef SOAP_TYPE_plu_gml__SolidPropertyType
#define SOAP_TYPE_plu_gml__SolidPropertyType (-188)

#endif

/* gml__AbstractSolidType has binding name 'gml__AbstractSolidType' for type 'gml:AbstractSolidType' */
#ifndef SOAP_TYPE_plu_gml__AbstractSolidType
#define SOAP_TYPE_plu_gml__AbstractSolidType (-187)

#endif

/* gml__LineStringSegmentArrayPropertyType has binding name 'gml__LineStringSegmentArrayPropertyType' for type 'gml:LineStringSegmentArrayPropertyType' */
#ifndef SOAP_TYPE_plu_gml__LineStringSegmentArrayPropertyType
#define SOAP_TYPE_plu_gml__LineStringSegmentArrayPropertyType (-186)

#endif

/* gml__TinType has binding name 'gml__TinType' for type 'gml:TinType' */
#ifndef SOAP_TYPE_plu_gml__TinType
#define SOAP_TYPE_plu_gml__TinType (-185)

#endif

/* gml__SphereType has binding name 'gml__SphereType' for type 'gml:SphereType' */
#ifndef SOAP_TYPE_plu_gml__SphereType
#define SOAP_TYPE_plu_gml__SphereType (-184)

#endif

/* gml__CylinderType has binding name 'gml__CylinderType' for type 'gml:CylinderType' */
#ifndef SOAP_TYPE_plu_gml__CylinderType
#define SOAP_TYPE_plu_gml__CylinderType (-183)

#endif

/* gml__ConeType has binding name 'gml__ConeType' for type 'gml:ConeType' */
#ifndef SOAP_TYPE_plu_gml__ConeType
#define SOAP_TYPE_plu_gml__ConeType (-182)

#endif

/* gml__AbstractGriddedSurfaceType has binding name 'gml__AbstractGriddedSurfaceType' for type 'gml:AbstractGriddedSurfaceType' */
#ifndef SOAP_TYPE_plu_gml__AbstractGriddedSurfaceType
#define SOAP_TYPE_plu_gml__AbstractGriddedSurfaceType (-181)

#endif

/* gml__AbstractParametricCurveSurfaceType has binding name 'gml__AbstractParametricCurveSurfaceType' for type 'gml:AbstractParametricCurveSurfaceType' */
#ifndef SOAP_TYPE_plu_gml__AbstractParametricCurveSurfaceType
#define SOAP_TYPE_plu_gml__AbstractParametricCurveSurfaceType (-180)

#endif

/* gml__RingPropertyType has binding name 'gml__RingPropertyType' for type 'gml:RingPropertyType' */
#ifndef SOAP_TYPE_plu_gml__RingPropertyType
#define SOAP_TYPE_plu_gml__RingPropertyType (-179)

#endif

/* gml__RingType has binding name 'gml__RingType' for type 'gml:RingType' */
#ifndef SOAP_TYPE_plu_gml__RingType
#define SOAP_TYPE_plu_gml__RingType (-178)

#endif

/* gml__RectangleType has binding name 'gml__RectangleType' for type 'gml:RectangleType' */
#ifndef SOAP_TYPE_plu_gml__RectangleType
#define SOAP_TYPE_plu_gml__RectangleType (-177)

#endif

/* gml__TriangleType has binding name 'gml__TriangleType' for type 'gml:TriangleType' */
#ifndef SOAP_TYPE_plu_gml__TriangleType
#define SOAP_TYPE_plu_gml__TriangleType (-176)

#endif

/* gml__PolygonPatchType has binding name 'gml__PolygonPatchType' for type 'gml:PolygonPatchType' */
#ifndef SOAP_TYPE_plu_gml__PolygonPatchType
#define SOAP_TYPE_plu_gml__PolygonPatchType (-175)

#endif

/* gml__SurfacePatchArrayPropertyType has binding name 'gml__SurfacePatchArrayPropertyType' for type 'gml:SurfacePatchArrayPropertyType' */
#ifndef SOAP_TYPE_plu_gml__SurfacePatchArrayPropertyType
#define SOAP_TYPE_plu_gml__SurfacePatchArrayPropertyType (-174)

#endif

/* gml__AbstractSurfacePatchType has binding name 'gml__AbstractSurfacePatchType' for type 'gml:AbstractSurfacePatchType' */
#ifndef SOAP_TYPE_plu_gml__AbstractSurfacePatchType
#define SOAP_TYPE_plu_gml__AbstractSurfacePatchType (-173)

#endif

/* gml__OrientableSurfaceType has binding name 'gml__OrientableSurfaceType' for type 'gml:OrientableSurfaceType' */
#ifndef SOAP_TYPE_plu_gml__OrientableSurfaceType
#define SOAP_TYPE_plu_gml__OrientableSurfaceType (-172)

#endif

/* gml__SurfaceType has binding name 'gml__SurfaceType' for type 'gml:SurfaceType' */
#ifndef SOAP_TYPE_plu_gml__SurfaceType
#define SOAP_TYPE_plu_gml__SurfaceType (-171)

#endif

/* gml__GeodesicType has binding name 'gml__GeodesicType' for type 'gml:GeodesicType' */
#ifndef SOAP_TYPE_plu_gml__GeodesicType
#define SOAP_TYPE_plu_gml__GeodesicType (-170)

#endif

/* gml__GeodesicStringType has binding name 'gml__GeodesicStringType' for type 'gml:GeodesicStringType' */
#ifndef SOAP_TYPE_plu_gml__GeodesicStringType
#define SOAP_TYPE_plu_gml__GeodesicStringType (-169)

#endif

/* gml__ClothoidType has binding name 'gml__ClothoidType' for type 'gml:ClothoidType' */
#ifndef SOAP_TYPE_plu_gml__ClothoidType
#define SOAP_TYPE_plu_gml__ClothoidType (-168)

#endif

/* gml__AffinePlacementType has binding name 'gml__AffinePlacementType' for type 'gml:AffinePlacementType' */
#ifndef SOAP_TYPE_plu_gml__AffinePlacementType
#define SOAP_TYPE_plu_gml__AffinePlacementType (-167)

#endif

/* gml__OffsetCurveType has binding name 'gml__OffsetCurveType' for type 'gml:OffsetCurveType' */
#ifndef SOAP_TYPE_plu_gml__OffsetCurveType
#define SOAP_TYPE_plu_gml__OffsetCurveType (-166)

#endif

/* gml__BezierType has binding name 'gml__BezierType' for type 'gml:BezierType' */
#ifndef SOAP_TYPE_plu_gml__BezierType
#define SOAP_TYPE_plu_gml__BezierType (-165)

#endif

/* gml__KnotPropertyType has binding name 'gml__KnotPropertyType' for type 'gml:KnotPropertyType' */
#ifndef SOAP_TYPE_plu_gml__KnotPropertyType
#define SOAP_TYPE_plu_gml__KnotPropertyType (-164)

#endif

/* gml__KnotType has binding name 'gml__KnotType' for type 'gml:KnotType' */
#ifndef SOAP_TYPE_plu_gml__KnotType
#define SOAP_TYPE_plu_gml__KnotType (-163)

#endif

/* gml__BSplineType has binding name 'gml__BSplineType' for type 'gml:BSplineType' */
#ifndef SOAP_TYPE_plu_gml__BSplineType
#define SOAP_TYPE_plu_gml__BSplineType (-162)

#endif

/* gml__CubicSplineType has binding name 'gml__CubicSplineType' for type 'gml:CubicSplineType' */
#ifndef SOAP_TYPE_plu_gml__CubicSplineType
#define SOAP_TYPE_plu_gml__CubicSplineType (-161)

#endif

/* gml__CircleByCenterPointType has binding name 'gml__CircleByCenterPointType' for type 'gml:CircleByCenterPointType' */
#ifndef SOAP_TYPE_plu_gml__CircleByCenterPointType
#define SOAP_TYPE_plu_gml__CircleByCenterPointType (-160)

#endif

/* gml__ArcByCenterPointType has binding name 'gml__ArcByCenterPointType' for type 'gml:ArcByCenterPointType' */
#ifndef SOAP_TYPE_plu_gml__ArcByCenterPointType
#define SOAP_TYPE_plu_gml__ArcByCenterPointType (-159)

#endif

/* gml__ArcByBulgeType has binding name 'gml__ArcByBulgeType' for type 'gml:ArcByBulgeType' */
#ifndef SOAP_TYPE_plu_gml__ArcByBulgeType
#define SOAP_TYPE_plu_gml__ArcByBulgeType (-158)

#endif

/* gml__ArcStringByBulgeType has binding name 'gml__ArcStringByBulgeType' for type 'gml:ArcStringByBulgeType' */
#ifndef SOAP_TYPE_plu_gml__ArcStringByBulgeType
#define SOAP_TYPE_plu_gml__ArcStringByBulgeType (-157)

#endif

/* gml__CircleType has binding name 'gml__CircleType' for type 'gml:CircleType' */
#ifndef SOAP_TYPE_plu_gml__CircleType
#define SOAP_TYPE_plu_gml__CircleType (-156)

#endif

/* gml__ArcType has binding name 'gml__ArcType' for type 'gml:ArcType' */
#ifndef SOAP_TYPE_plu_gml__ArcType
#define SOAP_TYPE_plu_gml__ArcType (-155)

#endif

/* gml__ArcStringType has binding name 'gml__ArcStringType' for type 'gml:ArcStringType' */
#ifndef SOAP_TYPE_plu_gml__ArcStringType
#define SOAP_TYPE_plu_gml__ArcStringType (-154)

#endif

/* gml__LineStringSegmentType has binding name 'gml__LineStringSegmentType' for type 'gml:LineStringSegmentType' */
#ifndef SOAP_TYPE_plu_gml__LineStringSegmentType
#define SOAP_TYPE_plu_gml__LineStringSegmentType (-153)

#endif

/* gml__CurveSegmentArrayPropertyType has binding name 'gml__CurveSegmentArrayPropertyType' for type 'gml:CurveSegmentArrayPropertyType' */
#ifndef SOAP_TYPE_plu_gml__CurveSegmentArrayPropertyType
#define SOAP_TYPE_plu_gml__CurveSegmentArrayPropertyType (-152)

#endif

/* gml__AbstractCurveSegmentType has binding name 'gml__AbstractCurveSegmentType' for type 'gml:AbstractCurveSegmentType' */
#ifndef SOAP_TYPE_plu_gml__AbstractCurveSegmentType
#define SOAP_TYPE_plu_gml__AbstractCurveSegmentType (-151)

#endif

/* gml__OrientableCurveType has binding name 'gml__OrientableCurveType' for type 'gml:OrientableCurveType' */
#ifndef SOAP_TYPE_plu_gml__OrientableCurveType
#define SOAP_TYPE_plu_gml__OrientableCurveType (-150)

#endif

/* gml__CurveType has binding name 'gml__CurveType' for type 'gml:CurveType' */
#ifndef SOAP_TYPE_plu_gml__CurveType
#define SOAP_TYPE_plu_gml__CurveType (-149)

#endif

/* gml__MultiSolidPropertyType has binding name 'gml__MultiSolidPropertyType' for type 'gml:MultiSolidPropertyType' */
#ifndef SOAP_TYPE_plu_gml__MultiSolidPropertyType
#define SOAP_TYPE_plu_gml__MultiSolidPropertyType (-148)

#endif

/* gml__MultiSolidType has binding name 'gml__MultiSolidType' for type 'gml:MultiSolidType' */
#ifndef SOAP_TYPE_plu_gml__MultiSolidType
#define SOAP_TYPE_plu_gml__MultiSolidType (-147)

#endif

/* gml__MultiSurfacePropertyType has binding name 'gml__MultiSurfacePropertyType' for type 'gml:MultiSurfacePropertyType' */
#ifndef SOAP_TYPE_plu_gml__MultiSurfacePropertyType
#define SOAP_TYPE_plu_gml__MultiSurfacePropertyType (-146)

#endif

/* gml__MultiSurfaceType has binding name 'gml__MultiSurfaceType' for type 'gml:MultiSurfaceType' */
#ifndef SOAP_TYPE_plu_gml__MultiSurfaceType
#define SOAP_TYPE_plu_gml__MultiSurfaceType (-145)

#endif

/* gml__MultiCurvePropertyType has binding name 'gml__MultiCurvePropertyType' for type 'gml:MultiCurvePropertyType' */
#ifndef SOAP_TYPE_plu_gml__MultiCurvePropertyType
#define SOAP_TYPE_plu_gml__MultiCurvePropertyType (-144)

#endif

/* gml__MultiCurveType has binding name 'gml__MultiCurveType' for type 'gml:MultiCurveType' */
#ifndef SOAP_TYPE_plu_gml__MultiCurveType
#define SOAP_TYPE_plu_gml__MultiCurveType (-143)

#endif

/* gml__MultiPointPropertyType has binding name 'gml__MultiPointPropertyType' for type 'gml:MultiPointPropertyType' */
#ifndef SOAP_TYPE_plu_gml__MultiPointPropertyType
#define SOAP_TYPE_plu_gml__MultiPointPropertyType (-142)

#endif

/* gml__MultiPointType has binding name 'gml__MultiPointType' for type 'gml:MultiPointType' */
#ifndef SOAP_TYPE_plu_gml__MultiPointType
#define SOAP_TYPE_plu_gml__MultiPointType (-141)

#endif

/* gml__MultiGeometryPropertyType has binding name 'gml__MultiGeometryPropertyType' for type 'gml:MultiGeometryPropertyType' */
#ifndef SOAP_TYPE_plu_gml__MultiGeometryPropertyType
#define SOAP_TYPE_plu_gml__MultiGeometryPropertyType (-140)

#endif

/* gml__MultiGeometryType has binding name 'gml__MultiGeometryType' for type 'gml:MultiGeometryType' */
#ifndef SOAP_TYPE_plu_gml__MultiGeometryType
#define SOAP_TYPE_plu_gml__MultiGeometryType (-139)

#endif

/* gml__AbstractGeometricAggregateType has binding name 'gml__AbstractGeometricAggregateType' for type 'gml:AbstractGeometricAggregateType' */
#ifndef SOAP_TYPE_plu_gml__AbstractGeometricAggregateType
#define SOAP_TYPE_plu_gml__AbstractGeometricAggregateType (-138)

#endif

/* gml__CompositeSolidType has binding name 'gml__CompositeSolidType' for type 'gml:CompositeSolidType' */
#ifndef SOAP_TYPE_plu_gml__CompositeSolidType
#define SOAP_TYPE_plu_gml__CompositeSolidType (-137)

#endif

/* gml__CompositeSurfaceType has binding name 'gml__CompositeSurfaceType' for type 'gml:CompositeSurfaceType' */
#ifndef SOAP_TYPE_plu_gml__CompositeSurfaceType
#define SOAP_TYPE_plu_gml__CompositeSurfaceType (-136)

#endif

/* gml__CompositeCurveType has binding name 'gml__CompositeCurveType' for type 'gml:CompositeCurveType' */
#ifndef SOAP_TYPE_plu_gml__CompositeCurveType
#define SOAP_TYPE_plu_gml__CompositeCurveType (-135)

#endif

/* gml__GeometricComplexPropertyType has binding name 'gml__GeometricComplexPropertyType' for type 'gml:GeometricComplexPropertyType' */
#ifndef SOAP_TYPE_plu_gml__GeometricComplexPropertyType
#define SOAP_TYPE_plu_gml__GeometricComplexPropertyType (-134)

#endif

/* gml__GeometricComplexType has binding name 'gml__GeometricComplexType' for type 'gml:GeometricComplexType' */
#ifndef SOAP_TYPE_plu_gml__GeometricComplexType
#define SOAP_TYPE_plu_gml__GeometricComplexType (-133)

#endif

/* gml__TopoComplexPropertyType has binding name 'gml__TopoComplexPropertyType' for type 'gml:TopoComplexPropertyType' */
#ifndef SOAP_TYPE_plu_gml__TopoComplexPropertyType
#define SOAP_TYPE_plu_gml__TopoComplexPropertyType (-132)

#endif

/* gml__TopoPrimitiveArrayAssociationType has binding name 'gml__TopoPrimitiveArrayAssociationType' for type 'gml:TopoPrimitiveArrayAssociationType' */
#ifndef SOAP_TYPE_plu_gml__TopoPrimitiveArrayAssociationType
#define SOAP_TYPE_plu_gml__TopoPrimitiveArrayAssociationType (-131)

#endif

/* gml__TopoPrimitiveMemberType has binding name 'gml__TopoPrimitiveMemberType' for type 'gml:TopoPrimitiveMemberType' */
#ifndef SOAP_TYPE_plu_gml__TopoPrimitiveMemberType
#define SOAP_TYPE_plu_gml__TopoPrimitiveMemberType (-130)

#endif

/* gml__TopoComplexType has binding name 'gml__TopoComplexType' for type 'gml:TopoComplexType' */
#ifndef SOAP_TYPE_plu_gml__TopoComplexType
#define SOAP_TYPE_plu_gml__TopoComplexType (-129)

#endif

/* gml__TopoVolumePropertyType has binding name 'gml__TopoVolumePropertyType' for type 'gml:TopoVolumePropertyType' */
#ifndef SOAP_TYPE_plu_gml__TopoVolumePropertyType
#define SOAP_TYPE_plu_gml__TopoVolumePropertyType (-128)

#endif

/* gml__TopoVolumeType has binding name 'gml__TopoVolumeType' for type 'gml:TopoVolumeType' */
#ifndef SOAP_TYPE_plu_gml__TopoVolumeType
#define SOAP_TYPE_plu_gml__TopoVolumeType (-127)

#endif

/* gml__TopoSurfacePropertyType has binding name 'gml__TopoSurfacePropertyType' for type 'gml:TopoSurfacePropertyType' */
#ifndef SOAP_TYPE_plu_gml__TopoSurfacePropertyType
#define SOAP_TYPE_plu_gml__TopoSurfacePropertyType (-126)

#endif

/* gml__TopoSurfaceType has binding name 'gml__TopoSurfaceType' for type 'gml:TopoSurfaceType' */
#ifndef SOAP_TYPE_plu_gml__TopoSurfaceType
#define SOAP_TYPE_plu_gml__TopoSurfaceType (-125)

#endif

/* gml__TopoCurvePropertyType has binding name 'gml__TopoCurvePropertyType' for type 'gml:TopoCurvePropertyType' */
#ifndef SOAP_TYPE_plu_gml__TopoCurvePropertyType
#define SOAP_TYPE_plu_gml__TopoCurvePropertyType (-124)

#endif

/* gml__TopoCurveType has binding name 'gml__TopoCurveType' for type 'gml:TopoCurveType' */
#ifndef SOAP_TYPE_plu_gml__TopoCurveType
#define SOAP_TYPE_plu_gml__TopoCurveType (-123)

#endif

/* gml__TopoPointPropertyType has binding name 'gml__TopoPointPropertyType' for type 'gml:TopoPointPropertyType' */
#ifndef SOAP_TYPE_plu_gml__TopoPointPropertyType
#define SOAP_TYPE_plu_gml__TopoPointPropertyType (-122)

#endif

/* gml__TopoPointType has binding name 'gml__TopoPointType' for type 'gml:TopoPointType' */
#ifndef SOAP_TYPE_plu_gml__TopoPointType
#define SOAP_TYPE_plu_gml__TopoPointType (-121)

#endif

/* gml__DirectedTopoSolidPropertyType has binding name 'gml__DirectedTopoSolidPropertyType' for type 'gml:DirectedTopoSolidPropertyType' */
#ifndef SOAP_TYPE_plu_gml__DirectedTopoSolidPropertyType
#define SOAP_TYPE_plu_gml__DirectedTopoSolidPropertyType (-120)

#endif

/* gml__TopoSolidType has binding name 'gml__TopoSolidType' for type 'gml:TopoSolidType' */
#ifndef SOAP_TYPE_plu_gml__TopoSolidType
#define SOAP_TYPE_plu_gml__TopoSolidType (-119)

#endif

/* gml__DirectedFacePropertyType has binding name 'gml__DirectedFacePropertyType' for type 'gml:DirectedFacePropertyType' */
#ifndef SOAP_TYPE_plu_gml__DirectedFacePropertyType
#define SOAP_TYPE_plu_gml__DirectedFacePropertyType (-118)

#endif

/* gml__FaceType has binding name 'gml__FaceType' for type 'gml:FaceType' */
#ifndef SOAP_TYPE_plu_gml__FaceType
#define SOAP_TYPE_plu_gml__FaceType (-117)

#endif

/* gml__DirectedEdgePropertyType has binding name 'gml__DirectedEdgePropertyType' for type 'gml:DirectedEdgePropertyType' */
#ifndef SOAP_TYPE_plu_gml__DirectedEdgePropertyType
#define SOAP_TYPE_plu_gml__DirectedEdgePropertyType (-116)

#endif

/* gml__EdgeType has binding name 'gml__EdgeType' for type 'gml:EdgeType' */
#ifndef SOAP_TYPE_plu_gml__EdgeType
#define SOAP_TYPE_plu_gml__EdgeType (-115)

#endif

/* gml__DirectedNodePropertyType has binding name 'gml__DirectedNodePropertyType' for type 'gml:DirectedNodePropertyType' */
#ifndef SOAP_TYPE_plu_gml__DirectedNodePropertyType
#define SOAP_TYPE_plu_gml__DirectedNodePropertyType (-114)

#endif

/* gml__NodeType has binding name 'gml__NodeType' for type 'gml:NodeType' */
#ifndef SOAP_TYPE_plu_gml__NodeType
#define SOAP_TYPE_plu_gml__NodeType (-113)

#endif

/* gml__TopoSolidPropertyType has binding name 'gml__TopoSolidPropertyType' for type 'gml:TopoSolidPropertyType' */
#ifndef SOAP_TYPE_plu_gml__TopoSolidPropertyType
#define SOAP_TYPE_plu_gml__TopoSolidPropertyType (-112)

#endif

/* gml__FaceOrTopoSolidPropertyType has binding name 'gml__FaceOrTopoSolidPropertyType' for type 'gml:FaceOrTopoSolidPropertyType' */
#ifndef SOAP_TYPE_plu_gml__FaceOrTopoSolidPropertyType
#define SOAP_TYPE_plu_gml__FaceOrTopoSolidPropertyType (-111)

#endif

/* gml__NodePropertyType has binding name 'gml__NodePropertyType' for type 'gml:NodePropertyType' */
#ifndef SOAP_TYPE_plu_gml__NodePropertyType
#define SOAP_TYPE_plu_gml__NodePropertyType (-110)

#endif

/* gml__NodeOrEdgePropertyType has binding name 'gml__NodeOrEdgePropertyType' for type 'gml:NodeOrEdgePropertyType' */
#ifndef SOAP_TYPE_plu_gml__NodeOrEdgePropertyType
#define SOAP_TYPE_plu_gml__NodeOrEdgePropertyType (-109)

#endif

/* gml__AbstractTopoPrimitiveType has binding name 'gml__AbstractTopoPrimitiveType' for type 'gml:AbstractTopoPrimitiveType' */
#ifndef SOAP_TYPE_plu_gml__AbstractTopoPrimitiveType
#define SOAP_TYPE_plu_gml__AbstractTopoPrimitiveType (-108)

#endif

/* gml__AbstractTopologyType has binding name 'gml__AbstractTopologyType' for type 'gml:AbstractTopologyType' */
#ifndef SOAP_TYPE_plu_gml__AbstractTopologyType
#define SOAP_TYPE_plu_gml__AbstractTopologyType (-107)

#endif

/* gml__HistoryPropertyType has binding name 'gml__HistoryPropertyType' for type 'gml:HistoryPropertyType' */
#ifndef SOAP_TYPE_plu_gml__HistoryPropertyType
#define SOAP_TYPE_plu_gml__HistoryPropertyType (-106)

#endif

/* gml__AbstractTimeSliceType has binding name 'gml__AbstractTimeSliceType' for type 'gml:AbstractTimeSliceType' */
#ifndef SOAP_TYPE_plu_gml__AbstractTimeSliceType
#define SOAP_TYPE_plu_gml__AbstractTimeSliceType (-105)

#endif

/* gml__DynamicFeatureMemberType has binding name 'gml__DynamicFeatureMemberType' for type 'gml:DynamicFeatureMemberType' */
#ifndef SOAP_TYPE_plu_gml__DynamicFeatureMemberType
#define SOAP_TYPE_plu_gml__DynamicFeatureMemberType (-104)

#endif

/* gml__DynamicFeatureCollectionType has binding name 'gml__DynamicFeatureCollectionType' for type 'gml:DynamicFeatureCollectionType' */
#ifndef SOAP_TYPE_plu_gml__DynamicFeatureCollectionType
#define SOAP_TYPE_plu_gml__DynamicFeatureCollectionType (-103)

#endif

/* gml__DynamicFeatureType has binding name 'gml__DynamicFeatureType' for type 'gml:DynamicFeatureType' */
#ifndef SOAP_TYPE_plu_gml__DynamicFeatureType
#define SOAP_TYPE_plu_gml__DynamicFeatureType (-102)

#endif

/* _sc__taggedValue has binding name '_sc__taggedValue' for type '' */
#ifndef SOAP_TYPE_plu__sc__taggedValue
#define SOAP_TYPE_plu__sc__taggedValue (-101)

#endif

/* lunom__HILUCSPercentagePropertyType has binding name 'lunom__HILUCSPercentagePropertyType' for type 'lunom:HILUCSPercentagePropertyType' */
#ifndef SOAP_TYPE_plu_lunom__HILUCSPercentagePropertyType
#define SOAP_TYPE_plu_lunom__HILUCSPercentagePropertyType (-100)

#endif

/* lunom__HILUCSPercentageType has binding name 'lunom__HILUCSPercentageType' for type 'lunom:HILUCSPercentageType' */
#ifndef SOAP_TYPE_plu_lunom__HILUCSPercentageType
#define SOAP_TYPE_plu_lunom__HILUCSPercentageType (-99)

#endif

/* lunom__SpecificPresencePropertyType has binding name 'lunom__SpecificPresencePropertyType' for type 'lunom:SpecificPresencePropertyType' */
#ifndef SOAP_TYPE_plu_lunom__SpecificPresencePropertyType
#define SOAP_TYPE_plu_lunom__SpecificPresencePropertyType (-98)

#endif

/* lunom__SpecificPresenceType has binding name 'lunom__SpecificPresenceType' for type 'lunom:SpecificPresenceType' */
#ifndef SOAP_TYPE_plu_lunom__SpecificPresenceType
#define SOAP_TYPE_plu_lunom__SpecificPresenceType (-97)

#endif

/* lunom__SpecificPercentagePropertyType has binding name 'lunom__SpecificPercentagePropertyType' for type 'lunom:SpecificPercentagePropertyType' */
#ifndef SOAP_TYPE_plu_lunom__SpecificPercentagePropertyType
#define SOAP_TYPE_plu_lunom__SpecificPercentagePropertyType (-96)

#endif

/* lunom__SpecificPercentageType has binding name 'lunom__SpecificPercentageType' for type 'lunom:SpecificPercentageType' */
#ifndef SOAP_TYPE_plu_lunom__SpecificPercentageType
#define SOAP_TYPE_plu_lunom__SpecificPercentageType (-95)

#endif

/* lunom__HILUCSPresencePropertyType has binding name 'lunom__HILUCSPresencePropertyType' for type 'lunom:HILUCSPresencePropertyType' */
#ifndef SOAP_TYPE_plu_lunom__HILUCSPresencePropertyType
#define SOAP_TYPE_plu_lunom__HILUCSPresencePropertyType (-94)

#endif

/* lunom__HILUCSPresenceType has binding name 'lunom__HILUCSPresenceType' for type 'lunom:HILUCSPresenceType' */
#ifndef SOAP_TYPE_plu_lunom__HILUCSPresenceType
#define SOAP_TYPE_plu_lunom__HILUCSPresenceType (-93)

#endif

/* base2__ThematicIdentifierPropertyType has binding name 'base2__ThematicIdentifierPropertyType' for type 'base2:ThematicIdentifierPropertyType' */
#ifndef SOAP_TYPE_plu_base2__ThematicIdentifierPropertyType
#define SOAP_TYPE_plu_base2__ThematicIdentifierPropertyType (-92)

#endif

/* base2__ThematicIdentifierType has binding name 'base2__ThematicIdentifierType' for type 'base2:ThematicIdentifierType' */
#ifndef SOAP_TYPE_plu_base2__ThematicIdentifierType
#define SOAP_TYPE_plu_base2__ThematicIdentifierType (-91)

#endif

/* base2__DocumentCitationPropertyType has binding name 'base2__DocumentCitationPropertyType' for type 'base2:DocumentCitationPropertyType' */
#ifndef SOAP_TYPE_plu_base2__DocumentCitationPropertyType
#define SOAP_TYPE_plu_base2__DocumentCitationPropertyType (-90)

#endif

/* base2__DocumentCitationType has binding name 'base2__DocumentCitationType' for type 'base2:DocumentCitationType' */
#ifndef SOAP_TYPE_plu_base2__DocumentCitationType
#define SOAP_TYPE_plu_base2__DocumentCitationType (-89)

#endif

/* base2__RelatedPartyPropertyType has binding name 'base2__RelatedPartyPropertyType' for type 'base2:RelatedPartyPropertyType' */
#ifndef SOAP_TYPE_plu_base2__RelatedPartyPropertyType
#define SOAP_TYPE_plu_base2__RelatedPartyPropertyType (-88)

#endif

/* base2__RelatedPartyType has binding name 'base2__RelatedPartyType' for type 'base2:RelatedPartyType' */
#ifndef SOAP_TYPE_plu_base2__RelatedPartyType
#define SOAP_TYPE_plu_base2__RelatedPartyType (-87)

#endif

/* base2__ContactPropertyType has binding name 'base2__ContactPropertyType' for type 'base2:ContactPropertyType' */
#ifndef SOAP_TYPE_plu_base2__ContactPropertyType
#define SOAP_TYPE_plu_base2__ContactPropertyType (-86)

#endif

/* base2__ContactType has binding name 'base2__ContactType' for type 'base2:ContactType' */
#ifndef SOAP_TYPE_plu_base2__ContactType
#define SOAP_TYPE_plu_base2__ContactType (-85)

#endif

/* base2__LegislationCitationPropertyType has binding name 'base2__LegislationCitationPropertyType' for type 'base2:LegislationCitationPropertyType' */
#ifndef SOAP_TYPE_plu_base2__LegislationCitationPropertyType
#define SOAP_TYPE_plu_base2__LegislationCitationPropertyType (-84)

#endif

/* base2__LegislationCitationType has binding name 'base2__LegislationCitationType' for type 'base2:LegislationCitationType' */
#ifndef SOAP_TYPE_plu_base2__LegislationCitationType
#define SOAP_TYPE_plu_base2__LegislationCitationType (-83)

#endif

/* base2__OfficialJournalInformationPropertyType has binding name 'base2__OfficialJournalInformationPropertyType' for type 'base2:OfficialJournalInformationPropertyType' */
#ifndef SOAP_TYPE_plu_base2__OfficialJournalInformationPropertyType
#define SOAP_TYPE_plu_base2__OfficialJournalInformationPropertyType (-82)

#endif

/* base2__OfficialJournalInformationType has binding name 'base2__OfficialJournalInformationType' for type 'base2:OfficialJournalInformationType' */
#ifndef SOAP_TYPE_plu_base2__OfficialJournalInformationType
#define SOAP_TYPE_plu_base2__OfficialJournalInformationType (-81)

#endif

/* base__IdentifierPropertyType has binding name 'base__IdentifierPropertyType' for type 'base:IdentifierPropertyType' */
#ifndef SOAP_TYPE_plu_base__IdentifierPropertyType
#define SOAP_TYPE_plu_base__IdentifierPropertyType (-80)

#endif

/* base__IdentifierType has binding name 'base__IdentifierType' for type 'base:IdentifierType' */
#ifndef SOAP_TYPE_plu_base__IdentifierType
#define SOAP_TYPE_plu_base__IdentifierType (-79)

#endif

/* base__SpatialDataSetPropertyType has binding name 'base__SpatialDataSetPropertyType' for type 'base:SpatialDataSetPropertyType' */
#ifndef SOAP_TYPE_plu_base__SpatialDataSetPropertyType
#define SOAP_TYPE_plu_base__SpatialDataSetPropertyType (-78)

#endif

/* base__SpatialDataSetType has binding name 'base__SpatialDataSetType' for type 'base:SpatialDataSetType' */
#ifndef SOAP_TYPE_plu_base__SpatialDataSetType
#define SOAP_TYPE_plu_base__SpatialDataSetType (-77)

#endif

/* plu__BackgroundMapValuePropertyType has binding name 'plu__BackgroundMapValuePropertyType' for type 'plu:BackgroundMapValuePropertyType' */
#ifndef SOAP_TYPE_plu_plu__BackgroundMapValuePropertyType
#define SOAP_TYPE_plu_plu__BackgroundMapValuePropertyType (-76)

#endif

/* plu__BackgroundMapValueType has binding name 'plu__BackgroundMapValueType' for type 'plu:BackgroundMapValueType' */
#ifndef SOAP_TYPE_plu_plu__BackgroundMapValueType
#define SOAP_TYPE_plu_plu__BackgroundMapValueType (-75)

#endif

/* plu__OrdinanceValuePropertyType has binding name 'plu__OrdinanceValuePropertyType' for type 'plu:OrdinanceValuePropertyType' */
#ifndef SOAP_TYPE_plu_plu__OrdinanceValuePropertyType
#define SOAP_TYPE_plu_plu__OrdinanceValuePropertyType (-74)

#endif

/* plu__OrdinanceValueType has binding name 'plu__OrdinanceValueType' for type 'plu:OrdinanceValueType' */
#ifndef SOAP_TYPE_plu_plu__OrdinanceValueType
#define SOAP_TYPE_plu_plu__OrdinanceValueType (-73)

#endif

/* plu__DimensioningIndicationRealValuePropertyType has binding name 'plu__DimensioningIndicationRealValuePropertyType' for type 'plu:DimensioningIndicationRealValuePropertyType' */
#ifndef SOAP_TYPE_plu_plu__DimensioningIndicationRealValuePropertyType
#define SOAP_TYPE_plu_plu__DimensioningIndicationRealValuePropertyType (-72)

#endif

/* plu__DimensioningIndicationRealValueType has binding name 'plu__DimensioningIndicationRealValueType' for type 'plu:DimensioningIndicationRealValueType' */
#ifndef SOAP_TYPE_plu_plu__DimensioningIndicationRealValueType
#define SOAP_TYPE_plu_plu__DimensioningIndicationRealValueType (-71)

#endif

/* plu__SpatialPlanPropertyType has binding name 'plu__SpatialPlanPropertyType' for type 'plu:SpatialPlanPropertyType' */
#ifndef SOAP_TYPE_plu_plu__SpatialPlanPropertyType
#define SOAP_TYPE_plu_plu__SpatialPlanPropertyType (-70)

#endif

/* plu__SpatialPlanType has binding name 'plu__SpatialPlanType' for type 'plu:SpatialPlanType' */
#ifndef SOAP_TYPE_plu_plu__SpatialPlanType
#define SOAP_TYPE_plu_plu__SpatialPlanType (-69)

#endif

/* plu__DimensioningIndicationValuePropertyType has binding name 'plu__DimensioningIndicationValuePropertyType' for type 'plu:DimensioningIndicationValuePropertyType' */
#ifndef SOAP_TYPE_plu_plu__DimensioningIndicationValuePropertyType
#define SOAP_TYPE_plu_plu__DimensioningIndicationValuePropertyType (-68)

#endif

/* plu__DimensioningIndicationValueType has binding name 'plu__DimensioningIndicationValueType' for type 'plu:DimensioningIndicationValueType' */
#ifndef SOAP_TYPE_plu_plu__DimensioningIndicationValueType
#define SOAP_TYPE_plu_plu__DimensioningIndicationValueType (-67)

#endif

/* plu__SupplementaryRegulationPropertyType has binding name 'plu__SupplementaryRegulationPropertyType' for type 'plu:SupplementaryRegulationPropertyType' */
#ifndef SOAP_TYPE_plu_plu__SupplementaryRegulationPropertyType
#define SOAP_TYPE_plu_plu__SupplementaryRegulationPropertyType (-66)

#endif

/* plu__SupplementaryRegulationType has binding name 'plu__SupplementaryRegulationType' for type 'plu:SupplementaryRegulationType' */
#ifndef SOAP_TYPE_plu_plu__SupplementaryRegulationType
#define SOAP_TYPE_plu_plu__SupplementaryRegulationType (-65)

#endif

/* plu__DimensioningIndicationCharacterValuePropertyType has binding name 'plu__DimensioningIndicationCharacterValuePropertyType' for type 'plu:DimensioningIndicationCharacterValuePropertyType' */
#ifndef SOAP_TYPE_plu_plu__DimensioningIndicationCharacterValuePropertyType
#define SOAP_TYPE_plu_plu__DimensioningIndicationCharacterValuePropertyType (-64)

#endif

/* plu__DimensioningIndicationCharacterValueType has binding name 'plu__DimensioningIndicationCharacterValueType' for type 'plu:DimensioningIndicationCharacterValueType' */
#ifndef SOAP_TYPE_plu_plu__DimensioningIndicationCharacterValueType
#define SOAP_TYPE_plu_plu__DimensioningIndicationCharacterValueType (-63)

#endif

/* plu__DimensioningIndicationIntegerValuePropertyType has binding name 'plu__DimensioningIndicationIntegerValuePropertyType' for type 'plu:DimensioningIndicationIntegerValuePropertyType' */
#ifndef SOAP_TYPE_plu_plu__DimensioningIndicationIntegerValuePropertyType
#define SOAP_TYPE_plu_plu__DimensioningIndicationIntegerValuePropertyType (-62)

#endif

/* plu__DimensioningIndicationIntegerValueType has binding name 'plu__DimensioningIndicationIntegerValueType' for type 'plu:DimensioningIndicationIntegerValueType' */
#ifndef SOAP_TYPE_plu_plu__DimensioningIndicationIntegerValueType
#define SOAP_TYPE_plu_plu__DimensioningIndicationIntegerValueType (-61)

#endif

/* plu__DimensioningIndicationMeasureValuePropertyType has binding name 'plu__DimensioningIndicationMeasureValuePropertyType' for type 'plu:DimensioningIndicationMeasureValuePropertyType' */
#ifndef SOAP_TYPE_plu_plu__DimensioningIndicationMeasureValuePropertyType
#define SOAP_TYPE_plu_plu__DimensioningIndicationMeasureValuePropertyType (-60)

#endif

/* plu__DimensioningIndicationMeasureValueType has binding name 'plu__DimensioningIndicationMeasureValueType' for type 'plu:DimensioningIndicationMeasureValueType' */
#ifndef SOAP_TYPE_plu_plu__DimensioningIndicationMeasureValueType
#define SOAP_TYPE_plu_plu__DimensioningIndicationMeasureValueType (-59)

#endif

/* plu__OfficialDocumentationPropertyType has binding name 'plu__OfficialDocumentationPropertyType' for type 'plu:OfficialDocumentationPropertyType' */
#ifndef SOAP_TYPE_plu_plu__OfficialDocumentationPropertyType
#define SOAP_TYPE_plu_plu__OfficialDocumentationPropertyType (-58)

#endif

/* plu__OfficialDocumentationType has binding name 'plu__OfficialDocumentationType' for type 'plu:OfficialDocumentationType' */
#ifndef SOAP_TYPE_plu_plu__OfficialDocumentationType
#define SOAP_TYPE_plu_plu__OfficialDocumentationType (-57)

#endif

/* plu__ZoningElementPropertyType has binding name 'plu__ZoningElementPropertyType' for type 'plu:ZoningElementPropertyType' */
#ifndef SOAP_TYPE_plu_plu__ZoningElementPropertyType
#define SOAP_TYPE_plu_plu__ZoningElementPropertyType (-56)

#endif

/* plu__ZoningElementType has binding name 'plu__ZoningElementType' for type 'plu:ZoningElementType' */
#ifndef SOAP_TYPE_plu_plu__ZoningElementType
#define SOAP_TYPE_plu_plu__ZoningElementType (-55)

#endif

/* xsd__hexBinary has binding name 'xsd__hexBinary' for type 'xsd:hexBinary' */
#ifndef SOAP_TYPE_plu_xsd__hexBinary
#define SOAP_TYPE_plu_xsd__hexBinary (-20)

#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_plu_xsd__base64Binary
#define SOAP_TYPE_plu_xsd__base64Binary (-16)

#endif

/* xsd__anyType has binding name 'xsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_plu_xsd__anyType
#define SOAP_TYPE_plu_xsd__anyType (-13)

#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_plu_SOAP_ENV__Fault
#define SOAP_TYPE_plu_SOAP_ENV__Fault (-775393287)

#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_plu_SOAP_ENV__Reason
#define SOAP_TYPE_plu_SOAP_ENV__Reason (-775393286)

#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_plu_SOAP_ENV__Detail
#define SOAP_TYPE_plu_SOAP_ENV__Detail (-775393283)

#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_plu_SOAP_ENV__Code
#define SOAP_TYPE_plu_SOAP_ENV__Code (-775393281)

#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_plu_SOAP_ENV__Header
#define SOAP_TYPE_plu_SOAP_ENV__Header (-775393280)

#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_plu_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_plu_PointerToSOAP_ENV__Reason (-775393289)

#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_plu_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_plu_PointerToSOAP_ENV__Detail (-775393288)

#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_plu_PointerToSOAP_ENV__Code
#define SOAP_TYPE_plu_PointerToSOAP_ENV__Code (-775393282)

#endif

/* __gml__union_TransformationType_ * has binding name 'PointerTo__gml__union_TransformationType_' for type '-gml:union-TransformationType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_TransformationType_
#define SOAP_TYPE_plu_PointerTo__gml__union_TransformationType_ (-2370)

#endif

/* __gml__union_ConversionType_ * has binding name 'PointerTo__gml__union_ConversionType_' for type '-gml:union-ConversionType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_ConversionType_
#define SOAP_TYPE_plu_PointerTo__gml__union_ConversionType_ (-2366)

#endif

/* gml__OperationMethodPropertyType * has binding name 'PointerTogml__OperationMethodPropertyType' for type 'gml:OperationMethodPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__OperationMethodPropertyType
#define SOAP_TYPE_plu_PointerTogml__OperationMethodPropertyType (-2363)

#endif

/* gml__GeographicCRSPropertyType * has binding name 'PointerTogml__GeographicCRSPropertyType' for type 'gml:GeographicCRSPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__GeographicCRSPropertyType
#define SOAP_TYPE_plu_PointerTogml__GeographicCRSPropertyType (-2359)

#endif

/* gml__GeodeticCRSPropertyType * has binding name 'PointerTogml__GeodeticCRSPropertyType' for type 'gml:GeodeticCRSPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__GeodeticCRSPropertyType
#define SOAP_TYPE_plu_PointerTogml__GeodeticCRSPropertyType (-2358)

#endif

/* __gml__union_OperationParameterGroupType * has binding name 'PointerTo__gml__union_OperationParameterGroupType' for type '-gml:union-OperationParameterGroupType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_OperationParameterGroupType
#define SOAP_TYPE_plu_PointerTo__gml__union_OperationParameterGroupType (-2355)

#endif

/* __gml__union_ConcatenatedOperationType * has binding name 'PointerTo__gml__union_ConcatenatedOperationType' for type '-gml:union-ConcatenatedOperationType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_ConcatenatedOperationType
#define SOAP_TYPE_plu_PointerTo__gml__union_ConcatenatedOperationType (-2350)

#endif

/* std::vector<gml__CoordinateOperationPropertyType *> * has binding name 'PointerTostd__vectorTemplateOfPointerTogml__CoordinateOperationPropertyType' for type 'gml:CoordinateOperationPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTogml__CoordinateOperationPropertyType
#define SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTogml__CoordinateOperationPropertyType (-2349)

#endif

/* gml__CoordinateOperationPropertyType * has binding name 'PointerTogml__CoordinateOperationPropertyType' for type 'gml:CoordinateOperationPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CoordinateOperationPropertyType
#define SOAP_TYPE_plu_PointerTogml__CoordinateOperationPropertyType (-2347)

#endif

/* gml__EllipsoidPropertyType * has binding name 'PointerTogml__EllipsoidPropertyType' for type 'gml:EllipsoidPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__EllipsoidPropertyType
#define SOAP_TYPE_plu_PointerTogml__EllipsoidPropertyType (-2344)

#endif

/* gml__PrimeMeridianPropertyType * has binding name 'PointerTogml__PrimeMeridianPropertyType' for type 'gml:PrimeMeridianPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__PrimeMeridianPropertyType
#define SOAP_TYPE_plu_PointerTogml__PrimeMeridianPropertyType (-2342)

#endif

/* gml__TemporalDatumPropertyType * has binding name 'PointerTogml__TemporalDatumPropertyType' for type 'gml:TemporalDatumPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TemporalDatumPropertyType
#define SOAP_TYPE_plu_PointerTogml__TemporalDatumPropertyType (-2340)

#endif

/* gml__TemporalCSPropertyType * has binding name 'PointerTogml__TemporalCSPropertyType' for type 'gml:TemporalCSPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TemporalCSPropertyType
#define SOAP_TYPE_plu_PointerTogml__TemporalCSPropertyType (-2338)

#endif

/* gml__TimeCSPropertyType * has binding name 'PointerTogml__TimeCSPropertyType' for type 'gml:TimeCSPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeCSPropertyType
#define SOAP_TYPE_plu_PointerTogml__TimeCSPropertyType (-2337)

#endif

/* gml__ImageDatumPropertyType * has binding name 'PointerTogml__ImageDatumPropertyType' for type 'gml:ImageDatumPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ImageDatumPropertyType
#define SOAP_TYPE_plu_PointerTogml__ImageDatumPropertyType (-2335)

#endif

/* gml__ObliqueCartesianCSPropertyType * has binding name 'PointerTogml__ObliqueCartesianCSPropertyType' for type 'gml:ObliqueCartesianCSPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ObliqueCartesianCSPropertyType
#define SOAP_TYPE_plu_PointerTogml__ObliqueCartesianCSPropertyType (-2333)

#endif

/* gml__EngineeringDatumPropertyType * has binding name 'PointerTogml__EngineeringDatumPropertyType' for type 'gml:EngineeringDatumPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__EngineeringDatumPropertyType
#define SOAP_TYPE_plu_PointerTogml__EngineeringDatumPropertyType (-2331)

#endif

/* gml__CoordinateSystemPropertyType * has binding name 'PointerTogml__CoordinateSystemPropertyType' for type 'gml:CoordinateSystemPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CoordinateSystemPropertyType
#define SOAP_TYPE_plu_PointerTogml__CoordinateSystemPropertyType (-2329)

#endif

/* gml__UserDefinedCSPropertyType * has binding name 'PointerTogml__UserDefinedCSPropertyType' for type 'gml:UserDefinedCSPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__UserDefinedCSPropertyType
#define SOAP_TYPE_plu_PointerTogml__UserDefinedCSPropertyType (-2328)

#endif

/* gml__PolarCSPropertyType * has binding name 'PointerTogml__PolarCSPropertyType' for type 'gml:PolarCSPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__PolarCSPropertyType
#define SOAP_TYPE_plu_PointerTogml__PolarCSPropertyType (-2327)

#endif

/* gml__LinearCSPropertyType * has binding name 'PointerTogml__LinearCSPropertyType' for type 'gml:LinearCSPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__LinearCSPropertyType
#define SOAP_TYPE_plu_PointerTogml__LinearCSPropertyType (-2326)

#endif

/* gml__CylindricalCSPropertyType * has binding name 'PointerTogml__CylindricalCSPropertyType' for type 'gml:CylindricalCSPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CylindricalCSPropertyType
#define SOAP_TYPE_plu_PointerTogml__CylindricalCSPropertyType (-2325)

#endif

/* gml__AffineCSPropertyType * has binding name 'PointerTogml__AffineCSPropertyType' for type 'gml:AffineCSPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__AffineCSPropertyType
#define SOAP_TYPE_plu_PointerTogml__AffineCSPropertyType (-2324)

#endif

/* gml__VerticalDatumPropertyType * has binding name 'PointerTogml__VerticalDatumPropertyType' for type 'gml:VerticalDatumPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__VerticalDatumPropertyType
#define SOAP_TYPE_plu_PointerTogml__VerticalDatumPropertyType (-2322)

#endif

/* gml__VerticalCSPropertyType * has binding name 'PointerTogml__VerticalCSPropertyType' for type 'gml:VerticalCSPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__VerticalCSPropertyType
#define SOAP_TYPE_plu_PointerTogml__VerticalCSPropertyType (-2320)

#endif

/* gml__GeodeticDatumPropertyType * has binding name 'PointerTogml__GeodeticDatumPropertyType' for type 'gml:GeodeticDatumPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__GeodeticDatumPropertyType
#define SOAP_TYPE_plu_PointerTogml__GeodeticDatumPropertyType (-2318)

#endif

/* gml__SphericalCSPropertyType * has binding name 'PointerTogml__SphericalCSPropertyType' for type 'gml:SphericalCSPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__SphericalCSPropertyType
#define SOAP_TYPE_plu_PointerTogml__SphericalCSPropertyType (-2316)

#endif

/* gml__CartesianCSPropertyType * has binding name 'PointerTogml__CartesianCSPropertyType' for type 'gml:CartesianCSPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CartesianCSPropertyType
#define SOAP_TYPE_plu_PointerTogml__CartesianCSPropertyType (-2315)

#endif

/* gml__EllipsoidalCSPropertyType * has binding name 'PointerTogml__EllipsoidalCSPropertyType' for type 'gml:EllipsoidalCSPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__EllipsoidalCSPropertyType
#define SOAP_TYPE_plu_PointerTogml__EllipsoidalCSPropertyType (-2314)

#endif

/* __gml__union_CompoundCRSType * has binding name 'PointerTo__gml__union_CompoundCRSType' for type '-gml:union-CompoundCRSType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_CompoundCRSType
#define SOAP_TYPE_plu_PointerTo__gml__union_CompoundCRSType (-2312)

#endif

/* std::vector<gml__SingleCRSPropertyType *> * has binding name 'PointerTostd__vectorTemplateOfPointerTogml__SingleCRSPropertyType' for type 'gml:SingleCRSPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTogml__SingleCRSPropertyType
#define SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTogml__SingleCRSPropertyType (-2311)

#endif

/* gml__SingleCRSPropertyType * has binding name 'PointerTogml__SingleCRSPropertyType' for type 'gml:SingleCRSPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__SingleCRSPropertyType
#define SOAP_TYPE_plu_PointerTogml__SingleCRSPropertyType (-2309)

#endif

/* gml__GeneralConversionPropertyType * has binding name 'PointerTogml__GeneralConversionPropertyType' for type 'gml:GeneralConversionPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__GeneralConversionPropertyType
#define SOAP_TYPE_plu_PointerTogml__GeneralConversionPropertyType (-2306)

#endif

/* __gml__union_LinearRingType_ * has binding name 'PointerTo__gml__union_LinearRingType_' for type '-gml:union-LinearRingType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_LinearRingType_
#define SOAP_TYPE_plu_PointerTo__gml__union_LinearRingType_ (-2304)

#endif

/* __gml__union_TinType_controlPoint_ * has binding name 'PointerTo__gml__union_TinType_controlPoint_' for type '-gml:union-TinType-controlPoint' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_TinType_controlPoint_
#define SOAP_TYPE_plu_PointerTo__gml__union_TinType_controlPoint_ (-2299)

#endif

/* gml__LineStringSegmentArrayPropertyType * has binding name 'PointerTogml__LineStringSegmentArrayPropertyType' for type 'gml:LineStringSegmentArrayPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__LineStringSegmentArrayPropertyType
#define SOAP_TYPE_plu_PointerTogml__LineStringSegmentArrayPropertyType (-2294)

#endif

/* gml__TimeEdgePropertyType * has binding name 'PointerTogml__TimeEdgePropertyType' for type 'gml:TimeEdgePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeEdgePropertyType
#define SOAP_TYPE_plu_PointerTogml__TimeEdgePropertyType (-2292)

#endif

/* gml__TimeCalendarPropertyType * has binding name 'PointerTogml__TimeCalendarPropertyType' for type 'gml:TimeCalendarPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeCalendarPropertyType
#define SOAP_TYPE_plu_PointerTogml__TimeCalendarPropertyType (-2290)

#endif

/* gml__TimeCalendarEraPropertyType * has binding name 'PointerTogml__TimeCalendarEraPropertyType' for type 'gml:TimeCalendarEraPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeCalendarEraPropertyType
#define SOAP_TYPE_plu_PointerTogml__TimeCalendarEraPropertyType (-2288)

#endif

/* ULONG64 * has binding name 'PointerToxsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_plu_PointerToxsd__nonNegativeInteger
#define SOAP_TYPE_plu_PointerToxsd__nonNegativeInteger (-2286)

#endif

/* __gml__union_OperationMethodType__ * has binding name 'PointerTo__gml__union_OperationMethodType__' for type '-gml:union-OperationMethodType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_OperationMethodType__
#define SOAP_TYPE_plu_PointerTo__gml__union_OperationMethodType__ (-2285)

#endif

/* std::vector<gml__AbstractGeneralOperationParameterPropertyType *> * has binding name 'PointerTostd__vectorTemplateOfPointerTogml__AbstractGeneralOperationParameterPropertyType' for type 'gml:AbstractGeneralOperationParameterPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTogml__AbstractGeneralOperationParameterPropertyType
#define SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTogml__AbstractGeneralOperationParameterPropertyType (-2284)

#endif

/* gml__AbstractGeneralOperationParameterPropertyType * has binding name 'PointerTogml__AbstractGeneralOperationParameterPropertyType' for type 'gml:AbstractGeneralOperationParameterPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__AbstractGeneralOperationParameterPropertyType
#define SOAP_TYPE_plu_PointerTogml__AbstractGeneralOperationParameterPropertyType (-2282)

#endif

/* _gml__formulaCitation * has binding name 'PointerTo_gml__formulaCitation' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_gml__formulaCitation
#define SOAP_TYPE_plu_PointerTo_gml__formulaCitation (-2279)

#endif

/* gml__CRSPropertyType * has binding name 'PointerTogml__CRSPropertyType' for type 'gml:CRSPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CRSPropertyType
#define SOAP_TYPE_plu_PointerTogml__CRSPropertyType (-2277)

#endif

/* _gml__coordinateOperationAccuracy * has binding name 'PointerTo_gml__coordinateOperationAccuracy' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_gml__coordinateOperationAccuracy
#define SOAP_TYPE_plu_PointerTo_gml__coordinateOperationAccuracy (-2275)

#endif

/* _gml__secondDefiningParameter * has binding name 'PointerTo_gml__secondDefiningParameter' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_gml__secondDefiningParameter
#define SOAP_TYPE_plu_PointerTo_gml__secondDefiningParameter (-2274)

#endif

/* char ** has binding name 'PointerToxsd__date' for type 'xsd:date' */
#ifndef SOAP_TYPE_plu_PointerToxsd__date
#define SOAP_TYPE_plu_PointerToxsd__date (-2273)

#endif

/* _gml__domainOfValidity * has binding name 'PointerTo_gml__domainOfValidity' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_gml__domainOfValidity
#define SOAP_TYPE_plu_PointerTo_gml__domainOfValidity (-2270)

#endif

/* __gml__union_AbstractCoordinateSystemType * has binding name 'PointerTo__gml__union_AbstractCoordinateSystemType' for type '-gml:union-AbstractCoordinateSystemType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_AbstractCoordinateSystemType
#define SOAP_TYPE_plu_PointerTo__gml__union_AbstractCoordinateSystemType (-2269)

#endif

/* std::vector<gml__CoordinateSystemAxisPropertyType *> * has binding name 'PointerTostd__vectorTemplateOfPointerTogml__CoordinateSystemAxisPropertyType' for type 'gml:CoordinateSystemAxisPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTogml__CoordinateSystemAxisPropertyType
#define SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTogml__CoordinateSystemAxisPropertyType (-2268)

#endif

/* gml__CoordinateSystemAxisPropertyType * has binding name 'PointerTogml__CoordinateSystemAxisPropertyType' for type 'gml:CoordinateSystemAxisPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CoordinateSystemAxisPropertyType
#define SOAP_TYPE_plu_PointerTogml__CoordinateSystemAxisPropertyType (-2266)

#endif

/* gml__TimeIntervalLengthType * has binding name 'PointerTogml__TimeIntervalLengthType' for type 'gml:TimeIntervalLengthType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeIntervalLengthType
#define SOAP_TYPE_plu_PointerTogml__TimeIntervalLengthType (-2263)

#endif

/* char ** has binding name 'PointerToxsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_plu_PointerToxsd__duration
#define SOAP_TYPE_plu_PointerToxsd__duration (-2262)

#endif

/* gml__TimeInstantPropertyType * has binding name 'PointerTogml__TimeInstantPropertyType' for type 'gml:TimeInstantPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeInstantPropertyType
#define SOAP_TYPE_plu_PointerTogml__TimeInstantPropertyType (-2259)

#endif

/* gml__ConversionToPreferredUnitType * has binding name 'PointerTogml__ConversionToPreferredUnitType' for type 'gml:ConversionToPreferredUnitType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ConversionToPreferredUnitType
#define SOAP_TYPE_plu_PointerTogml__ConversionToPreferredUnitType (-2257)

#endif

/* gml__DerivationUnitTermType * has binding name 'PointerTogml__DerivationUnitTermType' for type 'gml:DerivationUnitTermType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DerivationUnitTermType
#define SOAP_TYPE_plu_PointerTogml__DerivationUnitTermType (-2254)

#endif

/* __gml__union_LineStringType_ * has binding name 'PointerTo__gml__union_LineStringType_' for type '-gml:union-LineStringType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_LineStringType_
#define SOAP_TYPE_plu_PointerTo__gml__union_LineStringType_ (-2253)

#endif

/* gml__ShellPropertyType * has binding name 'PointerTogml__ShellPropertyType' for type 'gml:ShellPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ShellPropertyType
#define SOAP_TYPE_plu_PointerTogml__ShellPropertyType (-2247)

#endif

/* gml__SurfacePatchArrayPropertyType * has binding name 'PointerTogml__SurfacePatchArrayPropertyType' for type 'gml:SurfacePatchArrayPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__SurfacePatchArrayPropertyType
#define SOAP_TYPE_plu_PointerTogml__SurfacePatchArrayPropertyType (-2246)

#endif

/* gml__CurveSegmentArrayPropertyType * has binding name 'PointerTogml__CurveSegmentArrayPropertyType' for type 'gml:CurveSegmentArrayPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CurveSegmentArrayPropertyType
#define SOAP_TYPE_plu_PointerTogml__CurveSegmentArrayPropertyType (-2244)

#endif

/* gmd__MD_x005fImagingConditionCode_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fImagingConditionCode_x005fPropertyType' for type 'gmd:MD_ImagingConditionCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fImagingConditionCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fImagingConditionCode_x005fPropertyType (-2243)

#endif

/* gmd__MD_x005fPixelOrientationCode_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fPixelOrientationCode_x005fPropertyType' for type 'gmd:MD_PixelOrientationCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fPixelOrientationCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fPixelOrientationCode_x005fPropertyType (-2242)

#endif

/* gss__GM_x005fPoint_x005fPropertyType * has binding name 'PointerTogss__GM_x005fPoint_x005fPropertyType' for type 'gss:GM_Point_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogss__GM_x005fPoint_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogss__GM_x005fPoint_x005fPropertyType (-2240)

#endif

/* gml__TimeTopologyPrimitivePropertyType * has binding name 'PointerTogml__TimeTopologyPrimitivePropertyType' for type 'gml:TimeTopologyPrimitivePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeTopologyPrimitivePropertyType
#define SOAP_TYPE_plu_PointerTogml__TimeTopologyPrimitivePropertyType (-2238)

#endif

/* gml__TimeOrdinalEraPropertyType * has binding name 'PointerTogml__TimeOrdinalEraPropertyType' for type 'gml:TimeOrdinalEraPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeOrdinalEraPropertyType
#define SOAP_TYPE_plu_PointerTogml__TimeOrdinalEraPropertyType (-2236)

#endif

/* gml__TimeNodePropertyType * has binding name 'PointerTogml__TimeNodePropertyType' for type 'gml:TimeNodePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeNodePropertyType
#define SOAP_TYPE_plu_PointerTogml__TimeNodePropertyType (-2235)

#endif

/* gml__TimePeriodPropertyType * has binding name 'PointerTogml__TimePeriodPropertyType' for type 'gml:TimePeriodPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimePeriodPropertyType
#define SOAP_TYPE_plu_PointerTogml__TimePeriodPropertyType (-2234)

#endif

/* __gml__union_DictionaryType * has binding name 'PointerTo__gml__union_DictionaryType' for type '-gml:union-DictionaryType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_DictionaryType
#define SOAP_TYPE_plu_PointerTo__gml__union_DictionaryType (-2233)

#endif

/* gml__IndirectEntryType * has binding name 'PointerTogml__IndirectEntryType' for type 'gml:IndirectEntryType' */
#ifndef SOAP_TYPE_plu_PointerTogml__IndirectEntryType
#define SOAP_TYPE_plu_PointerTogml__IndirectEntryType (-2232)

#endif

/* gml__DictionaryEntryType * has binding name 'PointerTogml__DictionaryEntryType' for type 'gml:DictionaryEntryType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DictionaryEntryType
#define SOAP_TYPE_plu_PointerTogml__DictionaryEntryType (-2231)

#endif

/* gml__SolidArrayPropertyType * has binding name 'PointerTogml__SolidArrayPropertyType' for type 'gml:SolidArrayPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__SolidArrayPropertyType
#define SOAP_TYPE_plu_PointerTogml__SolidArrayPropertyType (-2227)

#endif

/* gml__SurfaceArrayPropertyType * has binding name 'PointerTogml__SurfaceArrayPropertyType' for type 'gml:SurfaceArrayPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__SurfaceArrayPropertyType
#define SOAP_TYPE_plu_PointerTogml__SurfaceArrayPropertyType (-2225)

#endif

/* gml__CurveArrayPropertyType * has binding name 'PointerTogml__CurveArrayPropertyType' for type 'gml:CurveArrayPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CurveArrayPropertyType
#define SOAP_TYPE_plu_PointerTogml__CurveArrayPropertyType (-2223)

#endif

/* gml__PointArrayPropertyType * has binding name 'PointerTogml__PointArrayPropertyType' for type 'gml:PointArrayPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__PointArrayPropertyType
#define SOAP_TYPE_plu_PointerTogml__PointArrayPropertyType (-2221)

#endif

/* gml__GeometryArrayPropertyType * has binding name 'PointerTogml__GeometryArrayPropertyType' for type 'gml:GeometryArrayPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__GeometryArrayPropertyType
#define SOAP_TYPE_plu_PointerTogml__GeometryArrayPropertyType (-2219)

#endif

/* gml__SolidPropertyType * has binding name 'PointerTogml__SolidPropertyType' for type 'gml:SolidPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__SolidPropertyType
#define SOAP_TYPE_plu_PointerTogml__SolidPropertyType (-2217)

#endif

/* gml__NodeOrEdgePropertyType * has binding name 'PointerTogml__NodeOrEdgePropertyType' for type 'gml:NodeOrEdgePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__NodeOrEdgePropertyType
#define SOAP_TYPE_plu_PointerTogml__NodeOrEdgePropertyType (-2215)

#endif

/* gml__SurfacePropertyType * has binding name 'PointerTogml__SurfacePropertyType' for type 'gml:SurfacePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__SurfacePropertyType
#define SOAP_TYPE_plu_PointerTogml__SurfacePropertyType (-2214)

#endif

/* gml__NodePropertyType * has binding name 'PointerTogml__NodePropertyType' for type 'gml:NodePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__NodePropertyType
#define SOAP_TYPE_plu_PointerTogml__NodePropertyType (-2212)

#endif

/* gml__TopoSolidPropertyType * has binding name 'PointerTogml__TopoSolidPropertyType' for type 'gml:TopoSolidPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TopoSolidPropertyType
#define SOAP_TYPE_plu_PointerTogml__TopoSolidPropertyType (-2210)

#endif

/* gml__FaceOrTopoSolidPropertyType * has binding name 'PointerTogml__FaceOrTopoSolidPropertyType' for type 'gml:FaceOrTopoSolidPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__FaceOrTopoSolidPropertyType
#define SOAP_TYPE_plu_PointerTogml__FaceOrTopoSolidPropertyType (-2209)

#endif

/* gml__DynamicFeatureMemberType * has binding name 'PointerTogml__DynamicFeatureMemberType' for type 'gml:DynamicFeatureMemberType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DynamicFeatureMemberType
#define SOAP_TYPE_plu_PointerTogml__DynamicFeatureMemberType (-2208)

#endif

/* gmd__MD_x005fClassificationCode_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fClassificationCode_x005fPropertyType' for type 'gmd:MD_ClassificationCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fClassificationCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fClassificationCode_x005fPropertyType (-2207)

#endif

/* gmd__MD_x005fRestrictionCode_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fRestrictionCode_x005fPropertyType' for type 'gmd:MD_RestrictionCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fRestrictionCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fRestrictionCode_x005fPropertyType (-2205)

#endif

/* gmd__MD_x005fTopicCategoryCode_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fTopicCategoryCode_x005fPropertyType' for type 'gmd:MD_TopicCategoryCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fTopicCategoryCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fTopicCategoryCode_x005fPropertyType (-2203)

#endif

/* gmd__MD_x005fResolution_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fResolution_x005fPropertyType' for type 'gmd:MD_Resolution_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fResolution_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fResolution_x005fPropertyType (-2200)

#endif

/* gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType' for type 'gmd:MD_SpatialRepresentationTypeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType (-2198)

#endif

/* gco__Record_x005fPropertyType * has binding name 'PointerTogco__Record_x005fPropertyType' for type 'gco:Record_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogco__Record_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogco__Record_x005fPropertyType (-2196)

#endif

/* gco__UnitOfMeasure_x005fPropertyType * has binding name 'PointerTogco__UnitOfMeasure_x005fPropertyType' for type 'gco:UnitOfMeasure_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogco__UnitOfMeasure_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogco__UnitOfMeasure_x005fPropertyType (-2195)

#endif

/* gco__UomLength_x005fPropertyType * has binding name 'PointerTogco__UomLength_x005fPropertyType' for type 'gco:UomLength_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogco__UomLength_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogco__UomLength_x005fPropertyType (-2194)

#endif

/* gmd__MD_x005fRangeDimension_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fRangeDimension_x005fPropertyType' for type 'gmd:MD_RangeDimension_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fRangeDimension_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fRangeDimension_x005fPropertyType (-2192)

#endif

/* gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fCoverageContentTypeCode_x005fPropertyType' for type 'gmd:MD_CoverageContentTypeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fCoverageContentTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fCoverageContentTypeCode_x005fPropertyType (-2191)

#endif

/* gco__RecordType_x005fPropertyType * has binding name 'PointerTogco__RecordType_x005fPropertyType' for type 'gco:RecordType_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogco__RecordType_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogco__RecordType_x005fPropertyType (-2190)

#endif

/* gco__GenericName_x005fPropertyType * has binding name 'PointerTogco__GenericName_x005fPropertyType' for type 'gco:GenericName_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogco__GenericName_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogco__GenericName_x005fPropertyType (-2188)

#endif

/* gco__Decimal_x005fPropertyType * has binding name 'PointerTogco__Decimal_x005fPropertyType' for type 'gco:Decimal_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogco__Decimal_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogco__Decimal_x005fPropertyType (-2187)

#endif

/* gss__GM_x005fObject_x005fPropertyType * has binding name 'PointerTogss__GM_x005fObject_x005fPropertyType' for type 'gss:GM_Object_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogss__GM_x005fObject_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogss__GM_x005fObject_x005fPropertyType (-2185)

#endif

/* gmd__MD_x005fGeometricObjects_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fGeometricObjects_x005fPropertyType' for type 'gmd:MD_GeometricObjects_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fGeometricObjects_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fGeometricObjects_x005fPropertyType (-2183)

#endif

/* gmd__MD_x005fTopologyLevelCode_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fTopologyLevelCode_x005fPropertyType' for type 'gmd:MD_TopologyLevelCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fTopologyLevelCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fTopologyLevelCode_x005fPropertyType (-2182)

#endif

/* gmd__MD_x005fCellGeometryCode_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fCellGeometryCode_x005fPropertyType' for type 'gmd:MD_CellGeometryCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fCellGeometryCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fCellGeometryCode_x005fPropertyType (-2181)

#endif

/* gmd__MD_x005fDimension_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fDimension_x005fPropertyType' for type 'gmd:MD_Dimension_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fDimension_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fDimension_x005fPropertyType (-2179)

#endif

/* gml__DirectionPropertyType * has binding name 'PointerTogml__DirectionPropertyType' for type 'gml:DirectionPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DirectionPropertyType
#define SOAP_TYPE_plu_PointerTogml__DirectionPropertyType (-2178)

#endif

/* gml__FeatureArrayPropertyType * has binding name 'PointerTogml__FeatureArrayPropertyType' for type 'gml:FeatureArrayPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__FeatureArrayPropertyType
#define SOAP_TYPE_plu_PointerTogml__FeatureArrayPropertyType (-2176)

#endif

/* enum _gml__DegreesType_direction * has binding name 'PointerTo_gml__DegreesType_direction' for type 'gml:DegreesType-direction' */
#ifndef SOAP_TYPE_plu_PointerTo_gml__DegreesType_direction
#define SOAP_TYPE_plu_PointerTo_gml__DegreesType_direction (-2174)

#endif

/* gml__ResultType * has binding name 'PointerTogml__ResultType' for type 'gml:ResultType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ResultType
#define SOAP_TYPE_plu_PointerTogml__ResultType (-2172)

#endif

/* gml__TargetPropertyType * has binding name 'PointerTogml__TargetPropertyType' for type 'gml:TargetPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TargetPropertyType
#define SOAP_TYPE_plu_PointerTogml__TargetPropertyType (-2171)

#endif

/* gml__ProcedurePropertyType * has binding name 'PointerTogml__ProcedurePropertyType' for type 'gml:ProcedurePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ProcedurePropertyType
#define SOAP_TYPE_plu_PointerTogml__ProcedurePropertyType (-2169)

#endif

/* std::vector<std::string> * has binding name 'PointerTostd__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_plu_PointerTostd__vectorTemplateOfstd__string
#define SOAP_TYPE_plu_PointerTostd__vectorTemplateOfstd__string (-2168)

#endif

/* gml__GridLimitsType * has binding name 'PointerTogml__GridLimitsType' for type 'gml:GridLimitsType' */
#ifndef SOAP_TYPE_plu_PointerTogml__GridLimitsType
#define SOAP_TYPE_plu_PointerTogml__GridLimitsType (-2165)

#endif

/* std::string * has binding name 'PointerTogml__UomIdentifier' for type 'gml:UomIdentifier' */
#ifndef SOAP_TYPE_plu_PointerTogml__UomIdentifier
#define SOAP_TYPE_plu_PointerTogml__UomIdentifier (-2164)

#endif

/* gml__RelatedTimeType * has binding name 'PointerTogml__RelatedTimeType' for type 'gml:RelatedTimeType' */
#ifndef SOAP_TYPE_plu_PointerTogml__RelatedTimeType
#define SOAP_TYPE_plu_PointerTogml__RelatedTimeType (-2162)

#endif

/* std::string * has binding name 'PointerTogml__AxisDirectionList' for type 'gml:AxisDirectionList' */
#ifndef SOAP_TYPE_plu_PointerTogml__AxisDirectionList
#define SOAP_TYPE_plu_PointerTogml__AxisDirectionList (-2161)

#endif

/* enum gml__IncrementOrder * has binding name 'PointerTogml__IncrementOrder' for type 'gml:IncrementOrder' */
#ifndef SOAP_TYPE_plu_PointerTogml__IncrementOrder
#define SOAP_TYPE_plu_PointerTogml__IncrementOrder (-2160)

#endif

/* gml__RangeSetType * has binding name 'PointerTogml__RangeSetType' for type 'gml:RangeSetType' */
#ifndef SOAP_TYPE_plu_PointerTogml__RangeSetType
#define SOAP_TYPE_plu_PointerTogml__RangeSetType (-2159)

#endif

/* gml__DomainSetType * has binding name 'PointerTogml__DomainSetType' for type 'gml:DomainSetType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DomainSetType
#define SOAP_TYPE_plu_PointerTogml__DomainSetType (-2158)

#endif

/* __gml__union_AbstractGriddedSurfaceType_rows_Row_ * has binding name 'PointerTo__gml__union_AbstractGriddedSurfaceType_rows_Row_' for type '-gml:union-AbstractGriddedSurfaceType-rows-Row' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_AbstractGriddedSurfaceType_rows_Row_
#define SOAP_TYPE_plu_PointerTo__gml__union_AbstractGriddedSurfaceType_rows_Row_ (-2155)

#endif

/* __gml__union_BezierType_ * has binding name 'PointerTo__gml__union_BezierType_' for type '-gml:union-BezierType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_BezierType_
#define SOAP_TYPE_plu_PointerTo__gml__union_BezierType_ (-2150)

#endif

/* __gml__union_ArcByBulgeType_ * has binding name 'PointerTo__gml__union_ArcByBulgeType_' for type '-gml:union-ArcByBulgeType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_ArcByBulgeType_
#define SOAP_TYPE_plu_PointerTo__gml__union_ArcByBulgeType_ (-2144)

#endif

/* __gml__union_ArcType_ * has binding name 'PointerTo__gml__union_ArcType_' for type '-gml:union-ArcType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_ArcType_
#define SOAP_TYPE_plu_PointerTo__gml__union_ArcType_ (-2139)

#endif

/* gml__GeometricPrimitivePropertyType * has binding name 'PointerTogml__GeometricPrimitivePropertyType' for type 'gml:GeometricPrimitivePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__GeometricPrimitivePropertyType
#define SOAP_TYPE_plu_PointerTogml__GeometricPrimitivePropertyType (-2133)

#endif

/* gml__TopoPrimitiveArrayAssociationType * has binding name 'PointerTogml__TopoPrimitiveArrayAssociationType' for type 'gml:TopoPrimitiveArrayAssociationType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TopoPrimitiveArrayAssociationType
#define SOAP_TYPE_plu_PointerTogml__TopoPrimitiveArrayAssociationType (-2132)

#endif

/* gml__TopoPrimitiveMemberType * has binding name 'PointerTogml__TopoPrimitiveMemberType' for type 'gml:TopoPrimitiveMemberType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TopoPrimitiveMemberType
#define SOAP_TYPE_plu_PointerTogml__TopoPrimitiveMemberType (-2130)

#endif

/* gml__TopoComplexPropertyType * has binding name 'PointerTogml__TopoComplexPropertyType' for type 'gml:TopoComplexPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TopoComplexPropertyType
#define SOAP_TYPE_plu_PointerTogml__TopoComplexPropertyType (-2128)

#endif

/* gml__DirectedTopoSolidPropertyType * has binding name 'PointerTogml__DirectedTopoSolidPropertyType' for type 'gml:DirectedTopoSolidPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DirectedTopoSolidPropertyType
#define SOAP_TYPE_plu_PointerTogml__DirectedTopoSolidPropertyType (-2126)

#endif

/* gml__DirectedFacePropertyType * has binding name 'PointerTogml__DirectedFacePropertyType' for type 'gml:DirectedFacePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DirectedFacePropertyType
#define SOAP_TYPE_plu_PointerTogml__DirectedFacePropertyType (-2124)

#endif

/* gml__DirectedEdgePropertyType * has binding name 'PointerTogml__DirectedEdgePropertyType' for type 'gml:DirectedEdgePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DirectedEdgePropertyType
#define SOAP_TYPE_plu_PointerTogml__DirectedEdgePropertyType (-2122)

#endif

/* gml__DirectedNodePropertyType * has binding name 'PointerTogml__DirectedNodePropertyType' for type 'gml:DirectedNodePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DirectedNodePropertyType
#define SOAP_TYPE_plu_PointerTogml__DirectedNodePropertyType (-2121)

#endif

/* gml__HistoryPropertyType * has binding name 'PointerTogml__HistoryPropertyType' for type 'gml:HistoryPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__HistoryPropertyType
#define SOAP_TYPE_plu_PointerTogml__HistoryPropertyType (-2120)

#endif

/* base2__OfficialJournalInformationPropertyType * has binding name 'PointerTobase2__OfficialJournalInformationPropertyType' for type 'base2:OfficialJournalInformationPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTobase2__OfficialJournalInformationPropertyType
#define SOAP_TYPE_plu_PointerTobase2__OfficialJournalInformationPropertyType (-2118)

#endif

/* gml__FeaturePropertyType * has binding name 'PointerTogml__FeaturePropertyType' for type 'gml:FeaturePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__FeaturePropertyType
#define SOAP_TYPE_plu_PointerTogml__FeaturePropertyType (-2116)

#endif

/* _base__SpatialDataSetType_metadata * has binding name 'PointerTo_base__SpatialDataSetType_metadata' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_base__SpatialDataSetType_metadata
#define SOAP_TYPE_plu_PointerTo_base__SpatialDataSetType_metadata (-2115)

#endif

/* __base__SpatialDataSetType_metadata_sequence * has binding name 'PointerTo__base__SpatialDataSetType_metadata_sequence' for type '-base:SpatialDataSetType-metadata-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__base__SpatialDataSetType_metadata_sequence
#define SOAP_TYPE_plu_PointerTo__base__SpatialDataSetType_metadata_sequence (-2114)

#endif

/* std::vector<_plu__SpatialPlanType_ordinance> * has binding name 'PointerTostd__vectorTemplateOf_plu__SpatialPlanType_ordinance' for type '' */
#ifndef SOAP_TYPE_plu_PointerTostd__vectorTemplateOf_plu__SpatialPlanType_ordinance
#define SOAP_TYPE_plu_PointerTostd__vectorTemplateOf_plu__SpatialPlanType_ordinance (-2111)

#endif

/* _plu__SpatialPlanType_backgroundMap * has binding name 'PointerTo_plu__SpatialPlanType_backgroundMap' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__SpatialPlanType_backgroundMap
#define SOAP_TYPE_plu_PointerTo_plu__SpatialPlanType_backgroundMap (-2108)

#endif

/* _plu__SpatialPlanType_alternativeTitle * has binding name 'PointerTo_plu__SpatialPlanType_alternativeTitle' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__SpatialPlanType_alternativeTitle
#define SOAP_TYPE_plu_PointerTo_plu__SpatialPlanType_alternativeTitle (-2106)

#endif

/* _plu__SpatialPlanType_validTo * has binding name 'PointerTo_plu__SpatialPlanType_validTo' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__SpatialPlanType_validTo
#define SOAP_TYPE_plu_PointerTo_plu__SpatialPlanType_validTo (-2104)

#endif

/* _plu__SpatialPlanType_validFrom * has binding name 'PointerTo_plu__SpatialPlanType_validFrom' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__SpatialPlanType_validFrom
#define SOAP_TYPE_plu_PointerTo_plu__SpatialPlanType_validFrom (-2102)

#endif

/* _plu__SpatialPlanType_endLifespanVersion * has binding name 'PointerTo_plu__SpatialPlanType_endLifespanVersion' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__SpatialPlanType_endLifespanVersion
#define SOAP_TYPE_plu_PointerTo_plu__SpatialPlanType_endLifespanVersion (-2100)

#endif

/* _plu__SpatialPlanType_beginLifespanVersion * has binding name 'PointerTo_plu__SpatialPlanType_beginLifespanVersion' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__SpatialPlanType_beginLifespanVersion
#define SOAP_TYPE_plu_PointerTo_plu__SpatialPlanType_beginLifespanVersion (-2098)

#endif

/* std::vector<_plu__SupplementaryRegulationType_name> * has binding name 'PointerTostd__vectorTemplateOf_plu__SupplementaryRegulationType_name' for type '' */
#ifndef SOAP_TYPE_plu_PointerTostd__vectorTemplateOf_plu__SupplementaryRegulationType_name
#define SOAP_TYPE_plu_PointerTostd__vectorTemplateOf_plu__SupplementaryRegulationType_name (-2096)

#endif

/* _plu__SupplementaryRegulationType_specificRegulationNature * has binding name 'PointerTo_plu__SupplementaryRegulationType_specificRegulationNature' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__SupplementaryRegulationType_specificRegulationNature
#define SOAP_TYPE_plu_PointerTo_plu__SupplementaryRegulationType_specificRegulationNature (-2093)

#endif

/* _plu__SupplementaryRegulationType_inheritedFromOtherPlans * has binding name 'PointerTo_plu__SupplementaryRegulationType_inheritedFromOtherPlans' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__SupplementaryRegulationType_inheritedFromOtherPlans
#define SOAP_TYPE_plu_PointerTo_plu__SupplementaryRegulationType_inheritedFromOtherPlans (-2091)

#endif

/* gml__GeometryPropertyType * has binding name 'PointerTogml__GeometryPropertyType' for type 'gml:GeometryPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__GeometryPropertyType
#define SOAP_TYPE_plu_PointerTogml__GeometryPropertyType (-2089)

#endif

/* _plu__SupplementaryRegulationType_endLifespanVersion * has binding name 'PointerTo_plu__SupplementaryRegulationType_endLifespanVersion' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__SupplementaryRegulationType_endLifespanVersion
#define SOAP_TYPE_plu_PointerTo_plu__SupplementaryRegulationType_endLifespanVersion (-2088)

#endif

/* std::vector<_plu__SupplementaryRegulationType_dimensioningIndication> * has binding name 'PointerTostd__vectorTemplateOf_plu__SupplementaryRegulationType_dimensioningIndication' for type '' */
#ifndef SOAP_TYPE_plu_PointerTostd__vectorTemplateOf_plu__SupplementaryRegulationType_dimensioningIndication
#define SOAP_TYPE_plu_PointerTostd__vectorTemplateOf_plu__SupplementaryRegulationType_dimensioningIndication (-2086)

#endif

/* _plu__SupplementaryRegulationType_beginLifespanVersion * has binding name 'PointerTo_plu__SupplementaryRegulationType_beginLifespanVersion' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__SupplementaryRegulationType_beginLifespanVersion
#define SOAP_TYPE_plu_PointerTo_plu__SupplementaryRegulationType_beginLifespanVersion (-2082)

#endif

/* _plu__SupplementaryRegulationType_backgroundMap * has binding name 'PointerTo_plu__SupplementaryRegulationType_backgroundMap' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__SupplementaryRegulationType_backgroundMap
#define SOAP_TYPE_plu_PointerTo_plu__SupplementaryRegulationType_backgroundMap (-2080)

#endif

/* _plu__SupplementaryRegulationType_validTo * has binding name 'PointerTo_plu__SupplementaryRegulationType_validTo' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__SupplementaryRegulationType_validTo
#define SOAP_TYPE_plu_PointerTo_plu__SupplementaryRegulationType_validTo (-2078)

#endif

/* _plu__SupplementaryRegulationType_validFrom * has binding name 'PointerTo_plu__SupplementaryRegulationType_validFrom' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__SupplementaryRegulationType_validFrom
#define SOAP_TYPE_plu_PointerTo_plu__SupplementaryRegulationType_validFrom (-2076)

#endif

/* _plu__OfficialDocumentationType_planDocument * has binding name 'PointerTo_plu__OfficialDocumentationType_planDocument' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__OfficialDocumentationType_planDocument
#define SOAP_TYPE_plu_PointerTo_plu__OfficialDocumentationType_planDocument (-2074)

#endif

/* __plu__OfficialDocumentationType_planDocument_sequence * has binding name 'PointerTo__plu__OfficialDocumentationType_planDocument_sequence' for type '-plu:OfficialDocumentationType-planDocument-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__plu__OfficialDocumentationType_planDocument_sequence
#define SOAP_TYPE_plu_PointerTo__plu__OfficialDocumentationType_planDocument_sequence (-2073)

#endif

/* _plu__OfficialDocumentationType_regulationText * has binding name 'PointerTo_plu__OfficialDocumentationType_regulationText' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__OfficialDocumentationType_regulationText
#define SOAP_TYPE_plu_PointerTo_plu__OfficialDocumentationType_regulationText (-2069)

#endif

/* _plu__OfficialDocumentationType_legislationCitation * has binding name 'PointerTo_plu__OfficialDocumentationType_legislationCitation' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__OfficialDocumentationType_legislationCitation
#define SOAP_TYPE_plu_PointerTo_plu__OfficialDocumentationType_legislationCitation (-2067)

#endif

/* __plu__OfficialDocumentationType_legislationCitation_sequence * has binding name 'PointerTo__plu__OfficialDocumentationType_legislationCitation_sequence' for type '-plu:OfficialDocumentationType-legislationCitation-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__plu__OfficialDocumentationType_legislationCitation_sequence
#define SOAP_TYPE_plu_PointerTo__plu__OfficialDocumentationType_legislationCitation_sequence (-2066)

#endif

/* std::vector<_plu__ZoningElementType_dimensioningIndication> * has binding name 'PointerTostd__vectorTemplateOf_plu__ZoningElementType_dimensioningIndication' for type '' */
#ifndef SOAP_TYPE_plu_PointerTostd__vectorTemplateOf_plu__ZoningElementType_dimensioningIndication
#define SOAP_TYPE_plu_PointerTostd__vectorTemplateOf_plu__ZoningElementType_dimensioningIndication (-2063)

#endif

/* _plu__ZoningElementType_backgroundMap * has binding name 'PointerTo_plu__ZoningElementType_backgroundMap' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__ZoningElementType_backgroundMap
#define SOAP_TYPE_plu_PointerTo_plu__ZoningElementType_backgroundMap (-2059)

#endif

/* _plu__ZoningElementType_endLifespanVersion * has binding name 'PointerTo_plu__ZoningElementType_endLifespanVersion' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__ZoningElementType_endLifespanVersion
#define SOAP_TYPE_plu_PointerTo_plu__ZoningElementType_endLifespanVersion (-2057)

#endif

/* _plu__ZoningElementType_specificPresence * has binding name 'PointerTo_plu__ZoningElementType_specificPresence' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__ZoningElementType_specificPresence
#define SOAP_TYPE_plu_PointerTo_plu__ZoningElementType_specificPresence (-2055)

#endif

/* _plu__ZoningElementType_hilucsPresence * has binding name 'PointerTo_plu__ZoningElementType_hilucsPresence' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__ZoningElementType_hilucsPresence
#define SOAP_TYPE_plu_PointerTo_plu__ZoningElementType_hilucsPresence (-2053)

#endif

/* _plu__ZoningElementType_beginLifespanVersion * has binding name 'PointerTo_plu__ZoningElementType_beginLifespanVersion' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__ZoningElementType_beginLifespanVersion
#define SOAP_TYPE_plu_PointerTo_plu__ZoningElementType_beginLifespanVersion (-2051)

#endif

/* _plu__ZoningElementType_validTo * has binding name 'PointerTo_plu__ZoningElementType_validTo' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__ZoningElementType_validTo
#define SOAP_TYPE_plu_PointerTo_plu__ZoningElementType_validTo (-2049)

#endif

/* _plu__ZoningElementType_validFrom * has binding name 'PointerTo_plu__ZoningElementType_validFrom' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__ZoningElementType_validFrom
#define SOAP_TYPE_plu_PointerTo_plu__ZoningElementType_validFrom (-2047)

#endif

/* gml__MultiSurfacePropertyType * has binding name 'PointerTogml__MultiSurfacePropertyType' for type 'gml:MultiSurfacePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__MultiSurfacePropertyType
#define SOAP_TYPE_plu_PointerTogml__MultiSurfacePropertyType (-2045)

#endif

/* base__IdentifierPropertyType * has binding name 'PointerTobase__IdentifierPropertyType' for type 'base:IdentifierPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTobase__IdentifierPropertyType
#define SOAP_TYPE_plu_PointerTobase__IdentifierPropertyType (-2044)

#endif

/* gco__UnlimitedInteger_x005fPropertyType * has binding name 'PointerTogco__UnlimitedInteger_x005fPropertyType' for type 'gco:UnlimitedInteger_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogco__UnlimitedInteger_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogco__UnlimitedInteger_x005fPropertyType (-2043)

#endif

/* gco__MultiplicityRange_x005fPropertyType * has binding name 'PointerTogco__MultiplicityRange_x005fPropertyType' for type 'gco:MultiplicityRange_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogco__MultiplicityRange_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogco__MultiplicityRange_x005fPropertyType (-2041)

#endif

/* gco__TypeName_x005fPropertyType * has binding name 'PointerTogco__TypeName_x005fPropertyType' for type 'gco:TypeName_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogco__TypeName_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogco__TypeName_x005fPropertyType (-2040)

#endif

/* __gmd__LocalisedCharacterString_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__LocalisedCharacterString_x005fPropertyType_sequence' for type '-gmd:LocalisedCharacterString_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__LocalisedCharacterString_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__LocalisedCharacterString_x005fPropertyType_sequence (-2039)

#endif

/* gmd__Country_x005fPropertyType * has binding name 'PointerTogmd__Country_x005fPropertyType' for type 'gmd:Country_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__Country_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__Country_x005fPropertyType (-2037)

#endif

/* gmd__LanguageCode_x005fPropertyType * has binding name 'PointerTogmd__LanguageCode_x005fPropertyType' for type 'gmd:LanguageCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__LanguageCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__LanguageCode_x005fPropertyType (-2036)

#endif

/* __gmd__PT_x005fFreeText_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__PT_x005fFreeText_x005fPropertyType_sequence' for type '-gmd:PT_FreeText_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__PT_x005fFreeText_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__PT_x005fFreeText_x005fPropertyType_sequence (-2035)

#endif

/* gmd__PT_x005fFreeText_x005fType * has binding name 'PointerTogmd__PT_x005fFreeText_x005fType' for type 'gmd:PT_FreeText_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__PT_x005fFreeText_x005fType
#define SOAP_TYPE_plu_PointerTogmd__PT_x005fFreeText_x005fType (-2034)

#endif

/* gts__TM_x005fPeriodDuration_x005fPropertyType * has binding name 'PointerTogts__TM_x005fPeriodDuration_x005fPropertyType' for type 'gts:TM_PeriodDuration_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogts__TM_x005fPeriodDuration_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogts__TM_x005fPeriodDuration_x005fPropertyType (-2032)

#endif

/* gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType' for type 'gmd:MD_MaintenanceFrequencyCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType (-2031)

#endif

/* gmd__MD_x005fDistributor_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fDistributor_x005fPropertyType' for type 'gmd:MD_Distributor_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fDistributor_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fDistributor_x005fPropertyType (-2029)

#endif

/* gmd__MD_x005fDigitalTransferOptions_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fDigitalTransferOptions_x005fPropertyType' for type 'gmd:MD_DigitalTransferOptions_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fDigitalTransferOptions_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fDigitalTransferOptions_x005fPropertyType (-2027)

#endif

/* gmd__MD_x005fStandardOrderProcess_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fStandardOrderProcess_x005fPropertyType' for type 'gmd:MD_StandardOrderProcess_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fStandardOrderProcess_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fStandardOrderProcess_x005fPropertyType (-2025)

#endif

/* gmd__MD_x005fMedium_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fMedium_x005fPropertyType' for type 'gmd:MD_Medium_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fMedium_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fMedium_x005fPropertyType (-2024)

#endif

/* gmd__MD_x005fMediumFormatCode_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fMediumFormatCode_x005fPropertyType' for type 'gmd:MD_MediumFormatCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fMediumFormatCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fMediumFormatCode_x005fPropertyType (-2021)

#endif

/* gmd__MD_x005fMediumNameCode_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fMediumNameCode_x005fPropertyType' for type 'gmd:MD_MediumNameCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fMediumNameCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fMediumNameCode_x005fPropertyType (-2019)

#endif

/* gmd__DS_x005fInitiativeTypeCode_x005fPropertyType * has binding name 'PointerTogmd__DS_x005fInitiativeTypeCode_x005fPropertyType' for type 'gmd:DS_InitiativeTypeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DS_x005fInitiativeTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__DS_x005fInitiativeTypeCode_x005fPropertyType (-2018)

#endif

/* gmd__DS_x005fAssociationTypeCode_x005fPropertyType * has binding name 'PointerTogmd__DS_x005fAssociationTypeCode_x005fPropertyType' for type 'gmd:DS_AssociationTypeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DS_x005fAssociationTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__DS_x005fAssociationTypeCode_x005fPropertyType (-2017)

#endif

/* gmd__MD_x005fKeywordTypeCode_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fKeywordTypeCode_x005fPropertyType' for type 'gmd:MD_KeywordTypeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fKeywordTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fKeywordTypeCode_x005fPropertyType (-2016)

#endif

/* gmd__MD_x005fAggregateInformation_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fAggregateInformation_x005fPropertyType' for type 'gmd:MD_AggregateInformation_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fAggregateInformation_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fAggregateInformation_x005fPropertyType (-2014)

#endif

/* gmd__MD_x005fUsage_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fUsage_x005fPropertyType' for type 'gmd:MD_Usage_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fUsage_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fUsage_x005fPropertyType (-2012)

#endif

/* gmd__MD_x005fKeywords_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fKeywords_x005fPropertyType' for type 'gmd:MD_Keywords_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fKeywords_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fKeywords_x005fPropertyType (-2010)

#endif

/* gmd__MD_x005fFormat_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fFormat_x005fPropertyType' for type 'gmd:MD_Format_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fFormat_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fFormat_x005fPropertyType (-2008)

#endif

/* gmd__MD_x005fBrowseGraphic_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fBrowseGraphic_x005fPropertyType' for type 'gmd:MD_BrowseGraphic_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fBrowseGraphic_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fBrowseGraphic_x005fPropertyType (-2006)

#endif

/* gmd__MD_x005fProgressCode_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fProgressCode_x005fPropertyType' for type 'gmd:MD_ProgressCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fProgressCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fProgressCode_x005fPropertyType (-2003)

#endif

/* gmd__MD_x005fScopeDescription_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fScopeDescription_x005fPropertyType' for type 'gmd:MD_ScopeDescription_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fScopeDescription_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fScopeDescription_x005fPropertyType (-2001)

#endif

/* gmd__LI_x005fLineage_x005fPropertyType * has binding name 'PointerTogmd__LI_x005fLineage_x005fPropertyType' for type 'gmd:LI_Lineage_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__LI_x005fLineage_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__LI_x005fLineage_x005fPropertyType (-2000)

#endif

/* gmd__DQ_x005fElement_x005fPropertyType * has binding name 'PointerTogmd__DQ_x005fElement_x005fPropertyType' for type 'gmd:DQ_Element_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fElement_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fElement_x005fPropertyType (-1998)

#endif

/* gmd__DQ_x005fScope_x005fPropertyType * has binding name 'PointerTogmd__DQ_x005fScope_x005fPropertyType' for type 'gmd:DQ_Scope_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fScope_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fScope_x005fPropertyType (-1997)

#endif

/* gmd__DQ_x005fResult_x005fPropertyType * has binding name 'PointerTogmd__DQ_x005fResult_x005fPropertyType' for type 'gmd:DQ_Result_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fResult_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fResult_x005fPropertyType (-1995)

#endif

/* gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType * has binding name 'PointerTogmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType' for type 'gmd:DQ_EvaluationMethodTypeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType (-1993)

#endif

/* gmd__LI_x005fProcessStep_x005fPropertyType * has binding name 'PointerTogmd__LI_x005fProcessStep_x005fPropertyType' for type 'gmd:LI_ProcessStep_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__LI_x005fProcessStep_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__LI_x005fProcessStep_x005fPropertyType (-1991)

#endif

/* gmd__LI_x005fSource_x005fPropertyType * has binding name 'PointerTogmd__LI_x005fSource_x005fPropertyType' for type 'gmd:LI_Source_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__LI_x005fSource_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__LI_x005fSource_x005fPropertyType (-1989)

#endif

/* gco__DateTime_x005fPropertyType * has binding name 'PointerTogco__DateTime_x005fPropertyType' for type 'gco:DateTime_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogco__DateTime_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogco__DateTime_x005fPropertyType (-1988)

#endif

/* gco__Binary_x005fPropertyType * has binding name 'PointerTogco__Binary_x005fPropertyType' for type 'gco:Binary_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogco__Binary_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogco__Binary_x005fPropertyType (-1986)

#endif

/* gco__MemberName_x005fPropertyType * has binding name 'PointerTogco__MemberName_x005fPropertyType' for type 'gco:MemberName_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogco__MemberName_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogco__MemberName_x005fPropertyType (-1985)

#endif

/* gmd__MD_x005fExtendedElementInformation_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fExtendedElementInformation_x005fPropertyType' for type 'gmd:MD_ExtendedElementInformation_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fExtendedElementInformation_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fExtendedElementInformation_x005fPropertyType (-1983)

#endif

/* gmd__MD_x005fDatatypeCode_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fDatatypeCode_x005fPropertyType' for type 'gmd:MD_DatatypeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fDatatypeCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fDatatypeCode_x005fPropertyType (-1982)

#endif

/* gmd__MD_x005fObligationCode_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fObligationCode_x005fPropertyType' for type 'gmd:MD_ObligationCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fObligationCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fObligationCode_x005fPropertyType (-1981)

#endif

/* gco__Boolean_x005fPropertyType * has binding name 'PointerTogco__Boolean_x005fPropertyType' for type 'gco:Boolean_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogco__Boolean_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogco__Boolean_x005fPropertyType (-1980)

#endif

/* gmd__EX_x005fVerticalExtent_x005fPropertyType * has binding name 'PointerTogmd__EX_x005fVerticalExtent_x005fPropertyType' for type 'gmd:EX_VerticalExtent_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__EX_x005fVerticalExtent_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__EX_x005fVerticalExtent_x005fPropertyType (-1978)

#endif

/* gmd__EX_x005fTemporalExtent_x005fPropertyType * has binding name 'PointerTogmd__EX_x005fTemporalExtent_x005fPropertyType' for type 'gmd:EX_TemporalExtent_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__EX_x005fTemporalExtent_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__EX_x005fTemporalExtent_x005fPropertyType (-1976)

#endif

/* gmd__EX_x005fGeographicExtent_x005fPropertyType * has binding name 'PointerTogmd__EX_x005fGeographicExtent_x005fPropertyType' for type 'gmd:EX_GeographicExtent_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__EX_x005fGeographicExtent_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__EX_x005fGeographicExtent_x005fPropertyType (-1974)

#endif

/* gsr__SC_x005fCRS_x005fPropertyType * has binding name 'PointerTogsr__SC_x005fCRS_x005fPropertyType' for type 'gsr:SC_CRS_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogsr__SC_x005fCRS_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogsr__SC_x005fCRS_x005fPropertyType (-1973)

#endif

/* gco__Real_x005fPropertyType * has binding name 'PointerTogco__Real_x005fPropertyType' for type 'gco:Real_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogco__Real_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogco__Real_x005fPropertyType (-1972)

#endif

/* gts__TM_x005fPrimitive_x005fPropertyType * has binding name 'PointerTogts__TM_x005fPrimitive_x005fPropertyType' for type 'gts:TM_Primitive_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogts__TM_x005fPrimitive_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogts__TM_x005fPrimitive_x005fPropertyType (-1971)

#endif

/* gmd__EX_x005fExtent_x005fPropertyType * has binding name 'PointerTogmd__EX_x005fExtent_x005fPropertyType' for type 'gmd:EX_Extent_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__EX_x005fExtent_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__EX_x005fExtent_x005fPropertyType (-1969)

#endif

/* gmd__CI_x005fCitation_x005fPropertyType * has binding name 'PointerTogmd__CI_x005fCitation_x005fPropertyType' for type 'gmd:CI_Citation_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__CI_x005fCitation_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__CI_x005fCitation_x005fPropertyType (-1968)

#endif

/* gmd__RS_x005fIdentifier_x005fPropertyType * has binding name 'PointerTogmd__RS_x005fIdentifier_x005fPropertyType' for type 'gmd:RS_Identifier_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__RS_x005fIdentifier_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__RS_x005fIdentifier_x005fPropertyType (-1967)

#endif

/* gmd__CI_x005fDateTypeCode_x005fPropertyType * has binding name 'PointerTogmd__CI_x005fDateTypeCode_x005fPropertyType' for type 'gmd:CI_DateTypeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__CI_x005fDateTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__CI_x005fDateTypeCode_x005fPropertyType (-1966)

#endif

/* gmd__CI_x005fOnlineResource_x005fPropertyType * has binding name 'PointerTogmd__CI_x005fOnlineResource_x005fPropertyType' for type 'gmd:CI_OnlineResource_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__CI_x005fOnlineResource_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__CI_x005fOnlineResource_x005fPropertyType (-1965)

#endif

/* gmd__CI_x005fAddress_x005fPropertyType * has binding name 'PointerTogmd__CI_x005fAddress_x005fPropertyType' for type 'gmd:CI_Address_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__CI_x005fAddress_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__CI_x005fAddress_x005fPropertyType (-1964)

#endif

/* gmd__CI_x005fTelephone_x005fPropertyType * has binding name 'PointerTogmd__CI_x005fTelephone_x005fPropertyType' for type 'gmd:CI_Telephone_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__CI_x005fTelephone_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__CI_x005fTelephone_x005fPropertyType (-1963)

#endif

/* gmd__CI_x005fOnLineFunctionCode_x005fPropertyType * has binding name 'PointerTogmd__CI_x005fOnLineFunctionCode_x005fPropertyType' for type 'gmd:CI_OnLineFunctionCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__CI_x005fOnLineFunctionCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__CI_x005fOnLineFunctionCode_x005fPropertyType (-1962)

#endif

/* gmd__URL_x005fPropertyType * has binding name 'PointerTogmd__URL_x005fPropertyType' for type 'gmd:URL_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__URL_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__URL_x005fPropertyType (-1961)

#endif

/* gmd__CI_x005fSeries_x005fPropertyType * has binding name 'PointerTogmd__CI_x005fSeries_x005fPropertyType' for type 'gmd:CI_Series_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__CI_x005fSeries_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__CI_x005fSeries_x005fPropertyType (-1960)

#endif

/* gmd__CI_x005fPresentationFormCode_x005fPropertyType * has binding name 'PointerTogmd__CI_x005fPresentationFormCode_x005fPropertyType' for type 'gmd:CI_PresentationFormCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__CI_x005fPresentationFormCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__CI_x005fPresentationFormCode_x005fPropertyType (-1958)

#endif

/* gmd__MD_x005fIdentifier_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fIdentifier_x005fPropertyType' for type 'gmd:MD_Identifier_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fIdentifier_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fIdentifier_x005fPropertyType (-1956)

#endif

/* gmd__CI_x005fRoleCode_x005fPropertyType * has binding name 'PointerTogmd__CI_x005fRoleCode_x005fPropertyType' for type 'gmd:CI_RoleCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__CI_x005fRoleCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__CI_x005fRoleCode_x005fPropertyType (-1955)

#endif

/* gmd__CI_x005fContact_x005fPropertyType * has binding name 'PointerTogmd__CI_x005fContact_x005fPropertyType' for type 'gmd:CI_Contact_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__CI_x005fContact_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__CI_x005fContact_x005fPropertyType (-1954)

#endif

/* gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType' for type 'gmd:MD_GeometricObjectTypeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType (-1953)

#endif

/* gco__Measure_x005fPropertyType * has binding name 'PointerTogco__Measure_x005fPropertyType' for type 'gco:Measure_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogco__Measure_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogco__Measure_x005fPropertyType (-1952)

#endif

/* gco__Integer_x005fPropertyType * has binding name 'PointerTogco__Integer_x005fPropertyType' for type 'gco:Integer_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogco__Integer_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogco__Integer_x005fPropertyType (-1951)

#endif

/* gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fDimensionNameTypeCode_x005fPropertyType' for type 'gmd:MD_DimensionNameTypeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fDimensionNameTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fDimensionNameTypeCode_x005fPropertyType (-1950)

#endif

/* gmd__MD_x005fMaintenanceInformation_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fMaintenanceInformation_x005fPropertyType' for type 'gmd:MD_MaintenanceInformation_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fMaintenanceInformation_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fMaintenanceInformation_x005fPropertyType (-1949)

#endif

/* gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fApplicationSchemaInformation_x005fPropertyType' for type 'gmd:MD_ApplicationSchemaInformation_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fApplicationSchemaInformation_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fApplicationSchemaInformation_x005fPropertyType (-1947)

#endif

/* gmd__MD_x005fConstraints_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fConstraints_x005fPropertyType' for type 'gmd:MD_Constraints_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fConstraints_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fConstraints_x005fPropertyType (-1945)

#endif

/* gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType' for type 'gmd:MD_PortrayalCatalogueReference_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType (-1943)

#endif

/* gmd__DQ_x005fDataQuality_x005fPropertyType * has binding name 'PointerTogmd__DQ_x005fDataQuality_x005fPropertyType' for type 'gmd:DQ_DataQuality_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fDataQuality_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fDataQuality_x005fPropertyType (-1941)

#endif

/* gmd__MD_x005fDistribution_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fDistribution_x005fPropertyType' for type 'gmd:MD_Distribution_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fDistribution_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fDistribution_x005fPropertyType (-1940)

#endif

/* gmd__MD_x005fContentInformation_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fContentInformation_x005fPropertyType' for type 'gmd:MD_ContentInformation_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fContentInformation_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fContentInformation_x005fPropertyType (-1938)

#endif

/* gmd__MD_x005fIdentification_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fIdentification_x005fPropertyType' for type 'gmd:MD_Identification_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fIdentification_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fIdentification_x005fPropertyType (-1936)

#endif

/* gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fMetadataExtensionInformation_x005fPropertyType' for type 'gmd:MD_MetadataExtensionInformation_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fMetadataExtensionInformation_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fMetadataExtensionInformation_x005fPropertyType (-1934)

#endif

/* gmd__MD_x005fReferenceSystem_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fReferenceSystem_x005fPropertyType' for type 'gmd:MD_ReferenceSystem_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fReferenceSystem_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fReferenceSystem_x005fPropertyType (-1932)

#endif

/* gmd__MD_x005fSpatialRepresentation_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fSpatialRepresentation_x005fPropertyType' for type 'gmd:MD_SpatialRepresentation_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fSpatialRepresentation_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fSpatialRepresentation_x005fPropertyType (-1930)

#endif

/* gco__Date_x005fPropertyType * has binding name 'PointerTogco__Date_x005fPropertyType' for type 'gco:Date_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogco__Date_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogco__Date_x005fPropertyType (-1928)

#endif

/* gmd__MD_x005fScopeCode_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fScopeCode_x005fPropertyType' for type 'gmd:MD_ScopeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fScopeCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fScopeCode_x005fPropertyType (-1925)

#endif

/* gmd__MD_x005fCharacterSetCode_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fCharacterSetCode_x005fPropertyType' for type 'gmd:MD_CharacterSetCode_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fCharacterSetCode_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fCharacterSetCode_x005fPropertyType (-1924)

#endif

/* gmd__DS_x005fAggregate_x005fPropertyType * has binding name 'PointerTogmd__DS_x005fAggregate_x005fPropertyType' for type 'gmd:DS_Aggregate_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DS_x005fAggregate_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__DS_x005fAggregate_x005fPropertyType (-1922)

#endif

/* gmd__MD_x005fMetadata_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fMetadata_x005fPropertyType' for type 'gmd:MD_Metadata_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fMetadata_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fMetadata_x005fPropertyType (-1920)

#endif

/* gmd__DS_x005fDataSet_x005fPropertyType * has binding name 'PointerTogmd__DS_x005fDataSet_x005fPropertyType' for type 'gmd:DS_DataSet_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DS_x005fDataSet_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__DS_x005fDataSet_x005fPropertyType (-1918)

#endif

/* gml__ArrayAssociationType * has binding name 'PointerTogml__ArrayAssociationType' for type 'gml:ArrayAssociationType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ArrayAssociationType
#define SOAP_TYPE_plu_PointerTogml__ArrayAssociationType (-1917)

#endif

/* gml__OperationParameterGroupPropertyType * has binding name 'PointerTogml__OperationParameterGroupPropertyType' for type 'gml:OperationParameterGroupPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__OperationParameterGroupPropertyType
#define SOAP_TYPE_plu_PointerTogml__OperationParameterGroupPropertyType (-1915)

#endif

/* __gml__union_ParameterValueGroupType * has binding name 'PointerTo__gml__union_ParameterValueGroupType' for type '-gml:union-ParameterValueGroupType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_ParameterValueGroupType
#define SOAP_TYPE_plu_PointerTo__gml__union_ParameterValueGroupType (-1913)

#endif

/* std::vector<gml__AbstractGeneralParameterValuePropertyType *> * has binding name 'PointerTostd__vectorTemplateOfPointerTogml__AbstractGeneralParameterValuePropertyType' for type 'gml:AbstractGeneralParameterValuePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTogml__AbstractGeneralParameterValuePropertyType
#define SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTogml__AbstractGeneralParameterValuePropertyType (-1912)

#endif

/* gml__AbstractGeneralParameterValuePropertyType * has binding name 'PointerTogml__AbstractGeneralParameterValuePropertyType' for type 'gml:AbstractGeneralParameterValuePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__AbstractGeneralParameterValuePropertyType
#define SOAP_TYPE_plu_PointerTogml__AbstractGeneralParameterValuePropertyType (-1910)

#endif

/* gml__OperationParameterPropertyType * has binding name 'PointerTogml__OperationParameterPropertyType' for type 'gml:OperationParameterPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__OperationParameterPropertyType
#define SOAP_TYPE_plu_PointerTogml__OperationParameterPropertyType (-1907)

#endif

/* gml__MeasureListType * has binding name 'PointerTogml__MeasureListType' for type 'gml:MeasureListType' */
#ifndef SOAP_TYPE_plu_PointerTogml__MeasureListType
#define SOAP_TYPE_plu_PointerTogml__MeasureListType (-1905)

#endif

/* gml__ValueArrayPropertyType * has binding name 'PointerTogml__ValueArrayPropertyType' for type 'gml:ValueArrayPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ValueArrayPropertyType
#define SOAP_TYPE_plu_PointerTogml__ValueArrayPropertyType (-1903)

#endif

/* gml__ValuePropertyType * has binding name 'PointerTogml__ValuePropertyType' for type 'gml:ValuePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ValuePropertyType
#define SOAP_TYPE_plu_PointerTogml__ValuePropertyType (-1901)

#endif

/* enum gml__TimeIndeterminateValueType * has binding name 'PointerTogml__TimeIndeterminateValueType' for type 'gml:TimeIndeterminateValueType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeIndeterminateValueType
#define SOAP_TYPE_plu_PointerTogml__TimeIndeterminateValueType (-1900)

#endif

/* enum _gml__RelatedTimeType_relativePosition * has binding name 'PointerTo_gml__RelatedTimeType_relativePosition' for type 'gml:RelatedTimeType-relativePosition' */
#ifndef SOAP_TYPE_plu_PointerTo_gml__RelatedTimeType_relativePosition
#define SOAP_TYPE_plu_PointerTo_gml__RelatedTimeType_relativePosition (-1899)

#endif

/* gml__TimePositionType * has binding name 'PointerTogml__TimePositionType' for type 'gml:TimePositionType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimePositionType
#define SOAP_TYPE_plu_PointerTogml__TimePositionType (-1897)

#endif

/* gml__PriorityLocationPropertyType * has binding name 'PointerTogml__PriorityLocationPropertyType' for type 'gml:PriorityLocationPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__PriorityLocationPropertyType
#define SOAP_TYPE_plu_PointerTogml__PriorityLocationPropertyType (-1896)

#endif

/* gml__LocationPropertyType * has binding name 'PointerTogml__LocationPropertyType' for type 'gml:LocationPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__LocationPropertyType
#define SOAP_TYPE_plu_PointerTogml__LocationPropertyType (-1895)

#endif

/* gml__BoundingShapeType * has binding name 'PointerTogml__BoundingShapeType' for type 'gml:BoundingShapeType' */
#ifndef SOAP_TYPE_plu_PointerTogml__BoundingShapeType
#define SOAP_TYPE_plu_PointerTogml__BoundingShapeType (-1893)

#endif

/* __gml__DictionaryEntryType_sequence * has binding name 'PointerTo__gml__DictionaryEntryType_sequence' for type '-gml:DictionaryEntryType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__DictionaryEntryType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__DictionaryEntryType_sequence (-1892)

#endif

/* gml__TimeOrdinalReferenceSystemType * has binding name 'PointerTogml__TimeOrdinalReferenceSystemType' for type 'gml:TimeOrdinalReferenceSystemType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeOrdinalReferenceSystemType
#define SOAP_TYPE_plu_PointerTogml__TimeOrdinalReferenceSystemType (-1891)

#endif

/* gml__TimeCoordinateSystemType * has binding name 'PointerTogml__TimeCoordinateSystemType' for type 'gml:TimeCoordinateSystemType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeCoordinateSystemType
#define SOAP_TYPE_plu_PointerTogml__TimeCoordinateSystemType (-1890)

#endif

/* gml__TimeReferenceSystemType * has binding name 'PointerTogml__TimeReferenceSystemType' for type 'gml:TimeReferenceSystemType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeReferenceSystemType
#define SOAP_TYPE_plu_PointerTogml__TimeReferenceSystemType (-1889)

#endif

/* gml__DictionaryType * has binding name 'PointerTogml__DictionaryType' for type 'gml:DictionaryType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DictionaryType
#define SOAP_TYPE_plu_PointerTogml__DictionaryType (-1888)

#endif

/* gml__DefinitionType * has binding name 'PointerTogml__DefinitionType' for type 'gml:DefinitionType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DefinitionType
#define SOAP_TYPE_plu_PointerTogml__DefinitionType (-1887)

#endif

/* gml__FormulaType * has binding name 'PointerTogml__FormulaType' for type 'gml:FormulaType' */
#ifndef SOAP_TYPE_plu_PointerTogml__FormulaType
#define SOAP_TYPE_plu_PointerTogml__FormulaType (-1884)

#endif

/* enum gml__AggregationType * has binding name 'PointerTogml__AggregationType' for type 'gml:AggregationType' */
#ifndef SOAP_TYPE_plu_PointerTogml__AggregationType
#define SOAP_TYPE_plu_PointerTogml__AggregationType (-1882)

#endif

/* enum gml__SurfaceInterpolationType * has binding name 'PointerTogml__SurfaceInterpolationType' for type 'gml:SurfaceInterpolationType' */
#ifndef SOAP_TYPE_plu_PointerTogml__SurfaceInterpolationType
#define SOAP_TYPE_plu_PointerTogml__SurfaceInterpolationType (-1881)

#endif

/* gml__AbstractRingPropertyType * has binding name 'PointerTogml__AbstractRingPropertyType' for type 'gml:AbstractRingPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__AbstractRingPropertyType
#define SOAP_TYPE_plu_PointerTogml__AbstractRingPropertyType (-1879)

#endif

/* __gml__union_GeodesicStringType_ * has binding name 'PointerTo__gml__union_GeodesicStringType_' for type '-gml:union-GeodesicStringType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_GeodesicStringType_
#define SOAP_TYPE_plu_PointerTo__gml__union_GeodesicStringType_ (-1878)

#endif

/* gml__CurvePropertyType * has binding name 'PointerTogml__CurvePropertyType' for type 'gml:CurvePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CurvePropertyType
#define SOAP_TYPE_plu_PointerTogml__CurvePropertyType (-1874)

#endif

/* enum gml__KnotTypesType * has binding name 'PointerTogml__KnotTypesType' for type 'gml:KnotTypesType' */
#ifndef SOAP_TYPE_plu_PointerTogml__KnotTypesType
#define SOAP_TYPE_plu_PointerTogml__KnotTypesType (-1873)

#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_plu_PointerTobool
#define SOAP_TYPE_plu_PointerTobool (-1872)

#endif

/* gml__KnotPropertyType * has binding name 'PointerTogml__KnotPropertyType' for type 'gml:KnotPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__KnotPropertyType
#define SOAP_TYPE_plu_PointerTogml__KnotPropertyType (-1870)

#endif

/* __gml__union_BSplineType_ * has binding name 'PointerTo__gml__union_BSplineType_' for type '-gml:union-BSplineType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_BSplineType_
#define SOAP_TYPE_plu_PointerTo__gml__union_BSplineType_ (-1869)

#endif

/* __gml__union_CubicSplineType_ * has binding name 'PointerTo__gml__union_CubicSplineType_' for type '-gml:union-CubicSplineType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_CubicSplineType_
#define SOAP_TYPE_plu_PointerTo__gml__union_CubicSplineType_ (-1864)

#endif

/* __gml__union_ArcStringByBulgeType_ * has binding name 'PointerTo__gml__union_ArcStringByBulgeType_' for type '-gml:union-ArcStringByBulgeType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_ArcStringByBulgeType_
#define SOAP_TYPE_plu_PointerTo__gml__union_ArcStringByBulgeType_ (-1857)

#endif

/* long * has binding name 'PointerTolong' for type 'xsd:long' */
#ifndef SOAP_TYPE_plu_PointerTolong
#define SOAP_TYPE_plu_PointerTolong (-1852)

#endif

/* __gml__union_ArcStringType_ * has binding name 'PointerTo__gml__union_ArcStringType_' for type '-gml:union-ArcStringType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_ArcStringType_
#define SOAP_TYPE_plu_PointerTo__gml__union_ArcStringType_ (-1851)

#endif

/* enum gml__CurveInterpolationType * has binding name 'PointerTogml__CurveInterpolationType' for type 'gml:CurveInterpolationType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CurveInterpolationType
#define SOAP_TYPE_plu_PointerTogml__CurveInterpolationType (-1846)

#endif

/* gml__DirectPositionListType * has binding name 'PointerTogml__DirectPositionListType' for type 'gml:DirectPositionListType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DirectPositionListType
#define SOAP_TYPE_plu_PointerTogml__DirectPositionListType (-1845)

#endif

/* __gml__union_LineStringSegmentType_ * has binding name 'PointerTo__gml__union_LineStringSegmentType_' for type '-gml:union-LineStringSegmentType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_LineStringSegmentType_
#define SOAP_TYPE_plu_PointerTo__gml__union_LineStringSegmentType_ (-1844)

#endif

/* gml__PointPropertyType * has binding name 'PointerTogml__PointPropertyType' for type 'gml:PointPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__PointPropertyType
#define SOAP_TYPE_plu_PointerTogml__PointPropertyType (-1843)

#endif

/* gml__TimePrimitivePropertyType * has binding name 'PointerTogml__TimePrimitivePropertyType' for type 'gml:TimePrimitivePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimePrimitivePropertyType
#define SOAP_TYPE_plu_PointerTogml__TimePrimitivePropertyType (-1838)

#endif

/* __gml__union_DynamicFeatureMemberType * has binding name 'PointerTo__gml__union_DynamicFeatureMemberType' for type '-gml:union-DynamicFeatureMemberType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_DynamicFeatureMemberType
#define SOAP_TYPE_plu_PointerTo__gml__union_DynamicFeatureMemberType (-1837)

#endif

/* std::vector<gml__DynamicFeatureType *> * has binding name 'PointerTostd__vectorTemplateOfPointerTogml__DynamicFeatureType' for type 'gml:DynamicFeatureType' */
#ifndef SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTogml__DynamicFeatureType
#define SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTogml__DynamicFeatureType (-1836)

#endif

/* std::vector<_base2__DocumentCitationType_specificReference> * has binding name 'PointerTostd__vectorTemplateOf_base2__DocumentCitationType_specificReference' for type '' */
#ifndef SOAP_TYPE_plu_PointerTostd__vectorTemplateOf_base2__DocumentCitationType_specificReference
#define SOAP_TYPE_plu_PointerTostd__vectorTemplateOf_base2__DocumentCitationType_specificReference (-1832)

#endif

/* std::vector<_base2__DocumentCitationType_link> * has binding name 'PointerTostd__vectorTemplateOf_base2__DocumentCitationType_link' for type '' */
#ifndef SOAP_TYPE_plu_PointerTostd__vectorTemplateOf_base2__DocumentCitationType_link
#define SOAP_TYPE_plu_PointerTostd__vectorTemplateOf_base2__DocumentCitationType_link (-1829)

#endif

/* _base2__DocumentCitationType_date * has binding name 'PointerTo_base2__DocumentCitationType_date' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_base2__DocumentCitationType_date
#define SOAP_TYPE_plu_PointerTo_base2__DocumentCitationType_date (-1826)

#endif

/* _base2__DocumentCitationType_shortName * has binding name 'PointerTo_base2__DocumentCitationType_shortName' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_base2__DocumentCitationType_shortName
#define SOAP_TYPE_plu_PointerTo_base2__DocumentCitationType_shortName (-1824)

#endif

/* __gsr__SC_x005fCRS_x005fPropertyType_sequence * has binding name 'PointerTo__gsr__SC_x005fCRS_x005fPropertyType_sequence' for type '-gsr:SC_CRS_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gsr__SC_x005fCRS_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gsr__SC_x005fCRS_x005fPropertyType_sequence (-1822)

#endif

/* __gts__TM_x005fPeriodDuration_x005fPropertyType_sequence * has binding name 'PointerTo__gts__TM_x005fPeriodDuration_x005fPropertyType_sequence' for type '-gts:TM_PeriodDuration_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gts__TM_x005fPeriodDuration_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gts__TM_x005fPeriodDuration_x005fPropertyType_sequence (-1819)

#endif

/* __gts__TM_x005fPrimitive_x005fPropertyType_sequence * has binding name 'PointerTo__gts__TM_x005fPrimitive_x005fPropertyType_sequence' for type '-gts:TM_Primitive_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gts__TM_x005fPrimitive_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gts__TM_x005fPrimitive_x005fPropertyType_sequence (-1817)

#endif

/* __gss__GM_x005fObject_x005fPropertyType_sequence * has binding name 'PointerTo__gss__GM_x005fObject_x005fPropertyType_sequence' for type '-gss:GM_Object_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gss__GM_x005fObject_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gss__GM_x005fObject_x005fPropertyType_sequence (-1814)

#endif

/* __gss__GM_x005fPoint_x005fPropertyType_sequence * has binding name 'PointerTo__gss__GM_x005fPoint_x005fPropertyType_sequence' for type '-gss:GM_Point_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gss__GM_x005fPoint_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gss__GM_x005fPoint_x005fPropertyType_sequence (-1811)

#endif

/* __gco__Binary_x005fPropertyType_sequence * has binding name 'PointerTo__gco__Binary_x005fPropertyType_sequence' for type '-gco:Binary_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__Binary_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__Binary_x005fPropertyType_sequence (-1809)

#endif

/* gco__Binary_x005fType * has binding name 'PointerTogco__Binary_x005fType' for type 'gco:Binary_Type' */
#ifndef SOAP_TYPE_plu_PointerTogco__Binary_x005fType
#define SOAP_TYPE_plu_PointerTogco__Binary_x005fType (-1808)

#endif

/* __gco__RecordType_x005fPropertyType_sequence * has binding name 'PointerTo__gco__RecordType_x005fPropertyType_sequence' for type '-gco:RecordType_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__RecordType_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__RecordType_x005fPropertyType_sequence (-1806)

#endif

/* gco__RecordType_x005fType * has binding name 'PointerTogco__RecordType_x005fType' for type 'gco:RecordType_Type' */
#ifndef SOAP_TYPE_plu_PointerTogco__RecordType_x005fType
#define SOAP_TYPE_plu_PointerTogco__RecordType_x005fType (-1805)

#endif

/* __gco__Record_x005fPropertyType_sequence * has binding name 'PointerTo__gco__Record_x005fPropertyType_sequence' for type '-gco:Record_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__Record_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__Record_x005fPropertyType_sequence (-1803)

#endif

/* __gco__UnlimitedInteger_x005fPropertyType_sequence * has binding name 'PointerTo__gco__UnlimitedInteger_x005fPropertyType_sequence' for type '-gco:UnlimitedInteger_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__UnlimitedInteger_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__UnlimitedInteger_x005fPropertyType_sequence (-1801)

#endif

/* gco__UnlimitedInteger_x005fType * has binding name 'PointerTogco__UnlimitedInteger_x005fType' for type 'gco:UnlimitedInteger_Type' */
#ifndef SOAP_TYPE_plu_PointerTogco__UnlimitedInteger_x005fType
#define SOAP_TYPE_plu_PointerTogco__UnlimitedInteger_x005fType (-1800)

#endif

/* __gco__Integer_x005fPropertyType_sequence * has binding name 'PointerTo__gco__Integer_x005fPropertyType_sequence' for type '-gco:Integer_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__Integer_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__Integer_x005fPropertyType_sequence (-1798)

#endif

/* __gco__Real_x005fPropertyType_sequence * has binding name 'PointerTo__gco__Real_x005fPropertyType_sequence' for type '-gco:Real_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__Real_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__Real_x005fPropertyType_sequence (-1796)

#endif

/* __gco__Decimal_x005fPropertyType_sequence * has binding name 'PointerTo__gco__Decimal_x005fPropertyType_sequence' for type '-gco:Decimal_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__Decimal_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__Decimal_x005fPropertyType_sequence (-1794)

#endif

/* double * has binding name 'PointerToxsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_plu_PointerToxsd__decimal
#define SOAP_TYPE_plu_PointerToxsd__decimal (-1792)

#endif

/* std::string * has binding name 'PointerTogco__Date_x005fType' for type 'gco:Date_Type' */
#ifndef SOAP_TYPE_plu_PointerTogco__Date_x005fType
#define SOAP_TYPE_plu_PointerTogco__Date_x005fType (-1790)

#endif

/* __gco__DateTime_x005fPropertyType_sequence * has binding name 'PointerTo__gco__DateTime_x005fPropertyType_sequence' for type '-gco:DateTime_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__DateTime_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__DateTime_x005fPropertyType_sequence (-1788)

#endif

/* __gco__UomVolume_x005fPropertyType_sequence * has binding name 'PointerTo__gco__UomVolume_x005fPropertyType_sequence' for type '-gco:UomVolume_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__UomVolume_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__UomVolume_x005fPropertyType_sequence (-1786)

#endif

/* __gco__UomTime_x005fPropertyType_sequence * has binding name 'PointerTo__gco__UomTime_x005fPropertyType_sequence' for type '-gco:UomTime_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__UomTime_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__UomTime_x005fPropertyType_sequence (-1783)

#endif

/* __gco__UomVelocity_x005fPropertyType_sequence * has binding name 'PointerTo__gco__UomVelocity_x005fPropertyType_sequence' for type '-gco:UomVelocity_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__UomVelocity_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__UomVelocity_x005fPropertyType_sequence (-1780)

#endif

/* __gco__UomArea_x005fPropertyType_sequence * has binding name 'PointerTo__gco__UomArea_x005fPropertyType_sequence' for type '-gco:UomArea_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__UomArea_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__UomArea_x005fPropertyType_sequence (-1777)

#endif

/* __gco__UnitOfMeasure_x005fPropertyType_sequence * has binding name 'PointerTo__gco__UnitOfMeasure_x005fPropertyType_sequence' for type '-gco:UnitOfMeasure_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__UnitOfMeasure_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__UnitOfMeasure_x005fPropertyType_sequence (-1774)

#endif

/* __gco__UomScale_x005fPropertyType_sequence * has binding name 'PointerTo__gco__UomScale_x005fPropertyType_sequence' for type '-gco:UomScale_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__UomScale_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__UomScale_x005fPropertyType_sequence (-1771)

#endif

/* __gco__UomLength_x005fPropertyType_sequence * has binding name 'PointerTo__gco__UomLength_x005fPropertyType_sequence' for type '-gco:UomLength_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__UomLength_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__UomLength_x005fPropertyType_sequence (-1768)

#endif

/* __gco__UomAngle_x005fPropertyType_sequence * has binding name 'PointerTo__gco__UomAngle_x005fPropertyType_sequence' for type '-gco:UomAngle_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__UomAngle_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__UomAngle_x005fPropertyType_sequence (-1765)

#endif

/* gml__ConventionalUnitType * has binding name 'PointerTogml__ConventionalUnitType' for type 'gml:ConventionalUnitType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ConventionalUnitType
#define SOAP_TYPE_plu_PointerTogml__ConventionalUnitType (-1764)

#endif

/* gml__DerivedUnitType * has binding name 'PointerTogml__DerivedUnitType' for type 'gml:DerivedUnitType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DerivedUnitType
#define SOAP_TYPE_plu_PointerTogml__DerivedUnitType (-1763)

#endif

/* gml__BaseUnitType * has binding name 'PointerTogml__BaseUnitType' for type 'gml:BaseUnitType' */
#ifndef SOAP_TYPE_plu_PointerTogml__BaseUnitType
#define SOAP_TYPE_plu_PointerTogml__BaseUnitType (-1762)

#endif

/* gml__UnitDefinitionType * has binding name 'PointerTogml__UnitDefinitionType' for type 'gml:UnitDefinitionType' */
#ifndef SOAP_TYPE_plu_PointerTogml__UnitDefinitionType
#define SOAP_TYPE_plu_PointerTogml__UnitDefinitionType (-1761)

#endif

/* __gco__ScopedName_x005fPropertyType_sequence * has binding name 'PointerTo__gco__ScopedName_x005fPropertyType_sequence' for type '-gco:ScopedName_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__ScopedName_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__ScopedName_x005fPropertyType_sequence (-1758)

#endif

/* __gco__LocalName_x005fPropertyType_sequence * has binding name 'PointerTo__gco__LocalName_x005fPropertyType_sequence' for type '-gco:LocalName_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__LocalName_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__LocalName_x005fPropertyType_sequence (-1756)

#endif

/* __gco__GenericName_x005fPropertyType_sequence * has binding name 'PointerTo__gco__GenericName_x005fPropertyType_sequence' for type '-gco:GenericName_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__GenericName_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__GenericName_x005fPropertyType_sequence (-1754)

#endif

/* __gco__Boolean_x005fPropertyType_sequence * has binding name 'PointerTo__gco__Boolean_x005fPropertyType_sequence' for type '-gco:Boolean_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__Boolean_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__Boolean_x005fPropertyType_sequence (-1751)

#endif

/* __gco__CharacterString_x005fPropertyType_sequence * has binding name 'PointerTo__gco__CharacterString_x005fPropertyType_sequence' for type '-gco:CharacterString_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__CharacterString_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__CharacterString_x005fPropertyType_sequence (-1749)

#endif

/* gmd__LocalisedCharacterString_x005fType * has binding name 'PointerTogmd__LocalisedCharacterString_x005fType' for type 'gmd:LocalisedCharacterString_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__LocalisedCharacterString_x005fType
#define SOAP_TYPE_plu_PointerTogmd__LocalisedCharacterString_x005fType (-1748)

#endif

/* __gco__Distance_x005fPropertyType_sequence * has binding name 'PointerTo__gco__Distance_x005fPropertyType_sequence' for type '-gco:Distance_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__Distance_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__Distance_x005fPropertyType_sequence (-1745)

#endif

/* __gco__Scale_x005fPropertyType_sequence * has binding name 'PointerTo__gco__Scale_x005fPropertyType_sequence' for type '-gco:Scale_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__Scale_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__Scale_x005fPropertyType_sequence (-1743)

#endif

/* __gco__Angle_x005fPropertyType_sequence * has binding name 'PointerTo__gco__Angle_x005fPropertyType_sequence' for type '-gco:Angle_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__Angle_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__Angle_x005fPropertyType_sequence (-1741)

#endif

/* __gco__Length_x005fPropertyType_sequence * has binding name 'PointerTo__gco__Length_x005fPropertyType_sequence' for type '-gco:Length_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__Length_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__Length_x005fPropertyType_sequence (-1739)

#endif

/* __gco__Measure_x005fPropertyType_sequence * has binding name 'PointerTo__gco__Measure_x005fPropertyType_sequence' for type '-gco:Measure_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__Measure_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__Measure_x005fPropertyType_sequence (-1736)

#endif

/* gml__ScaleType * has binding name 'PointerTogml__ScaleType' for type 'gml:ScaleType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ScaleType
#define SOAP_TYPE_plu_PointerTogml__ScaleType (-1735)

#endif

/* __gco__MultiplicityRange_x005fPropertyType_sequence * has binding name 'PointerTo__gco__MultiplicityRange_x005fPropertyType_sequence' for type '-gco:MultiplicityRange_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__MultiplicityRange_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__MultiplicityRange_x005fPropertyType_sequence (-1732)

#endif

/* gco__MultiplicityRange_x005fType * has binding name 'PointerTogco__MultiplicityRange_x005fType' for type 'gco:MultiplicityRange_Type' */
#ifndef SOAP_TYPE_plu_PointerTogco__MultiplicityRange_x005fType
#define SOAP_TYPE_plu_PointerTogco__MultiplicityRange_x005fType (-1731)

#endif

/* __gco__Multiplicity_x005fPropertyType_sequence * has binding name 'PointerTo__gco__Multiplicity_x005fPropertyType_sequence' for type '-gco:Multiplicity_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__Multiplicity_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__Multiplicity_x005fPropertyType_sequence (-1729)

#endif

/* gco__Multiplicity_x005fType * has binding name 'PointerTogco__Multiplicity_x005fType' for type 'gco:Multiplicity_Type' */
#ifndef SOAP_TYPE_plu_PointerTogco__Multiplicity_x005fType
#define SOAP_TYPE_plu_PointerTogco__Multiplicity_x005fType (-1728)

#endif

/* __gco__MemberName_x005fPropertyType_sequence * has binding name 'PointerTo__gco__MemberName_x005fPropertyType_sequence' for type '-gco:MemberName_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__MemberName_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__MemberName_x005fPropertyType_sequence (-1726)

#endif

/* gco__MemberName_x005fType * has binding name 'PointerTogco__MemberName_x005fType' for type 'gco:MemberName_Type' */
#ifndef SOAP_TYPE_plu_PointerTogco__MemberName_x005fType
#define SOAP_TYPE_plu_PointerTogco__MemberName_x005fType (-1725)

#endif

/* __gco__TypeName_x005fPropertyType_sequence * has binding name 'PointerTo__gco__TypeName_x005fPropertyType_sequence' for type '-gco:TypeName_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gco__TypeName_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gco__TypeName_x005fPropertyType_sequence (-1723)

#endif

/* gco__TypeName_x005fType * has binding name 'PointerTogco__TypeName_x005fType' for type 'gco:TypeName_Type' */
#ifndef SOAP_TYPE_plu_PointerTogco__TypeName_x005fType
#define SOAP_TYPE_plu_PointerTogco__TypeName_x005fType (-1722)

#endif

/* char ** has binding name 'PointerToxlink__toType' for type 'xlink:toType' */
#ifndef SOAP_TYPE_plu_PointerToxlink__toType
#define SOAP_TYPE_plu_PointerToxlink__toType (-1720)

#endif

/* char ** has binding name 'PointerToxlink__fromType' for type 'xlink:fromType' */
#ifndef SOAP_TYPE_plu_PointerToxlink__fromType
#define SOAP_TYPE_plu_PointerToxlink__fromType (-1719)

#endif

/* __xlink__union_arcType * has binding name 'PointerTo__xlink__union_arcType' for type '-xlink:union-arcType' */
#ifndef SOAP_TYPE_plu_PointerTo__xlink__union_arcType
#define SOAP_TYPE_plu_PointerTo__xlink__union_arcType (-1718)

#endif

/* __xlink__union_locatorType * has binding name 'PointerTo__xlink__union_locatorType' for type '-xlink:union-locatorType' */
#ifndef SOAP_TYPE_plu_PointerTo__xlink__union_locatorType
#define SOAP_TYPE_plu_PointerTo__xlink__union_locatorType (-1715)

#endif

/* char ** has binding name 'PointerToxlink__labelType' for type 'xlink:labelType' */
#ifndef SOAP_TYPE_plu_PointerToxlink__labelType
#define SOAP_TYPE_plu_PointerToxlink__labelType (-1712)

#endif

/* char ** has binding name 'PointerTo_xml__lang' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_xml__lang
#define SOAP_TYPE_plu_PointerTo_xml__lang (-1711)

#endif

/* __xlink__union_extended * has binding name 'PointerTo__xlink__union_extended' for type '-xlink:union-extended' */
#ifndef SOAP_TYPE_plu_PointerTo__xlink__union_extended
#define SOAP_TYPE_plu_PointerTo__xlink__union_extended (-1710)

#endif

/* __gmd__Country_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__Country_x005fPropertyType_sequence' for type '-gmd:Country_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__Country_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__Country_x005fPropertyType_sequence (-1707)

#endif

/* __gmd__LanguageCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__LanguageCode_x005fPropertyType_sequence' for type '-gmd:LanguageCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__LanguageCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__LanguageCode_x005fPropertyType_sequence (-1705)

#endif

/* __gmd__PT_x005fLocaleContainer_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__PT_x005fLocaleContainer_x005fPropertyType_sequence' for type '-gmd:PT_LocaleContainer_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__PT_x005fLocaleContainer_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__PT_x005fLocaleContainer_x005fPropertyType_sequence (-1703)

#endif

/* gmd__PT_x005fLocaleContainer_x005fType * has binding name 'PointerTogmd__PT_x005fLocaleContainer_x005fType' for type 'gmd:PT_LocaleContainer_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__PT_x005fLocaleContainer_x005fType
#define SOAP_TYPE_plu_PointerTogmd__PT_x005fLocaleContainer_x005fType (-1702)

#endif

/* gmd__LocalisedCharacterString_x005fPropertyType * has binding name 'PointerTogmd__LocalisedCharacterString_x005fPropertyType' for type 'gmd:LocalisedCharacterString_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__LocalisedCharacterString_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__LocalisedCharacterString_x005fPropertyType (-1699)

#endif

/* gmd__CI_x005fResponsibleParty_x005fPropertyType * has binding name 'PointerTogmd__CI_x005fResponsibleParty_x005fPropertyType' for type 'gmd:CI_ResponsibleParty_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__CI_x005fResponsibleParty_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__CI_x005fResponsibleParty_x005fPropertyType (-1697)

#endif

/* gmd__CI_x005fDate_x005fPropertyType * has binding name 'PointerTogmd__CI_x005fDate_x005fPropertyType' for type 'gmd:CI_Date_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__CI_x005fDate_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__CI_x005fDate_x005fPropertyType (-1695)

#endif

/* gmd__PT_x005fLocale_x005fPropertyType * has binding name 'PointerTogmd__PT_x005fLocale_x005fPropertyType' for type 'gmd:PT_Locale_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__PT_x005fLocale_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__PT_x005fLocale_x005fPropertyType (-1694)

#endif

/* __gmd__PT_x005fLocale_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__PT_x005fLocale_x005fPropertyType_sequence' for type '-gmd:PT_Locale_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__PT_x005fLocale_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__PT_x005fLocale_x005fPropertyType_sequence (-1693)

#endif

/* gmd__PT_x005fLocale_x005fType * has binding name 'PointerTogmd__PT_x005fLocale_x005fType' for type 'gmd:PT_Locale_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__PT_x005fLocale_x005fType
#define SOAP_TYPE_plu_PointerTogmd__PT_x005fLocale_x005fType (-1692)

#endif

/* __gmd__MD_x005fScopeCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fScopeCode_x005fPropertyType_sequence' for type '-gmd:MD_ScopeCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fScopeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fScopeCode_x005fPropertyType_sequence (-1690)

#endif

/* __gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType_sequence' for type '-gmd:MD_MaintenanceFrequencyCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fMaintenanceFrequencyCode_x005fPropertyType_sequence (-1688)

#endif

/* __gmd__MD_x005fScopeDescription_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fScopeDescription_x005fPropertyType_sequence' for type '-gmd:MD_ScopeDescription_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fScopeDescription_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fScopeDescription_x005fPropertyType_sequence (-1686)

#endif

/* gmd__MD_x005fScopeDescription_x005fType * has binding name 'PointerTogmd__MD_x005fScopeDescription_x005fType' for type 'gmd:MD_ScopeDescription_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fScopeDescription_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fScopeDescription_x005fType (-1685)

#endif

/* gco__CharacterString_x005fPropertyType * has binding name 'PointerTogco__CharacterString_x005fPropertyType' for type 'gco:CharacterString_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogco__CharacterString_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogco__CharacterString_x005fPropertyType (-1683)

#endif

/* std::vector<gco__ObjectReference_x005fPropertyType *> * has binding name 'PointerTostd__vectorTemplateOfPointerTogco__ObjectReference_x005fPropertyType' for type 'gco:ObjectReference_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTogco__ObjectReference_x005fPropertyType
#define SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTogco__ObjectReference_x005fPropertyType (-1682)

#endif

/* gco__ObjectReference_x005fPropertyType * has binding name 'PointerTogco__ObjectReference_x005fPropertyType' for type 'gco:ObjectReference_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogco__ObjectReference_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogco__ObjectReference_x005fPropertyType (-1680)

#endif

/* __gmd__MD_x005fMaintenanceInformation_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fMaintenanceInformation_x005fPropertyType_sequence' for type '-gmd:MD_MaintenanceInformation_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fMaintenanceInformation_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fMaintenanceInformation_x005fPropertyType_sequence (-1678)

#endif

/* gmd__MD_x005fMaintenanceInformation_x005fType * has binding name 'PointerTogmd__MD_x005fMaintenanceInformation_x005fType' for type 'gmd:MD_MaintenanceInformation_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fMaintenanceInformation_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fMaintenanceInformation_x005fType (-1677)

#endif

/* __gmd__MD_x005fMediumNameCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fMediumNameCode_x005fPropertyType_sequence' for type '-gmd:MD_MediumNameCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fMediumNameCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fMediumNameCode_x005fPropertyType_sequence (-1675)

#endif

/* __gmd__MD_x005fMediumFormatCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fMediumFormatCode_x005fPropertyType_sequence' for type '-gmd:MD_MediumFormatCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fMediumFormatCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fMediumFormatCode_x005fPropertyType_sequence (-1673)

#endif

/* __gmd__MD_x005fDistributionUnits_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fDistributionUnits_x005fPropertyType_sequence' for type '-gmd:MD_DistributionUnits_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fDistributionUnits_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fDistributionUnits_x005fPropertyType_sequence (-1671)

#endif

/* __gmd__MD_x005fFormat_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fFormat_x005fPropertyType_sequence' for type '-gmd:MD_Format_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fFormat_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fFormat_x005fPropertyType_sequence (-1669)

#endif

/* gmd__MD_x005fFormat_x005fType * has binding name 'PointerTogmd__MD_x005fFormat_x005fType' for type 'gmd:MD_Format_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fFormat_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fFormat_x005fType (-1668)

#endif

/* __gmd__MD_x005fDistribution_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fDistribution_x005fPropertyType_sequence' for type '-gmd:MD_Distribution_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fDistribution_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fDistribution_x005fPropertyType_sequence (-1666)

#endif

/* gmd__MD_x005fDistribution_x005fType * has binding name 'PointerTogmd__MD_x005fDistribution_x005fType' for type 'gmd:MD_Distribution_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fDistribution_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fDistribution_x005fType (-1665)

#endif

/* __gmd__MD_x005fDistributor_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fDistributor_x005fPropertyType_sequence' for type '-gmd:MD_Distributor_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fDistributor_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fDistributor_x005fPropertyType_sequence (-1663)

#endif

/* gmd__MD_x005fDistributor_x005fType * has binding name 'PointerTogmd__MD_x005fDistributor_x005fType' for type 'gmd:MD_Distributor_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fDistributor_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fDistributor_x005fType (-1662)

#endif

/* __gmd__MD_x005fStandardOrderProcess_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fStandardOrderProcess_x005fPropertyType_sequence' for type '-gmd:MD_StandardOrderProcess_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fStandardOrderProcess_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fStandardOrderProcess_x005fPropertyType_sequence (-1660)

#endif

/* gmd__MD_x005fStandardOrderProcess_x005fType * has binding name 'PointerTogmd__MD_x005fStandardOrderProcess_x005fType' for type 'gmd:MD_StandardOrderProcess_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fStandardOrderProcess_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fStandardOrderProcess_x005fType (-1659)

#endif

/* __gmd__MD_x005fDigitalTransferOptions_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fDigitalTransferOptions_x005fPropertyType_sequence' for type '-gmd:MD_DigitalTransferOptions_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fDigitalTransferOptions_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fDigitalTransferOptions_x005fPropertyType_sequence (-1657)

#endif

/* gmd__MD_x005fDigitalTransferOptions_x005fType * has binding name 'PointerTogmd__MD_x005fDigitalTransferOptions_x005fType' for type 'gmd:MD_DigitalTransferOptions_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fDigitalTransferOptions_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fDigitalTransferOptions_x005fType (-1656)

#endif

/* __gmd__MD_x005fMedium_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fMedium_x005fPropertyType_sequence' for type '-gmd:MD_Medium_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fMedium_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fMedium_x005fPropertyType_sequence (-1654)

#endif

/* gmd__MD_x005fMedium_x005fType * has binding name 'PointerTogmd__MD_x005fMedium_x005fType' for type 'gmd:MD_Medium_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fMedium_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fMedium_x005fType (-1653)

#endif

/* __gmd__MD_x005fRestrictionCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fRestrictionCode_x005fPropertyType_sequence' for type '-gmd:MD_RestrictionCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fRestrictionCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fRestrictionCode_x005fPropertyType_sequence (-1651)

#endif

/* __gmd__MD_x005fClassificationCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fClassificationCode_x005fPropertyType_sequence' for type '-gmd:MD_ClassificationCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fClassificationCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fClassificationCode_x005fPropertyType_sequence (-1649)

#endif

/* __gmd__MD_x005fSecurityConstraints_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fSecurityConstraints_x005fPropertyType_sequence' for type '-gmd:MD_SecurityConstraints_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fSecurityConstraints_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fSecurityConstraints_x005fPropertyType_sequence (-1647)

#endif

/* __gmd__MD_x005fLegalConstraints_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fLegalConstraints_x005fPropertyType_sequence' for type '-gmd:MD_LegalConstraints_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fLegalConstraints_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fLegalConstraints_x005fPropertyType_sequence (-1645)

#endif

/* __gmd__MD_x005fConstraints_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fConstraints_x005fPropertyType_sequence' for type '-gmd:MD_Constraints_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fConstraints_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fConstraints_x005fPropertyType_sequence (-1643)

#endif

/* gmd__MD_x005fSecurityConstraints_x005fType * has binding name 'PointerTogmd__MD_x005fSecurityConstraints_x005fType' for type 'gmd:MD_SecurityConstraints_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fSecurityConstraints_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fSecurityConstraints_x005fType (-1642)

#endif

/* gmd__MD_x005fLegalConstraints_x005fType * has binding name 'PointerTogmd__MD_x005fLegalConstraints_x005fType' for type 'gmd:MD_LegalConstraints_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fLegalConstraints_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fLegalConstraints_x005fType (-1641)

#endif

/* gmd__MD_x005fConstraints_x005fType * has binding name 'PointerTogmd__MD_x005fConstraints_x005fType' for type 'gmd:MD_Constraints_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fConstraints_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fConstraints_x005fType (-1640)

#endif

/* __gmd__DS_x005fInitiativeTypeCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DS_x005fInitiativeTypeCode_x005fPropertyType_sequence' for type '-gmd:DS_InitiativeTypeCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DS_x005fInitiativeTypeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DS_x005fInitiativeTypeCode_x005fPropertyType_sequence (-1637)

#endif

/* __gmd__DS_x005fAssociationTypeCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DS_x005fAssociationTypeCode_x005fPropertyType_sequence' for type '-gmd:DS_AssociationTypeCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DS_x005fAssociationTypeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DS_x005fAssociationTypeCode_x005fPropertyType_sequence (-1635)

#endif

/* __gmd__MD_x005fKeywordTypeCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fKeywordTypeCode_x005fPropertyType_sequence' for type '-gmd:MD_KeywordTypeCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fKeywordTypeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fKeywordTypeCode_x005fPropertyType_sequence (-1633)

#endif

/* __gmd__MD_x005fProgressCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fProgressCode_x005fPropertyType_sequence' for type '-gmd:MD_ProgressCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fProgressCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fProgressCode_x005fPropertyType_sequence (-1631)

#endif

/* __gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType_sequence' for type '-gmd:MD_SpatialRepresentationTypeCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType_sequence (-1629)

#endif

/* __gmd__MD_x005fCharacterSetCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fCharacterSetCode_x005fPropertyType_sequence' for type '-gmd:MD_CharacterSetCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fCharacterSetCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fCharacterSetCode_x005fPropertyType_sequence (-1627)

#endif

/* __gmd__MD_x005fTopicCategoryCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fTopicCategoryCode_x005fPropertyType_sequence' for type '-gmd:MD_TopicCategoryCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fTopicCategoryCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fTopicCategoryCode_x005fPropertyType_sequence (-1625)

#endif

/* __gmd__MD_x005fResolution_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fResolution_x005fPropertyType_sequence' for type '-gmd:MD_Resolution_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fResolution_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fResolution_x005fPropertyType_sequence (-1623)

#endif

/* gmd__MD_x005fResolution_x005fType * has binding name 'PointerTogmd__MD_x005fResolution_x005fType' for type 'gmd:MD_Resolution_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fResolution_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fResolution_x005fType (-1622)

#endif

/* gco__Distance_x005fPropertyType * has binding name 'PointerTogco__Distance_x005fPropertyType' for type 'gco:Distance_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogco__Distance_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogco__Distance_x005fPropertyType (-1620)

#endif

/* gmd__MD_x005fRepresentativeFraction_x005fPropertyType * has binding name 'PointerTogmd__MD_x005fRepresentativeFraction_x005fPropertyType' for type 'gmd:MD_RepresentativeFraction_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fRepresentativeFraction_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fRepresentativeFraction_x005fPropertyType (-1619)

#endif

/* __gmd__MD_x005fAggregateInformation_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fAggregateInformation_x005fPropertyType_sequence' for type '-gmd:MD_AggregateInformation_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fAggregateInformation_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fAggregateInformation_x005fPropertyType_sequence (-1617)

#endif

/* gmd__MD_x005fAggregateInformation_x005fType * has binding name 'PointerTogmd__MD_x005fAggregateInformation_x005fType' for type 'gmd:MD_AggregateInformation_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fAggregateInformation_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fAggregateInformation_x005fType (-1616)

#endif

/* __gmd__DS_x005fAssociation_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DS_x005fAssociation_x005fPropertyType_sequence' for type '-gmd:DS_Association_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DS_x005fAssociation_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DS_x005fAssociation_x005fPropertyType_sequence (-1614)

#endif

/* gmd__DS_x005fAssociation_x005fType * has binding name 'PointerTogmd__DS_x005fAssociation_x005fType' for type 'gmd:DS_Association_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DS_x005fAssociation_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DS_x005fAssociation_x005fType (-1613)

#endif

/* __gmd__MD_x005fKeywords_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fKeywords_x005fPropertyType_sequence' for type '-gmd:MD_Keywords_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fKeywords_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fKeywords_x005fPropertyType_sequence (-1611)

#endif

/* gmd__MD_x005fKeywords_x005fType * has binding name 'PointerTogmd__MD_x005fKeywords_x005fType' for type 'gmd:MD_Keywords_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fKeywords_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fKeywords_x005fType (-1610)

#endif

/* __gmd__MD_x005fUsage_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fUsage_x005fPropertyType_sequence' for type '-gmd:MD_Usage_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fUsage_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fUsage_x005fPropertyType_sequence (-1608)

#endif

/* gmd__MD_x005fUsage_x005fType * has binding name 'PointerTogmd__MD_x005fUsage_x005fType' for type 'gmd:MD_Usage_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fUsage_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fUsage_x005fType (-1607)

#endif

/* __gmd__MD_x005fRepresentativeFraction_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fRepresentativeFraction_x005fPropertyType_sequence' for type '-gmd:MD_RepresentativeFraction_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fRepresentativeFraction_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fRepresentativeFraction_x005fPropertyType_sequence (-1605)

#endif

/* gmd__MD_x005fRepresentativeFraction_x005fType * has binding name 'PointerTogmd__MD_x005fRepresentativeFraction_x005fType' for type 'gmd:MD_RepresentativeFraction_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fRepresentativeFraction_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fRepresentativeFraction_x005fType (-1604)

#endif

/* __gmd__MD_x005fServiceIdentification_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fServiceIdentification_x005fPropertyType_sequence' for type '-gmd:MD_ServiceIdentification_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fServiceIdentification_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fServiceIdentification_x005fPropertyType_sequence (-1602)

#endif

/* __gmd__MD_x005fDataIdentification_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fDataIdentification_x005fPropertyType_sequence' for type '-gmd:MD_DataIdentification_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fDataIdentification_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fDataIdentification_x005fPropertyType_sequence (-1600)

#endif

/* __gmd__MD_x005fBrowseGraphic_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fBrowseGraphic_x005fPropertyType_sequence' for type '-gmd:MD_BrowseGraphic_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fBrowseGraphic_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fBrowseGraphic_x005fPropertyType_sequence (-1598)

#endif

/* gmd__MD_x005fBrowseGraphic_x005fType * has binding name 'PointerTogmd__MD_x005fBrowseGraphic_x005fType' for type 'gmd:MD_BrowseGraphic_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fBrowseGraphic_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fBrowseGraphic_x005fType (-1597)

#endif

/* __gmd__MD_x005fIdentification_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fIdentification_x005fPropertyType_sequence' for type '-gmd:MD_Identification_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fIdentification_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fIdentification_x005fPropertyType_sequence (-1595)

#endif

/* gmd__MD_x005fServiceIdentification_x005fType * has binding name 'PointerTogmd__MD_x005fServiceIdentification_x005fType' for type 'gmd:MD_ServiceIdentification_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fServiceIdentification_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fServiceIdentification_x005fType (-1594)

#endif

/* gmd__MD_x005fDataIdentification_x005fType * has binding name 'PointerTogmd__MD_x005fDataIdentification_x005fType' for type 'gmd:MD_DataIdentification_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fDataIdentification_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fDataIdentification_x005fType (-1593)

#endif

/* __gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType_sequence' for type '-gmd:DQ_EvaluationMethodTypeCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fEvaluationMethodTypeCode_x005fPropertyType_sequence (-1590)

#endif

/* __gmd__DQ_x005fScope_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fScope_x005fPropertyType_sequence' for type '-gmd:DQ_Scope_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fScope_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fScope_x005fPropertyType_sequence (-1588)

#endif

/* gmd__DQ_x005fScope_x005fType * has binding name 'PointerTogmd__DQ_x005fScope_x005fType' for type 'gmd:DQ_Scope_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fScope_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fScope_x005fType (-1587)

#endif

/* __gmd__DQ_x005fDataQuality_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fDataQuality_x005fPropertyType_sequence' for type '-gmd:DQ_DataQuality_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fDataQuality_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fDataQuality_x005fPropertyType_sequence (-1585)

#endif

/* gmd__DQ_x005fDataQuality_x005fType * has binding name 'PointerTogmd__DQ_x005fDataQuality_x005fType' for type 'gmd:DQ_DataQuality_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fDataQuality_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fDataQuality_x005fType (-1584)

#endif

/* __gmd__DQ_x005fElement_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fElement_x005fPropertyType_sequence' for type '-gmd:DQ_Element_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fElement_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fElement_x005fPropertyType_sequence (-1582)

#endif

/* __gmd__DQ_x005fCompleteness_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fCompleteness_x005fPropertyType_sequence' for type '-gmd:DQ_Completeness_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fCompleteness_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fCompleteness_x005fPropertyType_sequence (-1579)

#endif

/* __gmd__DQ_x005fLogicalConsistency_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fLogicalConsistency_x005fPropertyType_sequence' for type '-gmd:DQ_LogicalConsistency_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fLogicalConsistency_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fLogicalConsistency_x005fPropertyType_sequence (-1576)

#endif

/* __gmd__DQ_x005fPositionalAccuracy_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fPositionalAccuracy_x005fPropertyType_sequence' for type '-gmd:DQ_PositionalAccuracy_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fPositionalAccuracy_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fPositionalAccuracy_x005fPropertyType_sequence (-1573)

#endif

/* __gmd__DQ_x005fThematicAccuracy_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fThematicAccuracy_x005fPropertyType_sequence' for type '-gmd:DQ_ThematicAccuracy_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fThematicAccuracy_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fThematicAccuracy_x005fPropertyType_sequence (-1570)

#endif

/* __gmd__DQ_x005fTemporalAccuracy_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fTemporalAccuracy_x005fPropertyType_sequence' for type '-gmd:DQ_TemporalAccuracy_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fTemporalAccuracy_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fTemporalAccuracy_x005fPropertyType_sequence (-1567)

#endif

/* __gmd__DQ_x005fCompletenessCommission_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fCompletenessCommission_x005fPropertyType_sequence' for type '-gmd:DQ_CompletenessCommission_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fCompletenessCommission_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fCompletenessCommission_x005fPropertyType_sequence (-1564)

#endif

/* gmd__DQ_x005fCompletenessCommission_x005fType * has binding name 'PointerTogmd__DQ_x005fCompletenessCommission_x005fType' for type 'gmd:DQ_CompletenessCommission_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fCompletenessCommission_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fCompletenessCommission_x005fType (-1563)

#endif

/* __gmd__DQ_x005fCompletenessOmission_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fCompletenessOmission_x005fPropertyType_sequence' for type '-gmd:DQ_CompletenessOmission_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fCompletenessOmission_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fCompletenessOmission_x005fPropertyType_sequence (-1561)

#endif

/* gmd__DQ_x005fCompletenessOmission_x005fType * has binding name 'PointerTogmd__DQ_x005fCompletenessOmission_x005fType' for type 'gmd:DQ_CompletenessOmission_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fCompletenessOmission_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fCompletenessOmission_x005fType (-1560)

#endif

/* __gmd__DQ_x005fConceptualConsistency_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fConceptualConsistency_x005fPropertyType_sequence' for type '-gmd:DQ_ConceptualConsistency_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fConceptualConsistency_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fConceptualConsistency_x005fPropertyType_sequence (-1558)

#endif

/* gmd__DQ_x005fConceptualConsistency_x005fType * has binding name 'PointerTogmd__DQ_x005fConceptualConsistency_x005fType' for type 'gmd:DQ_ConceptualConsistency_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fConceptualConsistency_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fConceptualConsistency_x005fType (-1557)

#endif

/* __gmd__DQ_x005fDomainConsistency_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fDomainConsistency_x005fPropertyType_sequence' for type '-gmd:DQ_DomainConsistency_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fDomainConsistency_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fDomainConsistency_x005fPropertyType_sequence (-1555)

#endif

/* gmd__DQ_x005fDomainConsistency_x005fType * has binding name 'PointerTogmd__DQ_x005fDomainConsistency_x005fType' for type 'gmd:DQ_DomainConsistency_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fDomainConsistency_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fDomainConsistency_x005fType (-1554)

#endif

/* __gmd__DQ_x005fFormatConsistency_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fFormatConsistency_x005fPropertyType_sequence' for type '-gmd:DQ_FormatConsistency_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fFormatConsistency_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fFormatConsistency_x005fPropertyType_sequence (-1552)

#endif

/* gmd__DQ_x005fFormatConsistency_x005fType * has binding name 'PointerTogmd__DQ_x005fFormatConsistency_x005fType' for type 'gmd:DQ_FormatConsistency_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fFormatConsistency_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fFormatConsistency_x005fType (-1551)

#endif

/* __gmd__DQ_x005fTopologicalConsistency_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fTopologicalConsistency_x005fPropertyType_sequence' for type '-gmd:DQ_TopologicalConsistency_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fTopologicalConsistency_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fTopologicalConsistency_x005fPropertyType_sequence (-1549)

#endif

/* gmd__DQ_x005fTopologicalConsistency_x005fType * has binding name 'PointerTogmd__DQ_x005fTopologicalConsistency_x005fType' for type 'gmd:DQ_TopologicalConsistency_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fTopologicalConsistency_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fTopologicalConsistency_x005fType (-1548)

#endif

/* __gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType_sequence' for type '-gmd:DQ_AbsoluteExternalPositionalAccuracy_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fPropertyType_sequence (-1546)

#endif

/* __gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType_sequence' for type '-gmd:DQ_GriddedDataPositionalAccuracy_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fPropertyType_sequence (-1544)

#endif

/* __gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType_sequence' for type '-gmd:DQ_RelativeInternalPositionalAccuracy_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fPropertyType_sequence (-1542)

#endif

/* __gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType_sequence' for type '-gmd:DQ_ThematicClassificationCorrectness_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fThematicClassificationCorrectness_x005fPropertyType_sequence (-1540)

#endif

/* gmd__DQ_x005fThematicClassificationCorrectness_x005fType * has binding name 'PointerTogmd__DQ_x005fThematicClassificationCorrectness_x005fType' for type 'gmd:DQ_ThematicClassificationCorrectness_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fThematicClassificationCorrectness_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fThematicClassificationCorrectness_x005fType (-1539)

#endif

/* __gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType_sequence' for type '-gmd:DQ_NonQuantitativeAttributeAccuracy_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fPropertyType_sequence (-1537)

#endif

/* gmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType * has binding name 'PointerTogmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType' for type 'gmd:DQ_NonQuantitativeAttributeAccuracy_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fNonQuantitativeAttributeAccuracy_x005fType (-1536)

#endif

/* __gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType_sequence' for type '-gmd:DQ_QuantitativeAttributeAccuracy_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fPropertyType_sequence (-1534)

#endif

/* gmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType * has binding name 'PointerTogmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType' for type 'gmd:DQ_QuantitativeAttributeAccuracy_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fQuantitativeAttributeAccuracy_x005fType (-1533)

#endif

/* __gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType_sequence' for type '-gmd:DQ_AccuracyOfATimeMeasurement_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fPropertyType_sequence (-1531)

#endif

/* gmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType * has binding name 'PointerTogmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType' for type 'gmd:DQ_AccuracyOfATimeMeasurement_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fAccuracyOfATimeMeasurement_x005fType (-1530)

#endif

/* __gmd__DQ_x005fTemporalConsistency_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fTemporalConsistency_x005fPropertyType_sequence' for type '-gmd:DQ_TemporalConsistency_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fTemporalConsistency_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fTemporalConsistency_x005fPropertyType_sequence (-1528)

#endif

/* gmd__DQ_x005fTemporalConsistency_x005fType * has binding name 'PointerTogmd__DQ_x005fTemporalConsistency_x005fType' for type 'gmd:DQ_TemporalConsistency_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fTemporalConsistency_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fTemporalConsistency_x005fType (-1527)

#endif

/* __gmd__DQ_x005fTemporalValidity_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fTemporalValidity_x005fPropertyType_sequence' for type '-gmd:DQ_TemporalValidity_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fTemporalValidity_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fTemporalValidity_x005fPropertyType_sequence (-1525)

#endif

/* gmd__DQ_x005fTemporalValidity_x005fType * has binding name 'PointerTogmd__DQ_x005fTemporalValidity_x005fType' for type 'gmd:DQ_TemporalValidity_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fTemporalValidity_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fTemporalValidity_x005fType (-1524)

#endif

/* __gmd__DQ_x005fResult_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fResult_x005fPropertyType_sequence' for type '-gmd:DQ_Result_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fResult_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fResult_x005fPropertyType_sequence (-1522)

#endif

/* __gmd__DQ_x005fQuantitativeResult_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fQuantitativeResult_x005fPropertyType_sequence' for type '-gmd:DQ_QuantitativeResult_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fQuantitativeResult_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fQuantitativeResult_x005fPropertyType_sequence (-1519)

#endif

/* gmd__DQ_x005fQuantitativeResult_x005fType * has binding name 'PointerTogmd__DQ_x005fQuantitativeResult_x005fType' for type 'gmd:DQ_QuantitativeResult_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fQuantitativeResult_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fQuantitativeResult_x005fType (-1518)

#endif

/* __gmd__DQ_x005fConformanceResult_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_x005fConformanceResult_x005fPropertyType_sequence' for type '-gmd:DQ_ConformanceResult_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fConformanceResult_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DQ_x005fConformanceResult_x005fPropertyType_sequence (-1516)

#endif

/* gmd__DQ_x005fConformanceResult_x005fType * has binding name 'PointerTogmd__DQ_x005fConformanceResult_x005fType' for type 'gmd:DQ_ConformanceResult_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fConformanceResult_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fConformanceResult_x005fType (-1515)

#endif

/* __gmd__LI_x005fLineage_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__LI_x005fLineage_x005fPropertyType_sequence' for type '-gmd:LI_Lineage_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__LI_x005fLineage_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__LI_x005fLineage_x005fPropertyType_sequence (-1513)

#endif

/* gmd__LI_x005fLineage_x005fType * has binding name 'PointerTogmd__LI_x005fLineage_x005fType' for type 'gmd:LI_Lineage_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__LI_x005fLineage_x005fType
#define SOAP_TYPE_plu_PointerTogmd__LI_x005fLineage_x005fType (-1512)

#endif

/* __gmd__LI_x005fSource_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__LI_x005fSource_x005fPropertyType_sequence' for type '-gmd:LI_Source_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__LI_x005fSource_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__LI_x005fSource_x005fPropertyType_sequence (-1510)

#endif

/* gmd__LI_x005fSource_x005fType * has binding name 'PointerTogmd__LI_x005fSource_x005fType' for type 'gmd:LI_Source_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__LI_x005fSource_x005fType
#define SOAP_TYPE_plu_PointerTogmd__LI_x005fSource_x005fType (-1509)

#endif

/* __gmd__LI_x005fProcessStep_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__LI_x005fProcessStep_x005fPropertyType_sequence' for type '-gmd:LI_ProcessStep_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__LI_x005fProcessStep_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__LI_x005fProcessStep_x005fPropertyType_sequence (-1507)

#endif

/* gmd__LI_x005fProcessStep_x005fType * has binding name 'PointerTogmd__LI_x005fProcessStep_x005fType' for type 'gmd:LI_ProcessStep_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__LI_x005fProcessStep_x005fType
#define SOAP_TYPE_plu_PointerTogmd__LI_x005fProcessStep_x005fType (-1506)

#endif

/* __gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType_sequence' for type '-gmd:MD_PortrayalCatalogueReference_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType_sequence (-1504)

#endif

/* gmd__MD_x005fPortrayalCatalogueReference_x005fType * has binding name 'PointerTogmd__MD_x005fPortrayalCatalogueReference_x005fType' for type 'gmd:MD_PortrayalCatalogueReference_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fPortrayalCatalogueReference_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fPortrayalCatalogueReference_x005fType (-1503)

#endif

/* __gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType_sequence' for type '-gmd:MD_ApplicationSchemaInformation_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType_sequence (-1501)

#endif

/* gmd__MD_x005fApplicationSchemaInformation_x005fType * has binding name 'PointerTogmd__MD_x005fApplicationSchemaInformation_x005fType' for type 'gmd:MD_ApplicationSchemaInformation_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fApplicationSchemaInformation_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fApplicationSchemaInformation_x005fType (-1500)

#endif

/* __gmd__MD_x005fImagingConditionCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fImagingConditionCode_x005fPropertyType_sequence' for type '-gmd:MD_ImagingConditionCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fImagingConditionCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fImagingConditionCode_x005fPropertyType_sequence (-1498)

#endif

/* __gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType_sequence' for type '-gmd:MD_CoverageContentTypeCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fCoverageContentTypeCode_x005fPropertyType_sequence (-1496)

#endif

/* __gmd__MD_x005fBand_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fBand_x005fPropertyType_sequence' for type '-gmd:MD_Band_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fBand_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fBand_x005fPropertyType_sequence (-1494)

#endif

/* __gmd__MD_x005fRangeDimension_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fRangeDimension_x005fPropertyType_sequence' for type '-gmd:MD_RangeDimension_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fRangeDimension_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fRangeDimension_x005fPropertyType_sequence (-1492)

#endif

/* gmd__MD_x005fBand_x005fType * has binding name 'PointerTogmd__MD_x005fBand_x005fType' for type 'gmd:MD_Band_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fBand_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fBand_x005fType (-1491)

#endif

/* gmd__MD_x005fRangeDimension_x005fType * has binding name 'PointerTogmd__MD_x005fRangeDimension_x005fType' for type 'gmd:MD_RangeDimension_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fRangeDimension_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fRangeDimension_x005fType (-1490)

#endif

/* __gmd__MD_x005fContentInformation_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fContentInformation_x005fPropertyType_sequence' for type '-gmd:MD_ContentInformation_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fContentInformation_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fContentInformation_x005fPropertyType_sequence (-1487)

#endif

/* __gmd__MD_x005fImageDescription_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fImageDescription_x005fPropertyType_sequence' for type '-gmd:MD_ImageDescription_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fImageDescription_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fImageDescription_x005fPropertyType_sequence (-1484)

#endif

/* __gmd__MD_x005fCoverageDescription_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fCoverageDescription_x005fPropertyType_sequence' for type '-gmd:MD_CoverageDescription_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fCoverageDescription_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fCoverageDescription_x005fPropertyType_sequence (-1482)

#endif

/* gmd__MD_x005fImageDescription_x005fType * has binding name 'PointerTogmd__MD_x005fImageDescription_x005fType' for type 'gmd:MD_ImageDescription_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fImageDescription_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fImageDescription_x005fType (-1481)

#endif

/* gmd__MD_x005fCoverageDescription_x005fType * has binding name 'PointerTogmd__MD_x005fCoverageDescription_x005fType' for type 'gmd:MD_CoverageDescription_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fCoverageDescription_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fCoverageDescription_x005fType (-1480)

#endif

/* __gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType_sequence' for type '-gmd:MD_FeatureCatalogueDescription_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fFeatureCatalogueDescription_x005fPropertyType_sequence (-1477)

#endif

/* gmd__MD_x005fFeatureCatalogueDescription_x005fType * has binding name 'PointerTogmd__MD_x005fFeatureCatalogueDescription_x005fType' for type 'gmd:MD_FeatureCatalogueDescription_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fFeatureCatalogueDescription_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fFeatureCatalogueDescription_x005fType (-1476)

#endif

/* __gmd__MD_x005fDatatypeCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fDatatypeCode_x005fPropertyType_sequence' for type '-gmd:MD_DatatypeCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fDatatypeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fDatatypeCode_x005fPropertyType_sequence (-1474)

#endif

/* __gmd__MD_x005fObligationCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fObligationCode_x005fPropertyType_sequence' for type '-gmd:MD_ObligationCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fObligationCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fObligationCode_x005fPropertyType_sequence (-1472)

#endif

/* __gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType_sequence' for type '-gmd:MD_MetadataExtensionInformation_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType_sequence (-1470)

#endif

/* gmd__MD_x005fMetadataExtensionInformation_x005fType * has binding name 'PointerTogmd__MD_x005fMetadataExtensionInformation_x005fType' for type 'gmd:MD_MetadataExtensionInformation_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fMetadataExtensionInformation_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fMetadataExtensionInformation_x005fType (-1469)

#endif

/* __gmd__MD_x005fExtendedElementInformation_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fExtendedElementInformation_x005fPropertyType_sequence' for type '-gmd:MD_ExtendedElementInformation_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fExtendedElementInformation_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fExtendedElementInformation_x005fPropertyType_sequence (-1467)

#endif

/* gmd__MD_x005fExtendedElementInformation_x005fType * has binding name 'PointerTogmd__MD_x005fExtendedElementInformation_x005fType' for type 'gmd:MD_ExtendedElementInformation_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fExtendedElementInformation_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fExtendedElementInformation_x005fType (-1466)

#endif

/* __gmd__EX_x005fGeographicDescription_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__EX_x005fGeographicDescription_x005fPropertyType_sequence' for type '-gmd:EX_GeographicDescription_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__EX_x005fGeographicDescription_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__EX_x005fGeographicDescription_x005fPropertyType_sequence (-1464)

#endif

/* __gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType_sequence' for type '-gmd:EX_SpatialTemporalExtent_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__EX_x005fSpatialTemporalExtent_x005fPropertyType_sequence (-1462)

#endif

/* __gmd__EX_x005fGeographicBoundingBox_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__EX_x005fGeographicBoundingBox_x005fPropertyType_sequence' for type '-gmd:EX_GeographicBoundingBox_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__EX_x005fGeographicBoundingBox_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__EX_x005fGeographicBoundingBox_x005fPropertyType_sequence (-1460)

#endif

/* __gmd__EX_x005fGeographicExtent_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__EX_x005fGeographicExtent_x005fPropertyType_sequence' for type '-gmd:EX_GeographicExtent_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__EX_x005fGeographicExtent_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__EX_x005fGeographicExtent_x005fPropertyType_sequence (-1458)

#endif

/* gmd__EX_x005fGeographicDescription_x005fType * has binding name 'PointerTogmd__EX_x005fGeographicDescription_x005fType' for type 'gmd:EX_GeographicDescription_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__EX_x005fGeographicDescription_x005fType
#define SOAP_TYPE_plu_PointerTogmd__EX_x005fGeographicDescription_x005fType (-1457)

#endif

/* gmd__EX_x005fGeographicBoundingBox_x005fType * has binding name 'PointerTogmd__EX_x005fGeographicBoundingBox_x005fType' for type 'gmd:EX_GeographicBoundingBox_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__EX_x005fGeographicBoundingBox_x005fType
#define SOAP_TYPE_plu_PointerTogmd__EX_x005fGeographicBoundingBox_x005fType (-1456)

#endif

/* __gmd__EX_x005fExtent_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__EX_x005fExtent_x005fPropertyType_sequence' for type '-gmd:EX_Extent_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__EX_x005fExtent_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__EX_x005fExtent_x005fPropertyType_sequence (-1453)

#endif

/* __gmd__EX_x005fBoundingPolygon_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__EX_x005fBoundingPolygon_x005fPropertyType_sequence' for type '-gmd:EX_BoundingPolygon_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__EX_x005fBoundingPolygon_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__EX_x005fBoundingPolygon_x005fPropertyType_sequence (-1451)

#endif

/* gmd__EX_x005fBoundingPolygon_x005fType * has binding name 'PointerTogmd__EX_x005fBoundingPolygon_x005fType' for type 'gmd:EX_BoundingPolygon_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__EX_x005fBoundingPolygon_x005fType
#define SOAP_TYPE_plu_PointerTogmd__EX_x005fBoundingPolygon_x005fType (-1450)

#endif

/* __gmd__EX_x005fVerticalExtent_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__EX_x005fVerticalExtent_x005fPropertyType_sequence' for type '-gmd:EX_VerticalExtent_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__EX_x005fVerticalExtent_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__EX_x005fVerticalExtent_x005fPropertyType_sequence (-1448)

#endif

/* gmd__EX_x005fVerticalExtent_x005fType * has binding name 'PointerTogmd__EX_x005fVerticalExtent_x005fType' for type 'gmd:EX_VerticalExtent_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__EX_x005fVerticalExtent_x005fType
#define SOAP_TYPE_plu_PointerTogmd__EX_x005fVerticalExtent_x005fType (-1447)

#endif

/* __gmd__EX_x005fTemporalExtent_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__EX_x005fTemporalExtent_x005fPropertyType_sequence' for type '-gmd:EX_TemporalExtent_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__EX_x005fTemporalExtent_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__EX_x005fTemporalExtent_x005fPropertyType_sequence (-1445)

#endif

/* gmd__EX_x005fSpatialTemporalExtent_x005fType * has binding name 'PointerTogmd__EX_x005fSpatialTemporalExtent_x005fType' for type 'gmd:EX_SpatialTemporalExtent_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__EX_x005fSpatialTemporalExtent_x005fType
#define SOAP_TYPE_plu_PointerTogmd__EX_x005fSpatialTemporalExtent_x005fType (-1444)

#endif

/* gmd__EX_x005fTemporalExtent_x005fType * has binding name 'PointerTogmd__EX_x005fTemporalExtent_x005fType' for type 'gmd:EX_TemporalExtent_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__EX_x005fTemporalExtent_x005fType
#define SOAP_TYPE_plu_PointerTogmd__EX_x005fTemporalExtent_x005fType (-1443)

#endif

/* __gmd__RS_x005fReferenceSystem_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__RS_x005fReferenceSystem_x005fPropertyType_sequence' for type '-gmd:RS_ReferenceSystem_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__RS_x005fReferenceSystem_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__RS_x005fReferenceSystem_x005fPropertyType_sequence (-1440)

#endif

/* __gmd__MD_x005fIdentifier_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fIdentifier_x005fPropertyType_sequence' for type '-gmd:MD_Identifier_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fIdentifier_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fIdentifier_x005fPropertyType_sequence (-1437)

#endif

/* gmd__MD_x005fIdentifier_x005fType * has binding name 'PointerTogmd__MD_x005fIdentifier_x005fType' for type 'gmd:MD_Identifier_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fIdentifier_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fIdentifier_x005fType (-1436)

#endif

/* __gmd__MD_x005fReferenceSystem_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fReferenceSystem_x005fPropertyType_sequence' for type '-gmd:MD_ReferenceSystem_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fReferenceSystem_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fReferenceSystem_x005fPropertyType_sequence (-1433)

#endif

/* gmd__MD_x005fReferenceSystem_x005fType * has binding name 'PointerTogmd__MD_x005fReferenceSystem_x005fType' for type 'gmd:MD_ReferenceSystem_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fReferenceSystem_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fReferenceSystem_x005fType (-1432)

#endif

/* __gmd__RS_x005fIdentifier_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__RS_x005fIdentifier_x005fPropertyType_sequence' for type '-gmd:RS_Identifier_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__RS_x005fIdentifier_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__RS_x005fIdentifier_x005fPropertyType_sequence (-1430)

#endif

/* gmd__RS_x005fIdentifier_x005fType * has binding name 'PointerTogmd__RS_x005fIdentifier_x005fType' for type 'gmd:RS_Identifier_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__RS_x005fIdentifier_x005fType
#define SOAP_TYPE_plu_PointerTogmd__RS_x005fIdentifier_x005fType (-1429)

#endif

/* __gmd__CI_x005fDateTypeCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__CI_x005fDateTypeCode_x005fPropertyType_sequence' for type '-gmd:CI_DateTypeCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__CI_x005fDateTypeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__CI_x005fDateTypeCode_x005fPropertyType_sequence (-1427)

#endif

/* __gmd__CI_x005fOnLineFunctionCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__CI_x005fOnLineFunctionCode_x005fPropertyType_sequence' for type '-gmd:CI_OnLineFunctionCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__CI_x005fOnLineFunctionCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__CI_x005fOnLineFunctionCode_x005fPropertyType_sequence (-1425)

#endif

/* __gmd__CI_x005fPresentationFormCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__CI_x005fPresentationFormCode_x005fPropertyType_sequence' for type '-gmd:CI_PresentationFormCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__CI_x005fPresentationFormCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__CI_x005fPresentationFormCode_x005fPropertyType_sequence (-1423)

#endif

/* __gmd__CI_x005fRoleCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__CI_x005fRoleCode_x005fPropertyType_sequence' for type '-gmd:CI_RoleCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__CI_x005fRoleCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__CI_x005fRoleCode_x005fPropertyType_sequence (-1421)

#endif

/* __gmd__URL_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__URL_x005fPropertyType_sequence' for type '-gmd:URL_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__URL_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__URL_x005fPropertyType_sequence (-1419)

#endif

/* __gmd__CI_x005fSeries_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__CI_x005fSeries_x005fPropertyType_sequence' for type '-gmd:CI_Series_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__CI_x005fSeries_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__CI_x005fSeries_x005fPropertyType_sequence (-1417)

#endif

/* gmd__CI_x005fSeries_x005fType * has binding name 'PointerTogmd__CI_x005fSeries_x005fType' for type 'gmd:CI_Series_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__CI_x005fSeries_x005fType
#define SOAP_TYPE_plu_PointerTogmd__CI_x005fSeries_x005fType (-1416)

#endif

/* __gmd__CI_x005fDate_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__CI_x005fDate_x005fPropertyType_sequence' for type '-gmd:CI_Date_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__CI_x005fDate_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__CI_x005fDate_x005fPropertyType_sequence (-1414)

#endif

/* gmd__CI_x005fDate_x005fType * has binding name 'PointerTogmd__CI_x005fDate_x005fType' for type 'gmd:CI_Date_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__CI_x005fDate_x005fType
#define SOAP_TYPE_plu_PointerTogmd__CI_x005fDate_x005fType (-1413)

#endif

/* __gmd__CI_x005fTelephone_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__CI_x005fTelephone_x005fPropertyType_sequence' for type '-gmd:CI_Telephone_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__CI_x005fTelephone_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__CI_x005fTelephone_x005fPropertyType_sequence (-1411)

#endif

/* gmd__CI_x005fTelephone_x005fType * has binding name 'PointerTogmd__CI_x005fTelephone_x005fType' for type 'gmd:CI_Telephone_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__CI_x005fTelephone_x005fType
#define SOAP_TYPE_plu_PointerTogmd__CI_x005fTelephone_x005fType (-1410)

#endif

/* __gmd__CI_x005fContact_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__CI_x005fContact_x005fPropertyType_sequence' for type '-gmd:CI_Contact_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__CI_x005fContact_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__CI_x005fContact_x005fPropertyType_sequence (-1408)

#endif

/* gmd__CI_x005fContact_x005fType * has binding name 'PointerTogmd__CI_x005fContact_x005fType' for type 'gmd:CI_Contact_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__CI_x005fContact_x005fType
#define SOAP_TYPE_plu_PointerTogmd__CI_x005fContact_x005fType (-1407)

#endif

/* __gmd__CI_x005fOnlineResource_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__CI_x005fOnlineResource_x005fPropertyType_sequence' for type '-gmd:CI_OnlineResource_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__CI_x005fOnlineResource_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__CI_x005fOnlineResource_x005fPropertyType_sequence (-1405)

#endif

/* gmd__CI_x005fOnlineResource_x005fType * has binding name 'PointerTogmd__CI_x005fOnlineResource_x005fType' for type 'gmd:CI_OnlineResource_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__CI_x005fOnlineResource_x005fType
#define SOAP_TYPE_plu_PointerTogmd__CI_x005fOnlineResource_x005fType (-1404)

#endif

/* __gmd__CI_x005fAddress_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__CI_x005fAddress_x005fPropertyType_sequence' for type '-gmd:CI_Address_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__CI_x005fAddress_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__CI_x005fAddress_x005fPropertyType_sequence (-1402)

#endif

/* gmd__CI_x005fAddress_x005fType * has binding name 'PointerTogmd__CI_x005fAddress_x005fType' for type 'gmd:CI_Address_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__CI_x005fAddress_x005fType
#define SOAP_TYPE_plu_PointerTogmd__CI_x005fAddress_x005fType (-1401)

#endif

/* __gmd__CI_x005fCitation_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__CI_x005fCitation_x005fPropertyType_sequence' for type '-gmd:CI_Citation_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__CI_x005fCitation_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__CI_x005fCitation_x005fPropertyType_sequence (-1399)

#endif

/* __gmd__CI_x005fResponsibleParty_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__CI_x005fResponsibleParty_x005fPropertyType_sequence' for type '-gmd:CI_ResponsibleParty_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__CI_x005fResponsibleParty_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__CI_x005fResponsibleParty_x005fPropertyType_sequence (-1397)

#endif

/* gmd__CI_x005fResponsibleParty_x005fType * has binding name 'PointerTogmd__CI_x005fResponsibleParty_x005fType' for type 'gmd:CI_ResponsibleParty_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__CI_x005fResponsibleParty_x005fType
#define SOAP_TYPE_plu_PointerTogmd__CI_x005fResponsibleParty_x005fType (-1396)

#endif

/* __gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType_sequence' for type '-gmd:MD_DimensionNameTypeCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fDimensionNameTypeCode_x005fPropertyType_sequence (-1394)

#endif

/* __gmd__MD_x005fCellGeometryCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fCellGeometryCode_x005fPropertyType_sequence' for type '-gmd:MD_CellGeometryCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fCellGeometryCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fCellGeometryCode_x005fPropertyType_sequence (-1392)

#endif

/* __gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType_sequence' for type '-gmd:MD_GeometricObjectTypeCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fGeometricObjectTypeCode_x005fPropertyType_sequence (-1390)

#endif

/* __gmd__MD_x005fTopologyLevelCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fTopologyLevelCode_x005fPropertyType_sequence' for type '-gmd:MD_TopologyLevelCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fTopologyLevelCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fTopologyLevelCode_x005fPropertyType_sequence (-1388)

#endif

/* gco__CodeListValue_x005fType * has binding name 'PointerTogco__CodeListValue_x005fType' for type 'gco:CodeListValue_Type' */
#ifndef SOAP_TYPE_plu_PointerTogco__CodeListValue_x005fType
#define SOAP_TYPE_plu_PointerTogco__CodeListValue_x005fType (-1387)

#endif

/* __gmd__MD_x005fPixelOrientationCode_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fPixelOrientationCode_x005fPropertyType_sequence' for type '-gmd:MD_PixelOrientationCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fPixelOrientationCode_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fPixelOrientationCode_x005fPropertyType_sequence (-1385)

#endif

/* __gmd__MD_x005fGeometricObjects_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fGeometricObjects_x005fPropertyType_sequence' for type '-gmd:MD_GeometricObjects_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fGeometricObjects_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fGeometricObjects_x005fPropertyType_sequence (-1383)

#endif

/* gmd__MD_x005fGeometricObjects_x005fType * has binding name 'PointerTogmd__MD_x005fGeometricObjects_x005fType' for type 'gmd:MD_GeometricObjects_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fGeometricObjects_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fGeometricObjects_x005fType (-1382)

#endif

/* __gmd__MD_x005fGeorectified_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fGeorectified_x005fPropertyType_sequence' for type '-gmd:MD_Georectified_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fGeorectified_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fGeorectified_x005fPropertyType_sequence (-1380)

#endif

/* __gmd__MD_x005fDimension_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fDimension_x005fPropertyType_sequence' for type '-gmd:MD_Dimension_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fDimension_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fDimension_x005fPropertyType_sequence (-1378)

#endif

/* gmd__MD_x005fDimension_x005fType * has binding name 'PointerTogmd__MD_x005fDimension_x005fType' for type 'gmd:MD_Dimension_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fDimension_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fDimension_x005fType (-1377)

#endif

/* __gmd__MD_x005fGeoreferenceable_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fGeoreferenceable_x005fPropertyType_sequence' for type '-gmd:MD_Georeferenceable_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fGeoreferenceable_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fGeoreferenceable_x005fPropertyType_sequence (-1375)

#endif

/* __gmd__MD_x005fSpatialRepresentation_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fSpatialRepresentation_x005fPropertyType_sequence' for type '-gmd:MD_SpatialRepresentation_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fSpatialRepresentation_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fSpatialRepresentation_x005fPropertyType_sequence (-1373)

#endif

/* __gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType_sequence' for type '-gmd:MD_VectorSpatialRepresentation_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fVectorSpatialRepresentation_x005fPropertyType_sequence (-1370)

#endif

/* gmd__MD_x005fVectorSpatialRepresentation_x005fType * has binding name 'PointerTogmd__MD_x005fVectorSpatialRepresentation_x005fType' for type 'gmd:MD_VectorSpatialRepresentation_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fVectorSpatialRepresentation_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fVectorSpatialRepresentation_x005fType (-1369)

#endif

/* __gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType_sequence' for type '-gmd:MD_GridSpatialRepresentation_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fGridSpatialRepresentation_x005fPropertyType_sequence (-1367)

#endif

/* gmd__MD_x005fGeorectified_x005fType * has binding name 'PointerTogmd__MD_x005fGeorectified_x005fType' for type 'gmd:MD_Georectified_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fGeorectified_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fGeorectified_x005fType (-1366)

#endif

/* gmd__MD_x005fGeoreferenceable_x005fType * has binding name 'PointerTogmd__MD_x005fGeoreferenceable_x005fType' for type 'gmd:MD_Georeferenceable_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fGeoreferenceable_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fGeoreferenceable_x005fType (-1365)

#endif

/* gmd__MD_x005fGridSpatialRepresentation_x005fType * has binding name 'PointerTogmd__MD_x005fGridSpatialRepresentation_x005fType' for type 'gmd:MD_GridSpatialRepresentation_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fGridSpatialRepresentation_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fGridSpatialRepresentation_x005fType (-1364)

#endif

/* __gmd__MD_x005fMetadata_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__MD_x005fMetadata_x005fPropertyType_sequence' for type '-gmd:MD_Metadata_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__MD_x005fMetadata_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__MD_x005fMetadata_x005fPropertyType_sequence (-1361)

#endif

/* gmd__MD_x005fMetadata_x005fType * has binding name 'PointerTogmd__MD_x005fMetadata_x005fType' for type 'gmd:MD_Metadata_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__MD_x005fMetadata_x005fType
#define SOAP_TYPE_plu_PointerTogmd__MD_x005fMetadata_x005fType (-1360)

#endif

/* __gmd__DS_x005fStereoMate_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DS_x005fStereoMate_x005fPropertyType_sequence' for type '-gmd:DS_StereoMate_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DS_x005fStereoMate_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DS_x005fStereoMate_x005fPropertyType_sequence (-1358)

#endif

/* __gmd__DS_x005fProductionSeries_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DS_x005fProductionSeries_x005fPropertyType_sequence' for type '-gmd:DS_ProductionSeries_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DS_x005fProductionSeries_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DS_x005fProductionSeries_x005fPropertyType_sequence (-1356)

#endif

/* __gmd__DS_x005fSensor_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DS_x005fSensor_x005fPropertyType_sequence' for type '-gmd:DS_Sensor_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DS_x005fSensor_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DS_x005fSensor_x005fPropertyType_sequence (-1354)

#endif

/* __gmd__DS_x005fPlatform_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DS_x005fPlatform_x005fPropertyType_sequence' for type '-gmd:DS_Platform_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DS_x005fPlatform_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DS_x005fPlatform_x005fPropertyType_sequence (-1352)

#endif

/* __gmd__DS_x005fInitiative_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DS_x005fInitiative_x005fPropertyType_sequence' for type '-gmd:DS_Initiative_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DS_x005fInitiative_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DS_x005fInitiative_x005fPropertyType_sequence (-1350)

#endif

/* __gmd__DS_x005fSeries_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DS_x005fSeries_x005fPropertyType_sequence' for type '-gmd:DS_Series_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DS_x005fSeries_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DS_x005fSeries_x005fPropertyType_sequence (-1348)

#endif

/* __gmd__DS_x005fOtherAggregate_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DS_x005fOtherAggregate_x005fPropertyType_sequence' for type '-gmd:DS_OtherAggregate_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DS_x005fOtherAggregate_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DS_x005fOtherAggregate_x005fPropertyType_sequence (-1345)

#endif

/* __gmd__DS_x005fDataSet_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DS_x005fDataSet_x005fPropertyType_sequence' for type '-gmd:DS_DataSet_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DS_x005fDataSet_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DS_x005fDataSet_x005fPropertyType_sequence (-1342)

#endif

/* gmd__DS_x005fDataSet_x005fType * has binding name 'PointerTogmd__DS_x005fDataSet_x005fType' for type 'gmd:DS_DataSet_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DS_x005fDataSet_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DS_x005fDataSet_x005fType (-1341)

#endif

/* __gmd__DS_x005fAggregate_x005fPropertyType_sequence * has binding name 'PointerTo__gmd__DS_x005fAggregate_x005fPropertyType_sequence' for type '-gmd:DS_Aggregate_PropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gmd__DS_x005fAggregate_x005fPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gmd__DS_x005fAggregate_x005fPropertyType_sequence (-1339)

#endif

/* gmd__DS_x005fInitiative_x005fType * has binding name 'PointerTogmd__DS_x005fInitiative_x005fType' for type 'gmd:DS_Initiative_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DS_x005fInitiative_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DS_x005fInitiative_x005fType (-1338)

#endif

/* gmd__DS_x005fProductionSeries_x005fType * has binding name 'PointerTogmd__DS_x005fProductionSeries_x005fType' for type 'gmd:DS_ProductionSeries_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DS_x005fProductionSeries_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DS_x005fProductionSeries_x005fType (-1337)

#endif

/* gmd__DS_x005fSensor_x005fType * has binding name 'PointerTogmd__DS_x005fSensor_x005fType' for type 'gmd:DS_Sensor_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DS_x005fSensor_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DS_x005fSensor_x005fType (-1336)

#endif

/* gmd__DS_x005fPlatform_x005fType * has binding name 'PointerTogmd__DS_x005fPlatform_x005fType' for type 'gmd:DS_Platform_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DS_x005fPlatform_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DS_x005fPlatform_x005fType (-1335)

#endif

/* gmd__DS_x005fSeries_x005fType * has binding name 'PointerTogmd__DS_x005fSeries_x005fType' for type 'gmd:DS_Series_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DS_x005fSeries_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DS_x005fSeries_x005fType (-1334)

#endif

/* gmd__DS_x005fStereoMate_x005fType * has binding name 'PointerTogmd__DS_x005fStereoMate_x005fType' for type 'gmd:DS_StereoMate_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DS_x005fStereoMate_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DS_x005fStereoMate_x005fType (-1333)

#endif

/* gmd__DS_x005fOtherAggregate_x005fType * has binding name 'PointerTogmd__DS_x005fOtherAggregate_x005fType' for type 'gmd:DS_OtherAggregate_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DS_x005fOtherAggregate_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DS_x005fOtherAggregate_x005fType (-1332)

#endif

/* __gml__formulaCitation_sequence * has binding name 'PointerTo__gml__formulaCitation_sequence' for type '-gml:formulaCitation-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__formulaCitation_sequence
#define SOAP_TYPE_plu_PointerTo__gml__formulaCitation_sequence (-1329)

#endif

/* gmd__CI_x005fCitation_x005fType * has binding name 'PointerTogmd__CI_x005fCitation_x005fType' for type 'gmd:CI_Citation_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__CI_x005fCitation_x005fType
#define SOAP_TYPE_plu_PointerTogmd__CI_x005fCitation_x005fType (-1328)

#endif

/* __gml__coordinateOperationAccuracy_sequence * has binding name 'PointerTo__gml__coordinateOperationAccuracy_sequence' for type '-gml:coordinateOperationAccuracy-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__coordinateOperationAccuracy_sequence
#define SOAP_TYPE_plu_PointerTo__gml__coordinateOperationAccuracy_sequence (-1326)

#endif

/* gmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType * has binding name 'PointerTogmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType' for type 'gmd:DQ_AbsoluteExternalPositionalAccuracy_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fAbsoluteExternalPositionalAccuracy_x005fType (-1325)

#endif

/* gmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType * has binding name 'PointerTogmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType' for type 'gmd:DQ_GriddedDataPositionalAccuracy_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fGriddedDataPositionalAccuracy_x005fType (-1324)

#endif

/* gmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType * has binding name 'PointerTogmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType' for type 'gmd:DQ_RelativeInternalPositionalAccuracy_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType
#define SOAP_TYPE_plu_PointerTogmd__DQ_x005fRelativeInternalPositionalAccuracy_x005fType (-1323)

#endif

/* gml__LengthType * has binding name 'PointerTogml__LengthType' for type 'gml:LengthType' */
#ifndef SOAP_TYPE_plu_PointerTogml__LengthType
#define SOAP_TYPE_plu_PointerTogml__LengthType (-1320)

#endif

/* gml__MeasureType * has binding name 'PointerTogml__MeasureType' for type 'gml:MeasureType' */
#ifndef SOAP_TYPE_plu_PointerTogml__MeasureType
#define SOAP_TYPE_plu_PointerTogml__MeasureType (-1319)

#endif

/* _gml__SecondDefiningParameter * has binding name 'PointerTo_gml__SecondDefiningParameter' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_gml__SecondDefiningParameter
#define SOAP_TYPE_plu_PointerTo_gml__SecondDefiningParameter (-1317)

#endif

/* __gml__domainOfValidity_sequence * has binding name 'PointerTo__gml__domainOfValidity_sequence' for type '-gml:domainOfValidity-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__domainOfValidity_sequence
#define SOAP_TYPE_plu_PointerTo__gml__domainOfValidity_sequence (-1316)

#endif

/* gmd__EX_x005fExtent_x005fType * has binding name 'PointerTogmd__EX_x005fExtent_x005fType' for type 'gmd:EX_Extent_Type' */
#ifndef SOAP_TYPE_plu_PointerTogmd__EX_x005fExtent_x005fType
#define SOAP_TYPE_plu_PointerTogmd__EX_x005fExtent_x005fType (-1315)

#endif

/* gml__DefinitionProxyType * has binding name 'PointerTogml__DefinitionProxyType' for type 'gml:DefinitionProxyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DefinitionProxyType
#define SOAP_TYPE_plu_PointerTogml__DefinitionProxyType (-1313)

#endif

/* __gml__MetaDataPropertyType_sequence * has binding name 'PointerTo__gml__MetaDataPropertyType_sequence' for type '-gml:MetaDataPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__MetaDataPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__MetaDataPropertyType_sequence (-1308)

#endif

/* gml__GenericMetaDataType * has binding name 'PointerTogml__GenericMetaDataType' for type 'gml:GenericMetaDataType' */
#ifndef SOAP_TYPE_plu_PointerTogml__GenericMetaDataType
#define SOAP_TYPE_plu_PointerTogml__GenericMetaDataType (-1307)

#endif

/* __gml__union_ArrayAssociationType * has binding name 'PointerTo__gml__union_ArrayAssociationType' for type '-gml:union-ArrayAssociationType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_ArrayAssociationType
#define SOAP_TYPE_plu_PointerTo__gml__union_ArrayAssociationType (-1304)

#endif

/* gml__CoverageFunctionType * has binding name 'PointerTogml__CoverageFunctionType' for type 'gml:CoverageFunctionType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CoverageFunctionType
#define SOAP_TYPE_plu_PointerTogml__CoverageFunctionType (-1303)

#endif

/* gml__AffinePlacementType * has binding name 'PointerTogml__AffinePlacementType' for type 'gml:AffinePlacementType' */
#ifndef SOAP_TYPE_plu_PointerTogml__AffinePlacementType
#define SOAP_TYPE_plu_PointerTogml__AffinePlacementType (-1302)

#endif

/* gml__DMSAngleType * has binding name 'PointerTogml__DMSAngleType' for type 'gml:DMSAngleType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DMSAngleType
#define SOAP_TYPE_plu_PointerTogml__DMSAngleType (-1299)

#endif

/* double * has binding name 'PointerTogml__ArcSecondsType' for type 'gml:ArcSecondsType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ArcSecondsType
#define SOAP_TYPE_plu_PointerTogml__ArcSecondsType (-1297)

#endif

/* ULONG64 * has binding name 'PointerTogml__ArcMinutesType' for type 'gml:ArcMinutesType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ArcMinutesType
#define SOAP_TYPE_plu_PointerTogml__ArcMinutesType (-1296)

#endif

/* double * has binding name 'PointerTogml__DecimalMinutesType' for type 'gml:DecimalMinutesType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DecimalMinutesType
#define SOAP_TYPE_plu_PointerTogml__DecimalMinutesType (-1295)

#endif

/* gml__DegreesType * has binding name 'PointerTogml__DegreesType' for type 'gml:DegreesType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DegreesType
#define SOAP_TYPE_plu_PointerTogml__DegreesType (-1294)

#endif

/* __gml__GeocentricCRSPropertyType_sequence * has binding name 'PointerTo__gml__GeocentricCRSPropertyType_sequence' for type '-gml:GeocentricCRSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__GeocentricCRSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__GeocentricCRSPropertyType_sequence (-1293)

#endif

/* __gml__GeographicCRSPropertyType_sequence * has binding name 'PointerTo__gml__GeographicCRSPropertyType_sequence' for type '-gml:GeographicCRSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__GeographicCRSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__GeographicCRSPropertyType_sequence (-1291)

#endif

/* __gml__ObliqueCartesianCSPropertyType_sequence * has binding name 'PointerTo__gml__ObliqueCartesianCSPropertyType_sequence' for type '-gml:ObliqueCartesianCSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__ObliqueCartesianCSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__ObliqueCartesianCSPropertyType_sequence (-1289)

#endif

/* __gml__TemporalCSPropertyType_sequence * has binding name 'PointerTo__gml__TemporalCSPropertyType_sequence' for type '-gml:TemporalCSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__TemporalCSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__TemporalCSPropertyType_sequence (-1287)

#endif

/* __gml__OperationPropertyType_sequence * has binding name 'PointerTo__gml__OperationPropertyType_sequence' for type '-gml:OperationPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__OperationPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__OperationPropertyType_sequence (-1285)

#endif

/* __gml__TimeEdgePropertyType_sequence * has binding name 'PointerTo__gml__TimeEdgePropertyType_sequence' for type '-gml:TimeEdgePropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__TimeEdgePropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__TimeEdgePropertyType_sequence (-1282)

#endif

/* __gml__TimeNodePropertyType_sequence * has binding name 'PointerTo__gml__TimeNodePropertyType_sequence' for type '-gml:TimeNodePropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__TimeNodePropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__TimeNodePropertyType_sequence (-1280)

#endif

/* __gml__TimeTopologyComplexPropertyType_sequence * has binding name 'PointerTo__gml__TimeTopologyComplexPropertyType_sequence' for type '-gml:TimeTopologyComplexPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__TimeTopologyComplexPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__TimeTopologyComplexPropertyType_sequence (-1278)

#endif

/* gml__TimeTopologyComplexType * has binding name 'PointerTogml__TimeTopologyComplexType' for type 'gml:TimeTopologyComplexType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeTopologyComplexType
#define SOAP_TYPE_plu_PointerTogml__TimeTopologyComplexType (-1277)

#endif

/* __gml__TimeTopologyPrimitivePropertyType_sequence * has binding name 'PointerTo__gml__TimeTopologyPrimitivePropertyType_sequence' for type '-gml:TimeTopologyPrimitivePropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__TimeTopologyPrimitivePropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__TimeTopologyPrimitivePropertyType_sequence (-1275)

#endif

/* gml__TimeEdgeType * has binding name 'PointerTogml__TimeEdgeType' for type 'gml:TimeEdgeType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeEdgeType
#define SOAP_TYPE_plu_PointerTogml__TimeEdgeType (-1274)

#endif

/* gml__TimeNodeType * has binding name 'PointerTogml__TimeNodeType' for type 'gml:TimeNodeType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeNodeType
#define SOAP_TYPE_plu_PointerTogml__TimeNodeType (-1273)

#endif

/* __gml__TimeOrdinalEraPropertyType_sequence * has binding name 'PointerTo__gml__TimeOrdinalEraPropertyType_sequence' for type '-gml:TimeOrdinalEraPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__TimeOrdinalEraPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__TimeOrdinalEraPropertyType_sequence (-1270)

#endif

/* gml__TimeOrdinalEraType * has binding name 'PointerTogml__TimeOrdinalEraType' for type 'gml:TimeOrdinalEraType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeOrdinalEraType
#define SOAP_TYPE_plu_PointerTogml__TimeOrdinalEraType (-1269)

#endif

/* __gml__TimeClockPropertyType_sequence * has binding name 'PointerTo__gml__TimeClockPropertyType_sequence' for type '-gml:TimeClockPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__TimeClockPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__TimeClockPropertyType_sequence (-1267)

#endif

/* gml__TimeClockType * has binding name 'PointerTogml__TimeClockType' for type 'gml:TimeClockType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeClockType
#define SOAP_TYPE_plu_PointerTogml__TimeClockType (-1266)

#endif

/* __gml__TimeCalendarEraPropertyType_sequence * has binding name 'PointerTo__gml__TimeCalendarEraPropertyType_sequence' for type '-gml:TimeCalendarEraPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__TimeCalendarEraPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__TimeCalendarEraPropertyType_sequence (-1264)

#endif

/* gml__TimeCalendarEraType * has binding name 'PointerTogml__TimeCalendarEraType' for type 'gml:TimeCalendarEraType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeCalendarEraType
#define SOAP_TYPE_plu_PointerTogml__TimeCalendarEraType (-1263)

#endif

/* __gml__TimeCalendarPropertyType_sequence * has binding name 'PointerTo__gml__TimeCalendarPropertyType_sequence' for type '-gml:TimeCalendarPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__TimeCalendarPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__TimeCalendarPropertyType_sequence (-1261)

#endif

/* gml__TimeCalendarType * has binding name 'PointerTogml__TimeCalendarType' for type 'gml:TimeCalendarType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeCalendarType
#define SOAP_TYPE_plu_PointerTogml__TimeCalendarType (-1260)

#endif

/* gml__AngleType * has binding name 'PointerTogml__AngleType' for type 'gml:AngleType' */
#ifndef SOAP_TYPE_plu_PointerTogml__AngleType
#define SOAP_TYPE_plu_PointerTogml__AngleType (-1257)

#endif

/* gml__DirectionDescriptionType * has binding name 'PointerTogml__DirectionDescriptionType' for type 'gml:DirectionDescriptionType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DirectionDescriptionType
#define SOAP_TYPE_plu_PointerTogml__DirectionDescriptionType (-1256)

#endif

/* gml__DirectionVectorType * has binding name 'PointerTogml__DirectionVectorType' for type 'gml:DirectionVectorType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DirectionVectorType
#define SOAP_TYPE_plu_PointerTogml__DirectionVectorType (-1255)

#endif

/* __gml__ResultType_sequence * has binding name 'PointerTo__gml__ResultType_sequence' for type '-gml:ResultType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__ResultType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__ResultType_sequence (-1253)

#endif

/* __gml__ProcedurePropertyType_sequence * has binding name 'PointerTo__gml__ProcedurePropertyType_sequence' for type '-gml:ProcedurePropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__ProcedurePropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__ProcedurePropertyType_sequence (-1250)

#endif

/* __gml__OperationParameterGroupPropertyType_sequence * has binding name 'PointerTo__gml__OperationParameterGroupPropertyType_sequence' for type '-gml:OperationParameterGroupPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__OperationParameterGroupPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__OperationParameterGroupPropertyType_sequence (-1247)

#endif

/* __gml__OperationParameterPropertyType_sequence * has binding name 'PointerTo__gml__OperationParameterPropertyType_sequence' for type '-gml:OperationParameterPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__OperationParameterPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__OperationParameterPropertyType_sequence (-1245)

#endif

/* __gml__AbstractGeneralOperationParameterPropertyType_sequence * has binding name 'PointerTo__gml__AbstractGeneralOperationParameterPropertyType_sequence' for type '-gml:AbstractGeneralOperationParameterPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__AbstractGeneralOperationParameterPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__AbstractGeneralOperationParameterPropertyType_sequence (-1243)

#endif

/* gml__OperationParameterGroupType * has binding name 'PointerTogml__OperationParameterGroupType' for type 'gml:OperationParameterGroupType' */
#ifndef SOAP_TYPE_plu_PointerTogml__OperationParameterGroupType
#define SOAP_TYPE_plu_PointerTogml__OperationParameterGroupType (-1242)

#endif

/* gml__OperationParameterType * has binding name 'PointerTogml__OperationParameterType' for type 'gml:OperationParameterType' */
#ifndef SOAP_TYPE_plu_PointerTogml__OperationParameterType
#define SOAP_TYPE_plu_PointerTogml__OperationParameterType (-1241)

#endif

/* __gml__OperationMethodPropertyType_sequence * has binding name 'PointerTo__gml__OperationMethodPropertyType_sequence' for type '-gml:OperationMethodPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__OperationMethodPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__OperationMethodPropertyType_sequence (-1238)

#endif

/* gml__OperationMethodType * has binding name 'PointerTogml__OperationMethodType' for type 'gml:OperationMethodType' */
#ifndef SOAP_TYPE_plu_PointerTogml__OperationMethodType
#define SOAP_TYPE_plu_PointerTogml__OperationMethodType (-1237)

#endif

/* gml__ParameterValueGroupType * has binding name 'PointerTogml__ParameterValueGroupType' for type 'gml:ParameterValueGroupType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ParameterValueGroupType
#define SOAP_TYPE_plu_PointerTogml__ParameterValueGroupType (-1235)

#endif

/* gml__ParameterValueType * has binding name 'PointerTogml__ParameterValueType' for type 'gml:ParameterValueType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ParameterValueType
#define SOAP_TYPE_plu_PointerTogml__ParameterValueType (-1234)

#endif

/* __gml__TransformationPropertyType_sequence * has binding name 'PointerTo__gml__TransformationPropertyType_sequence' for type '-gml:TransformationPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__TransformationPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__TransformationPropertyType_sequence (-1232)

#endif

/* __gml__ConversionPropertyType_sequence * has binding name 'PointerTo__gml__ConversionPropertyType_sequence' for type '-gml:ConversionPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__ConversionPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__ConversionPropertyType_sequence (-1230)

#endif

/* __gml__PassThroughOperationPropertyType_sequence * has binding name 'PointerTo__gml__PassThroughOperationPropertyType_sequence' for type '-gml:PassThroughOperationPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__PassThroughOperationPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__PassThroughOperationPropertyType_sequence (-1228)

#endif

/* __gml__ConcatenatedOperationPropertyType_sequence * has binding name 'PointerTo__gml__ConcatenatedOperationPropertyType_sequence' for type '-gml:ConcatenatedOperationPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__ConcatenatedOperationPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__ConcatenatedOperationPropertyType_sequence (-1226)

#endif

/* __gml__GeneralTransformationPropertyType_sequence * has binding name 'PointerTo__gml__GeneralTransformationPropertyType_sequence' for type '-gml:GeneralTransformationPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__GeneralTransformationPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__GeneralTransformationPropertyType_sequence (-1224)

#endif

/* gml__TransformationType * has binding name 'PointerTogml__TransformationType' for type 'gml:TransformationType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TransformationType
#define SOAP_TYPE_plu_PointerTogml__TransformationType (-1223)

#endif

/* __gml__GeneralConversionPropertyType_sequence * has binding name 'PointerTo__gml__GeneralConversionPropertyType_sequence' for type '-gml:GeneralConversionPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__GeneralConversionPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__GeneralConversionPropertyType_sequence (-1220)

#endif

/* gml__ConversionType * has binding name 'PointerTogml__ConversionType' for type 'gml:ConversionType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ConversionType
#define SOAP_TYPE_plu_PointerTogml__ConversionType (-1219)

#endif

/* __gml__SingleOperationPropertyType_sequence * has binding name 'PointerTo__gml__SingleOperationPropertyType_sequence' for type '-gml:SingleOperationPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__SingleOperationPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__SingleOperationPropertyType_sequence (-1216)

#endif

/* gml__PassThroughOperationType * has binding name 'PointerTogml__PassThroughOperationType' for type 'gml:PassThroughOperationType' */
#ifndef SOAP_TYPE_plu_PointerTogml__PassThroughOperationType
#define SOAP_TYPE_plu_PointerTogml__PassThroughOperationType (-1215)

#endif

/* __gml__CoordinateOperationPropertyType_sequence * has binding name 'PointerTo__gml__CoordinateOperationPropertyType_sequence' for type '-gml:CoordinateOperationPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__CoordinateOperationPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__CoordinateOperationPropertyType_sequence (-1212)

#endif

/* gml__ConcatenatedOperationType * has binding name 'PointerTogml__ConcatenatedOperationType' for type 'gml:ConcatenatedOperationType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ConcatenatedOperationType
#define SOAP_TYPE_plu_PointerTogml__ConcatenatedOperationType (-1211)

#endif

/* __gml__TemporalDatumPropertyType_sequence * has binding name 'PointerTo__gml__TemporalDatumPropertyType_sequence' for type '-gml:TemporalDatumPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__TemporalDatumPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__TemporalDatumPropertyType_sequence (-1208)

#endif

/* __gml__VerticalDatumPropertyType_sequence * has binding name 'PointerTo__gml__VerticalDatumPropertyType_sequence' for type '-gml:VerticalDatumPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__VerticalDatumPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__VerticalDatumPropertyType_sequence (-1206)

#endif

/* __gml__ImageDatumPropertyType_sequence * has binding name 'PointerTo__gml__ImageDatumPropertyType_sequence' for type '-gml:ImageDatumPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__ImageDatumPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__ImageDatumPropertyType_sequence (-1204)

#endif

/* __gml__EngineeringDatumPropertyType_sequence * has binding name 'PointerTo__gml__EngineeringDatumPropertyType_sequence' for type '-gml:EngineeringDatumPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__EngineeringDatumPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__EngineeringDatumPropertyType_sequence (-1202)

#endif

/* __gml__PrimeMeridianPropertyType_sequence * has binding name 'PointerTo__gml__PrimeMeridianPropertyType_sequence' for type '-gml:PrimeMeridianPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__PrimeMeridianPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__PrimeMeridianPropertyType_sequence (-1200)

#endif

/* gml__PrimeMeridianType * has binding name 'PointerTogml__PrimeMeridianType' for type 'gml:PrimeMeridianType' */
#ifndef SOAP_TYPE_plu_PointerTogml__PrimeMeridianType
#define SOAP_TYPE_plu_PointerTogml__PrimeMeridianType (-1199)

#endif

/* __gml__EllipsoidPropertyType_sequence * has binding name 'PointerTo__gml__EllipsoidPropertyType_sequence' for type '-gml:EllipsoidPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__EllipsoidPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__EllipsoidPropertyType_sequence (-1197)

#endif

/* gml__EllipsoidType * has binding name 'PointerTogml__EllipsoidType' for type 'gml:EllipsoidType' */
#ifndef SOAP_TYPE_plu_PointerTogml__EllipsoidType
#define SOAP_TYPE_plu_PointerTogml__EllipsoidType (-1196)

#endif

/* __gml__GeodeticDatumPropertyType_sequence * has binding name 'PointerTo__gml__GeodeticDatumPropertyType_sequence' for type '-gml:GeodeticDatumPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__GeodeticDatumPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__GeodeticDatumPropertyType_sequence (-1194)

#endif

/* __gml__DatumPropertyType_sequence * has binding name 'PointerTo__gml__DatumPropertyType_sequence' for type '-gml:DatumPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__DatumPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__DatumPropertyType_sequence (-1192)

#endif

/* gml__TemporalDatumType * has binding name 'PointerTogml__TemporalDatumType' for type 'gml:TemporalDatumType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TemporalDatumType
#define SOAP_TYPE_plu_PointerTogml__TemporalDatumType (-1191)

#endif

/* gml__VerticalDatumType * has binding name 'PointerTogml__VerticalDatumType' for type 'gml:VerticalDatumType' */
#ifndef SOAP_TYPE_plu_PointerTogml__VerticalDatumType
#define SOAP_TYPE_plu_PointerTogml__VerticalDatumType (-1190)

#endif

/* gml__ImageDatumType * has binding name 'PointerTogml__ImageDatumType' for type 'gml:ImageDatumType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ImageDatumType
#define SOAP_TYPE_plu_PointerTogml__ImageDatumType (-1189)

#endif

/* gml__EngineeringDatumType * has binding name 'PointerTogml__EngineeringDatumType' for type 'gml:EngineeringDatumType' */
#ifndef SOAP_TYPE_plu_PointerTogml__EngineeringDatumType
#define SOAP_TYPE_plu_PointerTogml__EngineeringDatumType (-1188)

#endif

/* gml__GeodeticDatumType * has binding name 'PointerTogml__GeodeticDatumType' for type 'gml:GeodeticDatumType' */
#ifndef SOAP_TYPE_plu_PointerTogml__GeodeticDatumType
#define SOAP_TYPE_plu_PointerTogml__GeodeticDatumType (-1187)

#endif

/* __gml__CRSPropertyType_sequence * has binding name 'PointerTo__gml__CRSPropertyType_sequence' for type '-gml:CRSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__CRSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__CRSPropertyType_sequence (-1184)

#endif

/* __gml__AffineCSPropertyType_sequence * has binding name 'PointerTo__gml__AffineCSPropertyType_sequence' for type '-gml:AffineCSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__AffineCSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__AffineCSPropertyType_sequence (-1181)

#endif

/* __gml__CylindricalCSPropertyType_sequence * has binding name 'PointerTo__gml__CylindricalCSPropertyType_sequence' for type '-gml:CylindricalCSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__CylindricalCSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__CylindricalCSPropertyType_sequence (-1179)

#endif

/* __gml__PolarCSPropertyType_sequence * has binding name 'PointerTo__gml__PolarCSPropertyType_sequence' for type '-gml:PolarCSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__PolarCSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__PolarCSPropertyType_sequence (-1177)

#endif

/* __gml__SphericalCSPropertyType_sequence * has binding name 'PointerTo__gml__SphericalCSPropertyType_sequence' for type '-gml:SphericalCSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__SphericalCSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__SphericalCSPropertyType_sequence (-1175)

#endif

/* __gml__UserDefinedCSPropertyType_sequence * has binding name 'PointerTo__gml__UserDefinedCSPropertyType_sequence' for type '-gml:UserDefinedCSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__UserDefinedCSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__UserDefinedCSPropertyType_sequence (-1173)

#endif

/* __gml__LinearCSPropertyType_sequence * has binding name 'PointerTo__gml__LinearCSPropertyType_sequence' for type '-gml:LinearCSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__LinearCSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__LinearCSPropertyType_sequence (-1171)

#endif

/* __gml__TimeCSPropertyType_sequence * has binding name 'PointerTo__gml__TimeCSPropertyType_sequence' for type '-gml:TimeCSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__TimeCSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__TimeCSPropertyType_sequence (-1169)

#endif

/* __gml__VerticalCSPropertyType_sequence * has binding name 'PointerTo__gml__VerticalCSPropertyType_sequence' for type '-gml:VerticalCSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__VerticalCSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__VerticalCSPropertyType_sequence (-1167)

#endif

/* __gml__CartesianCSPropertyType_sequence * has binding name 'PointerTo__gml__CartesianCSPropertyType_sequence' for type '-gml:CartesianCSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__CartesianCSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__CartesianCSPropertyType_sequence (-1165)

#endif

/* __gml__EllipsoidalCSPropertyType_sequence * has binding name 'PointerTo__gml__EllipsoidalCSPropertyType_sequence' for type '-gml:EllipsoidalCSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__EllipsoidalCSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__EllipsoidalCSPropertyType_sequence (-1163)

#endif

/* __gml__CoordinateSystemPropertyType_sequence * has binding name 'PointerTo__gml__CoordinateSystemPropertyType_sequence' for type '-gml:CoordinateSystemPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__CoordinateSystemPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__CoordinateSystemPropertyType_sequence (-1161)

#endif

/* gml__ObliqueCartesianCSType * has binding name 'PointerTogml__ObliqueCartesianCSType' for type 'gml:ObliqueCartesianCSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ObliqueCartesianCSType
#define SOAP_TYPE_plu_PointerTogml__ObliqueCartesianCSType (-1160)

#endif

/* gml__TemporalCSType * has binding name 'PointerTogml__TemporalCSType' for type 'gml:TemporalCSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TemporalCSType
#define SOAP_TYPE_plu_PointerTogml__TemporalCSType (-1159)

#endif

/* gml__AffineCSType * has binding name 'PointerTogml__AffineCSType' for type 'gml:AffineCSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__AffineCSType
#define SOAP_TYPE_plu_PointerTogml__AffineCSType (-1158)

#endif

/* gml__CylindricalCSType * has binding name 'PointerTogml__CylindricalCSType' for type 'gml:CylindricalCSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CylindricalCSType
#define SOAP_TYPE_plu_PointerTogml__CylindricalCSType (-1157)

#endif

/* gml__PolarCSType * has binding name 'PointerTogml__PolarCSType' for type 'gml:PolarCSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__PolarCSType
#define SOAP_TYPE_plu_PointerTogml__PolarCSType (-1156)

#endif

/* gml__SphericalCSType * has binding name 'PointerTogml__SphericalCSType' for type 'gml:SphericalCSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__SphericalCSType
#define SOAP_TYPE_plu_PointerTogml__SphericalCSType (-1155)

#endif

/* gml__UserDefinedCSType * has binding name 'PointerTogml__UserDefinedCSType' for type 'gml:UserDefinedCSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__UserDefinedCSType
#define SOAP_TYPE_plu_PointerTogml__UserDefinedCSType (-1154)

#endif

/* gml__LinearCSType * has binding name 'PointerTogml__LinearCSType' for type 'gml:LinearCSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__LinearCSType
#define SOAP_TYPE_plu_PointerTogml__LinearCSType (-1153)

#endif

/* gml__TimeCSType * has binding name 'PointerTogml__TimeCSType' for type 'gml:TimeCSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeCSType
#define SOAP_TYPE_plu_PointerTogml__TimeCSType (-1152)

#endif

/* gml__VerticalCSType * has binding name 'PointerTogml__VerticalCSType' for type 'gml:VerticalCSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__VerticalCSType
#define SOAP_TYPE_plu_PointerTogml__VerticalCSType (-1151)

#endif

/* gml__CartesianCSType * has binding name 'PointerTogml__CartesianCSType' for type 'gml:CartesianCSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CartesianCSType
#define SOAP_TYPE_plu_PointerTogml__CartesianCSType (-1150)

#endif

/* gml__EllipsoidalCSType * has binding name 'PointerTogml__EllipsoidalCSType' for type 'gml:EllipsoidalCSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__EllipsoidalCSType
#define SOAP_TYPE_plu_PointerTogml__EllipsoidalCSType (-1149)

#endif

/* __gml__CoordinateSystemAxisPropertyType_sequence * has binding name 'PointerTo__gml__CoordinateSystemAxisPropertyType_sequence' for type '-gml:CoordinateSystemAxisPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__CoordinateSystemAxisPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__CoordinateSystemAxisPropertyType_sequence (-1146)

#endif

/* gml__CoordinateSystemAxisType * has binding name 'PointerTogml__CoordinateSystemAxisType' for type 'gml:CoordinateSystemAxisType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CoordinateSystemAxisType
#define SOAP_TYPE_plu_PointerTogml__CoordinateSystemAxisType (-1145)

#endif

/* __gml__TemporalCRSPropertyType_sequence * has binding name 'PointerTo__gml__TemporalCRSPropertyType_sequence' for type '-gml:TemporalCRSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__TemporalCRSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__TemporalCRSPropertyType_sequence (-1143)

#endif

/* __gml__ImageCRSPropertyType_sequence * has binding name 'PointerTo__gml__ImageCRSPropertyType_sequence' for type '-gml:ImageCRSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__ImageCRSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__ImageCRSPropertyType_sequence (-1141)

#endif

/* __gml__EngineeringCRSPropertyType_sequence * has binding name 'PointerTo__gml__EngineeringCRSPropertyType_sequence' for type '-gml:EngineeringCRSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__EngineeringCRSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__EngineeringCRSPropertyType_sequence (-1139)

#endif

/* __gml__DerivedCRSPropertyType_sequence * has binding name 'PointerTo__gml__DerivedCRSPropertyType_sequence' for type '-gml:DerivedCRSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__DerivedCRSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__DerivedCRSPropertyType_sequence (-1137)

#endif

/* gml__DerivedCRSType * has binding name 'PointerTogml__DerivedCRSType' for type 'gml:DerivedCRSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DerivedCRSType
#define SOAP_TYPE_plu_PointerTogml__DerivedCRSType (-1136)

#endif

/* __gml__ProjectedCRSPropertyType_sequence * has binding name 'PointerTo__gml__ProjectedCRSPropertyType_sequence' for type '-gml:ProjectedCRSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__ProjectedCRSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__ProjectedCRSPropertyType_sequence (-1134)

#endif

/* gml__ProjectedCRSType * has binding name 'PointerTogml__ProjectedCRSType' for type 'gml:ProjectedCRSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ProjectedCRSType
#define SOAP_TYPE_plu_PointerTogml__ProjectedCRSType (-1133)

#endif

/* __gml__VerticalCRSPropertyType_sequence * has binding name 'PointerTo__gml__VerticalCRSPropertyType_sequence' for type '-gml:VerticalCRSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__VerticalCRSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__VerticalCRSPropertyType_sequence (-1131)

#endif

/* __gml__GeodeticCRSPropertyType_sequence * has binding name 'PointerTo__gml__GeodeticCRSPropertyType_sequence' for type '-gml:GeodeticCRSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__GeodeticCRSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__GeodeticCRSPropertyType_sequence (-1129)

#endif

/* __gml__CompoundCRSPropertyType_sequence * has binding name 'PointerTo__gml__CompoundCRSPropertyType_sequence' for type '-gml:CompoundCRSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__CompoundCRSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__CompoundCRSPropertyType_sequence (-1127)

#endif

/* gml__CompoundCRSType * has binding name 'PointerTogml__CompoundCRSType' for type 'gml:CompoundCRSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CompoundCRSType
#define SOAP_TYPE_plu_PointerTogml__CompoundCRSType (-1126)

#endif

/* __gml__SingleCRSPropertyType_sequence * has binding name 'PointerTo__gml__SingleCRSPropertyType_sequence' for type '-gml:SingleCRSPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__SingleCRSPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__SingleCRSPropertyType_sequence (-1124)

#endif

/* gml__GeocentricCRSType * has binding name 'PointerTogml__GeocentricCRSType' for type 'gml:GeocentricCRSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__GeocentricCRSType
#define SOAP_TYPE_plu_PointerTogml__GeocentricCRSType (-1123)

#endif

/* gml__GeographicCRSType * has binding name 'PointerTogml__GeographicCRSType' for type 'gml:GeographicCRSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__GeographicCRSType
#define SOAP_TYPE_plu_PointerTogml__GeographicCRSType (-1122)

#endif

/* gml__TemporalCRSType * has binding name 'PointerTogml__TemporalCRSType' for type 'gml:TemporalCRSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TemporalCRSType
#define SOAP_TYPE_plu_PointerTogml__TemporalCRSType (-1121)

#endif

/* gml__ImageCRSType * has binding name 'PointerTogml__ImageCRSType' for type 'gml:ImageCRSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ImageCRSType
#define SOAP_TYPE_plu_PointerTogml__ImageCRSType (-1120)

#endif

/* gml__EngineeringCRSType * has binding name 'PointerTogml__EngineeringCRSType' for type 'gml:EngineeringCRSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__EngineeringCRSType
#define SOAP_TYPE_plu_PointerTogml__EngineeringCRSType (-1119)

#endif

/* gml__VerticalCRSType * has binding name 'PointerTogml__VerticalCRSType' for type 'gml:VerticalCRSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__VerticalCRSType
#define SOAP_TYPE_plu_PointerTogml__VerticalCRSType (-1118)

#endif

/* gml__GeodeticCRSType * has binding name 'PointerTogml__GeodeticCRSType' for type 'gml:GeodeticCRSType' */
#ifndef SOAP_TYPE_plu_PointerTogml__GeodeticCRSType
#define SOAP_TYPE_plu_PointerTogml__GeodeticCRSType (-1117)

#endif

/* gml__GridEnvelopeType * has binding name 'PointerTogml__GridEnvelopeType' for type 'gml:GridEnvelopeType' */
#ifndef SOAP_TYPE_plu_PointerTogml__GridEnvelopeType
#define SOAP_TYPE_plu_PointerTogml__GridEnvelopeType (-1114)

#endif

/* __gml__CountPropertyType_sequence * has binding name 'PointerTo__gml__CountPropertyType_sequence' for type '-gml:CountPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__CountPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__CountPropertyType_sequence (-1113)

#endif

/* _gml__Count * has binding name 'PointerTo_gml__Count' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_gml__Count
#define SOAP_TYPE_plu_PointerTo_gml__Count (-1112)

#endif

/* __gml__QuantityPropertyType_sequence * has binding name 'PointerTo__gml__QuantityPropertyType_sequence' for type '-gml:QuantityPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__QuantityPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__QuantityPropertyType_sequence (-1110)

#endif

/* _gml__Quantity * has binding name 'PointerTo_gml__Quantity' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_gml__Quantity
#define SOAP_TYPE_plu_PointerTo_gml__Quantity (-1109)

#endif

/* __gml__CategoryPropertyType_sequence * has binding name 'PointerTo__gml__CategoryPropertyType_sequence' for type '-gml:CategoryPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__CategoryPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__CategoryPropertyType_sequence (-1107)

#endif

/* _gml__Category * has binding name 'PointerTo_gml__Category' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_gml__Category
#define SOAP_TYPE_plu_PointerTo_gml__Category (-1106)

#endif

/* __gml__BooleanPropertyType_sequence * has binding name 'PointerTo__gml__BooleanPropertyType_sequence' for type '-gml:BooleanPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__BooleanPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__BooleanPropertyType_sequence (-1104)

#endif

/* _gml__Boolean * has binding name 'PointerTo_gml__Boolean' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_gml__Boolean
#define SOAP_TYPE_plu_PointerTo_gml__Boolean (-1103)

#endif

/* __gml__ValuePropertyType_sequence * has binding name 'PointerTo__gml__ValuePropertyType_sequence' for type '-gml:ValuePropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__ValuePropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__ValuePropertyType_sequence (-1098)

#endif

/* gml__QuantityExtentType * has binding name 'PointerTogml__QuantityExtentType' for type 'gml:QuantityExtentType' */
#ifndef SOAP_TYPE_plu_PointerTogml__QuantityExtentType
#define SOAP_TYPE_plu_PointerTogml__QuantityExtentType (-1097)

#endif

/* std::string * has binding name 'PointerTogml__CountExtentType' for type 'gml:CountExtentType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CountExtentType
#define SOAP_TYPE_plu_PointerTogml__CountExtentType (-1096)

#endif

/* gml__CategoryExtentType * has binding name 'PointerTogml__CategoryExtentType' for type 'gml:CategoryExtentType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CategoryExtentType
#define SOAP_TYPE_plu_PointerTogml__CategoryExtentType (-1095)

#endif

/* gml__CompositeValueType * has binding name 'PointerTogml__CompositeValueType' for type 'gml:CompositeValueType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CompositeValueType
#define SOAP_TYPE_plu_PointerTogml__CompositeValueType (-1094)

#endif

/* __gml__TimePeriodPropertyType_sequence * has binding name 'PointerTo__gml__TimePeriodPropertyType_sequence' for type '-gml:TimePeriodPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__TimePeriodPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__TimePeriodPropertyType_sequence (-1091)

#endif

/* gml__TimePeriodType * has binding name 'PointerTogml__TimePeriodType' for type 'gml:TimePeriodType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimePeriodType
#define SOAP_TYPE_plu_PointerTogml__TimePeriodType (-1090)

#endif

/* __gml__TimeInstantPropertyType_sequence * has binding name 'PointerTo__gml__TimeInstantPropertyType_sequence' for type '-gml:TimeInstantPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__TimeInstantPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__TimeInstantPropertyType_sequence (-1088)

#endif

/* gml__TimeInstantType * has binding name 'PointerTogml__TimeInstantType' for type 'gml:TimeInstantType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TimeInstantType
#define SOAP_TYPE_plu_PointerTogml__TimeInstantType (-1087)

#endif

/* __gml__TimePrimitivePropertyType_sequence * has binding name 'PointerTo__gml__TimePrimitivePropertyType_sequence' for type '-gml:TimePrimitivePropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__TimePrimitivePropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__TimePrimitivePropertyType_sequence (-1085)

#endif

/* gml__EnvelopeWithTimePeriodType * has binding name 'PointerTogml__EnvelopeWithTimePeriodType' for type 'gml:EnvelopeWithTimePeriodType' */
#ifndef SOAP_TYPE_plu_PointerTogml__EnvelopeWithTimePeriodType
#define SOAP_TYPE_plu_PointerTogml__EnvelopeWithTimePeriodType (-1082)

#endif

/* gml__EnvelopeType * has binding name 'PointerTogml__EnvelopeType' for type 'gml:EnvelopeType' */
#ifndef SOAP_TYPE_plu_PointerTogml__EnvelopeType
#define SOAP_TYPE_plu_PointerTogml__EnvelopeType (-1081)

#endif

/* __gml__FeaturePropertyType_sequence * has binding name 'PointerTo__gml__FeaturePropertyType_sequence' for type '-gml:FeaturePropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__FeaturePropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__FeaturePropertyType_sequence (-1079)

#endif

/* gml__FeatureCollectionType * has binding name 'PointerTogml__FeatureCollectionType' for type 'gml:FeatureCollectionType' */
#ifndef SOAP_TYPE_plu_PointerTogml__FeatureCollectionType
#define SOAP_TYPE_plu_PointerTogml__FeatureCollectionType (-1078)

#endif

/* gml__DirectedObservationAtDistanceType * has binding name 'PointerTogml__DirectedObservationAtDistanceType' for type 'gml:DirectedObservationAtDistanceType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DirectedObservationAtDistanceType
#define SOAP_TYPE_plu_PointerTogml__DirectedObservationAtDistanceType (-1077)

#endif

/* gml__DirectedObservationType * has binding name 'PointerTogml__DirectedObservationType' for type 'gml:DirectedObservationType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DirectedObservationType
#define SOAP_TYPE_plu_PointerTogml__DirectedObservationType (-1076)

#endif

/* gml__ObservationType * has binding name 'PointerTogml__ObservationType' for type 'gml:ObservationType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ObservationType
#define SOAP_TYPE_plu_PointerTogml__ObservationType (-1075)

#endif

/* gml__DynamicFeatureCollectionType * has binding name 'PointerTogml__DynamicFeatureCollectionType' for type 'gml:DynamicFeatureCollectionType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DynamicFeatureCollectionType
#define SOAP_TYPE_plu_PointerTogml__DynamicFeatureCollectionType (-1074)

#endif

/* gml__DynamicFeatureType * has binding name 'PointerTogml__DynamicFeatureType' for type 'gml:DynamicFeatureType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DynamicFeatureType
#define SOAP_TYPE_plu_PointerTogml__DynamicFeatureType (-1073)

#endif

/* std::string * has binding name 'PointerTogml__integerList' for type 'gml:integerList' */
#ifndef SOAP_TYPE_plu_PointerTogml__integerList
#define SOAP_TYPE_plu_PointerTogml__integerList (-1070)

#endif

/* gml__SequenceRuleType * has binding name 'PointerTogml__SequenceRuleType' for type 'gml:SequenceRuleType' */
#ifndef SOAP_TYPE_plu_PointerTogml__SequenceRuleType
#define SOAP_TYPE_plu_PointerTogml__SequenceRuleType (-1069)

#endif

/* gml__GridFunctionType * has binding name 'PointerTogml__GridFunctionType' for type 'gml:GridFunctionType' */
#ifndef SOAP_TYPE_plu_PointerTogml__GridFunctionType
#define SOAP_TYPE_plu_PointerTogml__GridFunctionType (-1067)

#endif

/* gml__MappingRuleType * has binding name 'PointerTogml__MappingRuleType' for type 'gml:MappingRuleType' */
#ifndef SOAP_TYPE_plu_PointerTogml__MappingRuleType
#define SOAP_TYPE_plu_PointerTogml__MappingRuleType (-1066)

#endif

/* std::string * has binding name 'PointerTogml__doubleOrNilReasonList' for type 'gml:doubleOrNilReasonList' */
#ifndef SOAP_TYPE_plu_PointerTogml__doubleOrNilReasonList
#define SOAP_TYPE_plu_PointerTogml__doubleOrNilReasonList (-1063)

#endif

/* gml__AssociationRoleType * has binding name 'PointerTogml__AssociationRoleType' for type 'gml:AssociationRoleType' */
#ifndef SOAP_TYPE_plu_PointerTogml__AssociationRoleType
#define SOAP_TYPE_plu_PointerTogml__AssociationRoleType (-1061)

#endif

/* gml__FileType * has binding name 'PointerTogml__FileType' for type 'gml:FileType' */
#ifndef SOAP_TYPE_plu_PointerTogml__FileType
#define SOAP_TYPE_plu_PointerTogml__FileType (-1060)

#endif

/* gml__DataBlockType * has binding name 'PointerTogml__DataBlockType' for type 'gml:DataBlockType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DataBlockType
#define SOAP_TYPE_plu_PointerTogml__DataBlockType (-1059)

#endif

/* __gml__union_RangeSetType_ * has binding name 'PointerTo__gml__union_RangeSetType_' for type '-gml:union-RangeSetType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_RangeSetType_
#define SOAP_TYPE_plu_PointerTo__gml__union_RangeSetType_ (-1058)

#endif

/* gml__MeasureOrNilReasonListType * has binding name 'PointerTogml__MeasureOrNilReasonListType' for type 'gml:MeasureOrNilReasonListType' */
#ifndef SOAP_TYPE_plu_PointerTogml__MeasureOrNilReasonListType
#define SOAP_TYPE_plu_PointerTogml__MeasureOrNilReasonListType (-1057)

#endif

/* std::string * has binding name 'PointerTogml__integerOrNilReasonList' for type 'gml:integerOrNilReasonList' */
#ifndef SOAP_TYPE_plu_PointerTogml__integerOrNilReasonList
#define SOAP_TYPE_plu_PointerTogml__integerOrNilReasonList (-1056)

#endif

/* gml__CodeOrNilReasonListType * has binding name 'PointerTogml__CodeOrNilReasonListType' for type 'gml:CodeOrNilReasonListType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CodeOrNilReasonListType
#define SOAP_TYPE_plu_PointerTogml__CodeOrNilReasonListType (-1055)

#endif

/* std::string * has binding name 'PointerTogml__booleanOrNilReasonList' for type 'gml:booleanOrNilReasonList' */
#ifndef SOAP_TYPE_plu_PointerTogml__booleanOrNilReasonList
#define SOAP_TYPE_plu_PointerTogml__booleanOrNilReasonList (-1054)

#endif

/* std::vector<gml__ValueArrayType *> * has binding name 'PointerTostd__vectorTemplateOfPointerTogml__ValueArrayType' for type 'gml:ValueArrayType' */
#ifndef SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTogml__ValueArrayType
#define SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTogml__ValueArrayType (-1050)

#endif

/* gml__ValueArrayType * has binding name 'PointerTogml__ValueArrayType' for type 'gml:ValueArrayType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ValueArrayType
#define SOAP_TYPE_plu_PointerTogml__ValueArrayType (-1048)

#endif

/* __gml__DomainSetType_sequence * has binding name 'PointerTo__gml__DomainSetType_sequence' for type '-gml:DomainSetType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__DomainSetType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__DomainSetType_sequence (-1046)

#endif

/* __gml__AssociationRoleType_sequence * has binding name 'PointerTo__gml__AssociationRoleType_sequence' for type '-gml:AssociationRoleType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__AssociationRoleType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__AssociationRoleType_sequence (-1043)

#endif

/* char ** has binding name 'PointerToxsd__ID' for type 'xsd:ID' */
#ifndef SOAP_TYPE_plu_PointerToxsd__ID
#define SOAP_TYPE_plu_PointerToxsd__ID (-1041)

#endif

/* gml__CodeType * has binding name 'PointerTogml__CodeType' for type 'gml:CodeType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CodeType
#define SOAP_TYPE_plu_PointerTogml__CodeType (-1039)

#endif

/* gml__CodeWithAuthorityType * has binding name 'PointerTogml__CodeWithAuthorityType' for type 'gml:CodeWithAuthorityType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CodeWithAuthorityType
#define SOAP_TYPE_plu_PointerTogml__CodeWithAuthorityType (-1038)

#endif

/* gml__StringOrRefType * has binding name 'PointerTogml__StringOrRefType' for type 'gml:StringOrRefType' */
#ifndef SOAP_TYPE_plu_PointerTogml__StringOrRefType
#define SOAP_TYPE_plu_PointerTogml__StringOrRefType (-1037)

#endif

/* gml__MetaDataPropertyType * has binding name 'PointerTogml__MetaDataPropertyType' for type 'gml:MetaDataPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogml__MetaDataPropertyType
#define SOAP_TYPE_plu_PointerTogml__MetaDataPropertyType (-1035)

#endif

/* double * has binding name 'PointerTodouble' for type 'xsd:double' */
#ifndef SOAP_TYPE_plu_PointerTodouble
#define SOAP_TYPE_plu_PointerTodouble (-1034)

#endif

/* __gml__CurvePropertyType_sequence * has binding name 'PointerTo__gml__CurvePropertyType_sequence' for type '-gml:CurvePropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__CurvePropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__CurvePropertyType_sequence (-1030)

#endif

/* gml__LineStringType * has binding name 'PointerTogml__LineStringType' for type 'gml:LineStringType' */
#ifndef SOAP_TYPE_plu_PointerTogml__LineStringType
#define SOAP_TYPE_plu_PointerTogml__LineStringType (-1029)

#endif

/* gml__OrientableCurveType * has binding name 'PointerTogml__OrientableCurveType' for type 'gml:OrientableCurveType' */
#ifndef SOAP_TYPE_plu_PointerTogml__OrientableCurveType
#define SOAP_TYPE_plu_PointerTogml__OrientableCurveType (-1028)

#endif

/* gml__CurveType * has binding name 'PointerTogml__CurveType' for type 'gml:CurveType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CurveType
#define SOAP_TYPE_plu_PointerTogml__CurveType (-1027)

#endif

/* __gml__PointPropertyType_sequence * has binding name 'PointerTo__gml__PointPropertyType_sequence' for type '-gml:PointPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__PointPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__PointPropertyType_sequence (-1022)

#endif

/* __gml__GeometricPrimitivePropertyType_sequence * has binding name 'PointerTo__gml__GeometricPrimitivePropertyType_sequence' for type '-gml:GeometricPrimitivePropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__GeometricPrimitivePropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__GeometricPrimitivePropertyType_sequence (-1020)

#endif

/* gml__PointType * has binding name 'PointerTogml__PointType' for type 'gml:PointType' */
#ifndef SOAP_TYPE_plu_PointerTogml__PointType
#define SOAP_TYPE_plu_PointerTogml__PointType (-1019)

#endif

/* std::string * has binding name 'PointerTogml__NCNameList' for type 'gml:NCNameList' */
#ifndef SOAP_TYPE_plu_PointerTogml__NCNameList
#define SOAP_TYPE_plu_PointerTogml__NCNameList (-1016)

#endif

/* ULONG64 * has binding name 'PointerToxsd__positiveInteger' for type 'xsd:positiveInteger' */
#ifndef SOAP_TYPE_plu_PointerToxsd__positiveInteger
#define SOAP_TYPE_plu_PointerToxsd__positiveInteger (-1015)

#endif

/* gml__CoordinatesType * has binding name 'PointerTogml__CoordinatesType' for type 'gml:CoordinatesType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CoordinatesType
#define SOAP_TYPE_plu_PointerTogml__CoordinatesType (-1014)

#endif

/* __gml__GeometryPropertyType_sequence * has binding name 'PointerTo__gml__GeometryPropertyType_sequence' for type '-gml:GeometryPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__GeometryPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__GeometryPropertyType_sequence (-1009)

#endif

/* gml__LinearRingType * has binding name 'PointerTogml__LinearRingType' for type 'gml:LinearRingType' */
#ifndef SOAP_TYPE_plu_PointerTogml__LinearRingType
#define SOAP_TYPE_plu_PointerTogml__LinearRingType (-1006)

#endif

/* __gml__SurfacePropertyType_sequence * has binding name 'PointerTo__gml__SurfacePropertyType_sequence' for type '-gml:SurfacePropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__SurfacePropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__SurfacePropertyType_sequence (-1001)

#endif

/* gml__PolygonType * has binding name 'PointerTogml__PolygonType' for type 'gml:PolygonType' */
#ifndef SOAP_TYPE_plu_PointerTogml__PolygonType
#define SOAP_TYPE_plu_PointerTogml__PolygonType (-1000)

#endif

/* gml__OrientableSurfaceType * has binding name 'PointerTogml__OrientableSurfaceType' for type 'gml:OrientableSurfaceType' */
#ifndef SOAP_TYPE_plu_PointerTogml__OrientableSurfaceType
#define SOAP_TYPE_plu_PointerTogml__OrientableSurfaceType (-999)

#endif

/* gml__TinType * has binding name 'PointerTogml__TinType' for type 'gml:TinType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TinType
#define SOAP_TYPE_plu_PointerTogml__TinType (-998)

#endif

/* gml__SurfaceType * has binding name 'PointerTogml__SurfaceType' for type 'gml:SurfaceType' */
#ifndef SOAP_TYPE_plu_PointerTogml__SurfaceType
#define SOAP_TYPE_plu_PointerTogml__SurfaceType (-997)

#endif

/* gml__ShellType * has binding name 'PointerTogml__ShellType' for type 'gml:ShellType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ShellType
#define SOAP_TYPE_plu_PointerTogml__ShellType (-994)

#endif

/* __gml__SolidPropertyType_sequence * has binding name 'PointerTo__gml__SolidPropertyType_sequence' for type '-gml:SolidPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__SolidPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__SolidPropertyType_sequence (-990)

#endif

/* gml__SolidType * has binding name 'PointerTogml__SolidType' for type 'gml:SolidType' */
#ifndef SOAP_TYPE_plu_PointerTogml__SolidType
#define SOAP_TYPE_plu_PointerTogml__SolidType (-989)

#endif

/* gml__RingType * has binding name 'PointerTogml__RingType' for type 'gml:RingType' */
#ifndef SOAP_TYPE_plu_PointerTogml__RingType
#define SOAP_TYPE_plu_PointerTogml__RingType (-984)

#endif

/* gml__RectangleType * has binding name 'PointerTogml__RectangleType' for type 'gml:RectangleType' */
#ifndef SOAP_TYPE_plu_PointerTogml__RectangleType
#define SOAP_TYPE_plu_PointerTogml__RectangleType (-982)

#endif

/* gml__TriangleType * has binding name 'PointerTogml__TriangleType' for type 'gml:TriangleType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TriangleType
#define SOAP_TYPE_plu_PointerTogml__TriangleType (-981)

#endif

/* gml__PolygonPatchType * has binding name 'PointerTogml__PolygonPatchType' for type 'gml:PolygonPatchType' */
#ifndef SOAP_TYPE_plu_PointerTogml__PolygonPatchType
#define SOAP_TYPE_plu_PointerTogml__PolygonPatchType (-980)

#endif

/* gml__VectorType * has binding name 'PointerTogml__VectorType' for type 'gml:VectorType' */
#ifndef SOAP_TYPE_plu_PointerTogml__VectorType
#define SOAP_TYPE_plu_PointerTogml__VectorType (-976)

#endif

/* gml__DirectPositionType * has binding name 'PointerTogml__DirectPositionType' for type 'gml:DirectPositionType' */
#ifndef SOAP_TYPE_plu_PointerTogml__DirectPositionType
#define SOAP_TYPE_plu_PointerTogml__DirectPositionType (-975)

#endif

/* gml__KnotType * has binding name 'PointerTogml__KnotType' for type 'gml:KnotType' */
#ifndef SOAP_TYPE_plu_PointerTogml__KnotType
#define SOAP_TYPE_plu_PointerTogml__KnotType (-974)

#endif

/* gml__GeodesicType * has binding name 'PointerTogml__GeodesicType' for type 'gml:GeodesicType' */
#ifndef SOAP_TYPE_plu_PointerTogml__GeodesicType
#define SOAP_TYPE_plu_PointerTogml__GeodesicType (-972)

#endif

/* gml__GeodesicStringType * has binding name 'PointerTogml__GeodesicStringType' for type 'gml:GeodesicStringType' */
#ifndef SOAP_TYPE_plu_PointerTogml__GeodesicStringType
#define SOAP_TYPE_plu_PointerTogml__GeodesicStringType (-971)

#endif

/* gml__ClothoidType * has binding name 'PointerTogml__ClothoidType' for type 'gml:ClothoidType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ClothoidType
#define SOAP_TYPE_plu_PointerTogml__ClothoidType (-970)

#endif

/* gml__OffsetCurveType * has binding name 'PointerTogml__OffsetCurveType' for type 'gml:OffsetCurveType' */
#ifndef SOAP_TYPE_plu_PointerTogml__OffsetCurveType
#define SOAP_TYPE_plu_PointerTogml__OffsetCurveType (-969)

#endif

/* gml__BezierType * has binding name 'PointerTogml__BezierType' for type 'gml:BezierType' */
#ifndef SOAP_TYPE_plu_PointerTogml__BezierType
#define SOAP_TYPE_plu_PointerTogml__BezierType (-968)

#endif

/* gml__BSplineType * has binding name 'PointerTogml__BSplineType' for type 'gml:BSplineType' */
#ifndef SOAP_TYPE_plu_PointerTogml__BSplineType
#define SOAP_TYPE_plu_PointerTogml__BSplineType (-967)

#endif

/* gml__CubicSplineType * has binding name 'PointerTogml__CubicSplineType' for type 'gml:CubicSplineType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CubicSplineType
#define SOAP_TYPE_plu_PointerTogml__CubicSplineType (-966)

#endif

/* gml__CircleByCenterPointType * has binding name 'PointerTogml__CircleByCenterPointType' for type 'gml:CircleByCenterPointType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CircleByCenterPointType
#define SOAP_TYPE_plu_PointerTogml__CircleByCenterPointType (-965)

#endif

/* gml__ArcByCenterPointType * has binding name 'PointerTogml__ArcByCenterPointType' for type 'gml:ArcByCenterPointType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ArcByCenterPointType
#define SOAP_TYPE_plu_PointerTogml__ArcByCenterPointType (-964)

#endif

/* gml__ArcByBulgeType * has binding name 'PointerTogml__ArcByBulgeType' for type 'gml:ArcByBulgeType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ArcByBulgeType
#define SOAP_TYPE_plu_PointerTogml__ArcByBulgeType (-963)

#endif

/* gml__ArcStringByBulgeType * has binding name 'PointerTogml__ArcStringByBulgeType' for type 'gml:ArcStringByBulgeType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ArcStringByBulgeType
#define SOAP_TYPE_plu_PointerTogml__ArcStringByBulgeType (-962)

#endif

/* gml__CircleType * has binding name 'PointerTogml__CircleType' for type 'gml:CircleType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CircleType
#define SOAP_TYPE_plu_PointerTogml__CircleType (-961)

#endif

/* gml__ArcType * has binding name 'PointerTogml__ArcType' for type 'gml:ArcType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ArcType
#define SOAP_TYPE_plu_PointerTogml__ArcType (-960)

#endif

/* gml__ArcStringType * has binding name 'PointerTogml__ArcStringType' for type 'gml:ArcStringType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ArcStringType
#define SOAP_TYPE_plu_PointerTogml__ArcStringType (-959)

#endif

/* gml__LineStringSegmentType * has binding name 'PointerTogml__LineStringSegmentType' for type 'gml:LineStringSegmentType' */
#ifndef SOAP_TYPE_plu_PointerTogml__LineStringSegmentType
#define SOAP_TYPE_plu_PointerTogml__LineStringSegmentType (-958)

#endif

/* __gml__MultiSolidPropertyType_sequence * has binding name 'PointerTo__gml__MultiSolidPropertyType_sequence' for type '-gml:MultiSolidPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__MultiSolidPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__MultiSolidPropertyType_sequence (-955)

#endif

/* __gml__MultiSurfacePropertyType_sequence * has binding name 'PointerTo__gml__MultiSurfacePropertyType_sequence' for type '-gml:MultiSurfacePropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__MultiSurfacePropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__MultiSurfacePropertyType_sequence (-953)

#endif

/* __gml__MultiCurvePropertyType_sequence * has binding name 'PointerTo__gml__MultiCurvePropertyType_sequence' for type '-gml:MultiCurvePropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__MultiCurvePropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__MultiCurvePropertyType_sequence (-951)

#endif

/* __gml__MultiPointPropertyType_sequence * has binding name 'PointerTo__gml__MultiPointPropertyType_sequence' for type '-gml:MultiPointPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__MultiPointPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__MultiPointPropertyType_sequence (-949)

#endif

/* __gml__MultiGeometryPropertyType_sequence * has binding name 'PointerTo__gml__MultiGeometryPropertyType_sequence' for type '-gml:MultiGeometryPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__MultiGeometryPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__MultiGeometryPropertyType_sequence (-947)

#endif

/* gml__MultiSolidType * has binding name 'PointerTogml__MultiSolidType' for type 'gml:MultiSolidType' */
#ifndef SOAP_TYPE_plu_PointerTogml__MultiSolidType
#define SOAP_TYPE_plu_PointerTogml__MultiSolidType (-946)

#endif

/* gml__MultiSurfaceType * has binding name 'PointerTogml__MultiSurfaceType' for type 'gml:MultiSurfaceType' */
#ifndef SOAP_TYPE_plu_PointerTogml__MultiSurfaceType
#define SOAP_TYPE_plu_PointerTogml__MultiSurfaceType (-945)

#endif

/* gml__MultiCurveType * has binding name 'PointerTogml__MultiCurveType' for type 'gml:MultiCurveType' */
#ifndef SOAP_TYPE_plu_PointerTogml__MultiCurveType
#define SOAP_TYPE_plu_PointerTogml__MultiCurveType (-944)

#endif

/* gml__MultiPointType * has binding name 'PointerTogml__MultiPointType' for type 'gml:MultiPointType' */
#ifndef SOAP_TYPE_plu_PointerTogml__MultiPointType
#define SOAP_TYPE_plu_PointerTogml__MultiPointType (-943)

#endif

/* gml__MultiGeometryType * has binding name 'PointerTogml__MultiGeometryType' for type 'gml:MultiGeometryType' */
#ifndef SOAP_TYPE_plu_PointerTogml__MultiGeometryType
#define SOAP_TYPE_plu_PointerTogml__MultiGeometryType (-942)

#endif

/* __gml__GeometricComplexPropertyType_sequence * has binding name 'PointerTo__gml__GeometricComplexPropertyType_sequence' for type '-gml:GeometricComplexPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__GeometricComplexPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__GeometricComplexPropertyType_sequence (-939)

#endif

/* gml__CompositeSolidType * has binding name 'PointerTogml__CompositeSolidType' for type 'gml:CompositeSolidType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CompositeSolidType
#define SOAP_TYPE_plu_PointerTogml__CompositeSolidType (-938)

#endif

/* gml__CompositeSurfaceType * has binding name 'PointerTogml__CompositeSurfaceType' for type 'gml:CompositeSurfaceType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CompositeSurfaceType
#define SOAP_TYPE_plu_PointerTogml__CompositeSurfaceType (-937)

#endif

/* gml__CompositeCurveType * has binding name 'PointerTogml__CompositeCurveType' for type 'gml:CompositeCurveType' */
#ifndef SOAP_TYPE_plu_PointerTogml__CompositeCurveType
#define SOAP_TYPE_plu_PointerTogml__CompositeCurveType (-936)

#endif

/* gml__GeometricComplexType * has binding name 'PointerTogml__GeometricComplexType' for type 'gml:GeometricComplexType' */
#ifndef SOAP_TYPE_plu_PointerTogml__GeometricComplexType
#define SOAP_TYPE_plu_PointerTogml__GeometricComplexType (-935)

#endif

/* __gml__TopoComplexPropertyType_sequence * has binding name 'PointerTo__gml__TopoComplexPropertyType_sequence' for type '-gml:TopoComplexPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__TopoComplexPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__TopoComplexPropertyType_sequence (-932)

#endif

/* gml__TopoComplexType * has binding name 'PointerTogml__TopoComplexType' for type 'gml:TopoComplexType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TopoComplexType
#define SOAP_TYPE_plu_PointerTogml__TopoComplexType (-931)

#endif

/* __gml__TopoPrimitiveMemberType_sequence * has binding name 'PointerTo__gml__TopoPrimitiveMemberType_sequence' for type '-gml:TopoPrimitiveMemberType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__TopoPrimitiveMemberType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__TopoPrimitiveMemberType_sequence (-926)

#endif

/* gml__TopoVolumeType * has binding name 'PointerTogml__TopoVolumeType' for type 'gml:TopoVolumeType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TopoVolumeType
#define SOAP_TYPE_plu_PointerTogml__TopoVolumeType (-923)

#endif

/* gml__TopoSurfaceType * has binding name 'PointerTogml__TopoSurfaceType' for type 'gml:TopoSurfaceType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TopoSurfaceType
#define SOAP_TYPE_plu_PointerTogml__TopoSurfaceType (-922)

#endif

/* gml__TopoCurveType * has binding name 'PointerTogml__TopoCurveType' for type 'gml:TopoCurveType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TopoCurveType
#define SOAP_TYPE_plu_PointerTogml__TopoCurveType (-921)

#endif

/* gml__TopoPointType * has binding name 'PointerTogml__TopoPointType' for type 'gml:TopoPointType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TopoPointType
#define SOAP_TYPE_plu_PointerTogml__TopoPointType (-920)

#endif

/* __gml__DirectedTopoSolidPropertyType_sequence * has binding name 'PointerTo__gml__DirectedTopoSolidPropertyType_sequence' for type '-gml:DirectedTopoSolidPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__DirectedTopoSolidPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__DirectedTopoSolidPropertyType_sequence (-919)

#endif

/* __gml__DirectedFacePropertyType_sequence * has binding name 'PointerTo__gml__DirectedFacePropertyType_sequence' for type '-gml:DirectedFacePropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__DirectedFacePropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__DirectedFacePropertyType_sequence (-917)

#endif

/* __gml__DirectedEdgePropertyType_sequence * has binding name 'PointerTo__gml__DirectedEdgePropertyType_sequence' for type '-gml:DirectedEdgePropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__DirectedEdgePropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__DirectedEdgePropertyType_sequence (-915)

#endif

/* __gml__DirectedNodePropertyType_sequence * has binding name 'PointerTo__gml__DirectedNodePropertyType_sequence' for type '-gml:DirectedNodePropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__DirectedNodePropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__gml__DirectedNodePropertyType_sequence (-913)

#endif

/* gml__TopoSolidType * has binding name 'PointerTogml__TopoSolidType' for type 'gml:TopoSolidType' */
#ifndef SOAP_TYPE_plu_PointerTogml__TopoSolidType
#define SOAP_TYPE_plu_PointerTogml__TopoSolidType (-910)

#endif

/* gml__FaceType * has binding name 'PointerTogml__FaceType' for type 'gml:FaceType' */
#ifndef SOAP_TYPE_plu_PointerTogml__FaceType
#define SOAP_TYPE_plu_PointerTogml__FaceType (-909)

#endif

/* gml__EdgeType * has binding name 'PointerTogml__EdgeType' for type 'gml:EdgeType' */
#ifndef SOAP_TYPE_plu_PointerTogml__EdgeType
#define SOAP_TYPE_plu_PointerTogml__EdgeType (-906)

#endif

/* gml__NodeType * has binding name 'PointerTogml__NodeType' for type 'gml:NodeType' */
#ifndef SOAP_TYPE_plu_PointerTogml__NodeType
#define SOAP_TYPE_plu_PointerTogml__NodeType (-905)

#endif

/* __gml__union_HistoryPropertyType * has binding name 'PointerTo__gml__union_HistoryPropertyType' for type '-gml:union-HistoryPropertyType' */
#ifndef SOAP_TYPE_plu_PointerTo__gml__union_HistoryPropertyType
#define SOAP_TYPE_plu_PointerTo__gml__union_HistoryPropertyType (-903)

#endif

/* gml__MovingObjectStatusType * has binding name 'PointerTogml__MovingObjectStatusType' for type 'gml:MovingObjectStatusType' */
#ifndef SOAP_TYPE_plu_PointerTogml__MovingObjectStatusType
#define SOAP_TYPE_plu_PointerTogml__MovingObjectStatusType (-902)

#endif

/* lunom__HILUCSPercentageType * has binding name 'PointerTolunom__HILUCSPercentageType' for type 'lunom:HILUCSPercentageType' */
#ifndef SOAP_TYPE_plu_PointerTolunom__HILUCSPercentageType
#define SOAP_TYPE_plu_PointerTolunom__HILUCSPercentageType (-899)

#endif

/* lunom__SpecificPresenceType * has binding name 'PointerTolunom__SpecificPresenceType' for type 'lunom:SpecificPresenceType' */
#ifndef SOAP_TYPE_plu_PointerTolunom__SpecificPresenceType
#define SOAP_TYPE_plu_PointerTolunom__SpecificPresenceType (-898)

#endif

/* std::vector<lunom__SpecificPercentagePropertyType *> * has binding name 'PointerTostd__vectorTemplateOfPointerTolunom__SpecificPercentagePropertyType' for type 'lunom:SpecificPercentagePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTolunom__SpecificPercentagePropertyType
#define SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTolunom__SpecificPercentagePropertyType (-897)

#endif

/* lunom__SpecificPercentagePropertyType * has binding name 'PointerTolunom__SpecificPercentagePropertyType' for type 'lunom:SpecificPercentagePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTolunom__SpecificPercentagePropertyType
#define SOAP_TYPE_plu_PointerTolunom__SpecificPercentagePropertyType (-895)

#endif

/* lunom__SpecificPercentageType * has binding name 'PointerTolunom__SpecificPercentageType' for type 'lunom:SpecificPercentageType' */
#ifndef SOAP_TYPE_plu_PointerTolunom__SpecificPercentageType
#define SOAP_TYPE_plu_PointerTolunom__SpecificPercentageType (-893)

#endif

/* lunom__HILUCSPresenceType * has binding name 'PointerTolunom__HILUCSPresenceType' for type 'lunom:HILUCSPresenceType' */
#ifndef SOAP_TYPE_plu_PointerTolunom__HILUCSPresenceType
#define SOAP_TYPE_plu_PointerTolunom__HILUCSPresenceType (-891)

#endif

/* std::vector<lunom__HILUCSPercentagePropertyType *> * has binding name 'PointerTostd__vectorTemplateOfPointerTolunom__HILUCSPercentagePropertyType' for type 'lunom:HILUCSPercentagePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTolunom__HILUCSPercentagePropertyType
#define SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTolunom__HILUCSPercentagePropertyType (-890)

#endif

/* lunom__HILUCSPercentagePropertyType * has binding name 'PointerTolunom__HILUCSPercentagePropertyType' for type 'lunom:HILUCSPercentagePropertyType' */
#ifndef SOAP_TYPE_plu_PointerTolunom__HILUCSPercentagePropertyType
#define SOAP_TYPE_plu_PointerTolunom__HILUCSPercentagePropertyType (-888)

#endif

/* std::vector<gml__ReferenceType *> * has binding name 'PointerTostd__vectorTemplateOfPointerTogml__ReferenceType' for type 'gml:ReferenceType' */
#ifndef SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTogml__ReferenceType
#define SOAP_TYPE_plu_PointerTostd__vectorTemplateOfPointerTogml__ReferenceType (-887)

#endif

/* base2__ThematicIdentifierType * has binding name 'PointerTobase2__ThematicIdentifierType' for type 'base2:ThematicIdentifierType' */
#ifndef SOAP_TYPE_plu_PointerTobase2__ThematicIdentifierType
#define SOAP_TYPE_plu_PointerTobase2__ThematicIdentifierType (-885)

#endif

/* __base2__DocumentCitationPropertyType_sequence * has binding name 'PointerTo__base2__DocumentCitationPropertyType_sequence' for type '-base2:DocumentCitationPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__base2__DocumentCitationPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__base2__DocumentCitationPropertyType_sequence (-884)

#endif

/* base2__DocumentCitationType * has binding name 'PointerTobase2__DocumentCitationType' for type 'base2:DocumentCitationType' */
#ifndef SOAP_TYPE_plu_PointerTobase2__DocumentCitationType
#define SOAP_TYPE_plu_PointerTobase2__DocumentCitationType (-883)

#endif

/* base2__RelatedPartyType * has binding name 'PointerTobase2__RelatedPartyType' for type 'base2:RelatedPartyType' */
#ifndef SOAP_TYPE_plu_PointerTobase2__RelatedPartyType
#define SOAP_TYPE_plu_PointerTobase2__RelatedPartyType (-880)

#endif

/* gml__ReferenceType * has binding name 'PointerTogml__ReferenceType' for type 'gml:ReferenceType' */
#ifndef SOAP_TYPE_plu_PointerTogml__ReferenceType
#define SOAP_TYPE_plu_PointerTogml__ReferenceType (-878)

#endif

/* _base2__RelatedPartyType_contact * has binding name 'PointerTo_base2__RelatedPartyType_contact' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_base2__RelatedPartyType_contact
#define SOAP_TYPE_plu_PointerTo_base2__RelatedPartyType_contact (-877)

#endif

/* base2__ContactType * has binding name 'PointerTobase2__ContactType' for type 'base2:ContactType' */
#ifndef SOAP_TYPE_plu_PointerTobase2__ContactType
#define SOAP_TYPE_plu_PointerTobase2__ContactType (-875)

#endif

/* _base2__ContactType_website * has binding name 'PointerTo_base2__ContactType_website' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_base2__ContactType_website
#define SOAP_TYPE_plu_PointerTo_base2__ContactType_website (-874)

#endif

/* std::vector<_base2__ContactType_telephoneVoice> * has binding name 'PointerTostd__vectorTemplateOf_base2__ContactType_telephoneVoice' for type '' */
#ifndef SOAP_TYPE_plu_PointerTostd__vectorTemplateOf_base2__ContactType_telephoneVoice
#define SOAP_TYPE_plu_PointerTostd__vectorTemplateOf_base2__ContactType_telephoneVoice (-872)

#endif

/* std::vector<_base2__ContactType_telephoneFacsimile> * has binding name 'PointerTostd__vectorTemplateOf_base2__ContactType_telephoneFacsimile' for type '' */
#ifndef SOAP_TYPE_plu_PointerTostd__vectorTemplateOf_base2__ContactType_telephoneFacsimile
#define SOAP_TYPE_plu_PointerTostd__vectorTemplateOf_base2__ContactType_telephoneFacsimile (-869)

#endif

/* _base2__ContactType_electronicMailAddress * has binding name 'PointerTo_base2__ContactType_electronicMailAddress' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_base2__ContactType_electronicMailAddress
#define SOAP_TYPE_plu_PointerTo_base2__ContactType_electronicMailAddress (-866)

#endif

/* gmd__PT_x005fFreeText_x005fPropertyType * has binding name 'PointerTogmd__PT_x005fFreeText_x005fPropertyType' for type 'gmd:PT_FreeText_PropertyType' */
#ifndef SOAP_TYPE_plu_PointerTogmd__PT_x005fFreeText_x005fPropertyType
#define SOAP_TYPE_plu_PointerTogmd__PT_x005fFreeText_x005fPropertyType (-864)

#endif

/* __base2__LegislationCitationPropertyType_sequence * has binding name 'PointerTo__base2__LegislationCitationPropertyType_sequence' for type '-base2:LegislationCitationPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__base2__LegislationCitationPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__base2__LegislationCitationPropertyType_sequence (-863)

#endif

/* base2__LegislationCitationType * has binding name 'PointerTobase2__LegislationCitationType' for type 'base2:LegislationCitationType' */
#ifndef SOAP_TYPE_plu_PointerTobase2__LegislationCitationType
#define SOAP_TYPE_plu_PointerTobase2__LegislationCitationType (-862)

#endif

/* base2__OfficialJournalInformationType * has binding name 'PointerTobase2__OfficialJournalInformationType' for type 'base2:OfficialJournalInformationType' */
#ifndef SOAP_TYPE_plu_PointerTobase2__OfficialJournalInformationType
#define SOAP_TYPE_plu_PointerTobase2__OfficialJournalInformationType (-860)

#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_plu_PointerTostd__string
#define SOAP_TYPE_plu_PointerTostd__string (-859)

#endif

/* base__IdentifierType * has binding name 'PointerTobase__IdentifierType' for type 'base:IdentifierType' */
#ifndef SOAP_TYPE_plu_PointerTobase__IdentifierType
#define SOAP_TYPE_plu_PointerTobase__IdentifierType (-858)

#endif

/* _base__IdentifierType_versionId * has binding name 'PointerTo_base__IdentifierType_versionId' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_base__IdentifierType_versionId
#define SOAP_TYPE_plu_PointerTo_base__IdentifierType_versionId (-857)

#endif

/* __base__SpatialDataSetPropertyType_sequence * has binding name 'PointerTo__base__SpatialDataSetPropertyType_sequence' for type '-base:SpatialDataSetPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__base__SpatialDataSetPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__base__SpatialDataSetPropertyType_sequence (-855)

#endif

/* base__SpatialDataSetType * has binding name 'PointerTobase__SpatialDataSetType' for type 'base:SpatialDataSetType' */
#ifndef SOAP_TYPE_plu_PointerTobase__SpatialDataSetType
#define SOAP_TYPE_plu_PointerTobase__SpatialDataSetType (-854)

#endif

/* plu__BackgroundMapValueType * has binding name 'PointerToplu__BackgroundMapValueType' for type 'plu:BackgroundMapValueType' */
#ifndef SOAP_TYPE_plu_PointerToplu__BackgroundMapValueType
#define SOAP_TYPE_plu_PointerToplu__BackgroundMapValueType (-852)

#endif

/* _plu__BackgroundMapValueType_backgroudMapURI * has binding name 'PointerTo_plu__BackgroundMapValueType_backgroudMapURI' for type '' */
#ifndef SOAP_TYPE_plu_PointerTo_plu__BackgroundMapValueType_backgroudMapURI
#define SOAP_TYPE_plu_PointerTo_plu__BackgroundMapValueType_backgroudMapURI (-851)

#endif

/* plu__OrdinanceValueType * has binding name 'PointerToplu__OrdinanceValueType' for type 'plu:OrdinanceValueType' */
#ifndef SOAP_TYPE_plu_PointerToplu__OrdinanceValueType
#define SOAP_TYPE_plu_PointerToplu__OrdinanceValueType (-849)

#endif

/* __plu__SpatialPlanPropertyType_sequence * has binding name 'PointerTo__plu__SpatialPlanPropertyType_sequence' for type '-plu:SpatialPlanPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__plu__SpatialPlanPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__plu__SpatialPlanPropertyType_sequence (-847)

#endif

/* plu__SpatialPlanType * has binding name 'PointerToplu__SpatialPlanType' for type 'plu:SpatialPlanType' */
#ifndef SOAP_TYPE_plu_PointerToplu__SpatialPlanType
#define SOAP_TYPE_plu_PointerToplu__SpatialPlanType (-846)

#endif

/* plu__DimensioningIndicationRealValueType * has binding name 'PointerToplu__DimensioningIndicationRealValueType' for type 'plu:DimensioningIndicationRealValueType' */
#ifndef SOAP_TYPE_plu_PointerToplu__DimensioningIndicationRealValueType
#define SOAP_TYPE_plu_PointerToplu__DimensioningIndicationRealValueType (-844)

#endif

/* plu__DimensioningIndicationValueType * has binding name 'PointerToplu__DimensioningIndicationValueType' for type 'plu:DimensioningIndicationValueType' */
#ifndef SOAP_TYPE_plu_PointerToplu__DimensioningIndicationValueType
#define SOAP_TYPE_plu_PointerToplu__DimensioningIndicationValueType (-843)

#endif

/* __plu__SupplementaryRegulationPropertyType_sequence * has binding name 'PointerTo__plu__SupplementaryRegulationPropertyType_sequence' for type '-plu:SupplementaryRegulationPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__plu__SupplementaryRegulationPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__plu__SupplementaryRegulationPropertyType_sequence (-841)

#endif

/* plu__SupplementaryRegulationType * has binding name 'PointerToplu__SupplementaryRegulationType' for type 'plu:SupplementaryRegulationType' */
#ifndef SOAP_TYPE_plu_PointerToplu__SupplementaryRegulationType
#define SOAP_TYPE_plu_PointerToplu__SupplementaryRegulationType (-840)

#endif

/* plu__DimensioningIndicationCharacterValueType * has binding name 'PointerToplu__DimensioningIndicationCharacterValueType' for type 'plu:DimensioningIndicationCharacterValueType' */
#ifndef SOAP_TYPE_plu_PointerToplu__DimensioningIndicationCharacterValueType
#define SOAP_TYPE_plu_PointerToplu__DimensioningIndicationCharacterValueType (-838)

#endif

/* plu__DimensioningIndicationIntegerValueType * has binding name 'PointerToplu__DimensioningIndicationIntegerValueType' for type 'plu:DimensioningIndicationIntegerValueType' */
#ifndef SOAP_TYPE_plu_PointerToplu__DimensioningIndicationIntegerValueType
#define SOAP_TYPE_plu_PointerToplu__DimensioningIndicationIntegerValueType (-837)

#endif

/* plu__DimensioningIndicationMeasureValueType * has binding name 'PointerToplu__DimensioningIndicationMeasureValueType' for type 'plu:DimensioningIndicationMeasureValueType' */
#ifndef SOAP_TYPE_plu_PointerToplu__DimensioningIndicationMeasureValueType
#define SOAP_TYPE_plu_PointerToplu__DimensioningIndicationMeasureValueType (-836)

#endif

/* __plu__OfficialDocumentationPropertyType_sequence * has binding name 'PointerTo__plu__OfficialDocumentationPropertyType_sequence' for type '-plu:OfficialDocumentationPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__plu__OfficialDocumentationPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__plu__OfficialDocumentationPropertyType_sequence (-835)

#endif

/* plu__OfficialDocumentationType * has binding name 'PointerToplu__OfficialDocumentationType' for type 'plu:OfficialDocumentationType' */
#ifndef SOAP_TYPE_plu_PointerToplu__OfficialDocumentationType
#define SOAP_TYPE_plu_PointerToplu__OfficialDocumentationType (-834)

#endif

/* enum xlink__actuateType * has binding name 'PointerToxlink__actuateType' for type 'xlink:actuateType' */
#ifndef SOAP_TYPE_plu_PointerToxlink__actuateType
#define SOAP_TYPE_plu_PointerToxlink__actuateType (-831)

#endif

/* enum xlink__showType * has binding name 'PointerToxlink__showType' for type 'xlink:showType' */
#ifndef SOAP_TYPE_plu_PointerToxlink__showType
#define SOAP_TYPE_plu_PointerToxlink__showType (-830)

#endif

/* std::string * has binding name 'PointerToxlink__titleAttrType' for type 'xlink:titleAttrType' */
#ifndef SOAP_TYPE_plu_PointerToxlink__titleAttrType
#define SOAP_TYPE_plu_PointerToxlink__titleAttrType (-829)

#endif

/* char ** has binding name 'PointerToxlink__arcroleType' for type 'xlink:arcroleType' */
#ifndef SOAP_TYPE_plu_PointerToxlink__arcroleType
#define SOAP_TYPE_plu_PointerToxlink__arcroleType (-828)

#endif

/* char ** has binding name 'PointerToxlink__roleType' for type 'xlink:roleType' */
#ifndef SOAP_TYPE_plu_PointerToxlink__roleType
#define SOAP_TYPE_plu_PointerToxlink__roleType (-827)

#endif

/* char ** has binding name 'PointerToxlink__hrefType' for type 'xlink:hrefType' */
#ifndef SOAP_TYPE_plu_PointerToxlink__hrefType
#define SOAP_TYPE_plu_PointerToxlink__hrefType (-826)

#endif

/* enum xlink__typeType * has binding name 'PointerToxlink__typeType' for type 'xlink:typeType' */
#ifndef SOAP_TYPE_plu_PointerToxlink__typeType
#define SOAP_TYPE_plu_PointerToxlink__typeType (-825)

#endif

/* char ** has binding name 'PointerToxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_plu_PointerToxsd__anyURI
#define SOAP_TYPE_plu_PointerToxsd__anyURI (-824)

#endif

/* std::string * has binding name 'PointerTogml__NilReasonType' for type 'gml:NilReasonType' */
#ifndef SOAP_TYPE_plu_PointerTogml__NilReasonType
#define SOAP_TYPE_plu_PointerTogml__NilReasonType (-823)

#endif

/* __plu__ZoningElementPropertyType_sequence * has binding name 'PointerTo__plu__ZoningElementPropertyType_sequence' for type '-plu:ZoningElementPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_PointerTo__plu__ZoningElementPropertyType_sequence
#define SOAP_TYPE_plu_PointerTo__plu__ZoningElementPropertyType_sequence (-822)

#endif

/* plu__ZoningElementType * has binding name 'PointerToplu__ZoningElementType' for type 'plu:ZoningElementType' */
#ifndef SOAP_TYPE_plu_PointerToplu__ZoningElementType
#define SOAP_TYPE_plu_PointerToplu__ZoningElementType (-821)

#endif

/* xlink__toType has binding name 'xlink__toType' for type 'xlink:toType' */
#ifndef SOAP_TYPE_plu_xlink__toType
#define SOAP_TYPE_plu_xlink__toType (-818)

#endif

/* xlink__fromType has binding name 'xlink__fromType' for type 'xlink:fromType' */
#ifndef SOAP_TYPE_plu_xlink__fromType
#define SOAP_TYPE_plu_xlink__fromType (-816)

#endif

/* xlink__labelType has binding name 'xlink__labelType' for type 'xlink:labelType' */
#ifndef SOAP_TYPE_plu_xlink__labelType
#define SOAP_TYPE_plu_xlink__labelType (-814)

#endif

/* xlink__arcroleType has binding name 'xlink__arcroleType' for type 'xlink:arcroleType' */
#ifndef SOAP_TYPE_plu_xlink__arcroleType
#define SOAP_TYPE_plu_xlink__arcroleType (-806)

#endif

/* xlink__roleType has binding name 'xlink__roleType' for type 'xlink:roleType' */
#ifndef SOAP_TYPE_plu_xlink__roleType
#define SOAP_TYPE_plu_xlink__roleType (-804)

#endif

/* xlink__hrefType has binding name 'xlink__hrefType' for type 'xlink:hrefType' */
#ifndef SOAP_TYPE_plu_xlink__hrefType
#define SOAP_TYPE_plu_xlink__hrefType (-802)

#endif

/* gml__UomURI has binding name 'gml__UomURI' for type 'gml:UomURI' */
#ifndef SOAP_TYPE_plu_gml__UomURI
#define SOAP_TYPE_plu_gml__UomURI (-771)

#endif

/* gml__QNameList has binding name 'gml__QNameList' for type 'xsd:QName' */
#ifndef SOAP_TYPE_plu_gml__QNameList
#define SOAP_TYPE_plu_gml__QNameList (-747)

#endif

/* _SOAP_ENC__actor has binding name '_SOAP_ENC__actor' for type '' */
#ifndef SOAP_TYPE_plu__SOAP_ENC__actor
#define SOAP_TYPE_plu__SOAP_ENC__actor (-53)

#endif

/* xsd__token has binding name 'xsd__token' for type 'xsd:token' */
#ifndef SOAP_TYPE_plu_xsd__token
#define SOAP_TYPE_plu_xsd__token (-45)

#endif

/* xsd__time has binding name 'xsd__time' for type 'xsd:time' */
#ifndef SOAP_TYPE_plu_xsd__time
#define SOAP_TYPE_plu_xsd__time (-44)

#endif

/* xsd__QName has binding name 'xsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_plu_xsd__QName
#define SOAP_TYPE_plu_xsd__QName (-43)

#endif

/* xsd__normalizedString has binding name 'xsd__normalizedString' for type 'xsd:normalizedString' */
#ifndef SOAP_TYPE_plu_xsd__normalizedString
#define SOAP_TYPE_plu_xsd__normalizedString (-41)

#endif

/* xsd__NMTOKEN has binding name 'xsd__NMTOKEN' for type 'xsd:NMTOKEN' */
#ifndef SOAP_TYPE_plu_xsd__NMTOKEN
#define SOAP_TYPE_plu_xsd__NMTOKEN (-36)

#endif

/* xsd__NCName has binding name 'xsd__NCName' for type 'xsd:NCName' */
#ifndef SOAP_TYPE_plu_xsd__NCName
#define SOAP_TYPE_plu_xsd__NCName (-35)

#endif

/* xsd__Name has binding name 'xsd__Name' for type 'xsd:Name' */
#ifndef SOAP_TYPE_plu_xsd__Name
#define SOAP_TYPE_plu_xsd__Name (-34)

#endif

/* xsd__language has binding name 'xsd__language' for type 'xsd:language' */
#ifndef SOAP_TYPE_plu_xsd__language
#define SOAP_TYPE_plu_xsd__language (-32)

#endif

/* xsd__ID has binding name 'xsd__ID' for type 'xsd:ID' */
#ifndef SOAP_TYPE_plu_xsd__ID
#define SOAP_TYPE_plu_xsd__ID (-29)

#endif

/* xsd__duration has binding name 'xsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_plu_xsd__duration
#define SOAP_TYPE_plu_xsd__duration (-26)

#endif

/* xsd__date has binding name 'xsd__date' for type 'xsd:date' */
#ifndef SOAP_TYPE_plu_xsd__date
#define SOAP_TYPE_plu_xsd__date (-22)

#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_plu_PointerTounsignedByte
#define SOAP_TYPE_plu_PointerTounsignedByte (-19)

#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_plu_xsd__anyURI
#define SOAP_TYPE_plu_xsd__anyURI (-15)

#endif

/* _xsd__schema has binding name '_xsd__schema' for type '' */
#ifndef SOAP_TYPE_plu__xsd__schema
#define SOAP_TYPE_plu__xsd__schema (-12)

#endif

/* _xml__lang has binding name '_xml__lang' for type '' */
#ifndef SOAP_TYPE_plu__xml__lang
#define SOAP_TYPE_plu__xml__lang (-11)

#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_plu__QName
#define SOAP_TYPE_plu__QName (-6)

#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE_plu__XML
#define SOAP_TYPE_plu__XML (-5)

#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_plu_string
#define SOAP_TYPE_plu_string (-4)

#endif

/* std::vector<ULONG64>  has binding name 'std__vectorTemplateOfxsd__positiveInteger' for type 'xsd:positiveInteger' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfxsd__positiveInteger
#define SOAP_TYPE_plu_std__vectorTemplateOfxsd__positiveInteger (-2351)

#endif

/* std::vector<gml__CoordinateOperationPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__CoordinateOperationPropertyType' for type 'gml:CoordinateOperationPropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__CoordinateOperationPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__CoordinateOperationPropertyType (-2348)

#endif

/* std::vector<gml__SingleCRSPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__SingleCRSPropertyType' for type 'gml:SingleCRSPropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__SingleCRSPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__SingleCRSPropertyType (-2310)

#endif

/* std::vector<gml__LineStringSegmentArrayPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__LineStringSegmentArrayPropertyType' for type 'gml:LineStringSegmentArrayPropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__LineStringSegmentArrayPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__LineStringSegmentArrayPropertyType (-2295)

#endif

/* std::vector<gml__TimeEdgePropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__TimeEdgePropertyType' for type 'gml:TimeEdgePropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__TimeEdgePropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__TimeEdgePropertyType (-2293)

#endif

/* std::vector<gml__TimeCalendarPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__TimeCalendarPropertyType' for type 'gml:TimeCalendarPropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__TimeCalendarPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__TimeCalendarPropertyType (-2291)

#endif

/* std::vector<gml__TimeCalendarEraPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__TimeCalendarEraPropertyType' for type 'gml:TimeCalendarEraPropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__TimeCalendarEraPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__TimeCalendarEraPropertyType (-2289)

#endif

/* std::vector<gml__AbstractGeneralOperationParameterPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__AbstractGeneralOperationParameterPropertyType' for type 'gml:AbstractGeneralOperationParameterPropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__AbstractGeneralOperationParameterPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__AbstractGeneralOperationParameterPropertyType (-2283)

#endif

/* std::vector<_gml__coordinateOperationAccuracy *>  has binding name 'std__vectorTemplateOfPointerTo_gml__coordinateOperationAccuracy' for type '' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTo_gml__coordinateOperationAccuracy
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTo_gml__coordinateOperationAccuracy (-2276)

#endif

/* std::vector<_gml__domainOfValidity *>  has binding name 'std__vectorTemplateOfPointerTo_gml__domainOfValidity' for type '' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTo_gml__domainOfValidity
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTo_gml__domainOfValidity (-2271)

#endif

/* std::vector<gml__CoordinateSystemAxisPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__CoordinateSystemAxisPropertyType' for type 'gml:CoordinateSystemAxisPropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__CoordinateSystemAxisPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__CoordinateSystemAxisPropertyType (-2267)

#endif

/* std::vector<gml__DerivationUnitTermType *>  has binding name 'std__vectorTemplateOfPointerTogml__DerivationUnitTermType' for type 'gml:DerivationUnitTermType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__DerivationUnitTermType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__DerivationUnitTermType (-2255)

#endif

/* std::vector<gml__ShellPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__ShellPropertyType' for type 'gml:ShellPropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__ShellPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__ShellPropertyType (-2248)

#endif

/* std::vector<gss__GM_x005fPoint_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogss__GM_x005fPoint_x005fPropertyType' for type 'gss:GM_Point_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogss__GM_x005fPoint_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogss__GM_x005fPoint_x005fPropertyType (-2241)

#endif

/* std::vector<gml__TimeTopologyPrimitivePropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__TimeTopologyPrimitivePropertyType' for type 'gml:TimeTopologyPrimitivePropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__TimeTopologyPrimitivePropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__TimeTopologyPrimitivePropertyType (-2239)

#endif

/* std::vector<gml__TimeOrdinalEraPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__TimeOrdinalEraPropertyType' for type 'gml:TimeOrdinalEraPropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__TimeOrdinalEraPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__TimeOrdinalEraPropertyType (-2237)

#endif

/* std::vector<gml__SolidPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__SolidPropertyType' for type 'gml:SolidPropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__SolidPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__SolidPropertyType (-2226)

#endif

/* std::vector<gml__SurfacePropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__SurfacePropertyType' for type 'gml:SurfacePropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__SurfacePropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__SurfacePropertyType (-2224)

#endif

/* std::vector<gml__CurvePropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__CurvePropertyType' for type 'gml:CurvePropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__CurvePropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__CurvePropertyType (-2222)

#endif

/* std::vector<gml__PointPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__PointPropertyType' for type 'gml:PointPropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__PointPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__PointPropertyType (-2220)

#endif

/* std::vector<gml__GeometryPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__GeometryPropertyType' for type 'gml:GeometryPropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__GeometryPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__GeometryPropertyType (-2218)

#endif

/* std::vector<gml__NodeOrEdgePropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__NodeOrEdgePropertyType' for type 'gml:NodeOrEdgePropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__NodeOrEdgePropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__NodeOrEdgePropertyType (-2216)

#endif

/* std::vector<gml__NodePropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__NodePropertyType' for type 'gml:NodePropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__NodePropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__NodePropertyType (-2213)

#endif

/* std::vector<gml__DirectedNodePropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__DirectedNodePropertyType' for type 'gml:DirectedNodePropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__DirectedNodePropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__DirectedNodePropertyType (-2211)

#endif

/* std::vector<gmd__MD_x005fRestrictionCode_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fRestrictionCode_x005fPropertyType' for type 'gmd:MD_RestrictionCode_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fRestrictionCode_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fRestrictionCode_x005fPropertyType (-2206)

#endif

/* std::vector<gmd__MD_x005fTopicCategoryCode_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fTopicCategoryCode_x005fPropertyType' for type 'gmd:MD_TopicCategoryCode_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fTopicCategoryCode_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fTopicCategoryCode_x005fPropertyType (-2204)

#endif

/* std::vector<gmd__MD_x005fCharacterSetCode_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fCharacterSetCode_x005fPropertyType' for type 'gmd:MD_CharacterSetCode_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fCharacterSetCode_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fCharacterSetCode_x005fPropertyType (-2202)

#endif

/* std::vector<gmd__MD_x005fResolution_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fResolution_x005fPropertyType' for type 'gmd:MD_Resolution_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fResolution_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fResolution_x005fPropertyType (-2201)

#endif

/* std::vector<gmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType' for type 'gmd:MD_SpatialRepresentationTypeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fSpatialRepresentationTypeCode_x005fPropertyType (-2199)

#endif

/* std::vector<gco__Record_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogco__Record_x005fPropertyType' for type 'gco:Record_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogco__Record_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogco__Record_x005fPropertyType (-2197)

#endif

/* std::vector<gmd__MD_x005fRangeDimension_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fRangeDimension_x005fPropertyType' for type 'gmd:MD_RangeDimension_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fRangeDimension_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fRangeDimension_x005fPropertyType (-2193)

#endif

/* std::vector<gco__GenericName_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogco__GenericName_x005fPropertyType' for type 'gco:GenericName_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogco__GenericName_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogco__GenericName_x005fPropertyType (-2189)

#endif

/* std::vector<gss__GM_x005fObject_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogss__GM_x005fObject_x005fPropertyType' for type 'gss:GM_Object_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogss__GM_x005fObject_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogss__GM_x005fObject_x005fPropertyType (-2186)

#endif

/* std::vector<gmd__MD_x005fGeometricObjects_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fGeometricObjects_x005fPropertyType' for type 'gmd:MD_GeometricObjects_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fGeometricObjects_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fGeometricObjects_x005fPropertyType (-2184)

#endif

/* std::vector<gmd__MD_x005fDimension_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fDimension_x005fPropertyType' for type 'gmd:MD_Dimension_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fDimension_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fDimension_x005fPropertyType (-2180)

#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfstd__string
#define SOAP_TYPE_plu_std__vectorTemplateOfstd__string (-2167)

#endif

/* std::vector<gml__RelatedTimeType *>  has binding name 'std__vectorTemplateOfPointerTogml__RelatedTimeType' for type 'gml:RelatedTimeType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__RelatedTimeType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__RelatedTimeType (-2163)

#endif

/* std::vector<_gml__AbstractGriddedSurfaceType_rows_Row>  has binding name 'std__vectorTemplateOf_gml__AbstractGriddedSurfaceType_rows_Row' for type '' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOf_gml__AbstractGriddedSurfaceType_rows_Row
#define SOAP_TYPE_plu_std__vectorTemplateOf_gml__AbstractGriddedSurfaceType_rows_Row (-2156)

#endif

/* std::vector<gml__GeometricPrimitivePropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__GeometricPrimitivePropertyType' for type 'gml:GeometricPrimitivePropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__GeometricPrimitivePropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__GeometricPrimitivePropertyType (-2134)

#endif

/* std::vector<gml__TopoPrimitiveMemberType *>  has binding name 'std__vectorTemplateOfPointerTogml__TopoPrimitiveMemberType' for type 'gml:TopoPrimitiveMemberType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__TopoPrimitiveMemberType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__TopoPrimitiveMemberType (-2131)

#endif

/* std::vector<gml__TopoComplexPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__TopoComplexPropertyType' for type 'gml:TopoComplexPropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__TopoComplexPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__TopoComplexPropertyType (-2129)

#endif

/* std::vector<gml__DirectedTopoSolidPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__DirectedTopoSolidPropertyType' for type 'gml:DirectedTopoSolidPropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__DirectedTopoSolidPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__DirectedTopoSolidPropertyType (-2127)

#endif

/* std::vector<gml__DirectedFacePropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__DirectedFacePropertyType' for type 'gml:DirectedFacePropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__DirectedFacePropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__DirectedFacePropertyType (-2125)

#endif

/* std::vector<gml__DirectedEdgePropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__DirectedEdgePropertyType' for type 'gml:DirectedEdgePropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__DirectedEdgePropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__DirectedEdgePropertyType (-2123)

#endif

/* std::vector<gml__FeaturePropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__FeaturePropertyType' for type 'gml:FeaturePropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__FeaturePropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__FeaturePropertyType (-2117)

#endif

/* std::vector<_plu__SpatialPlanType_ordinance>  has binding name 'std__vectorTemplateOf_plu__SpatialPlanType_ordinance' for type '' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOf_plu__SpatialPlanType_ordinance
#define SOAP_TYPE_plu_std__vectorTemplateOf_plu__SpatialPlanType_ordinance (-2110)

#endif

/* std::vector<_plu__SupplementaryRegulationType_name>  has binding name 'std__vectorTemplateOf_plu__SupplementaryRegulationType_name' for type '' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOf_plu__SupplementaryRegulationType_name
#define SOAP_TYPE_plu_std__vectorTemplateOf_plu__SupplementaryRegulationType_name (-2095)

#endif

/* std::vector<_plu__SupplementaryRegulationType_dimensioningIndication>  has binding name 'std__vectorTemplateOf_plu__SupplementaryRegulationType_dimensioningIndication' for type '' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOf_plu__SupplementaryRegulationType_dimensioningIndication
#define SOAP_TYPE_plu_std__vectorTemplateOf_plu__SupplementaryRegulationType_dimensioningIndication (-2085)

#endif

/* std::vector<_plu__ZoningElementType_dimensioningIndication>  has binding name 'std__vectorTemplateOf_plu__ZoningElementType_dimensioningIndication' for type '' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOf_plu__ZoningElementType_dimensioningIndication
#define SOAP_TYPE_plu_std__vectorTemplateOf_plu__ZoningElementType_dimensioningIndication (-2062)

#endif

/* std::vector<gco__MultiplicityRange_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogco__MultiplicityRange_x005fPropertyType' for type 'gco:MultiplicityRange_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogco__MultiplicityRange_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogco__MultiplicityRange_x005fPropertyType (-2042)

#endif

/* std::vector<gmd__MD_x005fDistributor_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fDistributor_x005fPropertyType' for type 'gmd:MD_Distributor_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fDistributor_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fDistributor_x005fPropertyType (-2030)

#endif

/* std::vector<gmd__MD_x005fDigitalTransferOptions_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fDigitalTransferOptions_x005fPropertyType' for type 'gmd:MD_DigitalTransferOptions_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fDigitalTransferOptions_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fDigitalTransferOptions_x005fPropertyType (-2028)

#endif

/* std::vector<gmd__MD_x005fStandardOrderProcess_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fStandardOrderProcess_x005fPropertyType' for type 'gmd:MD_StandardOrderProcess_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fStandardOrderProcess_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fStandardOrderProcess_x005fPropertyType (-2026)

#endif

/* std::vector<gmd__CI_x005fOnlineResource_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__CI_x005fOnlineResource_x005fPropertyType' for type 'gmd:CI_OnlineResource_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__CI_x005fOnlineResource_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__CI_x005fOnlineResource_x005fPropertyType (-2023)

#endif

/* std::vector<gmd__MD_x005fMediumFormatCode_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fMediumFormatCode_x005fPropertyType' for type 'gmd:MD_MediumFormatCode_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fMediumFormatCode_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fMediumFormatCode_x005fPropertyType (-2022)

#endif

/* std::vector<gco__Real_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogco__Real_x005fPropertyType' for type 'gco:Real_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogco__Real_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogco__Real_x005fPropertyType (-2020)

#endif

/* std::vector<gmd__MD_x005fAggregateInformation_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fAggregateInformation_x005fPropertyType' for type 'gmd:MD_AggregateInformation_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fAggregateInformation_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fAggregateInformation_x005fPropertyType (-2015)

#endif

/* std::vector<gmd__MD_x005fUsage_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fUsage_x005fPropertyType' for type 'gmd:MD_Usage_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fUsage_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fUsage_x005fPropertyType (-2013)

#endif

/* std::vector<gmd__MD_x005fKeywords_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fKeywords_x005fPropertyType' for type 'gmd:MD_Keywords_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fKeywords_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fKeywords_x005fPropertyType (-2011)

#endif

/* std::vector<gmd__MD_x005fFormat_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fFormat_x005fPropertyType' for type 'gmd:MD_Format_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fFormat_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fFormat_x005fPropertyType (-2009)

#endif

/* std::vector<gmd__MD_x005fBrowseGraphic_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fBrowseGraphic_x005fPropertyType' for type 'gmd:MD_BrowseGraphic_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fBrowseGraphic_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fBrowseGraphic_x005fPropertyType (-2007)

#endif

/* std::vector<gmd__MD_x005fMaintenanceInformation_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fMaintenanceInformation_x005fPropertyType' for type 'gmd:MD_MaintenanceInformation_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fMaintenanceInformation_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fMaintenanceInformation_x005fPropertyType (-2005)

#endif

/* std::vector<gmd__MD_x005fProgressCode_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fProgressCode_x005fPropertyType' for type 'gmd:MD_ProgressCode_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fProgressCode_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fProgressCode_x005fPropertyType (-2004)

#endif

/* std::vector<gmd__MD_x005fScopeDescription_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fScopeDescription_x005fPropertyType' for type 'gmd:MD_ScopeDescription_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fScopeDescription_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fScopeDescription_x005fPropertyType (-2002)

#endif

/* std::vector<gmd__DQ_x005fElement_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__DQ_x005fElement_x005fPropertyType' for type 'gmd:DQ_Element_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__DQ_x005fElement_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__DQ_x005fElement_x005fPropertyType (-1999)

#endif

/* std::vector<gmd__DQ_x005fResult_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__DQ_x005fResult_x005fPropertyType' for type 'gmd:DQ_Result_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__DQ_x005fResult_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__DQ_x005fResult_x005fPropertyType (-1996)

#endif

/* std::vector<gco__DateTime_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogco__DateTime_x005fPropertyType' for type 'gco:DateTime_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogco__DateTime_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogco__DateTime_x005fPropertyType (-1994)

#endif

/* std::vector<gmd__LI_x005fProcessStep_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__LI_x005fProcessStep_x005fPropertyType' for type 'gmd:LI_ProcessStep_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__LI_x005fProcessStep_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__LI_x005fProcessStep_x005fPropertyType (-1992)

#endif

/* std::vector<gmd__LI_x005fSource_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__LI_x005fSource_x005fPropertyType' for type 'gmd:LI_Source_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__LI_x005fSource_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__LI_x005fSource_x005fPropertyType (-1990)

#endif

/* std::vector<gmd__CI_x005fCitation_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__CI_x005fCitation_x005fPropertyType' for type 'gmd:CI_Citation_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__CI_x005fCitation_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__CI_x005fCitation_x005fPropertyType (-1987)

#endif

/* std::vector<gmd__MD_x005fExtendedElementInformation_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fExtendedElementInformation_x005fPropertyType' for type 'gmd:MD_ExtendedElementInformation_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fExtendedElementInformation_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fExtendedElementInformation_x005fPropertyType (-1984)

#endif

/* std::vector<gmd__EX_x005fVerticalExtent_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__EX_x005fVerticalExtent_x005fPropertyType' for type 'gmd:EX_VerticalExtent_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__EX_x005fVerticalExtent_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__EX_x005fVerticalExtent_x005fPropertyType (-1979)

#endif

/* std::vector<gmd__EX_x005fTemporalExtent_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__EX_x005fTemporalExtent_x005fPropertyType' for type 'gmd:EX_TemporalExtent_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__EX_x005fTemporalExtent_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__EX_x005fTemporalExtent_x005fPropertyType (-1977)

#endif

/* std::vector<gmd__EX_x005fGeographicExtent_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__EX_x005fGeographicExtent_x005fPropertyType' for type 'gmd:EX_GeographicExtent_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__EX_x005fGeographicExtent_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__EX_x005fGeographicExtent_x005fPropertyType (-1975)

#endif

/* std::vector<gmd__EX_x005fExtent_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__EX_x005fExtent_x005fPropertyType' for type 'gmd:EX_Extent_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__EX_x005fExtent_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__EX_x005fExtent_x005fPropertyType (-1970)

#endif

/* std::vector<gmd__CI_x005fPresentationFormCode_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__CI_x005fPresentationFormCode_x005fPropertyType' for type 'gmd:CI_PresentationFormCode_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__CI_x005fPresentationFormCode_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__CI_x005fPresentationFormCode_x005fPropertyType (-1959)

#endif

/* std::vector<gmd__MD_x005fIdentifier_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fIdentifier_x005fPropertyType' for type 'gmd:MD_Identifier_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fIdentifier_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fIdentifier_x005fPropertyType (-1957)

#endif

/* std::vector<gmd__MD_x005fApplicationSchemaInformation_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fApplicationSchemaInformation_x005fPropertyType' for type 'gmd:MD_ApplicationSchemaInformation_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fApplicationSchemaInformation_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fApplicationSchemaInformation_x005fPropertyType (-1948)

#endif

/* std::vector<gmd__MD_x005fConstraints_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fConstraints_x005fPropertyType' for type 'gmd:MD_Constraints_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fConstraints_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fConstraints_x005fPropertyType (-1946)

#endif

/* std::vector<gmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType' for type 'gmd:MD_PortrayalCatalogueReference_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fPortrayalCatalogueReference_x005fPropertyType (-1944)

#endif

/* std::vector<gmd__DQ_x005fDataQuality_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__DQ_x005fDataQuality_x005fPropertyType' for type 'gmd:DQ_DataQuality_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__DQ_x005fDataQuality_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__DQ_x005fDataQuality_x005fPropertyType (-1942)

#endif

/* std::vector<gmd__MD_x005fContentInformation_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fContentInformation_x005fPropertyType' for type 'gmd:MD_ContentInformation_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fContentInformation_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fContentInformation_x005fPropertyType (-1939)

#endif

/* std::vector<gmd__MD_x005fIdentification_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fIdentification_x005fPropertyType' for type 'gmd:MD_Identification_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fIdentification_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fIdentification_x005fPropertyType (-1937)

#endif

/* std::vector<gmd__MD_x005fMetadataExtensionInformation_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fMetadataExtensionInformation_x005fPropertyType' for type 'gmd:MD_MetadataExtensionInformation_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fMetadataExtensionInformation_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fMetadataExtensionInformation_x005fPropertyType (-1935)

#endif

/* std::vector<gmd__MD_x005fReferenceSystem_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fReferenceSystem_x005fPropertyType' for type 'gmd:MD_ReferenceSystem_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fReferenceSystem_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fReferenceSystem_x005fPropertyType (-1933)

#endif

/* std::vector<gmd__MD_x005fSpatialRepresentation_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fSpatialRepresentation_x005fPropertyType' for type 'gmd:MD_SpatialRepresentation_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fSpatialRepresentation_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fSpatialRepresentation_x005fPropertyType (-1931)

#endif

/* std::vector<gmd__PT_x005fLocale_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__PT_x005fLocale_x005fPropertyType' for type 'gmd:PT_Locale_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__PT_x005fLocale_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__PT_x005fLocale_x005fPropertyType (-1929)

#endif

/* std::vector<gco__CharacterString_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogco__CharacterString_x005fPropertyType' for type 'gco:CharacterString_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogco__CharacterString_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogco__CharacterString_x005fPropertyType (-1927)

#endif

/* std::vector<gmd__MD_x005fScopeCode_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fScopeCode_x005fPropertyType' for type 'gmd:MD_ScopeCode_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fScopeCode_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fScopeCode_x005fPropertyType (-1926)

#endif

/* std::vector<gmd__DS_x005fAggregate_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__DS_x005fAggregate_x005fPropertyType' for type 'gmd:DS_Aggregate_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__DS_x005fAggregate_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__DS_x005fAggregate_x005fPropertyType (-1923)

#endif

/* std::vector<gmd__MD_x005fMetadata_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_x005fMetadata_x005fPropertyType' for type 'gmd:MD_Metadata_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fMetadata_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__MD_x005fMetadata_x005fPropertyType (-1921)

#endif

/* std::vector<gmd__DS_x005fDataSet_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__DS_x005fDataSet_x005fPropertyType' for type 'gmd:DS_DataSet_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__DS_x005fDataSet_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__DS_x005fDataSet_x005fPropertyType (-1919)

#endif

/* std::vector<gml__AssociationRoleType *>  has binding name 'std__vectorTemplateOfPointerTogml__AssociationRoleType' for type 'gml:AssociationRoleType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__AssociationRoleType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__AssociationRoleType (-1916)

#endif

/* std::vector<gml__AbstractGeneralParameterValuePropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__AbstractGeneralParameterValuePropertyType' for type 'gml:AbstractGeneralParameterValuePropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__AbstractGeneralParameterValuePropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__AbstractGeneralParameterValuePropertyType (-1911)

#endif

/* std::vector<gml__ValuePropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__ValuePropertyType' for type 'gml:ValuePropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__ValuePropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__ValuePropertyType (-1902)

#endif

/* std::vector<gml__AbstractRingPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__AbstractRingPropertyType' for type 'gml:AbstractRingPropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__AbstractRingPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__AbstractRingPropertyType (-1880)

#endif

/* std::vector<gml__KnotPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__KnotPropertyType' for type 'gml:KnotPropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__KnotPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__KnotPropertyType (-1871)

#endif

/* std::vector<double>  has binding name 'std__vectorTemplateOfdouble' for type 'xsd:double' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfdouble
#define SOAP_TYPE_plu_std__vectorTemplateOfdouble (-1858)

#endif

/* std::vector<gml__DynamicFeatureType *>  has binding name 'std__vectorTemplateOfPointerTogml__DynamicFeatureType' for type 'gml:DynamicFeatureType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__DynamicFeatureType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__DynamicFeatureType (-1835)

#endif

/* std::vector<_base2__DocumentCitationType_specificReference>  has binding name 'std__vectorTemplateOf_base2__DocumentCitationType_specificReference' for type '' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOf_base2__DocumentCitationType_specificReference
#define SOAP_TYPE_plu_std__vectorTemplateOf_base2__DocumentCitationType_specificReference (-1831)

#endif

/* std::vector<_base2__DocumentCitationType_link>  has binding name 'std__vectorTemplateOf_base2__DocumentCitationType_link' for type '' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOf_base2__DocumentCitationType_link
#define SOAP_TYPE_plu_std__vectorTemplateOf_base2__DocumentCitationType_link (-1828)

#endif

/* std::vector<gmd__LocalisedCharacterString_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__LocalisedCharacterString_x005fPropertyType' for type 'gmd:LocalisedCharacterString_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__LocalisedCharacterString_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__LocalisedCharacterString_x005fPropertyType (-1700)

#endif

/* std::vector<gmd__CI_x005fResponsibleParty_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__CI_x005fResponsibleParty_x005fPropertyType' for type 'gmd:CI_ResponsibleParty_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__CI_x005fResponsibleParty_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__CI_x005fResponsibleParty_x005fPropertyType (-1698)

#endif

/* std::vector<gmd__CI_x005fDate_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__CI_x005fDate_x005fPropertyType' for type 'gmd:CI_Date_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__CI_x005fDate_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogmd__CI_x005fDate_x005fPropertyType (-1696)

#endif

/* std::vector<gco__ObjectReference_x005fPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogco__ObjectReference_x005fPropertyType' for type 'gco:ObjectReference_PropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogco__ObjectReference_x005fPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogco__ObjectReference_x005fPropertyType (-1681)

#endif

/* std::vector<__gml__FeatureArrayPropertyType_sequence>  has binding name 'std__vectorTemplateOf__gml__FeatureArrayPropertyType_sequence' for type '-gml:FeatureArrayPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOf__gml__FeatureArrayPropertyType_sequence
#define SOAP_TYPE_plu_std__vectorTemplateOf__gml__FeatureArrayPropertyType_sequence (-1312)

#endif

/* std::vector<__gml__ValueArrayPropertyType_sequence>  has binding name 'std__vectorTemplateOf__gml__ValueArrayPropertyType_sequence' for type '-gml:ValueArrayPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOf__gml__ValueArrayPropertyType_sequence
#define SOAP_TYPE_plu_std__vectorTemplateOf__gml__ValueArrayPropertyType_sequence (-1101)

#endif

/* std::vector<gml__ValueArrayType *>  has binding name 'std__vectorTemplateOfPointerTogml__ValueArrayType' for type 'gml:ValueArrayType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__ValueArrayType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__ValueArrayType (-1049)

#endif

/* std::vector<gml__CodeType *>  has binding name 'std__vectorTemplateOfPointerTogml__CodeType' for type 'gml:CodeType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__CodeType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__CodeType (-1040)

#endif

/* std::vector<gml__MetaDataPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__MetaDataPropertyType' for type 'gml:MetaDataPropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__MetaDataPropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__MetaDataPropertyType (-1036)

#endif

/* std::vector<__gml__CurveArrayPropertyType_sequence>  has binding name 'std__vectorTemplateOf__gml__CurveArrayPropertyType_sequence' for type '-gml:CurveArrayPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOf__gml__CurveArrayPropertyType_sequence
#define SOAP_TYPE_plu_std__vectorTemplateOf__gml__CurveArrayPropertyType_sequence (-1033)

#endif

/* std::vector<__gml__PointArrayPropertyType_sequence>  has binding name 'std__vectorTemplateOf__gml__PointArrayPropertyType_sequence' for type '-gml:PointArrayPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOf__gml__PointArrayPropertyType_sequence
#define SOAP_TYPE_plu_std__vectorTemplateOf__gml__PointArrayPropertyType_sequence (-1024)

#endif

/* std::vector<gml__DirectPositionType *>  has binding name 'std__vectorTemplateOfPointerTogml__DirectPositionType' for type 'gml:DirectPositionType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__DirectPositionType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__DirectPositionType (-1013)

#endif

/* std::vector<__gml__GeometryArrayPropertyType_sequence>  has binding name 'std__vectorTemplateOf__gml__GeometryArrayPropertyType_sequence' for type '-gml:GeometryArrayPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOf__gml__GeometryArrayPropertyType_sequence
#define SOAP_TYPE_plu_std__vectorTemplateOf__gml__GeometryArrayPropertyType_sequence (-1012)

#endif

/* std::vector<__gml__SurfaceArrayPropertyType_sequence>  has binding name 'std__vectorTemplateOf__gml__SurfaceArrayPropertyType_sequence' for type '-gml:SurfaceArrayPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOf__gml__SurfaceArrayPropertyType_sequence
#define SOAP_TYPE_plu_std__vectorTemplateOf__gml__SurfaceArrayPropertyType_sequence (-1004)

#endif

/* std::vector<__gml__SolidArrayPropertyType_sequence>  has binding name 'std__vectorTemplateOf__gml__SolidArrayPropertyType_sequence' for type '-gml:SolidArrayPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOf__gml__SolidArrayPropertyType_sequence
#define SOAP_TYPE_plu_std__vectorTemplateOf__gml__SolidArrayPropertyType_sequence (-993)

#endif

/* std::vector<__gml__LineStringSegmentArrayPropertyType_sequence>  has binding name 'std__vectorTemplateOf__gml__LineStringSegmentArrayPropertyType_sequence' for type '-gml:LineStringSegmentArrayPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOf__gml__LineStringSegmentArrayPropertyType_sequence
#define SOAP_TYPE_plu_std__vectorTemplateOf__gml__LineStringSegmentArrayPropertyType_sequence (-986)

#endif

/* std::vector<__gml__SurfacePatchArrayPropertyType_sequence>  has binding name 'std__vectorTemplateOf__gml__SurfacePatchArrayPropertyType_sequence' for type '-gml:SurfacePatchArrayPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOf__gml__SurfacePatchArrayPropertyType_sequence
#define SOAP_TYPE_plu_std__vectorTemplateOf__gml__SurfacePatchArrayPropertyType_sequence (-983)

#endif

/* std::vector<gml__VectorType *>  has binding name 'std__vectorTemplateOfPointerTogml__VectorType' for type 'gml:VectorType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__VectorType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__VectorType (-977)

#endif

/* std::vector<__gml__CurveSegmentArrayPropertyType_sequence>  has binding name 'std__vectorTemplateOf__gml__CurveSegmentArrayPropertyType_sequence' for type '-gml:CurveSegmentArrayPropertyType-sequence' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOf__gml__CurveSegmentArrayPropertyType_sequence
#define SOAP_TYPE_plu_std__vectorTemplateOf__gml__CurveSegmentArrayPropertyType_sequence (-973)

#endif

/* std::vector<__gml__TopoPrimitiveArrayAssociationType_sequence>  has binding name 'std__vectorTemplateOf__gml__TopoPrimitiveArrayAssociationType_sequence' for type '-gml:TopoPrimitiveArrayAssociationType-sequence' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOf__gml__TopoPrimitiveArrayAssociationType_sequence
#define SOAP_TYPE_plu_std__vectorTemplateOf__gml__TopoPrimitiveArrayAssociationType_sequence (-929)

#endif

/* std::vector<lunom__SpecificPercentagePropertyType *>  has binding name 'std__vectorTemplateOfPointerTolunom__SpecificPercentagePropertyType' for type 'lunom:SpecificPercentagePropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTolunom__SpecificPercentagePropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTolunom__SpecificPercentagePropertyType (-896)

#endif

/* std::vector<lunom__HILUCSPercentagePropertyType *>  has binding name 'std__vectorTemplateOfPointerTolunom__HILUCSPercentagePropertyType' for type 'lunom:HILUCSPercentagePropertyType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTolunom__HILUCSPercentagePropertyType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTolunom__HILUCSPercentagePropertyType (-889)

#endif

/* std::vector<gml__ReferenceType *>  has binding name 'std__vectorTemplateOfPointerTogml__ReferenceType' for type 'gml:ReferenceType' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__ReferenceType
#define SOAP_TYPE_plu_std__vectorTemplateOfPointerTogml__ReferenceType (-879)

#endif

/* std::vector<_base2__ContactType_telephoneVoice>  has binding name 'std__vectorTemplateOf_base2__ContactType_telephoneVoice' for type '' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOf_base2__ContactType_telephoneVoice
#define SOAP_TYPE_plu_std__vectorTemplateOf_base2__ContactType_telephoneVoice (-871)

#endif

/* std::vector<_base2__ContactType_telephoneFacsimile>  has binding name 'std__vectorTemplateOf_base2__ContactType_telephoneFacsimile' for type '' */
#ifndef SOAP_TYPE_plu_std__vectorTemplateOf_base2__ContactType_telephoneFacsimile
#define SOAP_TYPE_plu_std__vectorTemplateOf_base2__ContactType_telephoneFacsimile (-868)

#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


} // namespace plu


#endif

/* End of pluStub.h */
